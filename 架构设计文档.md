# 电网台区美化治理与打分系统 - 架构设计文档

**版本**: v1.0  
**创建日期**: 2025年1月21日  
**设计目标**: 端到端自动化治理+打分系统

## 🎯 系统概述

### 核心功能
- **输入**: 结构化GIS数据（设备坐标、地形要素等）+ 可视化图片
- **处理**: 大模型基于数据进行自动化治理 + 美观性打分
- **输出**: 治理后的结构化数据 + 新生成的可视化图片 + 详细评分报告
- **可视化**: 双向转换（GIS数据 ↔ 图片可视化）
- **追踪**: WandB实验记录 + 成本分析
- **并行**: Multiprocessing批量处理

### 技术栈
- **多模态大模型**: OpenAI o3, 千问VL-Max, Kimi K2, 智谱GLM-4V
- **实验追踪**: Weights & Biases (WandB)
- **并行处理**: Python multiprocessing
- **可视化**: Matplotlib, PIL（GIS数据 → 图片生成）
- **数据格式**: JSON结构化数据, PNG/JPG图片

### 关键设计理念
**数据驱动的治理**: 系统的核心是处理结构化的GIS数据，而不是图片像素。图片仅作为：
1. **输入可视化**: 帮助大模型理解空间布局
2. **输出可视化**: 展示治理结果
3. **人工验证**: 便于人工检查治理效果

**工作流程**: 结构化数据 → 可视化图片 → 大模型分析 → 新的结构化数据 → 新的可视化图片

## 📁 项目结构

```
src/
├── core/                          # 核心业务逻辑
│   ├── __init__.py
│   ├── pipeline.py                # 主处理流程
│   ├── beautification.py          # 美化治理引擎
│   ├── evaluation.py              # 评分引擎
│   └── batch_processor.py         # 批量处理器
├── models/                        # 大模型接口
│   ├── __init__.py
│   ├── base_model.py              # 模型基类
│   ├── openai_model.py            # OpenAI API
│   ├── qwen_model.py              # 千问API
│   ├── kimi_model.py              # Kimi API (待实现)
│   └── glm_model.py               # 智谱GLM API (待实现)
├── utils/                         # 工具模块
│   ├── __init__.py
│   ├── gis_processor.py           # GIS数据处理和验证
│   ├── visualization.py           # GIS数据可视化生成器
│   ├── data_formatter.py          # 数据格式化
│   ├── prompt_manager.py          # Prompt管理
│   └── config.py                  # 配置管理
├── tracking/                      # 实验追踪
│   ├── __init__.py
│   ├── wandb_tracker.py           # WandB集成
│   └── metrics.py                 # 指标计算
├── data/                          # 数据接口
│   ├── __init__.py
│   ├── input_loader.py            # 输入数据加载
│   └── output_saver.py            # 结果保存
└── main.py                        # 主入口程序
```

## 🔧 核心接口设计

### 1. 数据格式规范

#### 输入格式
```python
class GISData:
    """结构化的GIS数据 - 用来画图的原始数据"""
    devices: List[dict]            # 设备坐标列表 [{"x": 100, "y": 200, "type": "transformer"}, ...]
    buildings: List[dict]          # 建筑物坐标 [{"coords": [[x1,y1], [x2,y2], ...], "type": "residential"}, ...]
    roads: List[dict]              # 道路坐标 [{"coords": [[x1,y1], [x2,y2], ...], "width": 5}, ...]
    rivers: List[dict]             # 河流坐标 [{"coords": [[x1,y1], [x2,y2], ...], "width": 10}, ...]
    boundaries: dict               # 台区边界 {"coords": [[x1,y1], [x2,y2], ...]}
    metadata: dict                 # 元数据 (台区ID、区域信息等)

class ImageInput:
    gis_data: GISData              # 核心：用来画图的结构化数据
    visual_image_path: str         # 辅助：基于gis_data生成的可视化图片路径
    image_format: str = "png"      # 图片格式
    
class BatchInput:
    inputs: List[ImageInput]       # 输入列表
    config: ProcessingConfig       # 处理配置
```

#### 输出格式
```python
class TreatmentResult:
    original_input: ImageInput     # 原始输入（包含原始GIS数据）
    treated_gis_data: GISData     # 治理后的结构化GIS数据
    treated_image_path: str       # 基于treated_gis_data生成的可视化图片
    beauty_score: float           # 美观性评分 (0-100)
    improvement_metrics: dict     # 改善指标 {"device_redistribution": 0.8, "visual_harmony": 0.9}
    model_info: ModelInfo         # 使用的模型信息
    tokens_used: TokenUsage       # token使用情况
    processing_time: float        # 处理时间
    cost: float                   # 处理成本

class BatchResult:
    results: List[TreatmentResult] # 所有结果
    summary: BatchSummary          # 批量处理汇总
    wandb_run_id: str             # WandB运行ID
```

### 2. 模型接口规范

#### 基础模型接口 (`models/base_model.py`)
```python
from abc import ABC, abstractmethod
from typing import Optional, Dict, Any, List
import time
import logging
from dataclasses import dataclass

@dataclass
class ModelPricing:
    """模型定价信息"""
    input_price_per_1m_tokens: float    # 输入价格 (美元/1M tokens)
    output_price_per_1m_tokens: float   # 输出价格 (美元/1M tokens)
    currency: str = "USD"
    model_name: str = ""

@dataclass
class TokenUsage:
    """Token使用统计"""
    input_tokens: int = 0
    output_tokens: int = 0
    total_tokens: int = 0
    
    def calculate_cost(self, pricing: ModelPricing) -> float:
        """计算调用成本"""
        input_cost = self.input_tokens * pricing.input_price_per_1m_tokens / 1_000_000
        output_cost = self.output_tokens * pricing.output_price_per_1m_tokens / 1_000_000
        return input_cost + output_cost

class BaseModel(ABC):
    """所有大模型的基类"""
    
    def __init__(self, api_key: str, model_name: str, **kwargs):
        self.api_key = api_key
        self.model_name = model_name
        self.max_retries = kwargs.get('max_retries', 3)
        self.timeout = kwargs.get('timeout', 300)
        self.logger = logging.getLogger(f"{self.__class__.__name__}")
        
        # 子类可重写的配置
        self.base_url = kwargs.get('base_url', None)
        self.extra_headers = kwargs.get('extra_headers', {})
    
    @abstractmethod
    def _make_api_call(self, messages: List[dict], **kwargs) -> Dict[str, Any]:
        """
        实际的API调用实现 (子类必须实现)
        返回: {"response": str, "usage": TokenUsage, "raw_response": dict}
        """
        pass
    
    @abstractmethod
    def get_pricing(self) -> ModelPricing:
        """获取模型定价信息 (子类必须实现)"""
        pass
    
    def beautify(self, image_input: ImageInput, prompt: str) -> TreatmentResponse:
        """
        美化治理接口 (通用实现)
        - 输入: ImageInput (包含GIS结构化数据 + 可视化图片)
        - 输出: 治理后的结构化GIS数据
        """
        # 构建消息
        messages = self._build_beautify_messages(image_input, prompt)
        
        # 调用API
        start_time = time.perf_counter()
        api_result = self._make_api_call_with_retry(messages)
        processing_time = time.perf_counter() - start_time
        
        # 解析治理结果
        treated_gis_data = self._parse_treatment_response(api_result["response"])
        
        return TreatmentResponse(
            treated_gis_data=treated_gis_data,
            input_tokens=api_result["usage"].input_tokens,
            output_tokens=api_result["usage"].output_tokens,
            processing_time=processing_time,
            raw_response=api_result["response"],
            confidence_score=self._extract_confidence(api_result["response"])
        )
    
    def evaluate(self, original_input: ImageInput, treated_gis_data: GISData) -> EvaluationResponse:
        """
        美观性评分接口 (通用实现)
        - 对比原始和治理后的结构化数据
        - 返回美观性评分和改善指标
        """
        # 构建评分消息
        messages = self._build_evaluate_messages(original_input, treated_gis_data)
        
        # 调用API
        api_result = self._make_api_call_with_retry(messages)
        
        # 解析评分结果
        evaluation_data = self._parse_evaluation_response(api_result["response"])
        
        return EvaluationResponse(
            beauty_score=evaluation_data["beauty_score"],
            dimension_scores=evaluation_data["dimension_scores"],
            improvement_analysis=evaluation_data["improvement_analysis"],
            reasoning=evaluation_data["reasoning"],
            input_tokens=api_result["usage"].input_tokens,
            output_tokens=api_result["usage"].output_tokens
        )
    
    def _make_api_call_with_retry(self, messages: List[dict]) -> Dict[str, Any]:
        """带重试的API调用"""
        last_exception = None
        
        for attempt in range(self.max_retries):
            try:
                return self._make_api_call(messages)
            except Exception as e:
                last_exception = e
                self.logger.warning(f"API调用失败 (尝试 {attempt + 1}/{self.max_retries}): {e}")
                if attempt < self.max_retries - 1:
                    # 指数退避
                    wait_time = 2 ** attempt
                    time.sleep(wait_time)
        
        raise last_exception
    
    def _build_beautify_messages(self, image_input: ImageInput, prompt: str) -> List[dict]:
        """构建治理请求的消息 (子类可重写)"""
        # 将GIS数据序列化为JSON字符串
        gis_json = json.dumps(image_input.gis_data.__dict__, ensure_ascii=False, indent=2)
        
        user_message = f"""
{prompt}

## 当前台区GIS数据:
```json
{gis_json}
```

请基于以上数据进行美观性治理，返回JSON格式的优化后数据。
"""
        
        messages = [
            {"role": "system", "content": "你是电网台区布局优化专家，擅长优化设备空间布局。"},
            {"role": "user", "content": user_message}
        ]
        
        # 如果有图片，添加图片
        if hasattr(image_input, 'visual_image_path') and image_input.visual_image_path:
            messages = self._add_image_to_messages(messages, image_input.visual_image_path)
        
        return messages
    
    def _build_evaluate_messages(self, original_input: ImageInput, treated_gis_data: GISData) -> List[dict]:
        """构建评分请求的消息 (子类可重写)"""
        original_json = json.dumps(original_input.gis_data.__dict__, ensure_ascii=False, indent=2)
        treated_json = json.dumps(treated_gis_data.__dict__, ensure_ascii=False, indent=2)
        
        user_message = f"""
请对台区治理效果进行美观性评分 (0-100分)。

## 治理前数据:
```json
{original_json}
```

## 治理后数据:
```json
{treated_json}
```

请从以下维度评分并返回JSON格式:
1. layout (布局合理性)
2. spacing (设备间距)  
3. harmony (视觉和谐性)
4. accessibility (可达性)
"""
        
        return [
            {"role": "system", "content": "你是台区美观性评价专家，能客观评估设备布局的美观性。"},
            {"role": "user", "content": user_message}
        ]
    
    @abstractmethod
    def _add_image_to_messages(self, messages: List[dict], image_path: str) -> List[dict]:
        """添加图片到消息 (不同模型实现不同)"""
        pass
    
    def _parse_treatment_response(self, response: str) -> GISData:
        """解析治理响应为GIS数据 (子类可重写)"""
        # 基础JSON解析实现
        try:
            data = json.loads(response)
            return GISData(**data)
        except Exception as e:
            self.logger.error(f"解析治理响应失败: {e}")
            raise ValueError(f"无法解析治理结果: {response}")
    
    def _parse_evaluation_response(self, response: str) -> Dict[str, Any]:
        """解析评分响应 (子类可重写)"""
        try:
            return json.loads(response)
        except Exception as e:
            self.logger.error(f"解析评分响应失败: {e}")
            raise ValueError(f"无法解析评分结果: {response}")
    
    def _extract_confidence(self, response: str) -> float:
        """提取置信度 (子类可重写)"""
        return 0.8  # 默认置信度
```

#### 模型实现示例 (`models/qwen_model.py`)
```python
import requests
import base64
import json
from typing import List, Dict, Any
from .base_model import BaseModel, ModelPricing, TokenUsage

class QwenModel(BaseModel):
    """阿里云千问VL-Max模型实现 - 基于现有codespace/qwenMaxApi.py"""
    
    def __init__(self, api_key: str, model_name: str = "qwen-vl-max-latest", **kwargs):
        super().__init__(api_key, model_name, **kwargs)
        self.base_url = kwargs.get('base_url', "https://dashscope.aliyuncs.com/api/v1/services/aigc/multimodal-generation/generation")
    
    def _make_api_call(self, messages: List[dict], **kwargs) -> Dict[str, Any]:
        """千问API调用实现"""
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
        
        data = {
            "model": self.model_name,
            "input": {"messages": messages},
            "parameters": {
                "max_tokens": kwargs.get('max_tokens', 4000),
                "temperature": kwargs.get('temperature', 0.3)
            }
        }
        
        response = requests.post(self.base_url, headers=headers, json=data, timeout=self.timeout)
        response.raise_for_status()
        result = response.json()
        
        if result.get("code"):
            raise Exception(f"千问API错误: {result.get('message')}")
        
        # 提取响应信息
        content = result["output"]["choices"][0]["message"]["content"]
        usage_data = result.get("usage", {})
        usage = TokenUsage(
            input_tokens=usage_data.get("input_tokens", 0),
            output_tokens=usage_data.get("output_tokens", 0),
            total_tokens=usage_data.get("total_tokens", 0)
        )
        
        return {"response": content, "usage": usage, "raw_response": result}
    
    def _add_image_to_messages(self, messages: List[dict], image_path: str) -> List[dict]:
        """千问的图片添加方式"""
        with open(image_path, "rb") as image_file:
            base64_image = base64.b64encode(image_file.read()).decode('utf-8')
        
        # 千问使用特殊的多模态格式
        if messages and messages[-1]["role"] == "user":
            messages[-1]["content"] = [
                {"text": messages[-1]["content"]},
                {"image": f"data:image/jpeg;base64,{base64_image}"}
            ]
        
        return messages
    
    def get_pricing(self) -> ModelPricing:
        """千问定价"""
        return ModelPricing(
            input_price_per_1m_tokens=0.4,
            output_price_per_1m_tokens=1.2,
            model_name=self.model_name
        )
```

#### 其他模型实现
- `models/openai_model.py`: OpenAI GPT-4o/o3模型 (待实现)
- `models/kimi_model.py`: Moonshot Kimi模型 (待实现)  
- `models/glm_model.py`: 智谱GLM-4V模型 (待实现)

#### 模型工厂设计 (`models/__init__.py`)
```python
def get_model(model_type: str, **kwargs) -> BaseModel:
    """
    模型工厂函数 - 统一创建各种大模型
    
    示例:
    model = get_model('qwen', api_key='sk-xxx', model_name='qwen-vl-max-latest')
    result = model.beautify(image_input, prompt)
    """
    # 实现模型注册和创建逻辑
    pass
```

### 3. 处理流程设计

#### 单图处理流程
```python
def process_single_image(image_input: ImageInput, models: List[str]) -> List[TreatmentResult]:
    """
    单图处理流程
    1. 验证和预处理GIS数据
    2. 生成可视化图片（如果需要）
    3. 调用治理模型（输入：结构化数据+图片，输出：优化后的结构化数据）
    4. 生成治理后的可视化图片
    5. 调用评分模型（对比原始和治理后的数据）
    6. 计算成本和指标
    7. 返回结果
    """
    results = []
    for model_name in models:
        model = get_model(model_name)
        
        # 治理步骤：基于GIS数据进行治理
        treatment_resp = model.beautify(image_input, get_treatment_prompt())
        
        # 生成治理后的可视化图片
        treated_image_path = generate_visualization(treatment_resp.treated_gis_data)
        
        # 评分步骤：对比原始和治理后的GIS数据
        evaluation_resp = model.evaluate(image_input, treatment_resp.treated_gis_data)
        
        # 组装结果
        result = TreatmentResult(
            original_input=image_input,
            treated_gis_data=treatment_resp.treated_gis_data,
            treated_image_path=treated_image_path,
            beauty_score=evaluation_resp.beauty_score,
            improvement_metrics=evaluation_resp.improvement_analysis,
            # ... 其他字段
        )
        results.append(result)
    
    return results
```

#### 批量处理流程
```python
def process_batch(batch_input: BatchInput) -> BatchResult:
    """
    批量处理流程
    1. 初始化WandB实验
    2. 准备任务队列
    3. Multiprocessing并行处理
    4. 收集结果并记录到WandB
    5. 生成汇总报告
    """
    with multiprocessing.Pool() as pool:
        task_args = prepare_tasks(batch_input)
        results = pool.map(process_single_image, task_args)
    
    # 记录到WandB并生成报告
    wandb_tracker.log_batch_results(results)
    return BatchResult(...)
```

## 📊 WandB实验追踪设计

### 追踪指标
```python
# 业务指标
BUSINESS_METRICS = {
    'beauty_score': '美观性评分',
    'device_count_before': '治理前设备数量', 
    'device_count_after': '治理后设备数量',
    'devices_moved': '移动的设备数量',
    'layout_improvement': '布局改善度',
    'spacing_improvement': '间距改善度',
    'visual_harmony_score': '视觉和谐性评分'
}

# 成本指标  
COST_METRICS = {
    'input_tokens': '输入token数',
    'output_tokens': '输出token数', 
    'total_cost_usd': '总成本(美元)',
    'cost_per_image': '单图成本',
    'cost_per_device': '单设备成本'
}

# 性能指标
PERFORMANCE_METRICS = {
    'processing_time': '处理时间(秒)',
    'api_latency': 'API延迟(秒)',
    'throughput': '吞吐量(图片/分钟)'
}
```

### 实验组织
```python
# 实验命名规范
RUN_NAME_FORMAT = "{model}_{batch_size}_{timestamp}"

# 项目结构
PROJECT_NAME = "gis-beautification"
ENTITY_NAME = "dy-gis-team"

# Artifacts管理
ARTIFACT_TYPES = {
    'dataset': '输入图片数据集',
    'prompts': 'Prompt模板版本',
    'results': '处理结果数据',
    'models': '模型权重文件'
}
```

## 🚀 实现优先级

### Phase 1: 基础框架 (本次实现)
- [x] 项目结构搭建
- [ ] 核心接口定义
- [ ] 千问模型集成 (基于现有代码)
- [ ] 基础WandB追踪
- [ ] 单图处理流程
- [ ] 简单的placeholder函数

### Phase 2: 功能完善
- [ ] OpenAI模型集成
- [ ] 批量处理和multiprocessing
- [ ] 完整的WandB实验追踪
- [ ] 错误处理和重试机制
- [ ] 配置文件管理

### Phase 3: 扩展优化
- [ ] Kimi和智谱GLM模型
- [ ] 高级图像预处理
- [ ] 模型结果对比分析
- [ ] 性能优化和缓存
- [ ] Web界面集成

## ⚙️ 配置管理

### 环境变量
```bash
# API Keys
OPENAI_API_KEY=sk-xxx
QWEN_API_KEY=sk-xxx  
KIMI_API_KEY=sk-xxx
GLM_API_KEY=xxx

# WandB配置
WANDB_API_KEY=xxx
WANDB_PROJECT=gis-beautification
WANDB_ENTITY=dy-gis-team

# 处理配置
MAX_WORKERS=4
BATCH_SIZE=10
DEFAULT_MODEL=qwen-vl-max
```

### 处理参数
```python
class ProcessingConfig:
    models: List[str] = ['qwen-vl-max']      # 使用的模型列表
    max_workers: int = 4                      # 并行进程数
    batch_size: int = 10                      # 批处理大小
    enable_wandb: bool = True                 # 是否启用WandB
    save_intermediate: bool = False           # 是否保存中间结果
    retry_count: int = 3                      # 失败重试次数
    timeout: int = 300                        # API调用超时(秒)
```

## 🔍 质量保证

### 错误处理策略
- API调用失败自动重试 (指数退避)
- 网络超时处理
- 格式错误的响应处理
- 进程异常恢复

### 日志记录
- 结构化日志输出
- 不同级别的日志记录
- 性能监控点埋设
- 异常堆栈追踪

### 测试策略
- 单元测试: 各模块功能测试
- 集成测试: 端到端流程测试  
- 性能测试: 并发处理能力测试
- 回归测试: 模型输出一致性测试

---

**下一步**: 请审阅此架构设计，确认无误后我将开始实现Phase 1的基础框架。
# ç”µç½‘å°åŒºç¾åŒ–æ²»ç†ä¸æ‰“åˆ†ç³»ç»Ÿ - æ¶æ„è®¾è®¡æ–‡æ¡£

**ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¥æœŸ**: 2025å¹´1æœˆ21æ—¥  
**è®¾è®¡ç›®æ ‡**: ç«¯åˆ°ç«¯è‡ªåŠ¨åŒ–æ²»ç†+æ‰“åˆ†ç³»ç»Ÿ

## ğŸ¯ ç³»ç»Ÿæ¦‚è¿°

### æ ¸å¿ƒåŠŸèƒ½
- **è¾“å…¥**: ç»“æ„åŒ–GISæ•°æ®ï¼ˆè®¾å¤‡åæ ‡ã€åœ°å½¢è¦ç´ ç­‰ï¼‰+ å¯è§†åŒ–å›¾ç‰‡
- **å¤„ç†**: å¤§æ¨¡å‹åŸºäºæ•°æ®è¿›è¡Œè‡ªåŠ¨åŒ–æ²»ç† + ç¾è§‚æ€§æ‰“åˆ†
- **è¾“å‡º**: æ²»ç†åçš„ç»“æ„åŒ–æ•°æ® + æ–°ç”Ÿæˆçš„å¯è§†åŒ–å›¾ç‰‡ + è¯¦ç»†è¯„åˆ†æŠ¥å‘Š
- **å¯è§†åŒ–**: åŒå‘è½¬æ¢ï¼ˆGISæ•°æ® â†” å›¾ç‰‡å¯è§†åŒ–ï¼‰
- **è¿½è¸ª**: WandBå®éªŒè®°å½• + æˆæœ¬åˆ†æ
- **å¹¶è¡Œ**: Multiprocessingæ‰¹é‡å¤„ç†

### æŠ€æœ¯æ ˆ
- **å¤šæ¨¡æ€å¤§æ¨¡å‹**: OpenAI o3, åƒé—®VL-Max, Kimi K2, æ™ºè°±GLM-4V
- **å®éªŒè¿½è¸ª**: Weights & Biases (WandB)
- **å¹¶è¡Œå¤„ç†**: Python multiprocessing
- **å¯è§†åŒ–**: Matplotlib, PILï¼ˆGISæ•°æ® â†’ å›¾ç‰‡ç”Ÿæˆï¼‰
- **æ•°æ®æ ¼å¼**: JSONç»“æ„åŒ–æ•°æ®, PNG/JPGå›¾ç‰‡

### å…³é”®è®¾è®¡ç†å¿µ
**æ•°æ®é©±åŠ¨çš„æ²»ç†**: ç³»ç»Ÿçš„æ ¸å¿ƒæ˜¯å¤„ç†ç»“æ„åŒ–çš„GISæ•°æ®ï¼Œè€Œä¸æ˜¯å›¾ç‰‡åƒç´ ã€‚å›¾ç‰‡ä»…ä½œä¸ºï¼š
1. **è¾“å…¥å¯è§†åŒ–**: å¸®åŠ©å¤§æ¨¡å‹ç†è§£ç©ºé—´å¸ƒå±€
2. **è¾“å‡ºå¯è§†åŒ–**: å±•ç¤ºæ²»ç†ç»“æœ
3. **äººå·¥éªŒè¯**: ä¾¿äºäººå·¥æ£€æŸ¥æ²»ç†æ•ˆæœ

**å·¥ä½œæµç¨‹**: ç»“æ„åŒ–æ•°æ® â†’ å¯è§†åŒ–å›¾ç‰‡ â†’ å¤§æ¨¡å‹åˆ†æ â†’ æ–°çš„ç»“æ„åŒ–æ•°æ® â†’ æ–°çš„å¯è§†åŒ–å›¾ç‰‡

## ğŸ“ é¡¹ç›®ç»“æ„

```
src/
â”œâ”€â”€ core/                          # æ ¸å¿ƒä¸šåŠ¡é€»è¾‘
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ pipeline.py                # ä¸»å¤„ç†æµç¨‹
â”‚   â”œâ”€â”€ beautification.py          # ç¾åŒ–æ²»ç†å¼•æ“
â”‚   â”œâ”€â”€ evaluation.py              # è¯„åˆ†å¼•æ“
â”‚   â””â”€â”€ batch_processor.py         # æ‰¹é‡å¤„ç†å™¨
â”œâ”€â”€ models/                        # å¤§æ¨¡å‹æ¥å£
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ base_model.py              # æ¨¡å‹åŸºç±»
â”‚   â”œâ”€â”€ openai_model.py            # OpenAI API
â”‚   â”œâ”€â”€ qwen_model.py              # åƒé—®API
â”‚   â”œâ”€â”€ kimi_model.py              # Kimi API (å¾…å®ç°)
â”‚   â””â”€â”€ glm_model.py               # æ™ºè°±GLM API (å¾…å®ç°)
â”œâ”€â”€ utils/                         # å·¥å…·æ¨¡å—
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ gis_processor.py           # GISæ•°æ®å¤„ç†å’ŒéªŒè¯
â”‚   â”œâ”€â”€ visualization.py           # GISæ•°æ®å¯è§†åŒ–ç”Ÿæˆå™¨
â”‚   â”œâ”€â”€ data_formatter.py          # æ•°æ®æ ¼å¼åŒ–
â”‚   â”œâ”€â”€ prompt_manager.py          # Promptç®¡ç†
â”‚   â””â”€â”€ config.py                  # é…ç½®ç®¡ç†
â”œâ”€â”€ tracking/                      # å®éªŒè¿½è¸ª
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ wandb_tracker.py           # WandBé›†æˆ
â”‚   â””â”€â”€ metrics.py                 # æŒ‡æ ‡è®¡ç®—
â”œâ”€â”€ data/                          # æ•°æ®æ¥å£
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ input_loader.py            # è¾“å…¥æ•°æ®åŠ è½½
â”‚   â””â”€â”€ output_saver.py            # ç»“æœä¿å­˜
â””â”€â”€ main.py                        # ä¸»å…¥å£ç¨‹åº
```

## ğŸ”§ æ ¸å¿ƒæ¥å£è®¾è®¡

### 1. æ•°æ®æ ¼å¼è§„èŒƒ

#### è¾“å…¥æ ¼å¼
```python
class GISData:
    """ç»“æ„åŒ–çš„GISæ•°æ® - ç”¨æ¥ç”»å›¾çš„åŸå§‹æ•°æ®"""
    devices: List[dict]            # è®¾å¤‡åæ ‡åˆ—è¡¨ [{"x": 100, "y": 200, "type": "transformer"}, ...]
    buildings: List[dict]          # å»ºç­‘ç‰©åæ ‡ [{"coords": [[x1,y1], [x2,y2], ...], "type": "residential"}, ...]
    roads: List[dict]              # é“è·¯åæ ‡ [{"coords": [[x1,y1], [x2,y2], ...], "width": 5}, ...]
    rivers: List[dict]             # æ²³æµåæ ‡ [{"coords": [[x1,y1], [x2,y2], ...], "width": 10}, ...]
    boundaries: dict               # å°åŒºè¾¹ç•Œ {"coords": [[x1,y1], [x2,y2], ...]}
    metadata: dict                 # å…ƒæ•°æ® (å°åŒºIDã€åŒºåŸŸä¿¡æ¯ç­‰)

class ImageInput:
    gis_data: GISData              # æ ¸å¿ƒï¼šç”¨æ¥ç”»å›¾çš„ç»“æ„åŒ–æ•°æ®
    visual_image_path: str         # è¾…åŠ©ï¼šåŸºäºgis_dataç”Ÿæˆçš„å¯è§†åŒ–å›¾ç‰‡è·¯å¾„
    image_format: str = "png"      # å›¾ç‰‡æ ¼å¼
    
class BatchInput:
    inputs: List[ImageInput]       # è¾“å…¥åˆ—è¡¨
    config: ProcessingConfig       # å¤„ç†é…ç½®
```

#### è¾“å‡ºæ ¼å¼
```python
class TreatmentResult:
    original_input: ImageInput     # åŸå§‹è¾“å…¥ï¼ˆåŒ…å«åŸå§‹GISæ•°æ®ï¼‰
    treated_gis_data: GISData     # æ²»ç†åçš„ç»“æ„åŒ–GISæ•°æ®
    treated_image_path: str       # åŸºäºtreated_gis_dataç”Ÿæˆçš„å¯è§†åŒ–å›¾ç‰‡
    beauty_score: float           # ç¾è§‚æ€§è¯„åˆ† (0-100)
    improvement_metrics: dict     # æ”¹å–„æŒ‡æ ‡ {"device_redistribution": 0.8, "visual_harmony": 0.9}
    model_info: ModelInfo         # ä½¿ç”¨çš„æ¨¡å‹ä¿¡æ¯
    tokens_used: TokenUsage       # tokenä½¿ç”¨æƒ…å†µ
    processing_time: float        # å¤„ç†æ—¶é—´
    cost: float                   # å¤„ç†æˆæœ¬

class BatchResult:
    results: List[TreatmentResult] # æ‰€æœ‰ç»“æœ
    summary: BatchSummary          # æ‰¹é‡å¤„ç†æ±‡æ€»
    wandb_run_id: str             # WandBè¿è¡ŒID
```

### 2. æ¨¡å‹æ¥å£è§„èŒƒ

#### åŸºç¡€æ¨¡å‹æ¥å£ (`models/base_model.py`)
```python
from abc import ABC, abstractmethod
from typing import Optional, Dict, Any, List
import time
import logging
from dataclasses import dataclass

@dataclass
class ModelPricing:
    """æ¨¡å‹å®šä»·ä¿¡æ¯"""
    input_price_per_1m_tokens: float    # è¾“å…¥ä»·æ ¼ (ç¾å…ƒ/1M tokens)
    output_price_per_1m_tokens: float   # è¾“å‡ºä»·æ ¼ (ç¾å…ƒ/1M tokens)
    currency: str = "USD"
    model_name: str = ""

@dataclass
class TokenUsage:
    """Tokenä½¿ç”¨ç»Ÿè®¡"""
    input_tokens: int = 0
    output_tokens: int = 0
    total_tokens: int = 0
    
    def calculate_cost(self, pricing: ModelPricing) -> float:
        """è®¡ç®—è°ƒç”¨æˆæœ¬"""
        input_cost = self.input_tokens * pricing.input_price_per_1m_tokens / 1_000_000
        output_cost = self.output_tokens * pricing.output_price_per_1m_tokens / 1_000_000
        return input_cost + output_cost

class BaseModel(ABC):
    """æ‰€æœ‰å¤§æ¨¡å‹çš„åŸºç±»"""
    
    def __init__(self, api_key: str, model_name: str, **kwargs):
        self.api_key = api_key
        self.model_name = model_name
        self.max_retries = kwargs.get('max_retries', 3)
        self.timeout = kwargs.get('timeout', 300)
        self.logger = logging.getLogger(f"{self.__class__.__name__}")
        
        # å­ç±»å¯é‡å†™çš„é…ç½®
        self.base_url = kwargs.get('base_url', None)
        self.extra_headers = kwargs.get('extra_headers', {})
    
    @abstractmethod
    def _make_api_call(self, messages: List[dict], **kwargs) -> Dict[str, Any]:
        """
        å®é™…çš„APIè°ƒç”¨å®ç° (å­ç±»å¿…é¡»å®ç°)
        è¿”å›: {"response": str, "usage": TokenUsage, "raw_response": dict}
        """
        pass
    
    @abstractmethod
    def get_pricing(self) -> ModelPricing:
        """è·å–æ¨¡å‹å®šä»·ä¿¡æ¯ (å­ç±»å¿…é¡»å®ç°)"""
        pass
    
    def beautify(self, image_input: ImageInput, prompt: str) -> TreatmentResponse:
        """
        ç¾åŒ–æ²»ç†æ¥å£ (é€šç”¨å®ç°)
        - è¾“å…¥: ImageInput (åŒ…å«GISç»“æ„åŒ–æ•°æ® + å¯è§†åŒ–å›¾ç‰‡)
        - è¾“å‡º: æ²»ç†åçš„ç»“æ„åŒ–GISæ•°æ®
        """
        # æ„å»ºæ¶ˆæ¯
        messages = self._build_beautify_messages(image_input, prompt)
        
        # è°ƒç”¨API
        start_time = time.perf_counter()
        api_result = self._make_api_call_with_retry(messages)
        processing_time = time.perf_counter() - start_time
        
        # è§£ææ²»ç†ç»“æœ
        treated_gis_data = self._parse_treatment_response(api_result["response"])
        
        return TreatmentResponse(
            treated_gis_data=treated_gis_data,
            input_tokens=api_result["usage"].input_tokens,
            output_tokens=api_result["usage"].output_tokens,
            processing_time=processing_time,
            raw_response=api_result["response"],
            confidence_score=self._extract_confidence(api_result["response"])
        )
    
    def evaluate(self, original_input: ImageInput, treated_gis_data: GISData) -> EvaluationResponse:
        """
        ç¾è§‚æ€§è¯„åˆ†æ¥å£ (é€šç”¨å®ç°)
        - å¯¹æ¯”åŸå§‹å’Œæ²»ç†åçš„ç»“æ„åŒ–æ•°æ®
        - è¿”å›ç¾è§‚æ€§è¯„åˆ†å’Œæ”¹å–„æŒ‡æ ‡
        """
        # æ„å»ºè¯„åˆ†æ¶ˆæ¯
        messages = self._build_evaluate_messages(original_input, treated_gis_data)
        
        # è°ƒç”¨API
        api_result = self._make_api_call_with_retry(messages)
        
        # è§£æè¯„åˆ†ç»“æœ
        evaluation_data = self._parse_evaluation_response(api_result["response"])
        
        return EvaluationResponse(
            beauty_score=evaluation_data["beauty_score"],
            dimension_scores=evaluation_data["dimension_scores"],
            improvement_analysis=evaluation_data["improvement_analysis"],
            reasoning=evaluation_data["reasoning"],
            input_tokens=api_result["usage"].input_tokens,
            output_tokens=api_result["usage"].output_tokens
        )
    
    def _make_api_call_with_retry(self, messages: List[dict]) -> Dict[str, Any]:
        """å¸¦é‡è¯•çš„APIè°ƒç”¨"""
        last_exception = None
        
        for attempt in range(self.max_retries):
            try:
                return self._make_api_call(messages)
            except Exception as e:
                last_exception = e
                self.logger.warning(f"APIè°ƒç”¨å¤±è´¥ (å°è¯• {attempt + 1}/{self.max_retries}): {e}")
                if attempt < self.max_retries - 1:
                    # æŒ‡æ•°é€€é¿
                    wait_time = 2 ** attempt
                    time.sleep(wait_time)
        
        raise last_exception
    
    def _build_beautify_messages(self, image_input: ImageInput, prompt: str) -> List[dict]:
        """æ„å»ºæ²»ç†è¯·æ±‚çš„æ¶ˆæ¯ (å­ç±»å¯é‡å†™)"""
        # å°†GISæ•°æ®åºåˆ—åŒ–ä¸ºJSONå­—ç¬¦ä¸²
        gis_json = json.dumps(image_input.gis_data.__dict__, ensure_ascii=False, indent=2)
        
        user_message = f"""
{prompt}

## å½“å‰å°åŒºGISæ•°æ®:
```json
{gis_json}
```

è¯·åŸºäºä»¥ä¸Šæ•°æ®è¿›è¡Œç¾è§‚æ€§æ²»ç†ï¼Œè¿”å›JSONæ ¼å¼çš„ä¼˜åŒ–åæ•°æ®ã€‚
"""
        
        messages = [
            {"role": "system", "content": "ä½ æ˜¯ç”µç½‘å°åŒºå¸ƒå±€ä¼˜åŒ–ä¸“å®¶ï¼Œæ“…é•¿ä¼˜åŒ–è®¾å¤‡ç©ºé—´å¸ƒå±€ã€‚"},
            {"role": "user", "content": user_message}
        ]
        
        # å¦‚æœæœ‰å›¾ç‰‡ï¼Œæ·»åŠ å›¾ç‰‡
        if hasattr(image_input, 'visual_image_path') and image_input.visual_image_path:
            messages = self._add_image_to_messages(messages, image_input.visual_image_path)
        
        return messages
    
    def _build_evaluate_messages(self, original_input: ImageInput, treated_gis_data: GISData) -> List[dict]:
        """æ„å»ºè¯„åˆ†è¯·æ±‚çš„æ¶ˆæ¯ (å­ç±»å¯é‡å†™)"""
        original_json = json.dumps(original_input.gis_data.__dict__, ensure_ascii=False, indent=2)
        treated_json = json.dumps(treated_gis_data.__dict__, ensure_ascii=False, indent=2)
        
        user_message = f"""
è¯·å¯¹å°åŒºæ²»ç†æ•ˆæœè¿›è¡Œç¾è§‚æ€§è¯„åˆ† (0-100åˆ†)ã€‚

## æ²»ç†å‰æ•°æ®:
```json
{original_json}
```

## æ²»ç†åæ•°æ®:
```json
{treated_json}
```

è¯·ä»ä»¥ä¸‹ç»´åº¦è¯„åˆ†å¹¶è¿”å›JSONæ ¼å¼:
1. layout (å¸ƒå±€åˆç†æ€§)
2. spacing (è®¾å¤‡é—´è·)  
3. harmony (è§†è§‰å’Œè°æ€§)
4. accessibility (å¯è¾¾æ€§)
"""
        
        return [
            {"role": "system", "content": "ä½ æ˜¯å°åŒºç¾è§‚æ€§è¯„ä»·ä¸“å®¶ï¼Œèƒ½å®¢è§‚è¯„ä¼°è®¾å¤‡å¸ƒå±€çš„ç¾è§‚æ€§ã€‚"},
            {"role": "user", "content": user_message}
        ]
    
    @abstractmethod
    def _add_image_to_messages(self, messages: List[dict], image_path: str) -> List[dict]:
        """æ·»åŠ å›¾ç‰‡åˆ°æ¶ˆæ¯ (ä¸åŒæ¨¡å‹å®ç°ä¸åŒ)"""
        pass
    
    def _parse_treatment_response(self, response: str) -> GISData:
        """è§£ææ²»ç†å“åº”ä¸ºGISæ•°æ® (å­ç±»å¯é‡å†™)"""
        # åŸºç¡€JSONè§£æå®ç°
        try:
            data = json.loads(response)
            return GISData(**data)
        except Exception as e:
            self.logger.error(f"è§£ææ²»ç†å“åº”å¤±è´¥: {e}")
            raise ValueError(f"æ— æ³•è§£ææ²»ç†ç»“æœ: {response}")
    
    def _parse_evaluation_response(self, response: str) -> Dict[str, Any]:
        """è§£æè¯„åˆ†å“åº” (å­ç±»å¯é‡å†™)"""
        try:
            return json.loads(response)
        except Exception as e:
            self.logger.error(f"è§£æè¯„åˆ†å“åº”å¤±è´¥: {e}")
            raise ValueError(f"æ— æ³•è§£æè¯„åˆ†ç»“æœ: {response}")
    
    def _extract_confidence(self, response: str) -> float:
        """æå–ç½®ä¿¡åº¦ (å­ç±»å¯é‡å†™)"""
        return 0.8  # é»˜è®¤ç½®ä¿¡åº¦
```

#### æ¨¡å‹å®ç°ç¤ºä¾‹ (`models/qwen_model.py`)
```python
import requests
import base64
import json
from typing import List, Dict, Any
from .base_model import BaseModel, ModelPricing, TokenUsage

class QwenModel(BaseModel):
    """é˜¿é‡Œäº‘åƒé—®VL-Maxæ¨¡å‹å®ç° - åŸºäºç°æœ‰codespace/qwenMaxApi.py"""
    
    def __init__(self, api_key: str, model_name: str = "qwen-vl-max-latest", **kwargs):
        super().__init__(api_key, model_name, **kwargs)
        self.base_url = kwargs.get('base_url', "https://dashscope.aliyuncs.com/api/v1/services/aigc/multimodal-generation/generation")
    
    def _make_api_call(self, messages: List[dict], **kwargs) -> Dict[str, Any]:
        """åƒé—®APIè°ƒç”¨å®ç°"""
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
        
        data = {
            "model": self.model_name,
            "input": {"messages": messages},
            "parameters": {
                "max_tokens": kwargs.get('max_tokens', 4000),
                "temperature": kwargs.get('temperature', 0.3)
            }
        }
        
        response = requests.post(self.base_url, headers=headers, json=data, timeout=self.timeout)
        response.raise_for_status()
        result = response.json()
        
        if result.get("code"):
            raise Exception(f"åƒé—®APIé”™è¯¯: {result.get('message')}")
        
        # æå–å“åº”ä¿¡æ¯
        content = result["output"]["choices"][0]["message"]["content"]
        usage_data = result.get("usage", {})
        usage = TokenUsage(
            input_tokens=usage_data.get("input_tokens", 0),
            output_tokens=usage_data.get("output_tokens", 0),
            total_tokens=usage_data.get("total_tokens", 0)
        )
        
        return {"response": content, "usage": usage, "raw_response": result}
    
    def _add_image_to_messages(self, messages: List[dict], image_path: str) -> List[dict]:
        """åƒé—®çš„å›¾ç‰‡æ·»åŠ æ–¹å¼"""
        with open(image_path, "rb") as image_file:
            base64_image = base64.b64encode(image_file.read()).decode('utf-8')
        
        # åƒé—®ä½¿ç”¨ç‰¹æ®Šçš„å¤šæ¨¡æ€æ ¼å¼
        if messages and messages[-1]["role"] == "user":
            messages[-1]["content"] = [
                {"text": messages[-1]["content"]},
                {"image": f"data:image/jpeg;base64,{base64_image}"}
            ]
        
        return messages
    
    def get_pricing(self) -> ModelPricing:
        """åƒé—®å®šä»·"""
        return ModelPricing(
            input_price_per_1m_tokens=0.4,
            output_price_per_1m_tokens=1.2,
            model_name=self.model_name
        )
```

#### å…¶ä»–æ¨¡å‹å®ç°
- `models/openai_model.py`: OpenAI GPT-4o/o3æ¨¡å‹ (å¾…å®ç°)
- `models/kimi_model.py`: Moonshot Kimiæ¨¡å‹ (å¾…å®ç°)  
- `models/glm_model.py`: æ™ºè°±GLM-4Væ¨¡å‹ (å¾…å®ç°)

#### æ¨¡å‹å·¥å‚è®¾è®¡ (`models/__init__.py`)
```python
def get_model(model_type: str, **kwargs) -> BaseModel:
    """
    æ¨¡å‹å·¥å‚å‡½æ•° - ç»Ÿä¸€åˆ›å»ºå„ç§å¤§æ¨¡å‹
    
    ç¤ºä¾‹:
    model = get_model('qwen', api_key='sk-xxx', model_name='qwen-vl-max-latest')
    result = model.beautify(image_input, prompt)
    """
    # å®ç°æ¨¡å‹æ³¨å†Œå’Œåˆ›å»ºé€»è¾‘
    pass
```

### 3. å¤„ç†æµç¨‹è®¾è®¡

#### å•å›¾å¤„ç†æµç¨‹
```python
def process_single_image(image_input: ImageInput, models: List[str]) -> List[TreatmentResult]:
    """
    å•å›¾å¤„ç†æµç¨‹
    1. éªŒè¯å’Œé¢„å¤„ç†GISæ•°æ®
    2. ç”Ÿæˆå¯è§†åŒ–å›¾ç‰‡ï¼ˆå¦‚æœéœ€è¦ï¼‰
    3. è°ƒç”¨æ²»ç†æ¨¡å‹ï¼ˆè¾“å…¥ï¼šç»“æ„åŒ–æ•°æ®+å›¾ç‰‡ï¼Œè¾“å‡ºï¼šä¼˜åŒ–åçš„ç»“æ„åŒ–æ•°æ®ï¼‰
    4. ç”Ÿæˆæ²»ç†åçš„å¯è§†åŒ–å›¾ç‰‡
    5. è°ƒç”¨è¯„åˆ†æ¨¡å‹ï¼ˆå¯¹æ¯”åŸå§‹å’Œæ²»ç†åçš„æ•°æ®ï¼‰
    6. è®¡ç®—æˆæœ¬å’ŒæŒ‡æ ‡
    7. è¿”å›ç»“æœ
    """
    results = []
    for model_name in models:
        model = get_model(model_name)
        
        # æ²»ç†æ­¥éª¤ï¼šåŸºäºGISæ•°æ®è¿›è¡Œæ²»ç†
        treatment_resp = model.beautify(image_input, get_treatment_prompt())
        
        # ç”Ÿæˆæ²»ç†åçš„å¯è§†åŒ–å›¾ç‰‡
        treated_image_path = generate_visualization(treatment_resp.treated_gis_data)
        
        # è¯„åˆ†æ­¥éª¤ï¼šå¯¹æ¯”åŸå§‹å’Œæ²»ç†åçš„GISæ•°æ®
        evaluation_resp = model.evaluate(image_input, treatment_resp.treated_gis_data)
        
        # ç»„è£…ç»“æœ
        result = TreatmentResult(
            original_input=image_input,
            treated_gis_data=treatment_resp.treated_gis_data,
            treated_image_path=treated_image_path,
            beauty_score=evaluation_resp.beauty_score,
            improvement_metrics=evaluation_resp.improvement_analysis,
            # ... å…¶ä»–å­—æ®µ
        )
        results.append(result)
    
    return results
```

#### æ‰¹é‡å¤„ç†æµç¨‹
```python
def process_batch(batch_input: BatchInput) -> BatchResult:
    """
    æ‰¹é‡å¤„ç†æµç¨‹
    1. åˆå§‹åŒ–WandBå®éªŒ
    2. å‡†å¤‡ä»»åŠ¡é˜Ÿåˆ—
    3. Multiprocessingå¹¶è¡Œå¤„ç†
    4. æ”¶é›†ç»“æœå¹¶è®°å½•åˆ°WandB
    5. ç”Ÿæˆæ±‡æ€»æŠ¥å‘Š
    """
    with multiprocessing.Pool() as pool:
        task_args = prepare_tasks(batch_input)
        results = pool.map(process_single_image, task_args)
    
    # è®°å½•åˆ°WandBå¹¶ç”ŸæˆæŠ¥å‘Š
    wandb_tracker.log_batch_results(results)
    return BatchResult(...)
```

## ğŸ“Š WandBå®éªŒè¿½è¸ªè®¾è®¡

### è¿½è¸ªæŒ‡æ ‡
```python
# ä¸šåŠ¡æŒ‡æ ‡
BUSINESS_METRICS = {
    'beauty_score': 'ç¾è§‚æ€§è¯„åˆ†',
    'device_count_before': 'æ²»ç†å‰è®¾å¤‡æ•°é‡', 
    'device_count_after': 'æ²»ç†åè®¾å¤‡æ•°é‡',
    'devices_moved': 'ç§»åŠ¨çš„è®¾å¤‡æ•°é‡',
    'layout_improvement': 'å¸ƒå±€æ”¹å–„åº¦',
    'spacing_improvement': 'é—´è·æ”¹å–„åº¦',
    'visual_harmony_score': 'è§†è§‰å’Œè°æ€§è¯„åˆ†'
}

# æˆæœ¬æŒ‡æ ‡  
COST_METRICS = {
    'input_tokens': 'è¾“å…¥tokenæ•°',
    'output_tokens': 'è¾“å‡ºtokenæ•°', 
    'total_cost_usd': 'æ€»æˆæœ¬(ç¾å…ƒ)',
    'cost_per_image': 'å•å›¾æˆæœ¬',
    'cost_per_device': 'å•è®¾å¤‡æˆæœ¬'
}

# æ€§èƒ½æŒ‡æ ‡
PERFORMANCE_METRICS = {
    'processing_time': 'å¤„ç†æ—¶é—´(ç§’)',
    'api_latency': 'APIå»¶è¿Ÿ(ç§’)',
    'throughput': 'ååé‡(å›¾ç‰‡/åˆ†é’Ÿ)'
}
```

### å®éªŒç»„ç»‡
```python
# å®éªŒå‘½åè§„èŒƒ
RUN_NAME_FORMAT = "{model}_{batch_size}_{timestamp}"

# é¡¹ç›®ç»“æ„
PROJECT_NAME = "gis-beautification"
ENTITY_NAME = "dy-gis-team"

# Artifactsç®¡ç†
ARTIFACT_TYPES = {
    'dataset': 'è¾“å…¥å›¾ç‰‡æ•°æ®é›†',
    'prompts': 'Promptæ¨¡æ¿ç‰ˆæœ¬',
    'results': 'å¤„ç†ç»“æœæ•°æ®',
    'models': 'æ¨¡å‹æƒé‡æ–‡ä»¶'
}
```

## ğŸš€ å®ç°ä¼˜å…ˆçº§

### Phase 1: åŸºç¡€æ¡†æ¶ (æœ¬æ¬¡å®ç°)
- [x] é¡¹ç›®ç»“æ„æ­å»º
- [ ] æ ¸å¿ƒæ¥å£å®šä¹‰
- [ ] åƒé—®æ¨¡å‹é›†æˆ (åŸºäºç°æœ‰ä»£ç )
- [ ] åŸºç¡€WandBè¿½è¸ª
- [ ] å•å›¾å¤„ç†æµç¨‹
- [ ] ç®€å•çš„placeholderå‡½æ•°

### Phase 2: åŠŸèƒ½å®Œå–„
- [ ] OpenAIæ¨¡å‹é›†æˆ
- [ ] æ‰¹é‡å¤„ç†å’Œmultiprocessing
- [ ] å®Œæ•´çš„WandBå®éªŒè¿½è¸ª
- [ ] é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶
- [ ] é…ç½®æ–‡ä»¶ç®¡ç†

### Phase 3: æ‰©å±•ä¼˜åŒ–
- [ ] Kimiå’Œæ™ºè°±GLMæ¨¡å‹
- [ ] é«˜çº§å›¾åƒé¢„å¤„ç†
- [ ] æ¨¡å‹ç»“æœå¯¹æ¯”åˆ†æ
- [ ] æ€§èƒ½ä¼˜åŒ–å’Œç¼“å­˜
- [ ] Webç•Œé¢é›†æˆ

## âš™ï¸ é…ç½®ç®¡ç†

### ç¯å¢ƒå˜é‡
```bash
# API Keys
OPENAI_API_KEY=sk-xxx
QWEN_API_KEY=sk-xxx  
KIMI_API_KEY=sk-xxx
GLM_API_KEY=xxx

# WandBé…ç½®
WANDB_API_KEY=xxx
WANDB_PROJECT=gis-beautification
WANDB_ENTITY=dy-gis-team

# å¤„ç†é…ç½®
MAX_WORKERS=4
BATCH_SIZE=10
DEFAULT_MODEL=qwen-vl-max
```

### å¤„ç†å‚æ•°
```python
class ProcessingConfig:
    models: List[str] = ['qwen-vl-max']      # ä½¿ç”¨çš„æ¨¡å‹åˆ—è¡¨
    max_workers: int = 4                      # å¹¶è¡Œè¿›ç¨‹æ•°
    batch_size: int = 10                      # æ‰¹å¤„ç†å¤§å°
    enable_wandb: bool = True                 # æ˜¯å¦å¯ç”¨WandB
    save_intermediate: bool = False           # æ˜¯å¦ä¿å­˜ä¸­é—´ç»“æœ
    retry_count: int = 3                      # å¤±è´¥é‡è¯•æ¬¡æ•°
    timeout: int = 300                        # APIè°ƒç”¨è¶…æ—¶(ç§’)
```

## ğŸ” è´¨é‡ä¿è¯

### é”™è¯¯å¤„ç†ç­–ç•¥
- APIè°ƒç”¨å¤±è´¥è‡ªåŠ¨é‡è¯• (æŒ‡æ•°é€€é¿)
- ç½‘ç»œè¶…æ—¶å¤„ç†
- æ ¼å¼é”™è¯¯çš„å“åº”å¤„ç†
- è¿›ç¨‹å¼‚å¸¸æ¢å¤

### æ—¥å¿—è®°å½•
- ç»“æ„åŒ–æ—¥å¿—è¾“å‡º
- ä¸åŒçº§åˆ«çš„æ—¥å¿—è®°å½•
- æ€§èƒ½ç›‘æ§ç‚¹åŸ‹è®¾
- å¼‚å¸¸å †æ ˆè¿½è¸ª

### æµ‹è¯•ç­–ç•¥
- å•å…ƒæµ‹è¯•: å„æ¨¡å—åŠŸèƒ½æµ‹è¯•
- é›†æˆæµ‹è¯•: ç«¯åˆ°ç«¯æµç¨‹æµ‹è¯•  
- æ€§èƒ½æµ‹è¯•: å¹¶å‘å¤„ç†èƒ½åŠ›æµ‹è¯•
- å›å½’æµ‹è¯•: æ¨¡å‹è¾“å‡ºä¸€è‡´æ€§æµ‹è¯•

---

**ä¸‹ä¸€æ­¥**: è¯·å®¡é˜…æ­¤æ¶æ„è®¾è®¡ï¼Œç¡®è®¤æ— è¯¯åæˆ‘å°†å¼€å§‹å®ç°Phase 1çš„åŸºç¡€æ¡†æ¶ã€‚
# 下一步工作计划（基于“机器评分相关性报告 - 20250828.pdf”与评审意见）

> 目标：在保持整体稳定的前提下，优先逐项提升表现不佳指标的相关性，从“8.档距段”开始，尽快将两个当前相关性在0.6+的单项提升至≥0.75，并推动整体相关性达到≥0.80。

---

## 1. 现状与聚焦方向

- 总体效果可接受，但需要对单项差异进行“逐个击破”。
- 聚焦顺序：先处理表现不佳的“8.档距段”，随后滚动到其他单项。

---

## 2. 报告改版与“当天级”修正项（优先完成）

### 2.1 图表增强与一致化

- 在“2.2”部分增加分布对比图：
  - 箱形图或小提琴图（violin plot）对比不同单项/分组的分数分布。
  - 图注明确：变量定义、特征工程方式、原始数据文件与列名来源。
- 在“3.1”部分为每个单项新增“人工 vs 机器”的散点图，另增加“十项总分”的散点图：
  - 要求：
    - 散点图叠加密度估计（KDE/等高线或透明度热度，后面有例子）。
    - 纵横比固定为 1（aspect=1）。
    - 保存前调用 `plt.tight_layout()`。
    - 统一配色与标记风格，便于跨图比较。
  - 图注规范（必须包含以下信息，不影响主要结论的前提下，放在主说明之后）：
    - 变量计算口径（注：“口径”一般指统计或计算时采用的范围与规则，包括纳入/剔除条件、定义、时间窗口、计算方法等。下同）；
    - 所用特征及工程方法；
    - 原始数据文件与列名（示例：`data.csv` 中 `human_score`, `model_score`）。

### 2.2 表格排序口径统一（3.1两张表）

- 问题：两张表数据顺序不一致，增加比较难度。
- 方案：统一按相同字段排序，建议“按人工总分（或均值）降序”。
- 要求：
  - 在表格标题或脚注明确“排序字段与方向”。
  - 若历史版本使用了其他排序规则，需在本次报告中说明变更原因与影响（有助于追踪差异）。

### 2.3 数据异常核查（“全0分”台区等）

- 现象：3.1表中疑似出现“全0分”样本，但机器打分差异不大，需核实。
- 排查步骤：
  1) 对该台区在原始人工打分明细中复核（确认是否缺失/误录/口径变更导致的0）。
  2) 对应机器打分的输入特征与标准化流程复核（是否截断、缩放或聚合掩盖差异）。
  3) 抽样查看对应图像/要素数据，确认是否存在“非适用/无数据”的场景。
- 处理原则：
  - 若确认为“缺失/非适用”，应剔除或单独标记，不纳入相关性计算；
  - 若为“真实全0”，需要在报告中显式说明原因与比例，并进行敏感性分析（含剔除后的对比结果）。
  - 在结论区单列“数据质量与异常说明”小节，避免误解。

#### 2.3.1 零分政策与机器规则跟进（“整体偏移/整体混乱”）

- 人工口径（已确认）：当台区“整体偏移”或“整体混乱”时，跳过评价，直接记0分。
- 机器规则（对齐原则）：在机器打分前增加“可评价性检查”。若判定为“整体偏移”或“整体混乱”，则：
  - 设置机器分为0；
  - 标记字段：`policy_zero = 1`，`policy_zero_reason ∈ {整体偏移, 整体混乱}`；
  - 在报告与明细清单中显式标注“政策零分（跳过评价）”。
- 结果呈现与评估：提供双版本相关性以避免混淆：
  - 版本A（含政策零分）：真实上线口径；
  - 版本B（不含政策零分）：观测纯模型行为；
  - 同时报告政策零分占比与原因构成。

---

## 3. 针对“8.档距段”的专项提升计划

### 3.1 样本优先级（基于人工 vs 机器差异的分层筛选）

- 定义：  
  $r_i = \hat{y}_i - y_i, \qquad \lvert r_i \rvert = \big\lvert \hat{y}_i - y_i \big\rvert.$
- 主排序规则（任选其一，需在报告中注明所用口径）：
  1) 绝对差值法：按 $\lvert r_i \rvert$ 从大到小排序，取 Top-K（适合快速发现偏差最大的样本）。  
     集合：$\mathcal{S}_{\text{top-K}} = \{\, i \mid \lvert r_i \rvert \text{ in top } K \,\}$。
  2) 分位阈值法：选择 $\lvert r_i \rvert$ 落在全体的高分位（如 $\ge P_{95}/P_{90}$）的样本（适合规模可控的审查）。  
     集合：$\mathcal{S}_{q} = \{\, i \mid \lvert r_i \rvert \ge P_{q}(\lvert r \rvert) \,\}$，$q\in\{90,95\}$。
  3) 标准化残差法：以整体波动为参照（如标准差或更稳健的中位绝对偏差 MAD）对 $r_i$ 标准化，再按 $\lvert z_i \rvert$ 排序（便于不同批次/口径可比）。  
     标准差口径：$z_i^{(\mathrm{std})} = \frac{r_i}{\sigma_r}$。  
     MAD 口径：$z_i^{(\mathrm{MAD})} = \frac{r_i - \operatorname{median}(r)}{\operatorname{MAD}(r)}$。
- 分层与均衡（在主排序的基础上叠加，确保覆盖面）：
  - 人工分数分层：按人工分数分位（如五分位/十分位）分层，每层取前若干，避免只关注极端样本。
  - 方向均衡：过高预测 $(r_i>0)$ 与过低预测 $(r_i<0)$ 两类各取一定比例。
  - 异常优先：包含“政策零分（整体偏移/整体混乱）”“全0分”“NA/非适用”“重复记录/口径可能变更”等标记的样本优先纳入审查。
- 稳定性加权（如有多个时间点/版本）：
  - 若同一台区在多期结果中持续出现在高残差集合，标记“持续偏差”，优先级上调。

### 3.2 输出清单（供人工复核与小样本回看）

- 建议规模：每轮 10–20 个样本（按工作量与时限微调）。
- 清单字段（最少包含）：
  - 台区/样本ID，人工分数 $y_i$，机器分数 $\hat{y}_i$，残差 $r_i$，绝对残差 $|r_i|$，人工分数分层、方向（高/低预测），异常标记（政策零分/全0/NA/重复/口径变更等），`policy_zero_reason`（如有）。
- 选择口径透明化：在清单抬头注明本轮所用的“主排序规则”“分层方式”“阈值/Top-K 数量”。

### 3.3 审核节奏与反馈闭环

- 节奏：每轮清单审查→记录原因类型→在不改变整体口径的前提下提出可操作的修订思路→下轮复核。
- 关注点：
  - 是否存在系统性偏差（集中在某些人工分数段或特定场景）。
  - 是否有明显的口径/数据问题。
  - 过高与过低预测的成因是否不同，应分开记录。
- 产出：
  - “本轮样本复核记录表”（含原因标签与备注），为后续改进提供定性线索；
  - 下一轮清单将包含“持续偏差”的样本，跟踪修正是否奏效。


---

## 4. 结果呈现规范

- 图表：
  - 散点图均为“人工 vs 机器”，叠加KDE/密度，`aspect=1`，`plt.tight_layout()`；
  - 文件命名建议：`results/plots/20250828/{section}_{item}_scatter.png`；
  - 图注包含：变量口径、特征工程、原始数据文件与列名。
- 表格：
  - 明确排序字段与方向，两个表严格一致；
  - 对“全0/NA/非适用”样本单独标识并在脚注解释。
- 统计说明：
  - 报告 Pearson 为主，必要时补充 Spearman；
  - 标注样本量、异常处理策略与敏感性分析结果。
- 工程规范：
  - 记录运行时长（`time.perf_counter()`计算起止）；

### KDE 叠加示例（可直接复用）

通用 `ax` 传入、`aspect=1`、`tight_layout`：

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

def plot_actual_vs_pred_with_kde(y_true, y_pred, ax=None, title=None):
    # Create ax if not provided
    created_fig = False
    if ax is None:
        fig, ax = plt.subplots(figsize=(5, 5))
        created_fig = True

    x = np.asarray(y_true)
    y = np.asarray(y_pred)

    # Base scatter
    ax.scatter(x, y, s=12, c="#1f77b4", alpha=0.6, edgecolor="none")

    # KDE overlay (only if both axes have >1 unique values)
    if pd.Series(x).nunique() > 1 and pd.Series(y).nunique() > 1:
        sns.kdeplot(
            x=x, y=y,
            fill=True, cmap="viridis",
            levels=30, thresh=0, alpha=0.4,
            ax=ax
        )

    # Identity line
    lo = np.nanmin([np.nanmin(x), np.nanmin(y)])
    hi = np.nanmax([np.nanmax(x), np.nanmax(y)])
    ax.plot([lo, hi], [lo, hi], color="black", lw=1, linestyle="--", alpha=0.8)

    # Labels and layout
    ax.set_xlabel("Actual")
    ax.set_ylabel("Predicted")
    if title:
        ax.set_title(title)
    ax.set_aspect("equal", adjustable="box")

    if created_fig:
        plt.tight_layout()

    return ax

# 用法示例（在已有子图上）
# ax = axes[plot_idx]
# plot_actual_vs_pred_with_kde(y_true, y_pred, ax=ax, title="8.档距段")
# 保存图时在外部调用：fig.tight_layout(); fig.savefig("path.png", dpi=200)
# 对于每个单项则可以用
# nrow = 2
# ncol = 5
# fig, axes = plt.subplots(nrow, ncol, squeeze=False)
# for plot_idx in range(plot_count):
#   ax = axes[plot_idx]
#   ...
```
(function(global, factory) {
    globalThis.bonck = [];
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self,
    global.SGMap = factory(globalThis.bonck));
}
)(this, (function(bonck) {
    'use strict';
    /* eslint-disable */

    var shared, worker, sgmap;
    // define gets called three times: one for each chunk. we rely on the order
    // they're imported to know which is which
    function define(_, chunk) {
        if (!shared) {
            shared = chunk;
        } else if (!worker) {
            worker = chunk;
        } else {
            var workerBundleString = "self.onerror = function(bonck) { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.sgmap.com/sgmap-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;"

            var sharedChunk = {};
            shared(sharedChunk);
            sgmap = chunk(sharedChunk);
            if (typeof window !== 'undefined' && window && window.URL && window.URL.createObjectURL) {
                sgmap.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString],{
                    type: 'text/javascript'
                }));
            }
        }
    }

    define(["exports"], (function(t) {
        "use strict";
        var e = "undefined" != typeof self ? self : {}
          , r = n;
        function n(t, e, r, n) {
            this.cx = 3 * t,
            this.bx = 3 * (r - t) - this.cx,
            this.ax = 1 - this.cx - this.bx,
            this.cy = 3 * e,
            this.by = 3 * (n - e) - this.cy,
            this.ay = 1 - this.cy - this.by,
            this.p1x = t,
            this.p1y = n,
            this.p2x = r,
            this.p2y = n;
        }
        n.prototype.sampleCurveX = function(t) {
            return ((this.ax * t + this.bx) * t + this.cx) * t
        }
        ,
        n.prototype.sampleCurveY = function(t) {
            return ((this.ay * t + this.by) * t + this.cy) * t
        }
        ,
        n.prototype.sampleCurveDerivativeX = function(t) {
            return (3 * this.ax * t + 2 * this.bx) * t + this.cx
        }
        ,
        n.prototype.solveCurveX = function(t, e) {
            var r, n, i, s, a;
            for (void 0 === e && (e = 1e-6),
            i = t,
            a = 0; a < 8; a++) {
                if (s = this.sampleCurveX(i) - t,
                Math.abs(s) < e)
                    return i;
                var o = this.sampleCurveDerivativeX(i);
                if (Math.abs(o) < 1e-6)
                    break;
                i -= s / o;
            }
            if ((i = t) < (r = 0))
                return r;
            if (i > (n = 1))
                return n;
            for (; r < n; ) {
                if (s = this.sampleCurveX(i),
                Math.abs(s - t) < e)
                    return i;
                t > s ? r = i : n = i,
                i = .5 * (n - r) + r;
            }
            return i
        }
        ,
        n.prototype.solve = function(t, e) {
            return this.sampleCurveY(this.solveCurveX(t, e))
        }
        ;
        var i = s;
        function s(t, e) {
            this.x = t,
            this.y = e;
        }
        s.prototype = {
            clone: function() {
                return new s(this.x,this.y)
            },
            add: function(t) {
                return this.clone()._add(t)
            },
            sub: function(t) {
                return this.clone()._sub(t)
            },
            multByPoint: function(t) {
                return this.clone()._multByPoint(t)
            },
            divByPoint: function(t) {
                return this.clone()._divByPoint(t)
            },
            mult: function(t) {
                return this.clone()._mult(t)
            },
            div: function(t) {
                return this.clone()._div(t)
            },
            rotate: function(t) {
                return this.clone()._rotate(t)
            },
            rotateAround: function(t, e) {
                return this.clone()._rotateAround(t, e)
            },
            matMult: function(t) {
                return this.clone()._matMult(t)
            },
            unit: function() {
                return this.clone()._unit()
            },
            perp: function() {
                return this.clone()._perp()
            },
            round: function() {
                return this.clone()._round()
            },
            mag: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            },
            equals: function(t) {
                return this.x === t.x && this.y === t.y
            },
            dist: function(t) {
                return Math.sqrt(this.distSqr(t))
            },
            distSqr: function(t) {
                var e = t.x - this.x
                  , r = t.y - this.y;
                return e * e + r * r
            },
            angle: function() {
                return Math.atan2(this.y, this.x)
            },
            angleTo: function(t) {
                return Math.atan2(this.y - t.y, this.x - t.x)
            },
            angleWith: function(t) {
                return this.angleWithSep(t.x, t.y)
            },
            angleWithSep: function(t, e) {
                return Math.atan2(this.x * e - this.y * t, this.x * t + this.y * e)
            },
            _matMult: function(t) {
                var e = t[2] * this.x + t[3] * this.y;
                return this.x = t[0] * this.x + t[1] * this.y,
                this.y = e,
                this
            },
            _add: function(t) {
                return this.x += t.x,
                this.y += t.y,
                this
            },
            _sub: function(t) {
                return this.x -= t.x,
                this.y -= t.y,
                this
            },
            _mult: function(t) {
                return this.x *= t,
                this.y *= t,
                this
            },
            _div: function(t) {
                return this.x /= t,
                this.y /= t,
                this
            },
            _multByPoint: function(t) {
                return this.x *= t.x,
                this.y *= t.y,
                this
            },
            _divByPoint: function(t) {
                return this.x /= t.x,
                this.y /= t.y,
                this
            },
            _unit: function() {
                return this._div(this.mag()),
                this
            },
            _perp: function() {
                var t = this.y;
                return this.y = this.x,
                this.x = -t,
                this
            },
            _rotate: function(t) {
                var e = Math.cos(t)
                  , r = Math.sin(t)
                  , n = r * this.x + e * this.y;
                return this.x = e * this.x - r * this.y,
                this.y = n,
                this
            },
            _rotateAround: function(t, e) {
                var r = Math.cos(t)
                  , n = Math.sin(t)
                  , i = e.y + n * (this.x - e.x) + r * (this.y - e.y);
                return this.x = e.x + r * (this.x - e.x) - n * (this.y - e.y),
                this.y = i,
                this
            },
            _round: function() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this
            }
        },
        s.convert = function(t) {
            return t instanceof s ? t : Array.isArray(t) ? new s(t[0],t[1]) : t
        }
        ;
        const a = Math.PI / 180
          , o = 180 / Math.PI;
        function l(t) {
            return t * a
        }
        function u(t) {
            return t * o
        }
        const c = [[0, 0], [1, 0], [1, 1], [0, 1]];
        function h(t) {
            if (t <= 0)
                return 0;
            if (t >= 1)
                return 1;
            const e = t * t
              , r = e * t;
            return 4 * (t < .5 ? r : 3 * (t - e) + r - .75)
        }
        function p(t, e, n, i) {
            const s = new r(t,e,n,i);
            return function(t) {
                return s.solve(t)
            }
        }
        const f = p(.25, .1, .25, 1);
        function d(t, e, r) {
            return Math.min(r, Math.max(e, t))
        }
        function y(t, e, r) {
            return (r = d((r - t) / (e - t), 0, 1)) * r * (3 - 2 * r)
        }
        function m(t, e, r) {
            const n = r - e
              , i = ((t - e) % n + n) % n + e;
            return i === e ? r : i
        }
        function g(t, e, r) {
            if (!t.length)
                return r(null, []);
            let n = t.length;
            const i = new Array(t.length);
            let s = null;
            t.forEach(( (t, a) => {
                e(t, ( (t, e) => {
                    t && (s = t),
                    i[a] = e,
                    0 == --n && r(s, i);
                }
                ));
            }
            ));
        }
        function x(t) {
            const e = [];
            for (const r in t)
                e.push(t[r]);
            return e
        }
        function v(t, ...e) {
            for (const r of e)
                for (const e in r)
                    t[e] = r[e];
            return t
        }
        let b = 1;
        function w() {
            return b++
        }
        function A(t) {
            return t <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
        }
        function k(t, e) {
            t.forEach((t => {
                e[t] && (e[t] = e[t].bind(e));
            }
            ));
        }
        function z(t, e) {
            return -1 !== t.indexOf(e, t.length - e.length)
        }
        function S(t, e, r) {
            const n = {};
            for (const i in t)
                n[i] = e.call(r || this, t[i], i, t);
            return n
        }
        function M(t, e, r) {
            const n = {};
            for (const i in t)
                e.call(r || this, t[i], i, t) && (n[i] = t[i]);
            return n
        }
        function I(t) {
            return Array.isArray(t) ? t.map(I) : "object" == typeof t && t ? S(t, I) : t
        }
        const T = {};
        function B(t) {
            T[t] || ("undefined" != typeof console && console.warn(t),
            T[t] = !0);
        }
        function C(t, e, r) {
            return (r.y - t.y) * (e.x - t.x) > (e.y - t.y) * (r.x - t.x)
        }
        function V(t) {
            let e = 0;
            for (let r, n, i = 0, s = t.length, a = s - 1; i < s; a = i++)
                r = t[i],
                n = t[a],
                e += (n.x - r.x) * (r.y + n.y);
            return e
        }
        function P() {
            return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope
        }
        function D(t) {
            const e = {};
            if (t.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ( (t, r, n, i) => {
                const s = n || i;
                return e[r] = !s || s.toLowerCase(),
                ""
            }
            )),
            e["max-age"]) {
                const t = parseInt(e["max-age"], 10);
                isNaN(t) ? delete e["max-age"] : e["max-age"] = t;
            }
            return e
        }
        let E = null;
        function F(t) {
            if (null == E) {
                const e = t.navigator ? t.navigator.userAgent : null;
                E = !!t.safari || !(!e || !(/\b(iPad|iPhone|iPod)\b/.test(e) || e.match("Safari") && !e.match("Chrome")));
            }
            return E
        }
        function L(t, e) {
            return [t[4 * e], t[4 * e + 1], t[4 * e + 2], t[4 * e + 3]]
        }
        const R = e.performance;
        function j(t) {
            if (!R)
                return;
            const e = t ? t.url.toString() : void 0;
            return R.getEntriesByName(e)
        }
        let U, O, $, q;
        const N = {
            now: () => void 0 !== $ ? $ : e.performance.now(),
            setNow(t) {
                $ = t;
            },
            restoreNow() {
                $ = void 0;
            },
            frame(t) {
                const r = e.requestAnimationFrame(t);
                return {
                    cancel: () => e.cancelAnimationFrame(r)
                }
            },
            getImageData(t, r=0) {
                const {width: n, height: i} = t;
                q || (q = e.document.createElement("canvas"));
                const s = q.getContext("2d", {
                    willReadFrequently: !0
                });
                if (!s)
                    throw new Error("failed to create canvas 2d context");
                return (n > q.width || i > q.height) && (q.width = n,
                q.height = i),
                s.clearRect(-r, -r, n + 2 * r, i + 2 * r),
                s.drawImage(t, 0, 0, n, i),
                s.getImageData(-r, -r, n + 2 * r, i + 2 * r)
            },
            resolveURL: t => (U || (U = e.document.createElement("a")),
            U.href = t,
            U.href),
            get devicePixelRatio() {
                return e.devicePixelRatio
            },
            get prefersReducedMotion() {
                return !!e.matchMedia && (null == O && (O = e.matchMedia("(prefers-reduced-motion: reduce)")),
                O.matches)
            }
        }
          , Z = {
            API_URL: "",
            ACCESS_TOKEN: null,
            MAX_PARALLEL_IMAGE_REQUESTS: 16
        }
          , G = {
            supported: !1,
            testSupport: function(t) {
                !H && Y && (K ? J(t) : X = t);
            }
        };
        let X, Y, H = !1, K = !1;
        function J(t) {
            const e = t.createTexture();
            t.bindTexture(t.TEXTURE_2D, e);
            try {
                if (t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, Y),
                t.isContextLost())
                    return;
                G.supported = !0;
            } catch (t) {}
            t.deleteTexture(e),
            H = !0;
        }
        e.document && (Y = e.document.createElement("img"),
        Y.onload = function() {
            X && J(X),
            X = null,
            K = !0;
        }
        ,
        Y.onerror = function() {
            H = !0,
            X = null;
        }
        ,
        Y.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
        const W = "01";
        function Q(t) {
            return 0 === t.indexOf("aegis:") || /aegis\./
        }
        const tt = /^((https?:)?\/\/)?([^\/]+\.)?(epgis|sgcc)\.c(n|om)(\.cn)?|^aegis:\/\//i;
        function et(t) {
            return tt.test(t)
        }
        function rt(t) {
            for (const e of t) {
                const t = e.match(/^access_token=(.*)$/);
                if (t)
                    return t[1]
            }
            return null
        }
        const nt = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        function it(t) {
            const e = t.match(nt);
            if (!e)
                throw new Error("Unable to parse URL object");
            return {
                protocol: e[1],
                authority: e[2],
                path: e[3] || "/",
                params: e[4] ? e[4].split("&") : []
            }
        }
        function st(t) {
            const e = t.params.length ? `?${t.params.join("&")}` : "";
            return `${t.protocol}://${t.authority}${t.path}${e}`
        }
        let at, ot = 500, lt = 50, ut = {};
        function ct(t) {
            const e = ft(t);
            let r, n;
            e && e.forEach((t => {
                const e = t.split("=");
                "language" === e[0] ? r = e[1] : "worldview" === e[0] && (n = e[1]);
            }
            ));
            let i = "sgmap-tiles";
            return r && (i += `-${r}`),
            n && (i += `-${n}`),
            i
        }
        function ht() {
            try {
                return e.caches
            } catch (t) {}
        }
        function pt(t) {
            const e = ht();
            e && !ut[t] && (ut[t] = e.open(t));
        }
        function ft(t) {
            const e = t.indexOf("?");
            return e > 0 ? t.slice(e + 1).split("&") : []
        }
        function dt(t) {
            const e = t.indexOf("?");
            if (e < 0)
                return t;
            const r = ft(t).filter((t => {
                const e = t.split("=");
                return "language" === e[0] || "worldview" === e[0]
            }
            ));
            return r.length ? `${t.slice(0, e)}?${r.join("&")}` : t.slice(0, e)
        }
        let yt = 1 / 0;
        !function() {
            for (var t = [], e = 0; e < 256; ++e)
                t.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
        }();
        const mt = (t, e) => {
            let r, n, i, s = t.z % 8, a = t.x % 8, o = t.y % 8, l = e, u = l.byteLength - s - a - o, c = Math.floor(u / 3), h = Math.floor(u / 3), p = u - c - h;
            o <= a && a <= s && o <= s ? (i = new Uint8Array(l.slice(o, p + o)),
            n = new Uint8Array(l.slice(p + a + o, p + h + a + o)),
            r = new Uint8Array(l.slice(p + h + a + o + s, u + s + a + o))) : o <= a && s <= a && o <= s ? (i = new Uint8Array(l.slice(o, p + o)),
            r = new Uint8Array(l.slice(p + s + o, p + c + s + o)),
            n = new Uint8Array(l.slice(p + c + s + o + a, u + s + a + o))) : a <= o && o <= s && a <= s ? (n = new Uint8Array(l.slice(a, h + a)),
            i = new Uint8Array(l.slice(h + a + o, p + h + a + o)),
            r = new Uint8Array(l.slice(p + h + s + o + a, u + s + a + o))) : a <= s && s <= o && a <= o ? (n = new Uint8Array(l.slice(a, h + a)),
            r = new Uint8Array(l.slice(h + a + s, h + c + a + s)),
            i = new Uint8Array(l.slice(h + c + s + o + a, u + s + a + o))) : s <= o && o <= a && s <= a ? (r = new Uint8Array(l.slice(s, c + s)),
            i = new Uint8Array(l.slice(c + s + o, p + c + s + o)),
            n = new Uint8Array(l.slice(p + c + s + o + a, u + s + a + o))) : s <= a && a <= o && s <= o && (r = new Uint8Array(l.slice(s, c + s)),
            n = new Uint8Array(l.slice(c + s + a, c + h + s + a)),
            i = new Uint8Array(l.slice(c + h + s + o + a, u + s + a + o)));
            let f = new Uint8Array(u);
            return f.set(r, 0),
            f.set(n, c),
            f.set(i, h + c),
            function() {
                const t = navigator.userAgent;
                return t.indexOf("Trident") > -1 && t.indexOf("rv:11.0") > -1
            }() ? [].slice.call(f) : f.buffer
        }
          , gt = ({url: t, params: e}) => {
            if (!e || 0 === Object.keys(e).length)
                return t;
            const r = -1 !== t.indexOf("?");
            return `${t}${r ? "&" : "?"}${(t => {
                var e = [];
                for (var r in t)
                    e.push(null === t[r] ? r : r + "=" + t[r]);
                return e.join("&")
            }
            )(e)}`
        }
          , xt = t => {
            const e = {};
            if (-1 !== t.indexOf("?")) {
                const r = t.split("?");
                e.url = r[0],
                e.params = (t => {
                    var e = t.split("&")
                      , r = {};
                    for (let t = 0; t < e.length; t++)
                        if (e[t].indexOf("=") >= 0) {
                            let n = e[t].split("=");
                            r[n[0]] = n[1];
                        } else
                            r[e[t]] = null;
                    return r
                }
                )(r[1]);
            } else
                e.url = t,
                e.params = {};
            return e
        }
          , vt = t => {
            window.__MAP_ISDEV && console.log(t);
        }
          , bt = {
            _Jm(t, e) {
                for (var r, n = [], i = [0, 0], s = 0, a = bt._w(t); s < a; ++s)
                    r = e ? e(t[s]) : t[s],
                    bt._zh(r[0] - i[0], n),
                    bt._zh(r[1] - i[1], n),
                    i = r;
                return n.join("")
            },
            _zh: (t, e) => bt._Km(0 > t ? ~(t << 1) : t << 1, e),
            _Km(t, e) {
                for (; 32 <= t; )
                    e.push(String.fromCharCode(63 + (32 | 31 & t))),
                    t >>= 5;
                return e.push(String.fromCharCode(t + 63)),
                e
            },
            _w: t => t ? t.length : 0,
            _F(t, e, r) {
                if (t && (void 0 !== t.lat || void 0 !== t.lng))
                    try {
                        Ac(t),
                        e = t.lng,
                        t = t.lat,
                        r = !1;
                    } catch (t) {
                        _.oc(t);
                    }
                return t -= 0,
                e -= 0,
                r || (t = bt._fb(t, -90, 90),
                180 != e && (e = bt._gb(e, -180, 180))),
                t || e
            },
            _fb: (t, e, r) => (null != e && (t = Math.max(t, e)),
            null != r && (t = Math.min(t, r)),
            t),
            _gb: (t, e, r) => ((t - e) % (r -= e) + r) % r + e
        }
          , _t = function(t) {
            if ("string" == typeof t)
                return (t => {
                    for (var e = [], r = bt._w(t), n = Array(Math.floor(t.length / 2)), i = 0, s = 0, a = 0, o = 0; i < r; ++o) {
                        var l = 1
                          , u = 0;
                        do {
                            var c = t.charCodeAt(i++) - 63 - 1;
                            l += c << u,
                            u += 5;
                        } while (31 <= c);
                        s += 1 & l ? ~(l >> 1) : l >> 1,
                        l = 1,
                        u = 0;
                        do {
                            l += (c = t.charCodeAt(i++) - 63 - 1) << u,
                            u += 5;
                        } while (31 <= c);
                        n[o] = bt._F(1e-5 * s, 1e-5 * (a += 1 & l ? ~(l >> 1) : l >> 1), !0),
                        e.push([1e-5 * a, 1e-5 * s]);
                    }
                    return n.length = o,
                    e.length > 1 ? e : e[0]
                }
                )(t);
            if (Array.isArray(t))
                return t.map((t => _t(t)));
            throw new Error("shape.coordinates参数格不正确")
        }
          , wt = (t, e, r, n) => {
            if (!n || !e || null == r || null == r)
                return t || {};
            var i = t.styleid
              , s = t.shieldType
              , a = 0;
            if (!i && !s)
                return t || {};
            if (!e[i] && !e["40001:" + s])
                return null;
            var o = r + 1;
            if (o = o <= 3 ? 3 : o >= 20 ? 20 : o,
            i && e[i]) {
                let r = Object.keys(e[i]);
                for (let n = 0; n < r.length; n++) {
                    let s = r[n];
                    if ("type" != s && (s = s.split(","),
                    s.indexOf(o) >= 0 || s.indexOf(String(o)) >= 0)) {
                        a = 1,
                        t = v(t, e[i][r[n]]);
                        break
                    }
                }
            }
            if (s && e["40001:" + s]) {
                let r = Object.keys(e["40001:" + s]);
                for (let n = 0; n < r.length; n++) {
                    let i = r[n];
                    if ("type" != i && (i = i.split(","),
                    i.indexOf(o) >= 0 || i.indexOf(String(o)) >= 0)) {
                        a = 1,
                        t = v(t, e["40001:" + s][r[n]]);
                        break
                    }
                }
            }
            return 0 == a ? null : t
        }
        ;
        let At = [];
        const kt = function(t) {
            return At.indexOf(t) >= 0
        }
          , zt = {
            Unknown: "Unknown",
            Style: "Style",
            Source: "Source",
            Tile: "Tile",
            Glyphs: "Glyphs",
            SpriteImage: "SpriteImage",
            SpriteJSON: "SpriteJSON",
            Image: "Image"
        };
        "function" == typeof Object.freeze && Object.freeze(zt);
        class St extends Error {
            constructor(t, e, r) {
                401 === e && et(r) && (t += ": you may have provided an invalid sgmap access token. See https://map.sgcc.com.cn/products/js-sdk/v3/#"),
                super(t),
                this.status = e,
                this.url = r;
            }
            toString() {
                return `${this.name}: ${this.message} (${this.status}): ${this.url}`
            }
        }
        const Mt = P() ? () => self.worker && self.worker.referrer : () => ("blob:" === e.location.protocol ? e.parent : e).location.href
          , It = t => /^file:/.test(t) || /^file:/.test(Mt()) && !/^\w+:/.test(t);
        function Tt(t, r) {
            const n = new e.AbortController
              , i = new e.Request(t.url,{
                method: t.method || "GET",
                body: t.body,
                credentials: t.credentials,
                headers: t.headers,
                referrer: Mt(),
                signal: n.signal
            });
            let s = !1
              , a = !1;
            const o = (l = i.url).indexOf("sku=") > 0 && et(l);
            var l;
            "json" === t.type && i.headers.set("Accept", "application/json");
            const u = (n, s, l) => {
                if (a)
                    return;
                if (n && "SecurityError" !== n.message && B(n),
                s && l)
                    return c(s);
                const u = Date.now();
                e.fetch(i).then((e => {
                    if (e.ok) {
                        const t = o ? e.clone() : null;
                        return c(e, t, u)
                    }
                    return r(new St(e.statusText,e.status,t.url))
                }
                )).catch((t => {
                    20 !== t.code && r(new Error(t.message));
                }
                ));
            }
              , c = (n, o, l) => {
                ("arrayBuffer" === t.type ? n.arrayBuffer() : "json" === t.type ? n.json() : n.text()).then((t => {
                    a || (o && l && function(t, r, n) {
                        const i = ct(t.url);
                        if (pt(i),
                        !ut[i])
                            return;
                        const s = {
                            status: r.status,
                            statusText: r.statusText,
                            headers: new e.Headers
                        };
                        r.headers.forEach(( (t, e) => s.headers.set(e, t)));
                        const a = D(r.headers.get("Cache-Control") || "");
                        if (a["no-store"])
                            return;
                        a["max-age"] && s.headers.set("Expires", new Date(n + 1e3 * a["max-age"]).toUTCString());
                        const o = s.headers.get("Expires");
                        o && (new Date(o).getTime() - n < 42e4 || function(t, e) {
                            if (void 0 === at)
                                try {
                                    new Response(new ReadableStream),
                                    at = !0;
                                } catch (t) {
                                    at = !1;
                                }
                            at ? e(t.body) : t.blob().then(e);
                        }(r, (r => {
                            const n = new e.Response(r,s);
                            pt(i),
                            ut[i] && ut[i].then((e => e.put(dt(t.url), n))).catch((t => B(t.message)));
                        }
                        )));
                    }(i, o, l),
                    s = !0,
                    r(null, t, n.headers.get("Cache-Control"), n.headers.get("Expires")));
                }
                )).catch((t => {
                    a || r(new Error(t.message));
                }
                ));
            }
            ;
            return o ? function(t, e) {
                const r = ct(t.url);
                if (pt(r),
                !ut[r])
                    return e(null);
                const n = dt(t.url);
                ut[r].then((t => {
                    t.match(n).then((r => {
                        const i = function(t) {
                            if (!t)
                                return !1;
                            const e = new Date(t.headers.get("Expires") || 0)
                              , r = D(t.headers.get("Cache-Control") || "");
                            return e > Date.now() && !r["no-cache"]
                        }(r);
                        t.delete(n),
                        i && t.put(n, r.clone()),
                        e(null, r, i);
                    }
                    )).catch(e);
                }
                )).catch(e);
            }(i, u) : u(null, null),
            {
                cancel: () => {
                    a = !0,
                    s || n.abort();
                }
            }
        }
        function Bt(t, r) {
            const n = new e.XMLHttpRequest;
            n.open(t.method || "GET", t.url, !0),
            "arrayBuffer" === t.type && (n.responseType = "arraybuffer");
            for (const e in t.headers)
                n.setRequestHeader(e, t.headers[e]);
            return "json" === t.type && (n.responseType = "text",
            n.setRequestHeader("Accept", "application/json")),
            n.withCredentials = "include" === t.credentials,
            n.onerror = () => {
                r(new Error(n.statusText));
            }
            ,
            n.onload = () => {
                if ((n.status >= 200 && n.status < 300 || 0 === n.status) && null !== n.response) {
                    let e = n.response;
                    if ("json" === t.type)
                        try {
                            e = JSON.parse(n.response);
                        } catch (t) {
                            return r(t)
                        }
                    r(null, e, n.getResponseHeader("Cache-Control"), n.getResponseHeader("Expires"));
                } else
                    r(new St(n.statusText,n.status,t.url));
            }
            ,
            n.send(t.body),
            {
                cancel: () => n.abort()
            }
        }
        const Ct = function(t, r) {
            const n = xt(t.url)
              , {access_token: i} = n.params;
            if (void 0 === t.cache && (t.cache = !0),
            i && (delete n.params.access_token,
            t.headers || (t.headers = {}),
            t.headers.Authorization = i),
            t.url = gt(n),
            !It(t.url)) {
                if (e.fetch && e.Request && e.AbortController && e.Request.prototype.hasOwnProperty("signal"))
                    return Tt(t, r);
                if (P() && self.worker && self.worker.actor)
                    return self.worker.actor.send("getResource", t, r, void 0, !0)
            }
            return Bt(t, r)
        }
          , Vt = function(t, e) {
            const {tilesecurity: r, zxy: n} = t;
            return delete t.zxy,
            delete t.tilesecurity,
            Ct(v(t, {
                type: "arrayBuffer"
            }), ( (t, i, s, a) => {
                !t && i && r && (i = mt(n, i)),
                e(t, i, s, a);
            }
            ))
        };
        function Pt(t) {
            const r = e.document.createElement("a");
            return r.href = t,
            r.protocol === e.document.location.protocol && r.host === e.document.location.host
        }
        const Dt = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        let Et, Ft;
        Et = [],
        Ft = 0;
        const Lt = function(t, r) {
            if (G.supported && (t.headers || (t.headers = {}),
            t.headers.accept = "image/webp,*/*"),
            Ft >= Z.MAX_PARALLEL_IMAGE_REQUESTS) {
                const e = {
                    requestParameters: t,
                    callback: r,
                    cancelled: !1,
                    cancel() {
                        this.cancelled = !0;
                    }
                };
                return Et.push(e),
                e
            }
            Ft++;
            let n = !1;
            const i = () => {
                if (!n)
                    for (n = !0,
                    Ft--; Et.length && Ft < Z.MAX_PARALLEL_IMAGE_REQUESTS; ) {
                        const t = Et.shift()
                          , {requestParameters: e, callback: r, cancelled: n} = t;
                        n || (t.cancel = Lt(e, r).cancel);
                    }
            }
              , s = Vt(t, ( (t, n, s, a) => {
                i(),
                t ? r(t) : n && (e.createImageBitmap ? function(t, r) {
                    const n = new e.Blob([new Uint8Array(t)],{
                        type: "image/png"
                    });
                    e.createImageBitmap(n).then((t => {
                        r(null, t);
                    }
                    )).catch((t => {
                        r(new Error(`Could not load image because of ${t.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
                    }
                    ));
                }(n, ( (t, e) => r(t, e, s, a))) : function(t, r) {
                    const n = new e.Image
                      , i = e.URL;
                    n.onload = () => {
                        r(null, n),
                        i.revokeObjectURL(n.src),
                        n.onload = null,
                        e.requestAnimationFrame(( () => {
                            n.src = Dt;
                        }
                        ));
                    }
                    ,
                    n.onerror = () => r(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                    const s = new e.Blob([new Uint8Array(t)],{
                        type: "image/png"
                    });
                    n.src = t.byteLength ? i.createObjectURL(s) : Dt;
                }(n, ( (t, e) => r(t, e, s, a))));
            }
            ));
            return {
                cancel: () => {
                    s.cancel(),
                    i();
                }
            }
        };
        function Rt(t, e, r) {
            r[t] && -1 !== r[t].indexOf(e) || (r[t] = r[t] || [],
            r[t].push(e));
        }
        function jt(t, e, r) {
            if (r && r[t]) {
                const n = r[t].indexOf(e);
                -1 !== n && r[t].splice(n, 1);
            }
        }
        class Ut {
            constructor(t, e={}) {
                v(this, e),
                this.type = t;
            }
        }
        class Ot extends Ut {
            constructor(t, e={}) {
                super("error", v({
                    error: t
                }, e));
            }
        }
        class $t {
            on(t, e) {
                return this._listeners = this._listeners || {},
                Rt(t, e, this._listeners),
                this
            }
            off(t, e) {
                return jt(t, e, this._listeners),
                jt(t, e, this._oneTimeListeners),
                this
            }
            once(t, e) {
                return e ? (this._oneTimeListeners = this._oneTimeListeners || {},
                Rt(t, e, this._oneTimeListeners),
                this) : new Promise((e => this.once(t, e)))
            }
            fire(t, e) {
                "string" == typeof t && (t = new Ut(t,e || {}));
                const r = t.type;
                if (this.listens(r)) {
                    t.target = this;
                    const e = this._listeners && this._listeners[r] ? this._listeners[r].slice() : [];
                    for (const r of e)
                        r.call(this, t);
                    const n = this._oneTimeListeners && this._oneTimeListeners[r] ? this._oneTimeListeners[r].slice() : [];
                    for (const e of n)
                        jt(r, e, this._oneTimeListeners),
                        e.call(this, t);
                    const i = this._eventedParent;
                    i && (v(t, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData),
                    i.fire(t));
                } else
                    t instanceof Ot && console.error(t.error);
                return this
            }
            listens(t) {
                return !!(this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t))
            }
            setEventedParent(t, e) {
                return this._eventedParent = t,
                this._eventedParentData = e,
                this
            }
        }
        var qt = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"light":{"type":"light"},"terrain":{"type":"terrain"},"fog":{"type":"fog"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":{},"sgmap":{},"epgis":{}},"default":"epgis"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":{}}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":{}}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":{}}},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"esymbol":{},"eline":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"background":{},"sky":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky","layout_esymbol"],"layout_background":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"property-type":"constant"}},"layout_line":{"esymbol-id":{"type":"string","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-cap":{"type":"enum","values":{"butt":{},"round":{},"square":{}},"default":"butt","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":{},"round":{},"miter":{}},"default":"miter","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"requires":[{"line-join":"miter"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"requires":[{"line-join":"round"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_symbol":{"symbol-scaleable":{"type":"boolean","default":false,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"symbol-placement":{"type":"enum","values":{"point":{},"line":{},"line-center":{}},"default":"point","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"units":"pixels","requires":[{"symbol-placement":"line"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":{},"viewport-y":{},"source":{}},"default":"auto","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"units":"factor of the original icon size","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":{},"width":{},"height":{},"both":{}},"default":"none","requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"units":"pixels","requires":["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Microsoft YaHei Regular"],"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"ems","requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":{},"left":{},"center":{},"right":{}},"default":"center","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","units":"ems","default":0,"requires":["text-field"],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["text-field",{"!":"text-variable-anchor"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"units":"degrees","requires":["text-field",{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":{},"vertical":{}},"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":{},"uppercase":{},"lowercase":{}},"default":"none","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","units":"ems","length":2,"default":[0,0],"requires":["text-field",{"!":"text-radial-offset"}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"requires":["text-field","icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_esymbol":{"esymbol-scaleable":{"type":"boolean","default":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"esymbol-size":{"type":"number","default":1,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"esymbol-rotate":{"type":"number","default":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"esymbol-id":{"type":"string","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"esymbol-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},"in":{},"!in":{},"all":{},"any":{},"none":{},"has":{},"!has":{},"within":{}}},"geometry_type":{"type":"enum","values":{"Point":{},"LineString":{},"Polygon":{}}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":{},"exponential":{},"interval":{},"categorical":{}},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":{},"lab":{},"hcl":{}},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":{},"viewport":{}},"property-type":"data-constant","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":{},"equalEarth":{},"equirectangular":{},"lambertConformalConic":{},"mercator":{},"naturalEarth":{},"winkelTripel":{},"globe":{}},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["source"]}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky","paint_esymbol"],"paint_fill":{"fill-minzoom":{"type":"number","default":0,"minimum":0,"maximum":24,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-maxzoom":{"type":"number","default":24,"minimum":1,"maximum":24,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-antialias":{"type":"boolean","default":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","transition":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"cross-faded-data-driven"}},"paint_fill-extrusion":{"fill-extrusion-minzoom":{"type":"number","default":0,"minimum":0,"maximum":24,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-maxzoom":{"type":"number","default":24,"minimum":1,"maximum":24,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-extrusion-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-topcolor":{"type":"color","default":"rgba(0,0,0,0)","transition":true,"requires":[{"!":"fill-extrusion-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-extrusion-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","transition":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"cross-faded-data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"requires":["fill-extrusion-height"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint_line":{"line-minzoom":{"type":"number","default":0,"minimum":0,"maximum":24,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-maxzoom":{"type":"number","default":24,"minimum":1,"maximum":24,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"line-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-outline-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"line-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["line-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-outline-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"transition":true,"units":"line widths","requires":[{"!":"line-pattern"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"cross-faded-data-driven"},"line-outline-dasharray":{"type":"array","value":"number","minimum":0,"transition":true,"units":"line widths","requires":[{"!":"line-pattern"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"cross-faded-data-driven"},"line-pattern":{"type":"resolvedImage","transition":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"cross-faded-data-driven"},"line-pattern-color":{"type":"boolean","default":false,"requires":["line-pattern","line-color"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"line-gradient":{"type":"color","transition":false,"requires":[{"!":"line-pattern"},{"source":"geojson","has":{"lineMetrics":true}}],"expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"transition":false,"requires":[{"source":"geojson","has":{"lineMetrics":true}}],"property-type":"constant"}},"paint_circle":{"circle-minzoom":{"type":"number","default":0,"minimum":0,"maximum":24,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-maxzoom":{"type":"number","default":24,"minimum":1,"maximum":24,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["circle-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_esymbol":{"esymbol-minzoom":{"type":"number","default":0,"minimum":0,"maximum":24,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"esymbol-maxzoom":{"type":"number","default":24,"minimum":1,"maximum":24,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"esymbol-radius":{"type":"number","default":40,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"esymbol-color":{"type":"color","default":"#b84842","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"esymbol-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"esymbol-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"esymbol-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"esymbol-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["circle-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"esymbol-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"esymbol-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"esymbol-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"transition":false,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"transition":false,"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"symbol-minzoom":{"type":"number","default":0,"minimum":0,"maximum":24,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"symbol-maxzoom":{"type":"number","default":24,"minimum":1,"maximum":24,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["icon-image","icon-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["text-field","text-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"units":"degrees","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":{},"nearest":{}},"default":"linear","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"transition":false,"units":"milliseconds","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"transition":false,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"background-pattern"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","transition":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"cross-faded"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":{},"atmosphere":{}},"default":"atmosphere","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"requires":[{"sky-type":"atmosphere"}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","requires":[{"sky-type":"atmosphere"}],"default":10,"minimum":0,"maximum":100,"transition":false,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","requires":[{"sky-type":"gradient"}],"value":"number","default":[0,0],"length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","requires":[{"sky-type":"gradient"}],"default":90,"minimum":0,"maximum":180,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"transition":false,"requires":[{"sky-type":"gradient"}],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}},"property-type":{"data-driven":{"type":"property-type"},"cross-faded":{"type":"property-type"},"cross-faded-data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');
        function Nt(t, ...e) {
            for (const r of e)
                for (const e in r)
                    t[e] = r[e];
            return t
        }
        function Zt(t) {
            return t instanceof Number || t instanceof String || t instanceof Boolean ? t.valueOf() : t
        }
        function Gt(t) {
            if (Array.isArray(t))
                return t.map(Gt);
            if (t instanceof Object && !(t instanceof Number || t instanceof String || t instanceof Boolean)) {
                const e = {};
                for (const r in t)
                    e[r] = Gt(t[r]);
                return e
            }
            return Zt(t)
        }
        class Xt extends Error {
            constructor(t, e) {
                super(e),
                this.message = e,
                this.key = t;
            }
        }
        var Yt = Xt;
        class Ht {
            constructor(t, e=[]) {
                this.parent = t,
                this.bindings = {};
                for (const [t,r] of e)
                    this.bindings[t] = r;
            }
            concat(t) {
                return new Ht(this,t)
            }
            get(t) {
                if (this.bindings[t])
                    return this.bindings[t];
                if (this.parent)
                    return this.parent.get(t);
                throw new Error(`${t} not found in scope.`)
            }
            has(t) {
                return !!this.bindings[t] || !!this.parent && this.parent.has(t)
            }
        }
        var Kt = Ht;
        const Jt = {
            kind: "null"
        }
          , Wt = {
            kind: "number"
        }
          , Qt = {
            kind: "string"
        }
          , te = {
            kind: "boolean"
        }
          , ee = {
            kind: "color"
        }
          , re = {
            kind: "object"
        }
          , ne = {
            kind: "value"
        }
          , ie = {
            kind: "collator"
        }
          , se = {
            kind: "formatted"
        }
          , ae = {
            kind: "resolvedImage"
        };
        function oe(t, e) {
            return {
                kind: "array",
                itemType: t,
                N: e
            }
        }
        function le(t) {
            if ("array" === t.kind) {
                const e = le(t.itemType);
                return "number" == typeof t.N ? `array<${e}, ${t.N}>` : "value" === t.itemType.kind ? "array" : `array<${e}>`
            }
            return t.kind
        }
        const ue = [Jt, Wt, Qt, te, ee, se, re, oe(ne), ae];
        function ce(t, e) {
            if ("error" === e.kind)
                return null;
            if ("array" === t.kind) {
                if ("array" === e.kind && (0 === e.N && "value" === e.itemType.kind || !ce(t.itemType, e.itemType)) && ("number" != typeof t.N || t.N === e.N))
                    return null
            } else {
                if (t.kind === e.kind)
                    return null;
                if ("value" === t.kind)
                    for (const t of ue)
                        if (!ce(t, e))
                            return null
            }
            return `Expected ${le(t)} but found ${le(e)} instead.`
        }
        function he(t, e) {
            return e.some((e => e.kind === t.kind))
        }
        function pe(t, e) {
            return e.some((e => "null" === e ? null === t : "array" === e ? Array.isArray(t) : "object" === e ? t && !Array.isArray(t) && "object" == typeof t : e === typeof t))
        }
        function fe(t) {
            var e = {
                exports: {}
            };
            return t(e, e.exports),
            e.exports
        }
        var de = fe((function(t, e) {
            var r = {
                transparent: [0, 0, 0, 0],
                aliceblue: [240, 248, 255, 1],
                antiquewhite: [250, 235, 215, 1],
                aqua: [0, 255, 255, 1],
                aquamarine: [127, 255, 212, 1],
                azure: [240, 255, 255, 1],
                beige: [245, 245, 220, 1],
                bisque: [255, 228, 196, 1],
                black: [0, 0, 0, 1],
                blanchedalmond: [255, 235, 205, 1],
                blue: [0, 0, 255, 1],
                blueviolet: [138, 43, 226, 1],
                brown: [165, 42, 42, 1],
                burlywood: [222, 184, 135, 1],
                cadetblue: [95, 158, 160, 1],
                chartreuse: [127, 255, 0, 1],
                chocolate: [210, 105, 30, 1],
                coral: [255, 127, 80, 1],
                cornflowerblue: [100, 149, 237, 1],
                cornsilk: [255, 248, 220, 1],
                crimson: [220, 20, 60, 1],
                cyan: [0, 255, 255, 1],
                darkblue: [0, 0, 139, 1],
                darkcyan: [0, 139, 139, 1],
                darkgoldenrod: [184, 134, 11, 1],
                darkgray: [169, 169, 169, 1],
                darkgreen: [0, 100, 0, 1],
                darkgrey: [169, 169, 169, 1],
                darkkhaki: [189, 183, 107, 1],
                darkmagenta: [139, 0, 139, 1],
                darkolivegreen: [85, 107, 47, 1],
                darkorange: [255, 140, 0, 1],
                darkorchid: [153, 50, 204, 1],
                darkred: [139, 0, 0, 1],
                darksalmon: [233, 150, 122, 1],
                darkseagreen: [143, 188, 143, 1],
                darkslateblue: [72, 61, 139, 1],
                darkslategray: [47, 79, 79, 1],
                darkslategrey: [47, 79, 79, 1],
                darkturquoise: [0, 206, 209, 1],
                darkviolet: [148, 0, 211, 1],
                deeppink: [255, 20, 147, 1],
                deepskyblue: [0, 191, 255, 1],
                dimgray: [105, 105, 105, 1],
                dimgrey: [105, 105, 105, 1],
                dodgerblue: [30, 144, 255, 1],
                firebrick: [178, 34, 34, 1],
                floralwhite: [255, 250, 240, 1],
                forestgreen: [34, 139, 34, 1],
                fuchsia: [255, 0, 255, 1],
                gainsboro: [220, 220, 220, 1],
                ghostwhite: [248, 248, 255, 1],
                gold: [255, 215, 0, 1],
                goldenrod: [218, 165, 32, 1],
                gray: [128, 128, 128, 1],
                green: [0, 128, 0, 1],
                greenyellow: [173, 255, 47, 1],
                grey: [128, 128, 128, 1],
                honeydew: [240, 255, 240, 1],
                hotpink: [255, 105, 180, 1],
                indianred: [205, 92, 92, 1],
                indigo: [75, 0, 130, 1],
                ivory: [255, 255, 240, 1],
                khaki: [240, 230, 140, 1],
                lavender: [230, 230, 250, 1],
                lavenderblush: [255, 240, 245, 1],
                lawngreen: [124, 252, 0, 1],
                lemonchiffon: [255, 250, 205, 1],
                lightblue: [173, 216, 230, 1],
                lightcoral: [240, 128, 128, 1],
                lightcyan: [224, 255, 255, 1],
                lightgoldenrodyellow: [250, 250, 210, 1],
                lightgray: [211, 211, 211, 1],
                lightgreen: [144, 238, 144, 1],
                lightgrey: [211, 211, 211, 1],
                lightpink: [255, 182, 193, 1],
                lightsalmon: [255, 160, 122, 1],
                lightseagreen: [32, 178, 170, 1],
                lightskyblue: [135, 206, 250, 1],
                lightslategray: [119, 136, 153, 1],
                lightslategrey: [119, 136, 153, 1],
                lightsteelblue: [176, 196, 222, 1],
                lightyellow: [255, 255, 224, 1],
                lime: [0, 255, 0, 1],
                limegreen: [50, 205, 50, 1],
                linen: [250, 240, 230, 1],
                magenta: [255, 0, 255, 1],
                maroon: [128, 0, 0, 1],
                mediumaquamarine: [102, 205, 170, 1],
                mediumblue: [0, 0, 205, 1],
                mediumorchid: [186, 85, 211, 1],
                mediumpurple: [147, 112, 219, 1],
                mediumseagreen: [60, 179, 113, 1],
                mediumslateblue: [123, 104, 238, 1],
                mediumspringgreen: [0, 250, 154, 1],
                mediumturquoise: [72, 209, 204, 1],
                mediumvioletred: [199, 21, 133, 1],
                midnightblue: [25, 25, 112, 1],
                mintcream: [245, 255, 250, 1],
                mistyrose: [255, 228, 225, 1],
                moccasin: [255, 228, 181, 1],
                navajowhite: [255, 222, 173, 1],
                navy: [0, 0, 128, 1],
                oldlace: [253, 245, 230, 1],
                olive: [128, 128, 0, 1],
                olivedrab: [107, 142, 35, 1],
                orange: [255, 165, 0, 1],
                orangered: [255, 69, 0, 1],
                orchid: [218, 112, 214, 1],
                palegoldenrod: [238, 232, 170, 1],
                palegreen: [152, 251, 152, 1],
                paleturquoise: [175, 238, 238, 1],
                palevioletred: [219, 112, 147, 1],
                papayawhip: [255, 239, 213, 1],
                peachpuff: [255, 218, 185, 1],
                peru: [205, 133, 63, 1],
                pink: [255, 192, 203, 1],
                plum: [221, 160, 221, 1],
                powderblue: [176, 224, 230, 1],
                purple: [128, 0, 128, 1],
                rebeccapurple: [102, 51, 153, 1],
                red: [255, 0, 0, 1],
                rosybrown: [188, 143, 143, 1],
                royalblue: [65, 105, 225, 1],
                saddlebrown: [139, 69, 19, 1],
                salmon: [250, 128, 114, 1],
                sandybrown: [244, 164, 96, 1],
                seagreen: [46, 139, 87, 1],
                seashell: [255, 245, 238, 1],
                sienna: [160, 82, 45, 1],
                silver: [192, 192, 192, 1],
                skyblue: [135, 206, 235, 1],
                slateblue: [106, 90, 205, 1],
                slategray: [112, 128, 144, 1],
                slategrey: [112, 128, 144, 1],
                snow: [255, 250, 250, 1],
                springgreen: [0, 255, 127, 1],
                steelblue: [70, 130, 180, 1],
                tan: [210, 180, 140, 1],
                teal: [0, 128, 128, 1],
                thistle: [216, 191, 216, 1],
                tomato: [255, 99, 71, 1],
                turquoise: [64, 224, 208, 1],
                violet: [238, 130, 238, 1],
                wheat: [245, 222, 179, 1],
                white: [255, 255, 255, 1],
                whitesmoke: [245, 245, 245, 1],
                yellow: [255, 255, 0, 1],
                yellowgreen: [154, 205, 50, 1]
            };
            function n(t) {
                return (t = Math.round(t)) < 0 ? 0 : t > 255 ? 255 : t
            }
            function i(t) {
                return n("%" === t[t.length - 1] ? parseFloat(t) / 100 * 255 : parseInt(t))
            }
            function s(t) {
                return (e = "%" === t[t.length - 1] ? parseFloat(t) / 100 : parseFloat(t)) < 0 ? 0 : e > 1 ? 1 : e;
                var e;
            }
            function a(t, e, r) {
                return r < 0 ? r += 1 : r > 1 && (r -= 1),
                6 * r < 1 ? t + (e - t) * r * 6 : 2 * r < 1 ? e : 3 * r < 2 ? t + (e - t) * (2 / 3 - r) * 6 : t
            }
            try {
                e.parseCSSColor = function(t) {
                    var e, o = t.replace(/ /g, "").toLowerCase();
                    if (o in r)
                        return r[o].slice();
                    if ("#" === o[0])
                        return 4 === o.length ? (e = parseInt(o.substr(1), 16)) >= 0 && e <= 4095 ? [(3840 & e) >> 4 | (3840 & e) >> 8, 240 & e | (240 & e) >> 4, 15 & e | (15 & e) << 4, 1] : null : 7 === o.length && (e = parseInt(o.substr(1), 16)) >= 0 && e <= 16777215 ? [(16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, 1] : null;
                    var l = o.indexOf("(")
                      , u = o.indexOf(")");
                    if (-1 !== l && u + 1 === o.length) {
                        var c = o.substr(0, l)
                          , h = o.substr(l + 1, u - (l + 1)).split(",")
                          , p = 1;
                        switch (c) {
                        case "rgba":
                            if (4 !== h.length)
                                return null;
                            p = s(h.pop());
                        case "rgb":
                            return 3 !== h.length ? null : [i(h[0]), i(h[1]), i(h[2]), p];
                        case "hsla":
                            if (4 !== h.length)
                                return null;
                            p = s(h.pop());
                        case "hsl":
                            if (3 !== h.length)
                                return null;
                            var f = (parseFloat(h[0]) % 360 + 360) % 360 / 360
                              , d = s(h[1])
                              , y = s(h[2])
                              , m = y <= .5 ? y * (d + 1) : y + d - y * d
                              , g = 2 * y - m;
                            return [n(255 * a(g, m, f + 1 / 3)), n(255 * a(g, m, f)), n(255 * a(g, m, f - 1 / 3)), p];
                        default:
                            return null
                        }
                    }
                    return null
                }
                ;
            } catch (t) {}
        }
        ));
        class ye {
            constructor(t, e, r, n=1) {
                this.r = t,
                this.g = e,
                this.b = r,
                this.a = n;
            }
            static parse(t) {
                if (!t)
                    return;
                if (t instanceof ye)
                    return t;
                if ("string" != typeof t)
                    return;
                const e = de.parseCSSColor(t);
                return e ? new ye(e[0] / 255 * e[3],e[1] / 255 * e[3],e[2] / 255 * e[3],e[3]) : void 0
            }
            toString() {
                const [t,e,r,n] = this.toArray();
                return `rgba(${Math.round(t)},${Math.round(e)},${Math.round(r)},${n})`
            }
            toArray() {
                const {r: t, g: e, b: r, a: n} = this;
                return 0 === n ? [0, 0, 0, 0] : [255 * t / n, 255 * e / n, 255 * r / n, n]
            }
            toArray01() {
                const {r: t, g: e, b: r, a: n} = this;
                return 0 === n ? [0, 0, 0, 0] : [t / n, e / n, r / n, n]
            }
            toArray01PremultipliedAlpha() {
                const {r: t, g: e, b: r, a: n} = this;
                return [t, e, r, n]
            }
        }
        ye.black = new ye(0,0,0,1),
        ye.white = new ye(1,1,1,1),
        ye.transparent = new ye(0,0,0,0),
        ye.red = new ye(1,0,0,1),
        ye.blue = new ye(0,0,1,1);
        var me = ye;
        class ge {
            constructor(t, e, r) {
                this.sensitivity = t ? e ? "variant" : "case" : e ? "accent" : "base",
                this.locale = r,
                this.collator = new Intl.Collator(this.locale ? this.locale : [],{
                    sensitivity: this.sensitivity,
                    usage: "search"
                });
            }
            compare(t, e) {
                return this.collator.compare(t, e)
            }
            resolvedLocale() {
                return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale
            }
        }
        class xe {
            constructor(t, e, r, n, i) {
                this.text = t.normalize ? t.normalize() : t,
                this.image = e,
                this.scale = r,
                this.fontStack = n,
                this.textColor = i;
            }
        }
        class ve {
            constructor(t) {
                this.sections = t;
            }
            static fromString(t) {
                return new ve([new xe(t,null,null,null,null)])
            }
            isEmpty() {
                return 0 === this.sections.length || !this.sections.some((t => 0 !== t.text.length || t.image && 0 !== t.image.name.length))
            }
            static factory(t) {
                return t instanceof ve ? t : ve.fromString(t)
            }
            toString() {
                return 0 === this.sections.length ? "" : this.sections.map((t => t.text)).join("")
            }
            serialize() {
                const t = ["format"];
                for (const e of this.sections) {
                    if (e.image) {
                        t.push(["image", e.image.name]);
                        continue
                    }
                    t.push(e.text);
                    const r = {};
                    e.fontStack && (r["text-font"] = ["literal", e.fontStack.split(",")]),
                    e.scale && (r["font-scale"] = e.scale),
                    e.textColor && (r["text-color"] = ["rgba"].concat(e.textColor.toArray())),
                    t.push(r);
                }
                return t
            }
        }
        class be {
            constructor(t) {
                this.name = t.name,
                this.available = t.available;
            }
            toString() {
                return this.name
            }
            static fromString(t) {
                return t ? new be({
                    name: t,
                    available: !1
                }) : null
            }
            serialize() {
                return ["image", this.name]
            }
        }
        function _e(t, e, r, n) {
            return "number" == typeof t && t >= 0 && t <= 255 && "number" == typeof e && e >= 0 && e <= 255 && "number" == typeof r && r >= 0 && r <= 255 ? void 0 === n || "number" == typeof n && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[t, e, r, n].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n ? [t, e, r, n] : [t, e, r]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`
        }
        function we(t) {
            if (null === t)
                return !0;
            if ("string" == typeof t)
                return !0;
            if ("boolean" == typeof t)
                return !0;
            if ("number" == typeof t)
                return !0;
            if (t instanceof me)
                return !0;
            if (t instanceof ge)
                return !0;
            if (t instanceof ve)
                return !0;
            if (t instanceof be)
                return !0;
            if (Array.isArray(t)) {
                for (const e of t)
                    if (!we(e))
                        return !1;
                return !0
            }
            if ("object" == typeof t) {
                for (const e in t)
                    if (!we(t[e]))
                        return !1;
                return !0
            }
            return !1
        }
        function Ae(t) {
            if (null === t)
                return Jt;
            if ("string" == typeof t)
                return Qt;
            if ("boolean" == typeof t)
                return te;
            if ("number" == typeof t)
                return Wt;
            if (t instanceof me)
                return ee;
            if (t instanceof ge)
                return ie;
            if (t instanceof ve)
                return se;
            if (t instanceof be)
                return ae;
            if (Array.isArray(t)) {
                const e = t.length;
                let r;
                for (const e of t) {
                    const t = Ae(e);
                    if (r) {
                        if (r === t)
                            continue;
                        r = ne;
                        break
                    }
                    r = t;
                }
                return oe(r || ne, e)
            }
            return re
        }
        function ke(t) {
            const e = typeof t;
            return null === t ? "" : "string" === e || "number" === e || "boolean" === e ? String(t) : t instanceof me || t instanceof ve || t instanceof be ? t.toString() : JSON.stringify(t)
        }
        class ze {
            constructor(t, e) {
                this.type = t,
                this.value = e;
            }
            static parse(t, e) {
                if (2 !== t.length)
                    return e.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);
                if (!we(t[1]))
                    return e.error("invalid value");
                const r = t[1];
                let n = Ae(r);
                const i = e.expectedType;
                return "array" !== n.kind || 0 !== n.N || !i || "array" !== i.kind || "number" == typeof i.N && 0 !== i.N || (n = i),
                new ze(n,r)
            }
            evaluate() {
                return this.value
            }
            eachChild() {}
            outputDefined() {
                return !0
            }
            serialize() {
                return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof me ? ["rgba"].concat(this.value.toArray()) : this.value instanceof ve ? this.value.serialize() : this.value
            }
        }
        var Se = ze
          , Me = class {
            constructor(t) {
                this.name = "ExpressionEvaluationError",
                this.message = t;
            }
            toJSON() {
                return this.message
            }
        }
        ;
        const Ie = {
            string: Qt,
            number: Wt,
            boolean: te,
            object: re
        };
        class Te {
            constructor(t, e) {
                this.type = t,
                this.args = e;
            }
            static parse(t, e) {
                if (t.length < 2)
                    return e.error("Expected at least one argument.");
                let r, n = 1;
                const i = t[0];
                if ("array" === i) {
                    let i, s;
                    if (t.length > 2) {
                        const r = t[1];
                        if ("string" != typeof r || !(r in Ie) || "object" === r)
                            return e.error('The item type argument of "array" must be one of string, number, boolean', 1);
                        i = Ie[r],
                        n++;
                    } else
                        i = ne;
                    if (t.length > 3) {
                        if (null !== t[2] && ("number" != typeof t[2] || t[2] < 0 || t[2] !== Math.floor(t[2])))
                            return e.error('The length argument to "array" must be a positive integer literal', 2);
                        s = t[2],
                        n++;
                    }
                    r = oe(i, s);
                } else
                    r = Ie[i];
                const s = [];
                for (; n < t.length; n++) {
                    const r = e.parse(t[n], n, ne);
                    if (!r)
                        return null;
                    s.push(r);
                }
                return new Te(r,s)
            }
            evaluate(t) {
                for (let e = 0; e < this.args.length; e++) {
                    const r = this.args[e].evaluate(t);
                    if (!ce(this.type, Ae(r)))
                        return r;
                    if (e === this.args.length - 1)
                        throw new Me(`Expected value to be of type ${le(this.type)}, but found ${le(Ae(r))} instead.`)
                }
                return null
            }
            eachChild(t) {
                this.args.forEach(t);
            }
            outputDefined() {
                return this.args.every((t => t.outputDefined()))
            }
            serialize() {
                const t = this.type
                  , e = [t.kind];
                if ("array" === t.kind) {
                    const r = t.itemType;
                    if ("string" === r.kind || "number" === r.kind || "boolean" === r.kind) {
                        e.push(r.kind);
                        const n = t.N;
                        ("number" == typeof n || this.args.length > 1) && e.push(n);
                    }
                }
                return e.concat(this.args.map((t => t.serialize())))
            }
        }
        var Be = Te;
        class Ce {
            constructor(t) {
                this.type = se,
                this.sections = t;
            }
            static parse(t, e) {
                if (t.length < 2)
                    return e.error("Expected at least one argument.");
                const r = t[1];
                if (!Array.isArray(r) && "object" == typeof r)
                    return e.error("First argument must be an image or text section.");
                const n = [];
                let i = !1;
                for (let r = 1; r <= t.length - 1; ++r) {
                    const s = t[r];
                    if (i && "object" == typeof s && !Array.isArray(s)) {
                        i = !1;
                        let t = null;
                        if (s["font-scale"] && (t = e.parse(s["font-scale"], 1, Wt),
                        !t))
                            return null;
                        let r = null;
                        if (s["text-font"] && (r = e.parse(s["text-font"], 1, oe(Qt)),
                        !r))
                            return null;
                        let a = null;
                        if (s["text-color"] && (a = e.parse(s["text-color"], 1, ee),
                        !a))
                            return null;
                        const o = n[n.length - 1];
                        o.scale = t,
                        o.font = r,
                        o.textColor = a;
                    } else {
                        const s = e.parse(t[r], 1, ne);
                        if (!s)
                            return null;
                        const a = s.type.kind;
                        if ("string" !== a && "value" !== a && "null" !== a && "resolvedImage" !== a)
                            return e.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                        i = !0,
                        n.push({
                            content: s,
                            scale: null,
                            font: null,
                            textColor: null
                        });
                    }
                }
                return new Ce(n)
            }
            evaluate(t) {
                return new ve(this.sections.map((e => {
                    const r = e.content.evaluate(t);
                    return Ae(r) === ae ? new xe("",r,null,null,null) : new xe(ke(r),null,e.scale ? e.scale.evaluate(t) : null,e.font ? e.font.evaluate(t).join(",") : null,e.textColor ? e.textColor.evaluate(t) : null)
                }
                )))
            }
            eachChild(t) {
                for (const e of this.sections)
                    t(e.content),
                    e.scale && t(e.scale),
                    e.font && t(e.font),
                    e.textColor && t(e.textColor);
            }
            outputDefined() {
                return !1
            }
            serialize() {
                const t = ["format"];
                for (const e of this.sections) {
                    t.push(e.content.serialize());
                    const r = {};
                    e.scale && (r["font-scale"] = e.scale.serialize()),
                    e.font && (r["text-font"] = e.font.serialize()),
                    e.textColor && (r["text-color"] = e.textColor.serialize()),
                    t.push(r);
                }
                return t
            }
        }
        class Ve {
            constructor(t) {
                this.type = ae,
                this.input = t;
            }
            static parse(t, e) {
                if (2 !== t.length)
                    return e.error("Expected two arguments.");
                const r = e.parse(t[1], 1, Qt);
                return r ? new Ve(r) : e.error("No image name provided.")
            }
            evaluate(t) {
                const e = this.input.evaluate(t)
                  , r = be.fromString(e);
                return r && t.availableImages && (r.available = t.availableImages.indexOf(e) > -1),
                r
            }
            eachChild(t) {
                t(this.input);
            }
            outputDefined() {
                return !1
            }
            serialize() {
                return ["image", this.input.serialize()]
            }
        }
        const Pe = {
            "to-boolean": te,
            "to-color": ee,
            "to-number": Wt,
            "to-string": Qt
        };
        class De {
            constructor(t, e) {
                this.type = t,
                this.args = e;
            }
            static parse(t, e) {
                if (t.length < 2)
                    return e.error("Expected at least one argument.");
                const r = t[0];
                if (("to-boolean" === r || "to-string" === r) && 2 !== t.length)
                    return e.error("Expected one argument.");
                const n = Pe[r]
                  , i = [];
                for (let r = 1; r < t.length; r++) {
                    const n = e.parse(t[r], r, ne);
                    if (!n)
                        return null;
                    i.push(n);
                }
                return new De(n,i)
            }
            evaluate(t) {
                if ("boolean" === this.type.kind)
                    return Boolean(this.args[0].evaluate(t));
                if ("color" === this.type.kind) {
                    let e, r;
                    for (const n of this.args) {
                        if (e = n.evaluate(t),
                        r = null,
                        e instanceof me)
                            return e;
                        if ("string" == typeof e) {
                            const r = t.parseColor(e);
                            if (r)
                                return r
                        } else if (Array.isArray(e) && (r = e.length < 3 || e.length > 4 ? `Invalid rbga value ${JSON.stringify(e)}: expected an array containing either three or four numeric values.` : _e(e[0], e[1], e[2], e[3]),
                        !r))
                            return new me(e[0] / 255,e[1] / 255,e[2] / 255,e[3])
                    }
                    throw new Me(r || `Could not parse color from value '${"string" == typeof e ? e : String(JSON.stringify(e))}'`)
                }
                if ("number" === this.type.kind) {
                    let e = null;
                    for (const r of this.args) {
                        if (e = r.evaluate(t),
                        null === e)
                            return 0;
                        const n = Number(e);
                        if (!isNaN(n))
                            return n
                    }
                    throw new Me(`Could not convert ${JSON.stringify(e)} to number.`)
                }
                return "formatted" === this.type.kind ? ve.fromString(ke(this.args[0].evaluate(t))) : "resolvedImage" === this.type.kind ? be.fromString(ke(this.args[0].evaluate(t))) : ke(this.args[0].evaluate(t))
            }
            eachChild(t) {
                this.args.forEach(t);
            }
            outputDefined() {
                return this.args.every((t => t.outputDefined()))
            }
            serialize() {
                if ("formatted" === this.type.kind)
                    return new Ce([{
                        content: this.args[0],
                        scale: null,
                        font: null,
                        textColor: null
                    }]).serialize();
                if ("resolvedImage" === this.type.kind)
                    return new Ve(this.args[0]).serialize();
                const t = [`to-${this.type.kind}`];
                return this.eachChild((e => {
                    t.push(e.serialize());
                }
                )),
                t
            }
        }
        var Ee = De;
        const Fe = ["Unknown", "Point", "LineString", "Polygon"];
        var Le = class {
            constructor() {
                this.globals = null,
                this.feature = null,
                this.featureState = null,
                this.formattedSection = null,
                this._parseColorCache = {},
                this.availableImages = null,
                this.canonical = null,
                this.featureTileCoord = null,
                this.featureDistanceData = null;
            }
            id() {
                return this.feature && void 0 !== this.feature.id ? this.feature.id : null
            }
            geometryType() {
                return this.feature ? "number" == typeof this.feature.type ? Fe[this.feature.type] : this.feature.type : null
            }
            geometry() {
                return this.feature && "geometry"in this.feature ? this.feature.geometry : null
            }
            canonicalID() {
                return this.canonical
            }
            properties() {
                return this.feature && this.feature.properties || {}
            }
            distanceFromCenter() {
                if (this.featureTileCoord && this.featureDistanceData) {
                    const t = this.featureDistanceData.center
                      , e = this.featureDistanceData.scale
                      , {x: r, y: n} = this.featureTileCoord;
                    return this.featureDistanceData.bearing[0] * (r * e - t[0]) + this.featureDistanceData.bearing[1] * (n * e - t[1])
                }
                return 0
            }
            parseColor(t) {
                let e = this._parseColorCache[t];
                return e || (e = this._parseColorCache[t] = me.parse(t)),
                e
            }
        }
        ;
        class Re {
            constructor(t, e, r, n) {
                this.name = t,
                this.type = e,
                this._evaluate = r,
                this.args = n;
            }
            evaluate(t) {
                return this._evaluate(t, this.args)
            }
            eachChild(t) {
                this.args.forEach(t);
            }
            outputDefined() {
                return !1
            }
            serialize() {
                return [this.name].concat(this.args.map((t => t.serialize())))
            }
            static parse(t, e) {
                const r = t[0]
                  , n = Re.definitions[r];
                if (!n)
                    return e.error(`Unknown expression "${r}". If you wanted a literal array, use ["literal", [...]].`, 0);
                const i = Array.isArray(n) ? n[0] : n.type
                  , s = Array.isArray(n) ? [[n[1], n[2]]] : n.overloads
                  , a = s.filter(( ([e]) => !Array.isArray(e) || e.length === t.length - 1));
                let o = null;
                for (const [n,s] of a) {
                    o = new hr(e.registry,e.path,null,e.scope);
                    const a = [];
                    let l = !1;
                    for (let e = 1; e < t.length; e++) {
                        const r = t[e]
                          , i = Array.isArray(n) ? n[e - 1] : n.type
                          , s = o.parse(r, 1 + a.length, i);
                        if (!s) {
                            l = !0;
                            break
                        }
                        a.push(s);
                    }
                    if (!l)
                        if (Array.isArray(n) && n.length !== a.length)
                            o.error(`Expected ${n.length} arguments, but found ${a.length} instead.`);
                        else {
                            for (let t = 0; t < a.length; t++) {
                                const e = Array.isArray(n) ? n[t] : n.type
                                  , r = a[t];
                                o.concat(t + 1).checkSubtype(e, r.type);
                            }
                            if (0 === o.errors.length)
                                return new Re(r,i,s,a)
                        }
                }
                if (1 === a.length)
                    e.errors.push(...o.errors);
                else {
                    const r = (a.length ? a : s).map(( ([t]) => {
                        return e = t,
                        Array.isArray(e) ? `(${e.map(le).join(", ")})` : `(${le(e.type)}...)`;
                        var e;
                    }
                    )).join(" | ")
                      , n = [];
                    for (let r = 1; r < t.length; r++) {
                        const i = e.parse(t[r], 1 + n.length);
                        if (!i)
                            return null;
                        n.push(le(i.type));
                    }
                    e.error(`Expected arguments of type ${r}, but found (${n.join(", ")}) instead.`);
                }
                return null
            }
            static register(t, e) {
                Re.definitions = e;
                for (const r in e)
                    t[r] = Re;
            }
        }
        var je = Re;
        class Ue {
            constructor(t, e, r) {
                this.type = ie,
                this.locale = r,
                this.caseSensitive = t,
                this.diacriticSensitive = e;
            }
            static parse(t, e) {
                if (2 !== t.length)
                    return e.error("Expected one argument.");
                const r = t[1];
                if ("object" != typeof r || Array.isArray(r))
                    return e.error("Collator options argument must be an object.");
                const n = e.parse(void 0 !== r["case-sensitive"] && r["case-sensitive"], 1, te);
                if (!n)
                    return null;
                const i = e.parse(void 0 !== r["diacritic-sensitive"] && r["diacritic-sensitive"], 1, te);
                if (!i)
                    return null;
                let s = null;
                return r.locale && (s = e.parse(r.locale, 1, Qt),
                !s) ? null : new Ue(n,i,s)
            }
            evaluate(t) {
                return new ge(this.caseSensitive.evaluate(t),this.diacriticSensitive.evaluate(t),this.locale ? this.locale.evaluate(t) : null)
            }
            eachChild(t) {
                t(this.caseSensitive),
                t(this.diacriticSensitive),
                this.locale && t(this.locale);
            }
            outputDefined() {
                return !1
            }
            serialize() {
                const t = {};
                return t["case-sensitive"] = this.caseSensitive.serialize(),
                t["diacritic-sensitive"] = this.diacriticSensitive.serialize(),
                this.locale && (t.locale = this.locale.serialize()),
                ["collator", t]
            }
        }
        const Oe = 8192;
        function $e(t, e) {
            t[0] = Math.min(t[0], e[0]),
            t[1] = Math.min(t[1], e[1]),
            t[2] = Math.max(t[2], e[0]),
            t[3] = Math.max(t[3], e[1]);
        }
        function qe(t, e) {
            return !(t[0] <= e[0] || t[2] >= e[2] || t[1] <= e[1] || t[3] >= e[3])
        }
        function Ne(t, e) {
            const r = (180 + t[0]) / 360
              , n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t[1] * Math.PI / 360))) / 360
              , i = Math.pow(2, e.z);
            return [Math.round(r * i * Oe), Math.round(n * i * Oe)]
        }
        function Ze(t, e, r) {
            const n = t[0] - e[0]
              , i = t[1] - e[1]
              , s = t[0] - r[0]
              , a = t[1] - r[1];
            return n * a - s * i == 0 && n * s <= 0 && i * a <= 0
        }
        function Ge(t, e) {
            let r = !1;
            for (let a = 0, o = e.length; a < o; a++) {
                const o = e[a];
                for (let e = 0, a = o.length; e < a - 1; e++) {
                    if (Ze(t, o[e], o[e + 1]))
                        return !1;
                    (i = o[e])[1] > (n = t)[1] != (s = o[e + 1])[1] > n[1] && n[0] < (s[0] - i[0]) * (n[1] - i[1]) / (s[1] - i[1]) + i[0] && (r = !r);
                }
            }
            var n, i, s;
            return r
        }
        function Xe(t, e) {
            for (let r = 0; r < e.length; r++)
                if (Ge(t, e[r]))
                    return !0;
            return !1
        }
        function Ye(t, e, r, n) {
            const i = n[0] - r[0]
              , s = n[1] - r[1]
              , a = (t[0] - r[0]) * s - i * (t[1] - r[1])
              , o = (e[0] - r[0]) * s - i * (e[1] - r[1]);
            return a > 0 && o < 0 || a < 0 && o > 0
        }
        function He(t, e, r) {
            for (const u of r)
                for (let r = 0; r < u.length - 1; ++r)
                    if (0 != (o = [(a = u[r + 1])[0] - (s = u[r])[0], a[1] - s[1]])[0] * (l = [(i = e)[0] - (n = t)[0], i[1] - n[1]])[1] - o[1] * l[0] && Ye(n, i, s, a) && Ye(s, a, n, i))
                        return !0;
            var n, i, s, a, o, l;
            return !1
        }
        function Ke(t, e) {
            for (let r = 0; r < t.length; ++r)
                if (!Ge(t[r], e))
                    return !1;
            for (let r = 0; r < t.length - 1; ++r)
                if (He(t[r], t[r + 1], e))
                    return !1;
            return !0
        }
        function Je(t, e) {
            for (let r = 0; r < e.length; r++)
                if (Ke(t, e[r]))
                    return !0;
            return !1
        }
        function We(t, e, r) {
            const n = [];
            for (let i = 0; i < t.length; i++) {
                const s = [];
                for (let n = 0; n < t[i].length; n++) {
                    const a = Ne(t[i][n], r);
                    $e(e, a),
                    s.push(a);
                }
                n.push(s);
            }
            return n
        }
        function Qe(t, e, r) {
            const n = [];
            for (let i = 0; i < t.length; i++) {
                const s = We(t[i], e, r);
                n.push(s);
            }
            return n
        }
        function tr(t, e, r, n) {
            if (t[0] < r[0] || t[0] > r[2]) {
                const e = .5 * n;
                let i = t[0] - r[0] > e ? -n : r[0] - t[0] > e ? n : 0;
                0 === i && (i = t[0] - r[2] > e ? -n : r[2] - t[0] > e ? n : 0),
                t[0] += i;
            }
            $e(e, t);
        }
        function er(t, e, r, n) {
            const i = Math.pow(2, n.z) * Oe
              , s = [n.x * Oe, n.y * Oe]
              , a = [];
            if (!t)
                return a;
            for (const n of t)
                for (const t of n) {
                    const n = [t.x + s[0], t.y + s[1]];
                    tr(n, e, r, i),
                    a.push(n);
                }
            return a
        }
        function rr(t, e, r, n) {
            const i = Math.pow(2, n.z) * Oe
              , s = [n.x * Oe, n.y * Oe]
              , a = [];
            if (!t)
                return a;
            for (const r of t) {
                const t = [];
                for (const n of r) {
                    const r = [n.x + s[0], n.y + s[1]];
                    $e(e, r),
                    t.push(r);
                }
                a.push(t);
            }
            if (e[2] - e[0] <= i / 2) {
                (o = e)[0] = o[1] = 1 / 0,
                o[2] = o[3] = -1 / 0;
                for (const t of a)
                    for (const n of t)
                        tr(n, e, r, i);
            }
            var o;
            return a
        }
        class nr {
            constructor(t, e) {
                this.type = te,
                this.geojson = t,
                this.geometries = e;
            }
            static parse(t, e) {
                if (2 !== t.length)
                    return e.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);
                if (we(t[1])) {
                    const e = t[1];
                    if ("FeatureCollection" === e.type)
                        for (let t = 0; t < e.features.length; ++t) {
                            const r = e.features[t].geometry.type;
                            if ("Polygon" === r || "MultiPolygon" === r)
                                return new nr(e,e.features[t].geometry)
                        }
                    else if ("Feature" === e.type) {
                        const t = e.geometry.type;
                        if ("Polygon" === t || "MultiPolygon" === t)
                            return new nr(e,e.geometry)
                    } else if ("Polygon" === e.type || "MultiPolygon" === e.type)
                        return new nr(e,e)
                }
                return e.error("'within' expression requires valid geojson object that contains polygon geometry type.")
            }
            evaluate(t) {
                if (null != t.geometry() && null != t.canonicalID()) {
                    if ("Point" === t.geometryType())
                        return function(t, e) {
                            const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                              , n = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                              , i = t.canonicalID();
                            if (!i)
                                return !1;
                            if ("Polygon" === e.type) {
                                const s = We(e.coordinates, n, i)
                                  , a = er(t.geometry(), r, n, i);
                                if (!qe(r, n))
                                    return !1;
                                for (const t of a)
                                    if (!Ge(t, s))
                                        return !1
                            }
                            if ("MultiPolygon" === e.type) {
                                const s = Qe(e.coordinates, n, i)
                                  , a = er(t.geometry(), r, n, i);
                                if (!qe(r, n))
                                    return !1;
                                for (const t of a)
                                    if (!Xe(t, s))
                                        return !1
                            }
                            return !0
                        }(t, this.geometries);
                    if ("LineString" === t.geometryType())
                        return function(t, e) {
                            const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                              , n = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                              , i = t.canonicalID();
                            if (!i)
                                return !1;
                            if ("Polygon" === e.type) {
                                const s = We(e.coordinates, n, i)
                                  , a = rr(t.geometry(), r, n, i);
                                if (!qe(r, n))
                                    return !1;
                                for (const t of a)
                                    if (!Ke(t, s))
                                        return !1
                            }
                            if ("MultiPolygon" === e.type) {
                                const s = Qe(e.coordinates, n, i)
                                  , a = rr(t.geometry(), r, n, i);
                                if (!qe(r, n))
                                    return !1;
                                for (const t of a)
                                    if (!Je(t, s))
                                        return !1
                            }
                            return !0
                        }(t, this.geometries)
                }
                return !1
            }
            eachChild() {}
            outputDefined() {
                return !0
            }
            serialize() {
                return ["within", this.geojson]
            }
        }
        var ir = nr;
        function sr(t) {
            if (t instanceof je) {
                if ("get" === t.name && 1 === t.args.length)
                    return !1;
                if ("feature-state" === t.name)
                    return !1;
                if ("has" === t.name && 1 === t.args.length)
                    return !1;
                if ("properties" === t.name || "geometry-type" === t.name || "id" === t.name)
                    return !1;
                if (/^filter-/.test(t.name))
                    return !1
            }
            if (t instanceof ir)
                return !1;
            let e = !0;
            return t.eachChild((t => {
                e && !sr(t) && (e = !1);
            }
            )),
            e
        }
        function ar(t) {
            if (t instanceof je && "feature-state" === t.name)
                return !1;
            let e = !0;
            return t.eachChild((t => {
                e && !ar(t) && (e = !1);
            }
            )),
            e
        }
        function or(t, e) {
            if (t instanceof je && e.indexOf(t.name) >= 0)
                return !1;
            let r = !0;
            return t.eachChild((t => {
                r && !or(t, e) && (r = !1);
            }
            )),
            r
        }
        class lr {
            constructor(t, e) {
                this.type = e.type,
                this.name = t,
                this.boundExpression = e;
            }
            static parse(t, e) {
                if (2 !== t.length || "string" != typeof t[1])
                    return e.error("'var' expression requires exactly one string literal argument.");
                const r = t[1];
                return e.scope.has(r) ? new lr(r,e.scope.get(r)) : e.error(`Unknown variable "${r}". Make sure "${r}" has been bound in an enclosing "let" expression before using it.`, 1)
            }
            evaluate(t) {
                return this.boundExpression.evaluate(t)
            }
            eachChild() {}
            outputDefined() {
                return !1
            }
            serialize() {
                return ["var", this.name]
            }
        }
        var ur = lr;
        class cr {
            constructor(t, e=[], r, n=new Kt, i=[]) {
                this.registry = t,
                this.path = e,
                this.key = e.map((t => `[${t}]`)).join(""),
                this.scope = n,
                this.errors = i,
                this.expectedType = r;
            }
            parse(t, e, r, n, i={}) {
                return e ? this.concat(e, r, n)._parse(t, i) : this._parse(t, i)
            }
            _parse(t, e) {
                function r(t, e, r) {
                    return "assert" === r ? new Be(e,[t]) : "coerce" === r ? new Ee(e,[t]) : t
                }
                if (null !== t && "string" != typeof t && "boolean" != typeof t && "number" != typeof t || (t = ["literal", t]),
                Array.isArray(t)) {
                    if (0 === t.length)
                        return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                    const n = t[0];
                    if ("string" != typeof n)
                        return this.error(`Expression name must be a string, but found ${typeof n} instead. If you wanted a literal array, use ["literal", [...]].`, 0),
                        null;
                    const i = this.registry[n];
                    if (i) {
                        let n = i.parse(t, this);
                        if (!n)
                            return null;
                        if (this.expectedType) {
                            const t = this.expectedType
                              , i = n.type;
                            if ("string" !== t.kind && "number" !== t.kind && "boolean" !== t.kind && "object" !== t.kind && "array" !== t.kind || "value" !== i.kind)
                                if ("color" !== t.kind && "formatted" !== t.kind && "resolvedImage" !== t.kind || "value" !== i.kind && "string" !== i.kind) {
                                    if (this.checkSubtype(t, i))
                                        return null
                                } else
                                    n = r(n, t, e.typeAnnotation || "coerce");
                            else
                                n = r(n, t, e.typeAnnotation || "assert");
                        }
                        if (!(n instanceof Se) && "resolvedImage" !== n.type.kind && pr(n)) {
                            const t = new Le;
                            try {
                                n = new Se(n.type,n.evaluate(t));
                            } catch (t) {
                                return this.error(t.message),
                                null
                            }
                        }
                        return n
                    }
                    return this.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0)
                }
                return this.error(void 0 === t ? "'undefined' value invalid. Use null instead." : "object" == typeof t ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`)
            }
            concat(t, e, r) {
                const n = "number" == typeof t ? this.path.concat(t) : this.path
                  , i = r ? this.scope.concat(r) : this.scope;
                return new cr(this.registry,n,e || null,i,this.errors)
            }
            error(t, ...e) {
                const r = `${this.key}${e.map((t => `[${t}]`)).join("")}`;
                this.errors.push(new Yt(r,t));
            }
            checkSubtype(t, e) {
                const r = ce(t, e);
                return r && this.error(r),
                r
            }
        }
        var hr = cr;
        function pr(t) {
            if (t instanceof ur)
                return pr(t.boundExpression);
            if (t instanceof je && "error" === t.name)
                return !1;
            if (t instanceof Ue)
                return !1;
            if (t instanceof ir)
                return !1;
            const e = t instanceof Ee || t instanceof Be;
            let r = !0;
            return t.eachChild((t => {
                r = e ? r && pr(t) : r && t instanceof Se;
            }
            )),
            !!r && sr(t) && or(t, ["zoom", "heatmap-density", "line-progress", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center"])
        }
        function fr(t, e) {
            const r = t.length - 1;
            let n, i, s = 0, a = r, o = 0;
            for (; s <= a; )
                if (o = Math.floor((s + a) / 2),
                n = t[o],
                i = t[o + 1],
                n <= e) {
                    if (o === r || e < i)
                        return o;
                    s = o + 1;
                } else {
                    if (!(n > e))
                        throw new Me("Input is not a number.");
                    a = o - 1;
                }
            return 0
        }
        class dr {
            constructor(t, e, r) {
                this.type = t,
                this.input = e,
                this.labels = [],
                this.outputs = [];
                for (const [t,e] of r)
                    this.labels.push(t),
                    this.outputs.push(e);
            }
            static parse(t, e) {
                if (t.length - 1 < 4)
                    return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
                if ((t.length - 1) % 2 != 0)
                    return e.error("Expected an even number of arguments.");
                const r = e.parse(t[1], 1, Wt);
                if (!r)
                    return null;
                const n = [];
                let i = null;
                e.expectedType && "value" !== e.expectedType.kind && (i = e.expectedType);
                for (let r = 1; r < t.length; r += 2) {
                    const s = 1 === r ? -1 / 0 : t[r]
                      , a = t[r + 1]
                      , o = r
                      , l = r + 1;
                    if ("number" != typeof s)
                        return e.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o);
                    if (n.length && n[n.length - 1][0] >= s)
                        return e.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o);
                    const u = e.parse(a, l, i);
                    if (!u)
                        return null;
                    i = i || u.type,
                    n.push([s, u]);
                }
                return new dr(i,r,n)
            }
            evaluate(t) {
                const e = this.labels
                  , r = this.outputs;
                if (1 === e.length)
                    return r[0].evaluate(t);
                const n = this.input.evaluate(t);
                if (n <= e[0])
                    return r[0].evaluate(t);
                const i = e.length;
                return n >= e[i - 1] ? r[i - 1].evaluate(t) : r[fr(e, n)].evaluate(t)
            }
            eachChild(t) {
                t(this.input);
                for (const e of this.outputs)
                    t(e);
            }
            outputDefined() {
                return this.outputs.every((t => t.outputDefined()))
            }
            serialize() {
                const t = ["step", this.input.serialize()];
                for (let e = 0; e < this.labels.length; e++)
                    e > 0 && t.push(this.labels[e]),
                    t.push(this.outputs[e].serialize());
                return t
            }
        }
        var yr = dr;
        function mr(t, e, r) {
            return t * (1 - r) + e * r
        }
        var gr = Object.freeze({
            __proto__: null,
            number: mr,
            color: function(t, e, r) {
                return new me(mr(t.r, e.r, r),mr(t.g, e.g, r),mr(t.b, e.b, r),mr(t.a, e.a, r))
            },
            array: function(t, e, r) {
                return t.map(( (t, n) => mr(t, e[n], r)))
            }
        });
        const xr = .95047
          , vr = 1.08883
          , br = 4 / 29
          , _r = 6 / 29
          , wr = 3 * _r * _r
          , Ar = Math.PI / 180
          , kr = 180 / Math.PI;
        function zr(t) {
            return t > .008856451679035631 ? Math.pow(t, 1 / 3) : t / wr + br
        }
        function Sr(t) {
            return t > _r ? t * t * t : wr * (t - br)
        }
        function Mr(t) {
            return 255 * (t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055)
        }
        function Ir(t) {
            return (t /= 255) <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4)
        }
        function Tr(t) {
            const e = Ir(t.r)
              , r = Ir(t.g)
              , n = Ir(t.b)
              , i = zr((.4124564 * e + .3575761 * r + .1804375 * n) / xr)
              , s = zr((.2126729 * e + .7151522 * r + .072175 * n) / 1);
            return {
                l: 116 * s - 16,
                a: 500 * (i - s),
                b: 200 * (s - zr((.0193339 * e + .119192 * r + .9503041 * n) / vr)),
                alpha: t.a
            }
        }
        function Br(t) {
            let e = (t.l + 16) / 116
              , r = isNaN(t.a) ? e : e + t.a / 500
              , n = isNaN(t.b) ? e : e - t.b / 200;
            return e = 1 * Sr(e),
            r = xr * Sr(r),
            n = vr * Sr(n),
            new me(Mr(3.2404542 * r - 1.5371385 * e - .4985314 * n),Mr(-.969266 * r + 1.8760108 * e + .041556 * n),Mr(.0556434 * r - .2040259 * e + 1.0572252 * n),t.alpha)
        }
        function Cr(t, e, r) {
            const n = e - t;
            return t + r * (n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n)
        }
        const Vr = {
            forward: Tr,
            reverse: Br,
            interpolate: function(t, e, r) {
                return {
                    l: mr(t.l, e.l, r),
                    a: mr(t.a, e.a, r),
                    b: mr(t.b, e.b, r),
                    alpha: mr(t.alpha, e.alpha, r)
                }
            }
        }
          , Pr = {
            forward: function(t) {
                const {l: e, a: r, b: n} = Tr(t)
                  , i = Math.atan2(n, r) * kr;
                return {
                    h: i < 0 ? i + 360 : i,
                    c: Math.sqrt(r * r + n * n),
                    l: e,
                    alpha: t.a
                }
            },
            reverse: function(t) {
                const e = t.h * Ar
                  , r = t.c;
                return Br({
                    l: t.l,
                    a: Math.cos(e) * r,
                    b: Math.sin(e) * r,
                    alpha: t.alpha
                })
            },
            interpolate: function(t, e, r) {
                return {
                    h: Cr(t.h, e.h, r),
                    c: mr(t.c, e.c, r),
                    l: mr(t.l, e.l, r),
                    alpha: mr(t.alpha, e.alpha, r)
                }
            }
        };
        var Dr = Object.freeze({
            __proto__: null,
            lab: Vr,
            hcl: Pr
        });
        class Er {
            constructor(t, e, r, n, i) {
                this.type = t,
                this.operator = e,
                this.interpolation = r,
                this.input = n,
                this.labels = [],
                this.outputs = [];
                for (const [t,e] of i)
                    this.labels.push(t),
                    this.outputs.push(e);
            }
            static interpolationFactor(t, e, n, i) {
                let s = 0;
                if ("exponential" === t.name)
                    s = Fr(e, t.base, n, i);
                else if ("linear" === t.name)
                    s = Fr(e, 1, n, i);
                else if ("cubic-bezier" === t.name) {
                    const a = t.controlPoints;
                    s = new r(a[0],a[1],a[2],a[3]).solve(Fr(e, 1, n, i));
                }
                return s
            }
            static parse(t, e) {
                let[r,n,i,...s] = t;
                if (!Array.isArray(n) || 0 === n.length)
                    return e.error("Expected an interpolation type expression.", 1);
                if ("linear" === n[0])
                    n = {
                        name: "linear"
                    };
                else if ("exponential" === n[0]) {
                    const t = n[1];
                    if ("number" != typeof t)
                        return e.error("Exponential interpolation requires a numeric base.", 1, 1);
                    n = {
                        name: "exponential",
                        base: t
                    };
                } else {
                    if ("cubic-bezier" !== n[0])
                        return e.error(`Unknown interpolation type ${String(n[0])}`, 1, 0);
                    {
                        const t = n.slice(1);
                        if (4 !== t.length || t.some((t => "number" != typeof t || t < 0 || t > 1)))
                            return e.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                        n = {
                            name: "cubic-bezier",
                            controlPoints: t
                        };
                    }
                }
                if (t.length - 1 < 4)
                    return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
                if ((t.length - 1) % 2 != 0)
                    return e.error("Expected an even number of arguments.");
                if (i = e.parse(i, 2, Wt),
                !i)
                    return null;
                const a = [];
                let o = null;
                "interpolate-hcl" === r || "interpolate-lab" === r ? o = ee : e.expectedType && "value" !== e.expectedType.kind && (o = e.expectedType);
                for (let t = 0; t < s.length; t += 2) {
                    const r = s[t]
                      , n = s[t + 1]
                      , i = t + 3
                      , l = t + 4;
                    if ("number" != typeof r)
                        return e.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i);
                    if (a.length && a[a.length - 1][0] >= r)
                        return e.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i);
                    const u = e.parse(n, l, o);
                    if (!u)
                        return null;
                    o = o || u.type,
                    a.push([r, u]);
                }
                return "number" === o.kind || "color" === o.kind || "array" === o.kind && "number" === o.itemType.kind && "number" == typeof o.N ? new Er(o,r,n,i,a) : e.error(`Type ${le(o)} is not interpolatable.`)
            }
            evaluate(t) {
                const e = this.labels
                  , r = this.outputs;
                if (1 === e.length)
                    return r[0].evaluate(t);
                const n = this.input.evaluate(t);
                if (n <= e[0])
                    return r[0].evaluate(t);
                const i = e.length;
                if (n >= e[i - 1])
                    return r[i - 1].evaluate(t);
                const s = fr(e, n)
                  , a = Er.interpolationFactor(this.interpolation, n, e[s], e[s + 1])
                  , o = r[s].evaluate(t)
                  , l = r[s + 1].evaluate(t);
                return "interpolate" === this.operator ? gr[this.type.kind.toLowerCase()](o, l, a) : "interpolate-hcl" === this.operator ? Pr.reverse(Pr.interpolate(Pr.forward(o), Pr.forward(l), a)) : Vr.reverse(Vr.interpolate(Vr.forward(o), Vr.forward(l), a))
            }
            eachChild(t) {
                t(this.input);
                for (const e of this.outputs)
                    t(e);
            }
            outputDefined() {
                return this.outputs.every((t => t.outputDefined()))
            }
            serialize() {
                let t;
                t = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
                const e = [this.operator, t, this.input.serialize()];
                for (let t = 0; t < this.labels.length; t++)
                    e.push(this.labels[t], this.outputs[t].serialize());
                return e
            }
        }
        function Fr(t, e, r, n) {
            const i = n - r
              , s = t - r;
            return 0 === i ? 0 : 1 === e ? s / i : (Math.pow(e, s) - 1) / (Math.pow(e, i) - 1)
        }
        var Lr = Er;
        class Rr {
            constructor(t, e) {
                this.type = t,
                this.args = e;
            }
            static parse(t, e) {
                if (t.length < 2)
                    return e.error("Expectected at least one argument.");
                let r = null;
                const n = e.expectedType;
                n && "value" !== n.kind && (r = n);
                const i = [];
                for (const n of t.slice(1)) {
                    const t = e.parse(n, 1 + i.length, r, void 0, {
                        typeAnnotation: "omit"
                    });
                    if (!t)
                        return null;
                    r = r || t.type,
                    i.push(t);
                }
                const s = n && i.some((t => ce(n, t.type)));
                return new Rr(s ? ne : r,i)
            }
            evaluate(t) {
                let e, r = null, n = 0;
                for (const i of this.args) {
                    if (n++,
                    r = i.evaluate(t),
                    r && r instanceof be && !r.available && (e || (e = r),
                    r = null,
                    n === this.args.length))
                        return e;
                    if (null !== r)
                        break
                }
                return r
            }
            eachChild(t) {
                this.args.forEach(t);
            }
            outputDefined() {
                return this.args.every((t => t.outputDefined()))
            }
            serialize() {
                const t = ["coalesce"];
                return this.eachChild((e => {
                    t.push(e.serialize());
                }
                )),
                t
            }
        }
        var jr = Rr;
        class Ur {
            constructor(t, e) {
                this.type = e.type,
                this.bindings = [].concat(t),
                this.result = e;
            }
            evaluate(t) {
                return this.result.evaluate(t)
            }
            eachChild(t) {
                for (const e of this.bindings)
                    t(e[1]);
                t(this.result);
            }
            static parse(t, e) {
                if (t.length < 4)
                    return e.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);
                const r = [];
                for (let n = 1; n < t.length - 1; n += 2) {
                    const i = t[n];
                    if ("string" != typeof i)
                        return e.error(`Expected string, but found ${typeof i} instead.`, n);
                    if (/[^a-zA-Z0-9_]/.test(i))
                        return e.error("Variable names must contain only alphanumeric characters or '_'.", n);
                    const s = e.parse(t[n + 1], n + 1);
                    if (!s)
                        return null;
                    r.push([i, s]);
                }
                const n = e.parse(t[t.length - 1], t.length - 1, e.expectedType, r);
                return n ? new Ur(r,n) : null
            }
            outputDefined() {
                return this.result.outputDefined()
            }
            serialize() {
                const t = ["let"];
                for (const [e,r] of this.bindings)
                    t.push(e, r.serialize());
                return t.push(this.result.serialize()),
                t
            }
        }
        var Or = Ur;
        class $r {
            constructor(t, e, r) {
                this.type = t,
                this.index = e,
                this.input = r;
            }
            static parse(t, e) {
                if (3 !== t.length)
                    return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
                const r = e.parse(t[1], 1, Wt)
                  , n = e.parse(t[2], 2, oe(e.expectedType || ne));
                return r && n ? new $r(n.type.itemType,r,n) : null
            }
            evaluate(t) {
                const e = this.index.evaluate(t)
                  , r = this.input.evaluate(t);
                if (e < 0)
                    throw new Me(`Array index out of bounds: ${e} < 0.`);
                if (e >= r.length)
                    throw new Me(`Array index out of bounds: ${e} > ${r.length - 1}.`);
                if (e !== Math.floor(e))
                    throw new Me(`Array index must be an integer, but found ${e} instead.`);
                return r[e]
            }
            eachChild(t) {
                t(this.index),
                t(this.input);
            }
            outputDefined() {
                return !1
            }
            serialize() {
                return ["at", this.index.serialize(), this.input.serialize()]
            }
        }
        var qr = $r;
        class Nr {
            constructor(t, e) {
                this.type = te,
                this.needle = t,
                this.haystack = e;
            }
            static parse(t, e) {
                if (3 !== t.length)
                    return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
                const r = e.parse(t[1], 1, ne)
                  , n = e.parse(t[2], 2, ne);
                return r && n ? he(r.type, [te, Qt, Wt, Jt, ne]) ? new Nr(r,n) : e.error(`Expected first argument to be of type boolean, string, number or null, but found ${le(r.type)} instead`) : null
            }
            evaluate(t) {
                const e = this.needle.evaluate(t)
                  , r = this.haystack.evaluate(t);
                if (null == r)
                    return !1;
                if (!pe(e, ["boolean", "string", "number", "null"]))
                    throw new Me(`Expected first argument to be of type boolean, string, number or null, but found ${le(Ae(e))} instead.`);
                if (!pe(r, ["string", "array"]))
                    throw new Me(`Expected second argument to be of type array or string, but found ${le(Ae(r))} instead.`);
                return r.indexOf(e) >= 0
            }
            eachChild(t) {
                t(this.needle),
                t(this.haystack);
            }
            outputDefined() {
                return !0
            }
            serialize() {
                return ["in", this.needle.serialize(), this.haystack.serialize()]
            }
        }
        var Zr = Nr;
        class Gr {
            constructor(t, e, r) {
                this.type = Wt,
                this.needle = t,
                this.haystack = e,
                this.fromIndex = r;
            }
            static parse(t, e) {
                if (t.length <= 2 || t.length >= 5)
                    return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
                const r = e.parse(t[1], 1, ne)
                  , n = e.parse(t[2], 2, ne);
                if (!r || !n)
                    return null;
                if (!he(r.type, [te, Qt, Wt, Jt, ne]))
                    return e.error(`Expected first argument to be of type boolean, string, number or null, but found ${le(r.type)} instead`);
                if (4 === t.length) {
                    const i = e.parse(t[3], 3, Wt);
                    return i ? new Gr(r,n,i) : null
                }
                return new Gr(r,n)
            }
            evaluate(t) {
                const e = this.needle.evaluate(t)
                  , r = this.haystack.evaluate(t);
                if (!pe(e, ["boolean", "string", "number", "null"]))
                    throw new Me(`Expected first argument to be of type boolean, string, number or null, but found ${le(Ae(e))} instead.`);
                if (!pe(r, ["string", "array"]))
                    throw new Me(`Expected second argument to be of type array or string, but found ${le(Ae(r))} instead.`);
                if (this.fromIndex) {
                    const n = this.fromIndex.evaluate(t);
                    return r.indexOf(e, n)
                }
                return r.indexOf(e)
            }
            eachChild(t) {
                t(this.needle),
                t(this.haystack),
                this.fromIndex && t(this.fromIndex);
            }
            outputDefined() {
                return !1
            }
            serialize() {
                if (null != this.fromIndex && void 0 !== this.fromIndex) {
                    const t = this.fromIndex.serialize();
                    return ["index-of", this.needle.serialize(), this.haystack.serialize(), t]
                }
                return ["index-of", this.needle.serialize(), this.haystack.serialize()]
            }
        }
        var Xr = Gr;
        class Yr {
            constructor(t, e, r, n, i, s) {
                this.inputType = t,
                this.type = e,
                this.input = r,
                this.cases = n,
                this.outputs = i,
                this.otherwise = s;
            }
            static parse(t, e) {
                if (t.length < 5)
                    return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
                if (t.length % 2 != 1)
                    return e.error("Expected an even number of arguments.");
                let r, n;
                e.expectedType && "value" !== e.expectedType.kind && (n = e.expectedType);
                const i = {}
                  , s = [];
                for (let a = 2; a < t.length - 1; a += 2) {
                    let o = t[a];
                    const l = t[a + 1];
                    Array.isArray(o) || (o = [o]);
                    const u = e.concat(a);
                    if (0 === o.length)
                        return u.error("Expected at least one branch label.");
                    for (const t of o) {
                        if ("number" != typeof t && "string" != typeof t)
                            return u.error("Branch labels must be numbers or strings.");
                        if ("number" == typeof t && Math.abs(t) > Number.MAX_SAFE_INTEGER)
                            return u.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                        if ("number" == typeof t && Math.floor(t) !== t)
                            return u.error("Numeric branch labels must be integer values.");
                        if (r) {
                            if (u.checkSubtype(r, Ae(t)))
                                return null
                        } else
                            r = Ae(t);
                        if (void 0 !== i[String(t)])
                            return u.error("Branch labels must be unique.");
                        i[String(t)] = s.length;
                    }
                    const c = e.parse(l, a, n);
                    if (!c)
                        return null;
                    n = n || c.type,
                    s.push(c);
                }
                const a = e.parse(t[1], 1, ne);
                if (!a)
                    return null;
                const o = e.parse(t[t.length - 1], t.length - 1, n);
                return o ? "value" !== a.type.kind && e.concat(1).checkSubtype(r, a.type) ? null : new Yr(r,n,a,i,s,o) : null
            }
            evaluate(t) {
                const e = this.input.evaluate(t);
                return (Ae(e) === this.inputType && this.outputs[this.cases[e]] || this.otherwise).evaluate(t)
            }
            eachChild(t) {
                t(this.input),
                this.outputs.forEach(t),
                t(this.otherwise);
            }
            outputDefined() {
                return this.outputs.every((t => t.outputDefined())) && this.otherwise.outputDefined()
            }
            serialize() {
                const t = ["match", this.input.serialize()]
                  , e = Object.keys(this.cases).sort()
                  , r = []
                  , n = {};
                for (const t of e) {
                    const e = n[this.cases[t]];
                    void 0 === e ? (n[this.cases[t]] = r.length,
                    r.push([this.cases[t], [t]])) : r[e][1].push(t);
                }
                const i = t => "number" === this.inputType.kind ? Number(t) : t;
                for (const [e,n] of r)
                    t.push(1 === n.length ? i(n[0]) : n.map(i)),
                    t.push(this.outputs[e].serialize());
                return t.push(this.otherwise.serialize()),
                t
            }
        }
        var Hr = Yr;
        class Kr {
            constructor(t, e, r) {
                this.type = t,
                this.branches = e,
                this.otherwise = r;
            }
            static parse(t, e) {
                if (t.length < 4)
                    return e.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);
                if (t.length % 2 != 0)
                    return e.error("Expected an odd number of arguments.");
                let r;
                e.expectedType && "value" !== e.expectedType.kind && (r = e.expectedType);
                const n = [];
                for (let i = 1; i < t.length - 1; i += 2) {
                    const s = e.parse(t[i], i, te);
                    if (!s)
                        return null;
                    const a = e.parse(t[i + 1], i + 1, r);
                    if (!a)
                        return null;
                    n.push([s, a]),
                    r = r || a.type;
                }
                const i = e.parse(t[t.length - 1], t.length - 1, r);
                return i ? new Kr(r,n,i) : null
            }
            evaluate(t) {
                for (const [e,r] of this.branches)
                    if (e.evaluate(t))
                        return r.evaluate(t);
                return this.otherwise.evaluate(t)
            }
            eachChild(t) {
                for (const [e,r] of this.branches)
                    t(e),
                    t(r);
                t(this.otherwise);
            }
            outputDefined() {
                return this.branches.every(( ([t,e]) => e.outputDefined())) && this.otherwise.outputDefined()
            }
            serialize() {
                const t = ["case"];
                return this.eachChild((e => {
                    t.push(e.serialize());
                }
                )),
                t
            }
        }
        var Jr = Kr;
        class Wr {
            constructor(t, e, r, n) {
                this.type = t,
                this.input = e,
                this.beginIndex = r,
                this.endIndex = n;
            }
            static parse(t, e) {
                if (t.length <= 2 || t.length >= 5)
                    return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
                const r = e.parse(t[1], 1, ne)
                  , n = e.parse(t[2], 2, Wt);
                if (!r || !n)
                    return null;
                if (!he(r.type, [oe(ne), Qt, ne]))
                    return e.error(`Expected first argument to be of type array or string, but found ${le(r.type)} instead`);
                if (4 === t.length) {
                    const i = e.parse(t[3], 3, Wt);
                    return i ? new Wr(r.type,r,n,i) : null
                }
                return new Wr(r.type,r,n)
            }
            evaluate(t) {
                const e = this.input.evaluate(t)
                  , r = this.beginIndex.evaluate(t);
                if (!pe(e, ["string", "array"]))
                    throw new Me(`Expected first argument to be of type array or string, but found ${le(Ae(e))} instead.`);
                if (this.endIndex) {
                    const n = this.endIndex.evaluate(t);
                    return e.slice(r, n)
                }
                return e.slice(r)
            }
            eachChild(t) {
                t(this.input),
                t(this.beginIndex),
                this.endIndex && t(this.endIndex);
            }
            outputDefined() {
                return !1
            }
            serialize() {
                if (null != this.endIndex && void 0 !== this.endIndex) {
                    const t = this.endIndex.serialize();
                    return ["slice", this.input.serialize(), this.beginIndex.serialize(), t]
                }
                return ["slice", this.input.serialize(), this.beginIndex.serialize()]
            }
        }
        var Qr = Wr;
        function tn(t, e) {
            return "==" === t || "!=" === t ? "boolean" === e.kind || "string" === e.kind || "number" === e.kind || "null" === e.kind || "value" === e.kind : "string" === e.kind || "number" === e.kind || "value" === e.kind
        }
        function en(t, e, r, n) {
            return 0 === n.compare(e, r)
        }
        function rn(t, e, r) {
            const n = "==" !== t && "!=" !== t;
            return class i {
                constructor(t, e, r) {
                    this.type = te,
                    this.lhs = t,
                    this.rhs = e,
                    this.collator = r,
                    this.hasUntypedArgument = "value" === t.type.kind || "value" === e.type.kind;
                }
                static parse(t, e) {
                    if (3 !== t.length && 4 !== t.length)
                        return e.error("Expected two or three arguments.");
                    const r = t[0];
                    let s = e.parse(t[1], 1, ne);
                    if (!s)
                        return null;
                    if (!tn(r, s.type))
                        return e.concat(1).error(`"${r}" comparisons are not supported for type '${le(s.type)}'.`);
                    let a = e.parse(t[2], 2, ne);
                    if (!a)
                        return null;
                    if (!tn(r, a.type))
                        return e.concat(2).error(`"${r}" comparisons are not supported for type '${le(a.type)}'.`);
                    if (s.type.kind !== a.type.kind && "value" !== s.type.kind && "value" !== a.type.kind)
                        return e.error(`Cannot compare types '${le(s.type)}' and '${le(a.type)}'.`);
                    n && ("value" === s.type.kind && "value" !== a.type.kind ? s = new Be(a.type,[s]) : "value" !== s.type.kind && "value" === a.type.kind && (a = new Be(s.type,[a])));
                    let o = null;
                    if (4 === t.length) {
                        if ("string" !== s.type.kind && "string" !== a.type.kind && "value" !== s.type.kind && "value" !== a.type.kind)
                            return e.error("Cannot use collator to compare non-string types.");
                        if (o = e.parse(t[3], 3, ie),
                        !o)
                            return null
                    }
                    return new i(s,a,o)
                }
                evaluate(i) {
                    const s = this.lhs.evaluate(i)
                      , a = this.rhs.evaluate(i);
                    if (n && this.hasUntypedArgument) {
                        const e = Ae(s)
                          , r = Ae(a);
                        if (e.kind !== r.kind || "string" !== e.kind && "number" !== e.kind)
                            throw new Me(`Expected arguments for "${t}" to be (string, string) or (number, number), but found (${e.kind}, ${r.kind}) instead.`)
                    }
                    if (this.collator && !n && this.hasUntypedArgument) {
                        const t = Ae(s)
                          , r = Ae(a);
                        if ("string" !== t.kind || "string" !== r.kind)
                            return e(i, s, a)
                    }
                    return this.collator ? r(i, s, a, this.collator.evaluate(i)) : e(i, s, a)
                }
                eachChild(t) {
                    t(this.lhs),
                    t(this.rhs),
                    this.collator && t(this.collator);
                }
                outputDefined() {
                    return !0
                }
                serialize() {
                    const e = [t];
                    return this.eachChild((t => {
                        e.push(t.serialize());
                    }
                    )),
                    e
                }
            }
        }
        const nn = rn("==", (function(t, e, r) {
            return e === r
        }
        ), en)
          , sn = rn("!=", (function(t, e, r) {
            return e !== r
        }
        ), (function(t, e, r, n) {
            return !en(0, e, r, n)
        }
        ))
          , an = rn("<", (function(t, e, r) {
            return e < r
        }
        ), (function(t, e, r, n) {
            return n.compare(e, r) < 0
        }
        ))
          , on = rn(">", (function(t, e, r) {
            return e > r
        }
        ), (function(t, e, r, n) {
            return n.compare(e, r) > 0
        }
        ))
          , ln = rn("<=", (function(t, e, r) {
            return e <= r
        }
        ), (function(t, e, r, n) {
            return n.compare(e, r) <= 0
        }
        ))
          , un = rn(">=", (function(t, e, r) {
            return e >= r
        }
        ), (function(t, e, r, n) {
            return n.compare(e, r) >= 0
        }
        ));
        class cn {
            constructor(t, e, r, n, i, s) {
                this.type = Qt,
                this.number = t,
                this.locale = e,
                this.currency = r,
                this.unit = n,
                this.minFractionDigits = i,
                this.maxFractionDigits = s;
            }
            static parse(t, e) {
                if (3 !== t.length)
                    return e.error("Expected two arguments.");
                const r = e.parse(t[1], 1, Wt);
                if (!r)
                    return null;
                const n = t[2];
                if ("object" != typeof n || Array.isArray(n))
                    return e.error("NumberFormat options argument must be an object.");
                let i = null;
                if (n.locale && (i = e.parse(n.locale, 1, Qt),
                !i))
                    return null;
                let s = null;
                if (n.currency && (s = e.parse(n.currency, 1, Qt),
                !s))
                    return null;
                let a = null;
                if (n.unit && (a = e.parse(n.unit, 1, Qt),
                !a))
                    return null;
                let o = null;
                if (n["min-fraction-digits"] && (o = e.parse(n["min-fraction-digits"], 1, Wt),
                !o))
                    return null;
                let l = null;
                return n["max-fraction-digits"] && (l = e.parse(n["max-fraction-digits"], 1, Wt),
                !l) ? null : new cn(r,i,s,a,o,l)
            }
            evaluate(t) {
                return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [],{
                    style: (this.currency ? "currency" : this.unit && "unit") || "decimal",
                    currency: this.currency ? this.currency.evaluate(t) : void 0,
                    unit: this.unit ? this.unit.evaluate(t) : void 0,
                    minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,
                    maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0
                }).format(this.number.evaluate(t))
            }
            eachChild(t) {
                t(this.number),
                this.locale && t(this.locale),
                this.currency && t(this.currency),
                this.unit && t(this.unit),
                this.minFractionDigits && t(this.minFractionDigits),
                this.maxFractionDigits && t(this.maxFractionDigits);
            }
            outputDefined() {
                return !1
            }
            serialize() {
                const t = {};
                return this.locale && (t.locale = this.locale.serialize()),
                this.currency && (t.currency = this.currency.serialize()),
                this.unit && (t.unit = this.unit.serialize()),
                this.minFractionDigits && (t["min-fraction-digits"] = this.minFractionDigits.serialize()),
                this.maxFractionDigits && (t["max-fraction-digits"] = this.maxFractionDigits.serialize()),
                ["number-format", this.number.serialize(), t]
            }
        }
        class hn {
            constructor(t) {
                this.type = Wt,
                this.input = t;
            }
            static parse(t, e) {
                if (2 !== t.length)
                    return e.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
                const r = e.parse(t[1], 1);
                return r ? "array" !== r.type.kind && "string" !== r.type.kind && "value" !== r.type.kind ? e.error(`Expected argument of type string or array, but found ${le(r.type)} instead.`) : new hn(r) : null
            }
            evaluate(t) {
                const e = this.input.evaluate(t);
                if ("string" == typeof e)
                    return e.length;
                if (Array.isArray(e))
                    return e.length;
                throw new Me(`Expected value to be of type string or array, but found ${le(Ae(e))} instead.`)
            }
            eachChild(t) {
                t(this.input);
            }
            outputDefined() {
                return !1
            }
            serialize() {
                const t = ["length"];
                return this.eachChild((e => {
                    t.push(e.serialize());
                }
                )),
                t
            }
        }
        const pn = {
            "==": nn,
            "!=": sn,
            ">": on,
            "<": an,
            ">=": un,
            "<=": ln,
            array: Be,
            at: qr,
            boolean: Be,
            case: Jr,
            coalesce: jr,
            collator: Ue,
            format: Ce,
            image: Ve,
            in: Zr,
            "index-of": Xr,
            interpolate: Lr,
            "interpolate-hcl": Lr,
            "interpolate-lab": Lr,
            length: hn,
            let: Or,
            literal: Se,
            match: Hr,
            number: Be,
            "number-format": cn,
            object: Be,
            slice: Qr,
            step: yr,
            string: Be,
            "to-boolean": Ee,
            "to-color": Ee,
            "to-number": Ee,
            "to-string": Ee,
            var: ur,
            within: ir
        };
        function fn(t, [e,r,n,i]) {
            e = e.evaluate(t),
            r = r.evaluate(t),
            n = n.evaluate(t);
            const s = i ? i.evaluate(t) : 1
              , a = _e(e, r, n, s);
            if (a)
                throw new Me(a);
            return new me(e / 255 * s,r / 255 * s,n / 255 * s,s)
        }
        function dn(t, e) {
            return t in e
        }
        function yn(t, e) {
            const r = e[t];
            return void 0 === r ? null : r
        }
        function mn(t) {
            return {
                type: t
            }
        }
        je.register(pn, {
            error: [{
                kind: "error"
            }, [Qt], (t, [e]) => {
                throw new Me(e.evaluate(t))
            }
            ],
            typeof: [Qt, [ne], (t, [e]) => le(Ae(e.evaluate(t)))],
            "to-rgba": [oe(Wt, 4), [ee], (t, [e]) => e.evaluate(t).toArray()],
            rgb: [ee, [Wt, Wt, Wt], fn],
            rgba: [ee, [Wt, Wt, Wt, Wt], fn],
            has: {
                type: te,
                overloads: [[[Qt], (t, [e]) => dn(e.evaluate(t), t.properties())], [[Qt, re], (t, [e,r]) => dn(e.evaluate(t), r.evaluate(t))]]
            },
            get: {
                type: ne,
                overloads: [[[Qt], (t, [e]) => yn(e.evaluate(t), t.properties())], [[Qt, re], (t, [e,r]) => yn(e.evaluate(t), r.evaluate(t))]]
            },
            "feature-state": [ne, [Qt], (t, [e]) => yn(e.evaluate(t), t.featureState || {})],
            properties: [re, [], t => t.properties()],
            "geometry-type": [Qt, [], t => t.geometryType()],
            id: [ne, [], t => t.id()],
            zoom: [Wt, [], t => t.globals.zoom],
            pitch: [Wt, [], t => t.globals.pitch || 0],
            "distance-from-center": [Wt, [], t => t.distanceFromCenter()],
            "heatmap-density": [Wt, [], t => t.globals.heatmapDensity || 0],
            "line-progress": [Wt, [], t => t.globals.lineProgress || 0],
            "sky-radial-progress": [Wt, [], t => t.globals.skyRadialProgress || 0],
            accumulated: [ne, [], t => void 0 === t.globals.accumulated ? null : t.globals.accumulated],
            "+": [Wt, mn(Wt), (t, e) => {
                let r = 0;
                for (const n of e)
                    r += n.evaluate(t);
                return r
            }
            ],
            "*": [Wt, mn(Wt), (t, e) => {
                let r = 1;
                for (const n of e)
                    r *= n.evaluate(t);
                return r
            }
            ],
            "-": {
                type: Wt,
                overloads: [[[Wt, Wt], (t, [e,r]) => e.evaluate(t) - r.evaluate(t)], [[Wt], (t, [e]) => -e.evaluate(t)]]
            },
            "/": [Wt, [Wt, Wt], (t, [e,r]) => e.evaluate(t) / r.evaluate(t)],
            "%": [Wt, [Wt, Wt], (t, [e,r]) => e.evaluate(t) % r.evaluate(t)],
            ln2: [Wt, [], () => Math.LN2],
            pi: [Wt, [], () => Math.PI],
            e: [Wt, [], () => Math.E],
            "^": [Wt, [Wt, Wt], (t, [e,r]) => Math.pow(e.evaluate(t), r.evaluate(t))],
            sqrt: [Wt, [Wt], (t, [e]) => Math.sqrt(e.evaluate(t))],
            log10: [Wt, [Wt], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN10],
            ln: [Wt, [Wt], (t, [e]) => Math.log(e.evaluate(t))],
            log2: [Wt, [Wt], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN2],
            sin: [Wt, [Wt], (t, [e]) => Math.sin(e.evaluate(t))],
            cos: [Wt, [Wt], (t, [e]) => Math.cos(e.evaluate(t))],
            tan: [Wt, [Wt], (t, [e]) => Math.tan(e.evaluate(t))],
            asin: [Wt, [Wt], (t, [e]) => Math.asin(e.evaluate(t))],
            acos: [Wt, [Wt], (t, [e]) => Math.acos(e.evaluate(t))],
            atan: [Wt, [Wt], (t, [e]) => Math.atan(e.evaluate(t))],
            min: [Wt, mn(Wt), (t, e) => Math.min(...e.map((e => e.evaluate(t))))],
            max: [Wt, mn(Wt), (t, e) => Math.max(...e.map((e => e.evaluate(t))))],
            abs: [Wt, [Wt], (t, [e]) => Math.abs(e.evaluate(t))],
            round: [Wt, [Wt], (t, [e]) => {
                const r = e.evaluate(t);
                return r < 0 ? -Math.round(-r) : Math.round(r)
            }
            ],
            floor: [Wt, [Wt], (t, [e]) => Math.floor(e.evaluate(t))],
            ceil: [Wt, [Wt], (t, [e]) => Math.ceil(e.evaluate(t))],
            "filter-==": [te, [Qt, ne], (t, [e,r]) => t.properties()[e.value] === r.value],
            "filter-id-==": [te, [ne], (t, [e]) => t.id() === e.value],
            "filter-type-==": [te, [Qt], (t, [e]) => t.geometryType() === e.value],
            "filter-<": [te, [Qt, ne], (t, [e,r]) => {
                const n = t.properties()[e.value]
                  , i = r.value;
                return typeof n == typeof i && n < i
            }
            ],
            "filter-id-<": [te, [ne], (t, [e]) => {
                const r = t.id()
                  , n = e.value;
                return typeof r == typeof n && r < n
            }
            ],
            "filter->": [te, [Qt, ne], (t, [e,r]) => {
                const n = t.properties()[e.value]
                  , i = r.value;
                return typeof n == typeof i && n > i
            }
            ],
            "filter-id->": [te, [ne], (t, [e]) => {
                const r = t.id()
                  , n = e.value;
                return typeof r == typeof n && r > n
            }
            ],
            "filter-<=": [te, [Qt, ne], (t, [e,r]) => {
                const n = t.properties()[e.value]
                  , i = r.value;
                return typeof n == typeof i && n <= i
            }
            ],
            "filter-id-<=": [te, [ne], (t, [e]) => {
                const r = t.id()
                  , n = e.value;
                return typeof r == typeof n && r <= n
            }
            ],
            "filter->=": [te, [Qt, ne], (t, [e,r]) => {
                const n = t.properties()[e.value]
                  , i = r.value;
                return typeof n == typeof i && n >= i
            }
            ],
            "filter-id->=": [te, [ne], (t, [e]) => {
                const r = t.id()
                  , n = e.value;
                return typeof r == typeof n && r >= n
            }
            ],
            "filter-has": [te, [ne], (t, [e]) => e.value in t.properties()],
            "filter-has-id": [te, [], t => null !== t.id() && void 0 !== t.id()],
            "filter-type-in": [te, [oe(Qt)], (t, [e]) => e.value.indexOf(t.geometryType()) >= 0],
            "filter-id-in": [te, [oe(ne)], (t, [e]) => e.value.indexOf(t.id()) >= 0],
            "filter-in-small": [te, [Qt, oe(ne)], (t, [e,r]) => r.value.indexOf(t.properties()[e.value]) >= 0],
            "filter-in-large": [te, [Qt, oe(ne)], (t, [e,r]) => function(t, e, r, n) {
                for (; r <= n; ) {
                    const i = r + n >> 1;
                    if (e[i] === t)
                        return !0;
                    e[i] > t ? n = i - 1 : r = i + 1;
                }
                return !1
            }(t.properties()[e.value], r.value, 0, r.value.length - 1)],
            all: {
                type: te,
                overloads: [[[te, te], (t, [e,r]) => e.evaluate(t) && r.evaluate(t)], [mn(te), (t, e) => {
                    for (const r of e)
                        if (!r.evaluate(t))
                            return !1;
                    return !0
                }
                ]]
            },
            any: {
                type: te,
                overloads: [[[te, te], (t, [e,r]) => e.evaluate(t) || r.evaluate(t)], [mn(te), (t, e) => {
                    for (const r of e)
                        if (r.evaluate(t))
                            return !0;
                    return !1
                }
                ]]
            },
            "!": [te, [te], (t, [e]) => !e.evaluate(t)],
            "is-supported-script": [te, [Qt], (t, [e]) => {
                const r = t.globals && t.globals.isSupportedScript;
                return !r || r(e.evaluate(t))
            }
            ],
            upcase: [Qt, [Qt], (t, [e]) => e.evaluate(t).toUpperCase()],
            downcase: [Qt, [Qt], (t, [e]) => e.evaluate(t).toLowerCase()],
            concat: [Qt, mn(ne), (t, e) => e.map((e => ke(e.evaluate(t)))).join("")],
            "resolved-locale": [Qt, [ie], (t, [e]) => e.evaluate(t).resolvedLocale()]
        });
        var gn = pn;
        function xn(t) {
            return {
                result: "success",
                value: t
            }
        }
        function vn(t) {
            return {
                result: "error",
                value: t
            }
        }
        function bn(t) {
            return "data-driven" === t["property-type"] || "cross-faded-data-driven" === t["property-type"]
        }
        function _n(t) {
            return !!t.expression && t.expression.parameters.indexOf("zoom") > -1
        }
        function wn(t) {
            return !!t.expression && t.expression.interpolated
        }
        function An(t) {
            return t instanceof Number ? "number" : t instanceof String ? "string" : t instanceof Boolean ? "boolean" : Array.isArray(t) ? "array" : null === t ? "null" : typeof t
        }
        function kn(t) {
            return "object" == typeof t && null !== t && !Array.isArray(t)
        }
        function zn(t) {
            return t
        }
        function Sn(t, e) {
            const r = "color" === e.type
              , n = t.stops && "object" == typeof t.stops[0][0]
              , i = n || !(n || void 0 !== t.property)
              , s = t.type || (wn(e) ? "exponential" : "interval");
            if (r && ((t = Nt({}, t)).stops && (t.stops = t.stops.map((t => [t[0], me.parse(t[1])]))),
            t.default = me.parse(t.default ? t.default : e.default)),
            t.colorSpace && "rgb" !== t.colorSpace && !Dr[t.colorSpace])
                throw new Error(`Unknown color space: ${t.colorSpace}`);
            let a, o, l;
            if ("exponential" === s)
                a = Bn;
            else if ("interval" === s)
                a = Tn;
            else if ("categorical" === s) {
                a = In,
                o = Object.create(null);
                for (const e of t.stops)
                    o[e[0]] = e[1];
                l = typeof t.stops[0][0];
            } else {
                if ("identity" !== s)
                    throw new Error(`Unknown function type "${s}"`);
                a = Cn;
            }
            if (n) {
                const r = {}
                  , n = [];
                for (let e = 0; e < t.stops.length; e++) {
                    const i = t.stops[e]
                      , s = i[0].zoom;
                    void 0 === r[s] && (r[s] = {
                        zoom: s,
                        type: t.type,
                        property: t.property,
                        default: t.default,
                        stops: []
                    },
                    n.push(s)),
                    r[s].stops.push([i[0].value, i[1]]);
                }
                const i = [];
                for (const t of n)
                    i.push([r[t].zoom, Sn(r[t], e)]);
                const s = {
                    name: "linear"
                };
                return {
                    kind: "composite",
                    interpolationType: s,
                    interpolationFactor: Lr.interpolationFactor.bind(void 0, s),
                    zoomStops: i.map((t => t[0])),
                    evaluate: ({zoom: r}, n) => Bn({
                        stops: i,
                        base: t.base
                    }, e, r).evaluate(r, n)
                }
            }
            if (i) {
                const r = "exponential" === s ? {
                    name: "exponential",
                    base: void 0 !== t.base ? t.base : 1
                } : null;
                return {
                    kind: "camera",
                    interpolationType: r,
                    interpolationFactor: Lr.interpolationFactor.bind(void 0, r),
                    zoomStops: t.stops.map((t => t[0])),
                    evaluate: ({zoom: r}) => a(t, e, r, o, l)
                }
            }
            return {
                kind: "source",
                evaluate(r, n) {
                    const i = n && n.properties ? n.properties[t.property] : void 0;
                    return void 0 === i ? Mn(t.default, e.default) : a(t, e, i, o, l)
                }
            }
        }
        function Mn(t, e, r) {
            return void 0 !== t ? t : void 0 !== e ? e : void 0 !== r ? r : void 0
        }
        function In(t, e, r, n, i) {
            return Mn(typeof r === i ? n[r] : void 0, t.default, e.default)
        }
        function Tn(t, e, r) {
            if ("number" !== An(r))
                return Mn(t.default, e.default);
            const n = t.stops.length;
            if (1 === n)
                return t.stops[0][1];
            if (r <= t.stops[0][0])
                return t.stops[0][1];
            if (r >= t.stops[n - 1][0])
                return t.stops[n - 1][1];
            const i = fr(t.stops.map((t => t[0])), r);
            return t.stops[i][1]
        }
        function Bn(t, e, r) {
            const n = void 0 !== t.base ? t.base : 1;
            if ("number" !== An(r))
                return Mn(t.default, e.default);
            const i = t.stops.length;
            if (1 === i)
                return t.stops[0][1];
            if (r <= t.stops[0][0])
                return t.stops[0][1];
            if (r >= t.stops[i - 1][0])
                return t.stops[i - 1][1];
            const s = fr(t.stops.map((t => t[0])), r)
              , a = function(t, e, r, n) {
                const i = n - r
                  , s = t - r;
                return 0 === i ? 0 : 1 === e ? s / i : (Math.pow(e, s) - 1) / (Math.pow(e, i) - 1)
            }(r, n, t.stops[s][0], t.stops[s + 1][0])
              , o = t.stops[s][1]
              , l = t.stops[s + 1][1];
            let u = gr[e.type] || zn;
            if (t.colorSpace && "rgb" !== t.colorSpace) {
                const e = Dr[t.colorSpace];
                u = (t, r) => e.reverse(e.interpolate(e.forward(t), e.forward(r), a));
            }
            return "function" == typeof o.evaluate ? {
                evaluate(...t) {
                    const e = o.evaluate.apply(void 0, t)
                      , r = l.evaluate.apply(void 0, t);
                    if (void 0 !== e && void 0 !== r)
                        return u(e, r, a)
                }
            } : u(o, l, a)
        }
        function Cn(t, e, r) {
            return "color" === e.type ? r = me.parse(r) : "formatted" === e.type ? r = ve.fromString(r.toString()) : "resolvedImage" === e.type ? r = be.fromString(r.toString()) : An(r) === e.type || "enum" === e.type && e.values[r] || (r = void 0),
            Mn(r, t.default, e.default)
        }
        class Vn {
            constructor(t, e) {
                this.expression = t,
                this._warningHistory = {},
                this._evaluator = new Le,
                this._defaultValue = e ? function(t) {
                    return "color" === t.type && (kn(t.default) || Array.isArray(t.default)) ? new me(0,0,0,0) : "color" === t.type ? me.parse(t.default) || null : void 0 === t.default ? null : t.default
                }(e) : null,
                this._enumValues = e && "enum" === e.type ? e.values : null;
            }
            evaluateWithoutErrorHandling(t, e, r, n, i, s, a, o) {
                return this._evaluator.globals = t,
                this._evaluator.feature = e,
                this._evaluator.featureState = r,
                this._evaluator.canonical = n || null,
                this._evaluator.availableImages = i || null,
                this._evaluator.formattedSection = s,
                this._evaluator.featureTileCoord = a || null,
                this._evaluator.featureDistanceData = o || null,
                this.expression.evaluate(this._evaluator)
            }
            evaluate(t, e, r, n, i, s, a, o) {
                this._evaluator.globals = t,
                this._evaluator.feature = e || null,
                this._evaluator.featureState = r || null,
                this._evaluator.canonical = n || null,
                this._evaluator.availableImages = i || null,
                this._evaluator.formattedSection = s || null,
                this._evaluator.featureTileCoord = a || null,
                this._evaluator.featureDistanceData = o || null;
                try {
                    const t = this.expression.evaluate(this._evaluator);
                    if (null == t || "number" == typeof t && t != t)
                        return this._defaultValue;
                    if (this._enumValues && !(t in this._enumValues))
                        throw new Me(`Expected value to be one of ${Object.keys(this._enumValues).map((t => JSON.stringify(t))).join(", ")}, but found ${JSON.stringify(t)} instead.`);
                    return t
                } catch (t) {
                    return this._warningHistory[t.message] || (this._warningHistory[t.message] = !0,
                    "undefined" != typeof console && console.warn(t.message)),
                    this._defaultValue
                }
            }
        }
        function Pn(t) {
            return Array.isArray(t) && t.length > 0 && "string" == typeof t[0] && t[0]in gn
        }
        function Dn(t, e) {
            const r = new hr(gn,[],e ? function(t) {
                const e = {
                    color: ee,
                    string: Qt,
                    number: Wt,
                    enum: Qt,
                    boolean: te,
                    formatted: se,
                    resolvedImage: ae
                };
                return "array" === t.type ? oe(e[t.value] || ne, t.length) : e[t.type]
            }(e) : void 0)
              , n = r.parse(t, void 0, void 0, void 0, e && "string" === e.type ? {
                typeAnnotation: "coerce"
            } : void 0);
            return n ? xn(new Vn(n,e)) : vn(r.errors)
        }
        class En {
            constructor(t, e) {
                this.kind = t,
                this._styleExpression = e,
                this.isStateDependent = "constant" !== t && !ar(e.expression);
            }
            evaluateWithoutErrorHandling(t, e, r, n, i, s) {
                return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, s)
            }
            evaluate(t, e, r, n, i, s) {
                return this._styleExpression.evaluate(t, e, r, n, i, s)
            }
        }
        class Fn {
            constructor(t, e, r, n) {
                this.kind = t,
                this.zoomStops = r,
                this._styleExpression = e,
                this.isStateDependent = "camera" !== t && !ar(e.expression),
                this.interpolationType = n;
            }
            evaluateWithoutErrorHandling(t, e, r, n, i, s) {
                return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, s)
            }
            evaluate(t, e, r, n, i, s) {
                return this._styleExpression.evaluate(t, e, r, n, i, s)
            }
            interpolationFactor(t, e, r) {
                return this.interpolationType ? Lr.interpolationFactor(this.interpolationType, t, e, r) : 0
            }
        }
        function Ln(t, e) {
            if ("error" === (t = Dn(t, e)).result)
                return t;
            const r = t.value.expression
              , n = sr(r);
            if (!n && !bn(e))
                return vn([new Yt("","data expressions not supported")]);
            const i = or(r, ["zoom", "pitch", "distance-from-center"]);
            if (!i && !_n(e))
                return vn([new Yt("","zoom expressions not supported")]);
            const s = jn(r);
            return s || i ? s instanceof Yt ? vn([s]) : s instanceof Lr && !wn(e) ? vn([new Yt("",'"interpolate" expressions cannot be used with this property')]) : xn(s ? new Fn(n ? "camera" : "composite",t.value,s.labels,s instanceof Lr ? s.interpolation : void 0) : new En(n ? "constant" : "source",t.value)) : vn([new Yt("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')])
        }
        class Rn {
            constructor(t, e) {
                this._parameters = t,
                this._specification = e,
                Nt(this, Sn(this._parameters, this._specification));
            }
            static deserialize(t) {
                return new Rn(t._parameters,t._specification)
            }
            static serialize(t) {
                return {
                    _parameters: t._parameters,
                    _specification: t._specification
                }
            }
        }
        function jn(t) {
            let e = null;
            if (t instanceof Or)
                e = jn(t.result);
            else if (t instanceof jr) {
                for (const r of t.args)
                    if (e = jn(r),
                    e)
                        break
            } else
                (t instanceof yr || t instanceof Lr) && t.input instanceof je && "zoom" === t.input.name && (e = t);
            return e instanceof Yt || t.eachChild((t => {
                const r = jn(t);
                r instanceof Yt ? e = r : !e && r ? e = new Yt("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e && r && e !== r && (e = new Yt("",'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
            }
            )),
            e
        }
        class Un {
            constructor(t, e, r, n) {
                this.message = (t ? `${t}: ` : "") + r,
                n && (this.identifier = n),
                null != e && e.__line__ && (this.line = e.__line__);
            }
        }
        function On(t) {
            const e = t.key
              , r = t.value
              , n = t.valueSpec || {}
              , i = t.objectElementValidators || {}
              , s = t.style
              , a = t.styleSpec;
            let o = [];
            const l = An(r);
            if ("object" !== l)
                return [new Un(e,r,`object expected, ${l} found`)];
            for (const t in r) {
                const l = t.split(".")[0]
                  , u = n[l] || n["*"];
                let c;
                i[l] ? c = i[l] : n[l] ? c = bi : i["*"] ? c = i["*"] : n["*"] && (c = bi),
                c ? o = o.concat(c({
                    key: (e ? `${e}.` : e) + t,
                    value: r[t],
                    valueSpec: u,
                    style: s,
                    styleSpec: a,
                    object: r,
                    objectKey: t
                }, r)) : o.push(new Un(e,r[t],`unknown property "${t}"`));
            }
            for (const t in n)
                i[t] || n[t].required && void 0 === n[t].default && void 0 === r[t] && o.push(new Un(e,r,`missing required property "${t}"`));
            return o
        }
        function $n(t) {
            const e = t.value
              , r = t.valueSpec
              , n = t.style
              , i = t.styleSpec
              , s = t.key
              , a = t.arrayElementValidator || bi;
            if ("array" !== An(e))
                return [new Un(s,e,`array expected, ${An(e)} found`)];
            if (r.length && e.length !== r.length)
                return [new Un(s,e,`array length ${r.length} expected, length ${e.length} found`)];
            if (r["min-length"] && e.length < r["min-length"])
                return [new Un(s,e,`array length at least ${r["min-length"]} expected, length ${e.length} found`)];
            let o = {
                type: r.value,
                values: r.values,
                minimum: r.minimum,
                maximum: r.maximum,
                function: void 0
            };
            i.$version < 7 && (o.function = r.function),
            "object" === An(r.value) && (o = r.value);
            let l = [];
            for (let t = 0; t < e.length; t++)
                l = l.concat(a({
                    array: e,
                    arrayIndex: t,
                    value: e[t],
                    valueSpec: o,
                    style: n,
                    styleSpec: i,
                    key: `${s}[${t}]`
                }));
            return l
        }
        function qn(t) {
            const e = t.key
              , r = t.value
              , n = t.valueSpec;
            let i = An(r);
            if ("number" === i && r != r && (i = "NaN"),
            "number" !== i)
                return [new Un(e,r,`number expected, ${i} found`)];
            if ("minimum"in n) {
                let i = n.minimum;
                if ("array" === An(n.minimum) && (i = n.minimum[t.arrayIndex]),
                r < i)
                    return [new Un(e,r,`${r} is less than the minimum value ${i}`)]
            }
            if ("maximum"in n) {
                let i = n.maximum;
                if ("array" === An(n.maximum) && (i = n.maximum[t.arrayIndex]),
                r > i)
                    return [new Un(e,r,`${r} is greater than the maximum value ${i}`)]
            }
            return []
        }
        function Nn(t) {
            const e = t.valueSpec
              , r = Zt(t.value.type);
            let n, i, s, a = {};
            const o = "categorical" !== r && void 0 === t.value.property
              , l = !o
              , u = "array" === An(t.value.stops) && "array" === An(t.value.stops[0]) && "object" === An(t.value.stops[0][0])
              , c = On({
                key: t.key,
                value: t.value,
                valueSpec: t.styleSpec.function,
                style: t.style,
                styleSpec: t.styleSpec,
                objectElementValidators: {
                    stops: function(t) {
                        if ("identity" === r)
                            return [new Un(t.key,t.value,'identity function may not have a "stops" property')];
                        let e = [];
                        const n = t.value;
                        return e = e.concat($n({
                            key: t.key,
                            value: n,
                            valueSpec: t.valueSpec,
                            style: t.style,
                            styleSpec: t.styleSpec,
                            arrayElementValidator: h
                        })),
                        "array" === An(n) && 0 === n.length && e.push(new Un(t.key,n,"array must have at least one stop")),
                        e
                    },
                    default: function(t) {
                        return bi({
                            key: t.key,
                            value: t.value,
                            valueSpec: e,
                            style: t.style,
                            styleSpec: t.styleSpec
                        })
                    }
                }
            });
            return "identity" === r && o && c.push(new Un(t.key,t.value,'missing required property "property"')),
            "identity" === r || t.value.stops || c.push(new Un(t.key,t.value,'missing required property "stops"')),
            "exponential" === r && t.valueSpec.expression && !wn(t.valueSpec) && c.push(new Un(t.key,t.value,"exponential functions not supported")),
            t.styleSpec.$version >= 8 && (l && !bn(t.valueSpec) ? c.push(new Un(t.key,t.value,"property functions not supported")) : o && !_n(t.valueSpec) && c.push(new Un(t.key,t.value,"zoom functions not supported"))),
            "categorical" !== r && !u || void 0 !== t.value.property || c.push(new Un(t.key,t.value,'"property" property is required')),
            c;
            function h(t) {
                let r = [];
                const n = t.value
                  , o = t.key;
                if ("array" !== An(n))
                    return [new Un(o,n,`array expected, ${An(n)} found`)];
                if (2 !== n.length)
                    return [new Un(o,n,`array length 2 expected, length ${n.length} found`)];
                if (u) {
                    if ("object" !== An(n[0]))
                        return [new Un(o,n,`object expected, ${An(n[0])} found`)];
                    if (void 0 === n[0].zoom)
                        return [new Un(o,n,"object stop key must have zoom")];
                    if (void 0 === n[0].value)
                        return [new Un(o,n,"object stop key must have value")];
                    const e = Zt(n[0].zoom);
                    if ("number" != typeof e)
                        return [new Un(o,n[0].zoom,"stop zoom values must be numbers")];
                    if (s && s > e)
                        return [new Un(o,n[0].zoom,"stop zoom values must appear in ascending order")];
                    e !== s && (s = e,
                    i = void 0,
                    a = {}),
                    r = r.concat(On({
                        key: `${o}[0]`,
                        value: n[0],
                        valueSpec: {
                            zoom: {}
                        },
                        style: t.style,
                        styleSpec: t.styleSpec,
                        objectElementValidators: {
                            zoom: qn,
                            value: p
                        }
                    }));
                } else
                    r = r.concat(p({
                        key: `${o}[0]`,
                        value: n[0],
                        valueSpec: {},
                        style: t.style,
                        styleSpec: t.styleSpec
                    }, n));
                return Pn(Gt(n[1])) ? r.concat([new Un(`${o}[1]`,n[1],"expressions are not allowed in function stops.")]) : r.concat(bi({
                    key: `${o}[1]`,
                    value: n[1],
                    valueSpec: e,
                    style: t.style,
                    styleSpec: t.styleSpec
                }))
            }
            function p(t, s) {
                const o = An(t.value)
                  , l = Zt(t.value)
                  , u = null !== t.value ? t.value : s;
                if (n) {
                    if (o !== n)
                        return [new Un(t.key,u,`${o} stop domain type must match previous stop domain type ${n}`)]
                } else
                    n = o;
                if ("number" !== o && "string" !== o && "boolean" !== o && "number" != typeof l && "string" != typeof l && "boolean" != typeof l)
                    return [new Un(t.key,u,"stop domain value must be a number, string, or boolean")];
                if ("number" !== o && "categorical" !== r) {
                    let n = `number expected, ${o} found`;
                    return bn(e) && void 0 === r && (n += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'),
                    [new Un(t.key,u,n)]
                }
                return "categorical" !== r || "number" !== o || "number" == typeof l && isFinite(l) && Math.floor(l) === l ? "categorical" !== r && "number" === o && "number" == typeof l && "number" == typeof i && void 0 !== i && l < i ? [new Un(t.key,u,"stop domain values must appear in ascending order")] : (i = l,
                "categorical" === r && l in a ? [new Un(t.key,u,"stop domain values must be unique")] : (a[l] = !0,
                [])) : [new Un(t.key,u,`integer expected, found ${String(l)}`)]
            }
        }
        function Zn(t) {
            const e = ("property" === t.expressionContext ? Ln : Dn)(Gt(t.value), t.valueSpec);
            if ("error" === e.result)
                return e.value.map((e => new Un(`${t.key}${e.key}`,t.value,e.message)));
            const r = e.value.expression || e.value._styleExpression.expression;
            if ("property" === t.expressionContext && "text-font" === t.propertyKey && !r.outputDefined())
                return [new Un(t.key,t.value,`Invalid data expression for "${t.propertyKey}". Output values must be contained as literals within the expression.`)];
            if ("property" === t.expressionContext && "layout" === t.propertyType && !ar(r))
                return [new Un(t.key,t.value,'"feature-state" data expressions are not supported with layout properties.')];
            if ("filter" === t.expressionContext)
                return Gn(r, t);
            if (t.expressionContext && 0 === t.expressionContext.indexOf("cluster")) {
                if (!or(r, ["zoom", "feature-state"]))
                    return [new Un(t.key,t.value,'"zoom" and "feature-state" expressions are not supported with cluster properties.')];
                if ("cluster-initial" === t.expressionContext && !sr(r))
                    return [new Un(t.key,t.value,"Feature data expressions are not supported with initial expression part of cluster properties.")]
            }
            return []
        }
        function Gn(t, e) {
            const r = new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
            if (e.valueSpec && e.valueSpec.expression)
                for (const t of e.valueSpec.expression.parameters)
                    r.delete(t);
            if (0 === r.size)
                return [];
            const n = [];
            return t instanceof je && r.has(t.name) ? [new Un(e.key,e.value,`["${t.name}"] expression is not supported in a filter for a ${e.object.type} layer with id: ${e.object.id}`)] : (t.eachChild((t => {
                n.push(...Gn(t, e));
            }
            )),
            n)
        }
        function Xn(t) {
            const e = t.key
              , r = t.value
              , n = t.valueSpec
              , i = [];
            return Array.isArray(n.values) ? -1 === n.values.indexOf(Zt(r)) && i.push(new Un(e,r,`expected one of [${n.values.join(", ")}], ${JSON.stringify(r)} found`)) : -1 === Object.keys(n.values).indexOf(Zt(r)) && i.push(new Un(e,r,`expected one of [${Object.keys(n.values).join(", ")}], ${JSON.stringify(r)} found`)),
            i
        }
        function Yn(t) {
            if (!0 === t || !1 === t)
                return !0;
            if (!Array.isArray(t) || 0 === t.length)
                return !1;
            switch (t[0]) {
            case "has":
                return t.length >= 2 && "$id" !== t[1] && "$type" !== t[1];
            case "in":
                return t.length >= 3 && ("string" != typeof t[1] || Array.isArray(t[2]));
            case "!in":
            case "!has":
            case "none":
                return !1;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
                return 3 !== t.length || Array.isArray(t[1]) || Array.isArray(t[2]);
            case "any":
            case "all":
                for (const e of t.slice(1))
                    if (!Yn(e) && "boolean" != typeof e)
                        return !1;
                return !0;
            default:
                return !0
            }
        }
        function Hn(t, e="fill") {
            if (null == t)
                return {
                    filter: () => !0,
                    needGeometry: !1,
                    needFeature: !1
                };
            Yn(t) || (t = ri(t));
            const r = t;
            let n = !0;
            try {
                n = function(t) {
                    if (!Wn(t))
                        return t;
                    let e = Gt(t);
                    return Jn(e),
                    e = Kn(e),
                    e
                }(r);
            } catch (t) {
                console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\nThis is most likely a bug, please report this via https://github.com/sgmap/sgmap-js/issues/new?assignees=&labels=&template=Bug_report.md\nand paste the contents of this message in the report.\nThank you!\nFilter Expression:\n${JSON.stringify(r, null, 2)}\n        `);
            }
            const i = qt[`filter_${e}`]
              , s = Dn(n, i);
            let a = null;
            if ("error" === s.result)
                throw new Error(s.value.map((t => `${t.key}: ${t.message}`)).join(", "));
            a = (t, e, r) => s.value.evaluate(t, e, {}, r);
            let o = null
              , l = null;
            if (n !== r) {
                const t = Dn(r, i);
                if ("error" === t.result)
                    throw new Error(t.value.map((t => `${t.key}: ${t.message}`)).join(", "));
                o = (e, r, n, i, s) => t.value.evaluate(e, r, {}, n, void 0, void 0, i, s),
                l = !sr(t.value.expression);
            }
            return a = a,
            {
                filter: a,
                dynamicFilter: o || void 0,
                needGeometry: ei(n),
                needFeature: !!l
            }
        }
        function Kn(t) {
            if (!Array.isArray(t))
                return t;
            const e = function(t) {
                if (Qn.has(t[0]))
                    for (let e = 1; e < t.length; e++)
                        if (Wn(t[e]))
                            return !0;
                return t
            }(t);
            return !0 === e ? e : e.map((t => Kn(t)))
        }
        function Jn(t) {
            let e = !1;
            const r = [];
            if ("case" === t[0]) {
                for (let n = 1; n < t.length - 1; n += 2)
                    e = e || Wn(t[n]),
                    r.push(t[n + 1]);
                r.push(t[t.length - 1]);
            } else if ("match" === t[0]) {
                e = e || Wn(t[1]);
                for (let e = 2; e < t.length - 1; e += 2)
                    r.push(t[e + 1]);
                r.push(t[t.length - 1]);
            } else if ("step" === t[0]) {
                e = e || Wn(t[1]);
                for (let e = 1; e < t.length - 1; e += 2)
                    r.push(t[e + 1]);
            }
            e && (t.length = 0,
            t.push("any", ...r));
            for (let e = 1; e < t.length; e++)
                Jn(t[e]);
        }
        function Wn(t) {
            if (!Array.isArray(t))
                return !1;
            if ("pitch" === (e = t[0]) || "distance-from-center" === e)
                return !0;
            var e;
            for (let e = 1; e < t.length; e++)
                if (Wn(t[e]))
                    return !0;
            return !1
        }
        const Qn = new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
        function ti(t, e) {
            return t < e ? -1 : t > e ? 1 : 0
        }
        function ei(t) {
            if (!Array.isArray(t))
                return !1;
            if ("within" === t[0])
                return !0;
            for (let e = 1; e < t.length; e++)
                if (ei(t[e]))
                    return !0;
            return !1
        }
        function ri(t) {
            if (!t)
                return !0;
            const e = t[0];
            return t.length <= 1 ? "any" !== e : "==" === e ? ni(t[1], t[2], "==") : "!=" === e ? ai(ni(t[1], t[2], "==")) : "<" === e || ">" === e || "<=" === e || ">=" === e ? ni(t[1], t[2], e) : "any" === e ? (r = t.slice(1),
            ["any"].concat(r.map(ri))) : "all" === e ? ["all"].concat(t.slice(1).map(ri)) : "none" === e ? ["all"].concat(t.slice(1).map(ri).map(ai)) : "in" === e ? ii(t[1], t.slice(2)) : "!in" === e ? ai(ii(t[1], t.slice(2))) : "has" === e ? si(t[1]) : "!has" === e ? ai(si(t[1])) : "within" !== e || t;
            var r;
        }
        function ni(t, e, r) {
            switch (t) {
            case "$type":
                return [`filter-type-${r}`, e];
            case "$id":
                return [`filter-id-${r}`, e];
            default:
                return [`filter-${r}`, t, e]
            }
        }
        function ii(t, e) {
            if (0 === e.length)
                return !1;
            switch (t) {
            case "$type":
                return ["filter-type-in", ["literal", e]];
            case "$id":
                return ["filter-id-in", ["literal", e]];
            default:
                return e.length > 200 && !e.some((t => typeof t != typeof e[0])) ? ["filter-in-large", t, ["literal", e.sort(ti)]] : ["filter-in-small", t, ["literal", e]]
            }
        }
        function si(t) {
            switch (t) {
            case "$type":
                return !0;
            case "$id":
                return ["filter-has-id"];
            default:
                return ["filter-has", t]
            }
        }
        function ai(t) {
            return ["!", t]
        }
        function oi(t) {
            return Yn(Gt(t.value)) ? Zn(Nt({}, t, {
                expressionContext: "filter",
                valueSpec: t.styleSpec[`filter_${t.layerType || "fill"}`]
            })) : li(t)
        }
        function li(t) {
            const e = t.value
              , r = t.key;
            if ("array" !== An(e))
                return [new Un(r,e,`array expected, ${An(e)} found`)];
            const n = t.styleSpec;
            let i, s = [];
            if (e.length < 1)
                return [new Un(r,e,"filter array must have at least 1 element")];
            switch (s = s.concat(Xn({
                key: `${r}[0]`,
                value: e[0],
                valueSpec: n.filter_operator,
                style: t.style,
                styleSpec: t.styleSpec
            })),
            Zt(e[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
                e.length >= 2 && "$type" === Zt(e[1]) && s.push(new Un(r,e,`"$type" cannot be use with operator "${e[0]}"`));
            case "==":
            case "!=":
                3 !== e.length && s.push(new Un(r,e,`filter array for operator "${e[0]}" must have 3 elements`));
            case "in":
            case "!in":
                e.length >= 2 && (i = An(e[1]),
                "string" !== i && s.push(new Un(`${r}[1]`,e[1],`string expected, ${i} found`)));
                for (let a = 2; a < e.length; a++)
                    i = An(e[a]),
                    "$type" === Zt(e[1]) ? s = s.concat(Xn({
                        key: `${r}[${a}]`,
                        value: e[a],
                        valueSpec: n.geometry_type,
                        style: t.style,
                        styleSpec: t.styleSpec
                    })) : "string" !== i && "number" !== i && "boolean" !== i && s.push(new Un(`${r}[${a}]`,e[a],`string, number, or boolean expected, ${i} found`));
                break;
            case "any":
            case "all":
            case "none":
                for (let n = 1; n < e.length; n++)
                    s = s.concat(li({
                        key: `${r}[${n}]`,
                        value: e[n],
                        style: t.style,
                        styleSpec: t.styleSpec
                    }));
                break;
            case "has":
            case "!has":
                i = An(e[1]),
                2 !== e.length ? s.push(new Un(r,e,`filter array for "${e[0]}" operator must have 2 elements`)) : "string" !== i && s.push(new Un(`${r}[1]`,e[1],`string expected, ${i} found`));
                break;
            case "within":
                i = An(e[1]),
                2 !== e.length ? s.push(new Un(r,e,`filter array for "${e[0]}" operator must have 2 elements`)) : "object" !== i && s.push(new Un(`${r}[1]`,e[1],`object expected, ${i} found`));
            }
            return s
        }
        function ui(t, e) {
            const r = t.key
              , n = t.style
              , i = t.styleSpec
              , s = t.value
              , a = t.objectKey
              , o = i[`${e}_${t.layerType}`];
            if (!o)
                return [];
            const l = a.match(/^(.*)-transition$/);
            if ("paint" === e && l && o[l[1]] && o[l[1]].transition)
                return bi({
                    key: r,
                    value: s,
                    valueSpec: i.transition,
                    style: n,
                    styleSpec: i
                });
            const u = t.valueSpec || o[a];
            if (!u)
                return [new Un(r,s,`unknown property "${a}"`)];
            let c;
            if ("string" === An(s) && bn(u) && !u.tokens && (c = /^{([^}]+)}$/.exec(s)))
                return [new Un(r,s,`"${a}" does not support interpolation syntax\nUse an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(c[1])} }\`.`)];
            const h = [];
            return "symbol" === t.layerType && ("text-field" === a && n && !n.glyphs && h.push(new Un(r,s,'use of "text-field" requires a style "glyphs" property')),
            "text-font" === a && kn(Gt(s)) && "identity" === Zt(s.type) && h.push(new Un(r,s,'"text-font" does not support identity functions'))),
            h.concat(bi({
                key: t.key,
                value: s,
                valueSpec: u,
                style: n,
                styleSpec: i,
                expressionContext: "property",
                propertyType: e,
                propertyKey: a
            }))
        }
        function ci(t) {
            return ui(t, "paint")
        }
        function hi(t) {
            return ui(t, "layout")
        }
        function pi(t) {
            let e = [];
            const r = t.value
              , n = t.key
              , i = t.style
              , s = t.styleSpec;
            r.type || r.ref || e.push(new Un(n,r,'either "type" or "ref" is required'));
            let a = Zt(r.type);
            const o = Zt(r.ref);
            if (r.id) {
                const s = Zt(r.id);
                for (let a = 0; a < t.arrayIndex; a++) {
                    const t = i.layers[a];
                    Zt(t.id) === s && e.push(new Un(n,r.id,`duplicate layer id "${r.id}", previously used at line ${t.id.__line__}`));
                }
            }
            if ("ref"in r) {
                let t;
                ["type", "source", "source-layer", "filter", "layout"].forEach((t => {
                    t in r && e.push(new Un(n,r[t],`"${t}" is prohibited for ref layers`));
                }
                )),
                i.layers.forEach((e => {
                    Zt(e.id) === o && (t = e);
                }
                )),
                t ? t.ref ? e.push(new Un(n,r.ref,"ref cannot reference another ref layer")) : a = Zt(t.type) : "string" == typeof o && e.push(new Un(n,r.ref,`ref layer "${o}" not found`));
            } else if ("background" !== a && "sky" !== a)
                if (r.source) {
                    const t = i.sources && i.sources[r.source]
                      , s = t && Zt(t.type);
                    t ? "vector" === s && "raster" === a ? e.push(new Un(n,r.source,`layer "${r.id}" requires a raster source`)) : "raster" === s && "raster" !== a ? e.push(new Un(n,r.source,`layer "${r.id}" requires a vector source`)) : "vector" !== s || r["source-layer"] ? "raster-dem" === s && "hillshade" !== a ? e.push(new Un(n,r.source,"raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== a || !r.paint || !r.paint["line-gradient"] && !r.paint["line-trim-offset"] || "geojson" === s && t.lineMetrics || e.push(new Un(n,r,`layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e.push(new Un(n,r,`layer "${r.id}" must specify a "source-layer"`)) : e.push(new Un(n,r.source,`source "${r.source}" not found`));
                } else
                    e.push(new Un(n,r,'missing required property "source"'));
            return e = e.concat(On({
                key: n,
                value: r,
                valueSpec: s.layer,
                style: t.style,
                styleSpec: t.styleSpec,
                objectElementValidators: {
                    "*": () => [],
                    type: () => bi({
                        key: `${n}.type`,
                        value: r.type,
                        valueSpec: s.layer.type,
                        style: t.style,
                        styleSpec: t.styleSpec,
                        object: r,
                        objectKey: "type"
                    }),
                    filter: t => oi(Nt({
                        layerType: a
                    }, t)),
                    layout: t => On({
                        layer: r,
                        key: t.key,
                        value: t.value,
                        valueSpec: {},
                        style: t.style,
                        styleSpec: t.styleSpec,
                        objectElementValidators: {
                            "*": t => hi(Nt({
                                layerType: a
                            }, t))
                        }
                    }),
                    paint: t => On({
                        layer: r,
                        key: t.key,
                        value: t.value,
                        valueSpec: {},
                        style: t.style,
                        styleSpec: t.styleSpec,
                        objectElementValidators: {
                            "*": t => ci(Nt({
                                layerType: a
                            }, t))
                        }
                    })
                }
            })),
            e
        }
        function fi(t) {
            const e = t.value
              , r = t.key
              , n = An(e);
            return "string" !== n ? [new Un(r,e,`string expected, ${n} found`)] : []
        }
        const di = {
            promoteId: function({key: t, value: e}) {
                if ("string" === An(e))
                    return fi({
                        key: t,
                        value: e
                    });
                {
                    const r = [];
                    for (const n in e)
                        r.push(...fi({
                            key: `${t}.${n}`,
                            value: e[n]
                        }));
                    return r
                }
            }
        };
        function yi(t) {
            const e = t.value
              , r = t.key
              , n = t.styleSpec
              , i = t.style;
            if (!e.type)
                return [new Un(r,e,'"type" is required')];
            const s = Zt(e.type);
            let a;
            switch (s) {
            case "vector":
            case "raster":
            case "raster-dem":
                return a = On({
                    key: r,
                    value: e,
                    valueSpec: n[`source_${s.replace("-", "_")}`],
                    style: t.style,
                    styleSpec: n,
                    objectElementValidators: di
                }),
                a;
            case "geojson":
                if (a = On({
                    key: r,
                    value: e,
                    valueSpec: n.source_geojson,
                    style: i,
                    styleSpec: n,
                    objectElementValidators: di
                }),
                e.cluster)
                    for (const t in e.clusterProperties) {
                        const [n,i] = e.clusterProperties[t]
                          , s = "string" == typeof n ? [n, ["accumulated"], ["get", t]] : n;
                        a.push(...Zn({
                            key: `${r}.${t}.map`,
                            value: i,
                            expressionContext: "cluster-map"
                        })),
                        a.push(...Zn({
                            key: `${r}.${t}.reduce`,
                            value: s,
                            expressionContext: "cluster-reduce"
                        }));
                    }
                return a;
            case "video":
                return On({
                    key: r,
                    value: e,
                    valueSpec: n.source_video,
                    style: i,
                    styleSpec: n
                });
            case "image":
                return On({
                    key: r,
                    value: e,
                    valueSpec: n.source_image,
                    style: i,
                    styleSpec: n
                });
            case "canvas":
                return [new Un(r,null,"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.","source.canvas")];
            default:
                return Xn({
                    key: `${r}.type`,
                    value: e.type,
                    valueSpec: {
                        values: ["vector", "raster", "raster-dem", "geojson", "video", "image"]
                    },
                    style: i,
                    styleSpec: n
                })
            }
        }
        function mi(t) {
            const e = t.value
              , r = t.styleSpec
              , n = r.light
              , i = t.style;
            let s = [];
            const a = An(e);
            if (void 0 === e)
                return s;
            if ("object" !== a)
                return s = s.concat([new Un("light",e,`object expected, ${a} found`)]),
                s;
            for (const t in e) {
                const a = t.match(/^(.*)-transition$/);
                s = s.concat(a && n[a[1]] && n[a[1]].transition ? bi({
                    key: t,
                    value: e[t],
                    valueSpec: r.transition,
                    style: i,
                    styleSpec: r
                }) : n[t] ? bi({
                    key: t,
                    value: e[t],
                    valueSpec: n[t],
                    style: i,
                    styleSpec: r
                }) : [new Un(t,e[t],`unknown property "${t}"`)]);
            }
            return s
        }
        function gi(t) {
            const e = t.value
              , r = t.key
              , n = t.style
              , i = t.styleSpec
              , s = i.terrain;
            let a = [];
            const o = An(e);
            if (void 0 === e)
                return a;
            if ("object" !== o)
                return a = a.concat([new Un("terrain",e,`object expected, ${o} found`)]),
                a;
            for (const t in e) {
                const r = t.match(/^(.*)-transition$/);
                a = a.concat(r && s[r[1]] && s[r[1]].transition ? bi({
                    key: t,
                    value: e[t],
                    valueSpec: i.transition,
                    style: n,
                    styleSpec: i
                }) : s[t] ? bi({
                    key: t,
                    value: e[t],
                    valueSpec: s[t],
                    style: n,
                    styleSpec: i
                }) : [new Un(t,e[t],`unknown property "${t}"`)]);
            }
            if (e.source) {
                const t = n.sources && n.sources[e.source]
                  , i = t && Zt(t.type);
                t ? "raster-dem" !== i && a.push(new Un(r,e.source,`terrain cannot be used with a source of type ${String(i)}, it only be used with a "raster-dem" source type`)) : a.push(new Un(r,e.source,`source "${e.source}" not found`));
            } else
                a.push(new Un(r,e,'terrain is missing required property "source"'));
            return a
        }
        function xi(t) {
            const e = t.value
              , r = t.style
              , n = t.styleSpec
              , i = n.fog;
            let s = [];
            const a = An(e);
            if (void 0 === e)
                return s;
            if ("object" !== a)
                return s = s.concat([new Un("fog",e,`object expected, ${a} found`)]),
                s;
            for (const t in e) {
                const a = t.match(/^(.*)-transition$/);
                s = s.concat(a && i[a[1]] && i[a[1]].transition ? bi({
                    key: t,
                    value: e[t],
                    valueSpec: n.transition,
                    style: r,
                    styleSpec: n
                }) : i[t] ? bi({
                    key: t,
                    value: e[t],
                    valueSpec: i[t],
                    style: r,
                    styleSpec: n
                }) : [new Un(t,e[t],`unknown property "${t}"`)]);
            }
            return s
        }
        const vi = {
            "*": () => [],
            array: $n,
            boolean: function(t) {
                const e = t.value
                  , r = t.key
                  , n = An(e);
                return "boolean" !== n ? [new Un(r,e,`boolean expected, ${n} found`)] : []
            },
            number: qn,
            color: function(t) {
                const e = t.key
                  , r = t.value
                  , n = An(r);
                return "string" !== n ? [new Un(e,r,`color expected, ${n} found`)] : null === de.parseCSSColor(r) ? [new Un(e,r,`color expected, "${r}" found`)] : []
            },
            enum: Xn,
            filter: oi,
            function: Nn,
            layer: pi,
            object: On,
            source: yi,
            light: mi,
            terrain: gi,
            fog: xi,
            string: fi,
            formatted: function(t) {
                return 0 === fi(t).length ? [] : Zn(t)
            },
            resolvedImage: function(t) {
                return 0 === fi(t).length ? [] : Zn(t)
            },
            projection: function(t) {
                const e = t.value
                  , r = t.styleSpec
                  , n = r.projection
                  , i = t.style;
                let s = [];
                const a = An(e);
                if ("object" === a)
                    for (const t in e)
                        s = s.concat(bi({
                            key: t,
                            value: e[t],
                            valueSpec: n[t],
                            style: i,
                            styleSpec: r
                        }));
                else
                    "string" !== a && (s = s.concat([new Un("projection",e,`object or string expected, ${a} found`)]));
                return s
            }
        };
        function bi(t) {
            const e = t.value
              , r = t.valueSpec
              , n = t.styleSpec;
            return r.expression && kn(Zt(e)) ? Nn(t) : r.expression && Pn(Gt(e)) ? Zn(t) : r.type && vi[r.type] ? vi[r.type](t) : On(Nt({}, t, {
                valueSpec: r.type ? n[r.type] : r
            }))
        }
        function _i(t) {
            const e = t.value
              , r = t.key
              , n = fi(t);
            return n.length || (-1 === e.indexOf("{fontstack}") && n.push(new Un(r,e,'"glyphs" url must include a "{fontstack}" token')),
            -1 === e.indexOf("{range}") && n.push(new Un(r,e,'"glyphs" url must include a "{range}" token'))),
            n
        }
        function wi(t, e=qt) {
            return zi(bi({
                key: "",
                value: t,
                valueSpec: e.$root,
                styleSpec: e,
                style: t,
                objectElementValidators: {
                    glyphs: _i,
                    "*": () => []
                }
            }))
        }
        const Ai = t => zi(ci(t))
          , ki = t => zi(hi(t));
        function zi(t) {
            return t.slice().sort(( (t, e) => t.line && e.line ? t.line - e.line : 0))
        }
        function Si(t, e) {
            let r = !1;
            if (e && e.length)
                for (const n of e)
                    t.fire(new Ot(new Error(n.message))),
                    r = !0;
            return r
        }
        var Mi = Ii;
        function Ii(t, e, r) {
            var n = this.cells = [];
            if (t instanceof ArrayBuffer) {
                this.arrayBuffer = t;
                var i = new Int32Array(this.arrayBuffer);
                t = i[0],
                this.d = (e = i[1]) + 2 * (r = i[2]);
                for (var s = 0; s < this.d * this.d; s++) {
                    var a = i[3 + s]
                      , o = i[3 + s + 1];
                    n.push(a === o ? null : i.subarray(a, o));
                }
                var l = i[3 + n.length + 1];
                this.keys = i.subarray(i[3 + n.length], l),
                this.bboxes = i.subarray(l),
                this.insert = this._insertReadonly;
            } else {
                this.d = e + 2 * r;
                for (var u = 0; u < this.d * this.d; u++)
                    n.push([]);
                this.keys = [],
                this.bboxes = [];
            }
            this.n = e,
            this.extent = t,
            this.padding = r,
            this.scale = e / t,
            this.uid = 0;
            var c = r / e * t;
            this.min = -c,
            this.max = t + c;
        }
        Ii.prototype.insert = function(t, e, r, n, i) {
            this._forEachCell(e, r, n, i, this._insertCell, this.uid++),
            this.keys.push(t),
            this.bboxes.push(e),
            this.bboxes.push(r),
            this.bboxes.push(n),
            this.bboxes.push(i);
        }
        ,
        Ii.prototype._insertReadonly = function() {
            throw "Cannot insert into a GridIndex created from an ArrayBuffer."
        }
        ,
        Ii.prototype._insertCell = function(t, e, r, n, i, s) {
            this.cells[i].push(s);
        }
        ,
        Ii.prototype.query = function(t, e, r, n, i) {
            var s = this.min
              , a = this.max;
            if (t <= s && e <= s && a <= r && a <= n && !i)
                return Array.prototype.slice.call(this.keys);
            var o = [];
            return this._forEachCell(t, e, r, n, this._queryCell, o, {}, i),
            o
        }
        ,
        Ii.prototype._queryCell = function(t, e, r, n, i, s, a, o) {
            var l = this.cells[i];
            if (null !== l)
                for (var u = this.keys, c = this.bboxes, h = 0; h < l.length; h++) {
                    var p = l[h];
                    if (void 0 === a[p]) {
                        var f = 4 * p;
                        (o ? o(c[f + 0], c[f + 1], c[f + 2], c[f + 3]) : t <= c[f + 2] && e <= c[f + 3] && r >= c[f + 0] && n >= c[f + 1]) ? (a[p] = !0,
                        s.push(u[p])) : a[p] = !1;
                    }
                }
        }
        ,
        Ii.prototype._forEachCell = function(t, e, r, n, i, s, a, o) {
            for (var l = this._convertToCellCoord(t), u = this._convertToCellCoord(e), c = this._convertToCellCoord(r), h = this._convertToCellCoord(n), p = l; p <= c; p++)
                for (var f = u; f <= h; f++) {
                    var d = this.d * f + p;
                    if ((!o || o(this._convertFromCellCoord(p), this._convertFromCellCoord(f), this._convertFromCellCoord(p + 1), this._convertFromCellCoord(f + 1))) && i.call(this, t, e, r, n, d, s, a, o))
                        return
                }
        }
        ,
        Ii.prototype._convertFromCellCoord = function(t) {
            return (t - this.padding) / this.scale
        }
        ,
        Ii.prototype._convertToCellCoord = function(t) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding))
        }
        ,
        Ii.prototype.toArrayBuffer = function() {
            if (this.arrayBuffer)
                return this.arrayBuffer;
            for (var t = this.cells, e = 3 + this.cells.length + 1 + 1, r = 0, n = 0; n < this.cells.length; n++)
                r += this.cells[n].length;
            var i = new Int32Array(e + r + this.keys.length + this.bboxes.length);
            i[0] = this.extent,
            i[1] = this.n,
            i[2] = this.padding;
            for (var s = e, a = 0; a < t.length; a++) {
                var o = t[a];
                i[3 + a] = s,
                i.set(o, s),
                s += o.length;
            }
            return i[3 + t.length] = s,
            i.set(this.keys, s),
            i[3 + t.length + 1] = s += this.keys.length,
            i.set(this.bboxes, s),
            s += this.bboxes.length,
            i.buffer
        }
        ;
        const Ti = {};
        function Bi(t, e, r={}) {
            Object.defineProperty(t, "_classRegistryKey", {
                value: e,
                writeable: !1
            }),
            Ti[e] = {
                klass: t,
                omit: r.omit || []
            };
        }
        Bi(Object, "Object"),
        Mi.serialize = function(t, e) {
            const r = t.toArrayBuffer();
            return e && e.push(r),
            {
                buffer: r
            }
        }
        ,
        Mi.deserialize = function(t) {
            return new Mi(t.buffer)
        }
        ,
        Object.defineProperty(Mi, "name", {
            value: "Grid"
        }),
        Bi(Mi, "Grid"),
        Bi(me, "Color"),
        Bi(Error, "Error"),
        Bi(St, "AJAXError"),
        Bi(be, "ResolvedImage"),
        Bi(Rn, "StylePropertyFunction"),
        Bi(Vn, "StyleExpression", {
            omit: ["_evaluator"]
        }),
        Bi(Fn, "ZoomDependentExpression"),
        Bi(En, "ZoomConstantExpression"),
        Bi(je, "CompoundExpression", {
            omit: ["_evaluate"]
        });
        for (const t in gn)
            Ti[gn[t]._classRegistryKey] || Bi(gn[t], `Expression${t}`);
        function Ci(t) {
            return t && "undefined" != typeof ArrayBuffer && (t instanceof ArrayBuffer || t.constructor && "ArrayBuffer" === t.constructor.name)
        }
        function Vi(t) {
            return e.ImageBitmap && t instanceof e.ImageBitmap
        }
        function Pi(t, r) {
            if (null == t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp)
                return t;
            if (Ci(t) || Vi(t))
                return r && r.push(t),
                t;
            if (ArrayBuffer.isView(t)) {
                const e = t;
                return r && r.push(e.buffer),
                e
            }
            if (t instanceof e.ImageData)
                return r && r.push(t.data.buffer),
                t;
            if (Array.isArray(t)) {
                const e = [];
                for (const n of t)
                    e.push(Pi(n, r));
                return e
            }
            if ("object" == typeof t) {
                const e = t.constructor
                  , n = e._classRegistryKey;
                if (!n)
                    throw new Error(`can't serialize object of unregistered class ${n}`);
                const i = e.serialize ? e.serialize(t, r) : {};
                if (!e.serialize) {
                    for (const e in t)
                        t.hasOwnProperty(e) && (Ti[n].omit.indexOf(e) >= 0 || (i[e] = Pi(t[e], r)));
                    t instanceof Error && (i.message = t.message);
                }
                if (i.$name)
                    throw new Error("$name property is reserved for worker serialization logic.");
                return "Object" !== n && (i.$name = n),
                i
            }
            throw new Error("can't serialize object of type " + typeof t)
        }
        function Di(t) {
            if (null == t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp || Ci(t) || Vi(t) || ArrayBuffer.isView(t) || t instanceof e.ImageData)
                return t;
            if (Array.isArray(t))
                return t.map(Di);
            if ("object" == typeof t) {
                const e = t.$name || "Object"
                  , {klass: r} = Ti[e];
                if (!r)
                    throw new Error(`can't deserialize unregistered class ${e}`);
                if (r.deserialize)
                    return r.deserialize(t);
                const n = Object.create(r.prototype);
                for (const e of Object.keys(t))
                    "$name" !== e && (n[e] = Di(t[e]));
                return n
            }
            throw new Error("can't deserialize object of type " + typeof t)
        }
        class Ei {
            constructor() {
                this.first = !0;
            }
            update(t, e) {
                const r = Math.floor(t);
                return this.first ? (this.first = !1,
                this.lastIntegerZoom = r,
                this.lastIntegerZoomTime = 0,
                this.lastZoom = t,
                this.lastFloorZoom = r,
                !0) : (this.lastFloorZoom > r ? (this.lastIntegerZoom = r + 1,
                this.lastIntegerZoomTime = e) : this.lastFloorZoom < r && (this.lastIntegerZoom = r,
                this.lastIntegerZoomTime = e),
                t !== this.lastZoom && (this.lastZoom = t,
                this.lastFloorZoom = r,
                !0))
            }
        }
        const Fi = t => t >= 1536 && t <= 1791
          , Li = t => t >= 1872 && t <= 1919
          , Ri = t => t >= 2208 && t <= 2303
          , ji = t => t >= 11904 && t <= 12031
          , Ui = t => t >= 12032 && t <= 12255
          , Oi = t => t >= 12272 && t <= 12287
          , $i = t => t >= 12288 && t <= 12351
          , qi = t => t >= 12352 && t <= 12447
          , Ni = t => t >= 12448 && t <= 12543
          , Zi = t => t >= 12544 && t <= 12591
          , Gi = t => t >= 12704 && t <= 12735
          , Xi = t => t >= 12736 && t <= 12783
          , Yi = t => t >= 12784 && t <= 12799
          , Hi = t => t >= 12800 && t <= 13055
          , Ki = t => t >= 13056 && t <= 13311
          , Ji = t => t >= 13312 && t <= 19903
          , Wi = t => t >= 19968 && t <= 40959
          , Qi = t => t >= 40960 && t <= 42127
          , ts = t => t >= 42128 && t <= 42191
          , es = t => t >= 44032 && t <= 55215
          , rs = t => t >= 63744 && t <= 64255
          , ns = t => t >= 64336 && t <= 65023
          , is = t => t >= 65040 && t <= 65055
          , ss = t => t >= 65072 && t <= 65103
          , as = t => t >= 65104 && t <= 65135
          , os = t => t >= 65136 && t <= 65279
          , ls = t => t >= 65280 && t <= 65519;
        function us(t) {
            for (const e of t)
                if (ps(e.charCodeAt(0)))
                    return !0;
            return !1
        }
        function cs(t) {
            for (const e of t)
                if (!hs(e.charCodeAt(0)))
                    return !1;
            return !0
        }
        function hs(t) {
            return !(Fi(t) || Li(t) || Ri(t) || ns(t) || os(t))
        }
        function ps(t) {
            return !(746 !== t && 747 !== t && (t < 4352 || !(Gi(t) || Zi(t) || ss(t) && !(t >= 65097 && t <= 65103) || rs(t) || Ki(t) || ji(t) || Xi(t) || !(!$i(t) || t >= 12296 && t <= 12305 || t >= 12308 && t <= 12319 || 12336 === t) || Ji(t) || Wi(t) || Hi(t) || (t => t >= 12592 && t <= 12687)(t) || (t => t >= 43360 && t <= 43391)(t) || (t => t >= 55216 && t <= 55295)(t) || (t => t >= 4352 && t <= 4607)(t) || es(t) || qi(t) || Oi(t) || (t => t >= 12688 && t <= 12703)(t) || Ui(t) || Yi(t) || Ni(t) && 12540 !== t || !(!ls(t) || 65288 === t || 65289 === t || 65293 === t || t >= 65306 && t <= 65310 || 65339 === t || 65341 === t || 65343 === t || t >= 65371 && t <= 65503 || 65507 === t || t >= 65512 && t <= 65519) || !(!as(t) || t >= 65112 && t <= 65118 || t >= 65123 && t <= 65126) || (t => t >= 5120 && t <= 5759)(t) || (t => t >= 6320 && t <= 6399)(t) || is(t) || (t => t >= 19904 && t <= 19967)(t) || Qi(t) || ts(t))))
        }
        function fs(t) {
            return !(ps(t) || function(t) {
                return !!((t => t >= 128 && t <= 255)(t) && (167 === t || 169 === t || 174 === t || 177 === t || 188 === t || 189 === t || 190 === t || 215 === t || 247 === t) || (t => t >= 8192 && t <= 8303)(t) && (8214 === t || 8224 === t || 8225 === t || 8240 === t || 8241 === t || 8251 === t || 8252 === t || 8258 === t || 8263 === t || 8264 === t || 8265 === t || 8273 === t) || (t => t >= 8448 && t <= 8527)(t) || (t => t >= 8528 && t <= 8591)(t) || (t => t >= 8960 && t <= 9215)(t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || 9003 === t || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || 9167 === t || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || (t => t >= 9216 && t <= 9279)(t) && 9251 !== t || (t => t >= 9280 && t <= 9311)(t) || (t => t >= 9312 && t <= 9471)(t) || (t => t >= 9632 && t <= 9727)(t) || (t => t >= 9728 && t <= 9983)(t) && !(t >= 9754 && t <= 9759) || (t => t >= 11008 && t <= 11263)(t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || $i(t) || Ni(t) || (t => t >= 57344 && t <= 63743)(t) || ss(t) || as(t) || ls(t) || 8734 === t || 8756 === t || 8757 === t || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || 65532 === t || 65533 === t)
            }(t))
        }
        function ds(t) {
            return t >= 1424 && t <= 2303 || ns(t) || os(t)
        }
        function ys(t, e) {
            return !(!e && ds(t) || t >= 2304 && t <= 3583 || t >= 3840 && t <= 4255 || (t => t >= 6016 && t <= 6143)(t))
        }
        function ms(t) {
            for (const e of t)
                if (ds(e.charCodeAt(0)))
                    return !0;
            return !1
        }
        const gs = "deferred"
          , xs = "loading"
          , vs = "loaded";
        let bs = null
          , _s = "unavailable"
          , ws = null;
        const As = function(t) {
            t && "string" == typeof t && t.indexOf("NetworkError") > -1 && (_s = "error"),
            bs && bs(t);
        };
        function ks() {
            zs.fire(new Ut("pluginStateChange",{
                pluginStatus: _s,
                pluginURL: ws
            }));
        }
        const zs = new $t
          , Ss = function() {
            return _s
        }
          , Ms = function() {
            if (_s !== gs || !ws)
                throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
            _s = xs,
            ks(),
            ws && Vt({
                url: ws
            }, (t => {
                t ? As(t) : (_s = vs,
                ks());
            }
            ));
        }
          , Is = {
            applyArabicShaping: null,
            processBidirectionalText: null,
            processStyledBidirectionalText: null,
            isLoaded: () => _s === vs || null != Is.applyArabicShaping,
            isLoading: () => _s === xs,
            setState(t) {
                _s = t.pluginStatus,
                ws = t.pluginURL;
            },
            isParsed: () => null != Is.applyArabicShaping && null != Is.processBidirectionalText && null != Is.processStyledBidirectionalText,
            getPluginURL: () => ws
        };
        class Ts {
            constructor(t, e) {
                this.zoom = t,
                e ? (this.now = e.now,
                this.fadeDuration = e.fadeDuration,
                this.zoomHistory = e.zoomHistory,
                this.transition = e.transition,
                this.pitch = e.pitch) : (this.now = 0,
                this.fadeDuration = 0,
                this.zoomHistory = new Ei,
                this.transition = {},
                this.pitch = 0);
            }
            isSupportedScript(t) {
                return function(t, e) {
                    for (const r of t)
                        if (!ys(r.charCodeAt(0), e))
                            return !1;
                    return !0
                }(t, Is.isLoaded())
            }
            crossFadingFactor() {
                return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1)
            }
            getCrossfadeParameters() {
                const t = this.zoom
                  , e = t - Math.floor(t)
                  , r = this.crossFadingFactor();
                return t > this.zoomHistory.lastIntegerZoom ? {
                    fromScale: 2,
                    toScale: 1,
                    t: e + (1 - e) * r
                } : {
                    fromScale: .5,
                    toScale: 1,
                    t: 1 - (1 - r) * e
                }
            }
        }
        class Bs {
            constructor(t, e) {
                this.property = t,
                this.value = e,
                this.expression = function(t, e) {
                    if (kn(t))
                        return new Rn(t,e);
                    if (Pn(t)) {
                        const r = Ln(t, e);
                        if ("error" === r.result)
                            throw new Error(r.value.map((t => `${t.key}: ${t.message}`)).join(", "));
                        return r.value
                    }
                    {
                        let r = t;
                        return "string" == typeof t && "color" === e.type && (r = me.parse(t)),
                        {
                            kind: "constant",
                            evaluate: () => r
                        }
                    }
                }(void 0 === e ? t.specification.default : e, t.specification);
            }
            isDataDriven() {
                return "source" === this.expression.kind || "composite" === this.expression.kind
            }
            possiblyEvaluate(t, e, r) {
                return this.property.possiblyEvaluate(this, t, e, r)
            }
        }
        class Cs {
            constructor(t) {
                this.property = t,
                this.value = new Bs(t,void 0);
            }
            transitioned(t, e) {
                return new Ps(this.property,this.value,e,v({}, t.transition, this.transition),t.now)
            }
            untransitioned() {
                return new Ps(this.property,this.value,null,{},0)
            }
        }
        class Vs {
            constructor(t) {
                this._properties = t,
                this._values = Object.create(t.defaultTransitionablePropertyValues);
            }
            getValue(t) {
                return I(this._values[t].value.value)
            }
            setValue(t, e) {
                this._values.hasOwnProperty(t) || (this._values[t] = new Cs(this._values[t].property)),
                this._values[t].value = new Bs(this._values[t].property,null === e ? void 0 : I(e));
            }
            getTransition(t) {
                return I(this._values[t].transition)
            }
            setTransition(t, e) {
                this._values.hasOwnProperty(t) || (this._values[t] = new Cs(this._values[t].property)),
                this._values[t].transition = I(e) || void 0;
            }
            serialize() {
                const t = {};
                for (const e of Object.keys(this._values)) {
                    const r = this.getValue(e);
                    void 0 !== r && (t[e] = r);
                    const n = this.getTransition(e);
                    void 0 !== n && (t[`${e}-transition`] = n);
                }
                return t
            }
            transitioned(t, e) {
                const r = new Ds(this._properties);
                for (const n of Object.keys(this._values))
                    r._values[n] = this._values[n].transitioned(t, e._values[n]);
                return r
            }
            untransitioned() {
                const t = new Ds(this._properties);
                for (const e of Object.keys(this._values))
                    t._values[e] = this._values[e].untransitioned();
                return t
            }
        }
        class Ps {
            constructor(t, e, r, n, i) {
                const s = n.delay || 0
                  , a = n.duration || 0;
                i = i || 0,
                this.property = t,
                this.value = e,
                this.begin = i + s,
                this.end = this.begin + a,
                t.specification.transition && (n.delay || n.duration) && (this.prior = r);
            }
            possiblyEvaluate(t, e, r) {
                const n = t.now || 0
                  , i = this.value.possiblyEvaluate(t, e, r)
                  , s = this.prior;
                if (s) {
                    if (n > this.end)
                        return this.prior = null,
                        i;
                    if (this.value.isDataDriven())
                        return this.prior = null,
                        i;
                    if (n < this.begin)
                        return s.possiblyEvaluate(t, e, r);
                    {
                        const a = (n - this.begin) / (this.end - this.begin);
                        return this.property.interpolate(s.possiblyEvaluate(t, e, r), i, h(a))
                    }
                }
                return i
            }
        }
        class Ds {
            constructor(t) {
                this._properties = t,
                this._values = Object.create(t.defaultTransitioningPropertyValues);
            }
            possiblyEvaluate(t, e, r) {
                const n = new Ls(this._properties);
                for (const i of Object.keys(this._values))
                    n._values[i] = this._values[i].possiblyEvaluate(t, e, r);
                return n
            }
            hasTransition() {
                for (const t of Object.keys(this._values))
                    if (this._values[t].prior)
                        return !0;
                return !1
            }
        }
        class Es {
            constructor(t) {
                this._properties = t,
                this._values = Object.create(t.defaultPropertyValues);
            }
            getValue(t) {
                return I(this._values[t].value)
            }
            setValue(t, e) {
                this._values[t] = new Bs(this._values[t].property,null === e ? void 0 : I(e));
            }
            serialize() {
                const t = {};
                for (const e of Object.keys(this._values)) {
                    const r = this.getValue(e);
                    void 0 !== r && (t[e] = r);
                }
                return t
            }
            possiblyEvaluate(t, e, r) {
                const n = new Ls(this._properties);
                for (const i of Object.keys(this._values))
                    n._values[i] = this._values[i].possiblyEvaluate(t, e, r);
                return n
            }
        }
        class Fs {
            constructor(t, e, r) {
                this.property = t,
                this.value = e,
                this.parameters = r;
            }
            isConstant() {
                return "constant" === this.value.kind
            }
            constantOr(t) {
                return "constant" === this.value.kind ? this.value.value : t
            }
            evaluate(t, e, r, n) {
                return this.property.evaluate(this.value, this.parameters, t, e, r, n)
            }
        }
        class Ls {
            constructor(t) {
                this._properties = t,
                this._values = Object.create(t.defaultPossiblyEvaluatedValues);
            }
            get(t) {
                return this._values[t]
            }
        }
        class Rs {
            constructor(t) {
                this.specification = t;
            }
            possiblyEvaluate(t, e) {
                return t.expression.evaluate(e)
            }
            interpolate(t, e, r) {
                const n = gr[this.specification.type];
                return n ? n(t, e, r) : t
            }
        }
        class js {
            constructor(t, e) {
                this.specification = t,
                this.overrides = e;
            }
            possiblyEvaluate(t, e, r, n) {
                return new Fs(this,"constant" === t.expression.kind || "camera" === t.expression.kind ? {
                    kind: "constant",
                    value: t.expression.evaluate(e, null, {}, r, n)
                } : t.expression,e)
            }
            interpolate(t, e, r) {
                if ("constant" !== t.value.kind || "constant" !== e.value.kind)
                    return t;
                if (void 0 === t.value.value || void 0 === e.value.value)
                    return new Fs(this,{
                        kind: "constant",
                        value: void 0
                    },t.parameters);
                const n = gr[this.specification.type];
                return n ? new Fs(this,{
                    kind: "constant",
                    value: n(t.value.value, e.value.value, r)
                },t.parameters) : t
            }
            evaluate(t, e, r, n, i, s) {
                return "constant" === t.kind ? t.value : t.evaluate(e, r, n, i, s)
            }
        }
        class Us extends js {
            possiblyEvaluate(t, e, r, n) {
                if (void 0 === t.value)
                    return new Fs(this,{
                        kind: "constant",
                        value: void 0
                    },e);
                if ("constant" === t.expression.kind) {
                    const i = t.expression.evaluate(e, null, {}, r, n)
                      , s = "resolvedImage" === t.property.specification.type && "string" != typeof i ? i.name : i
                      , a = this._calculate(s, s, s, e);
                    return new Fs(this,{
                        kind: "constant",
                        value: a
                    },e)
                }
                if ("camera" === t.expression.kind) {
                    const r = this._calculate(t.expression.evaluate({
                        zoom: e.zoom - 1
                    }), t.expression.evaluate({
                        zoom: e.zoom
                    }), t.expression.evaluate({
                        zoom: e.zoom + 1
                    }), e);
                    return new Fs(this,{
                        kind: "constant",
                        value: r
                    },e)
                }
                return new Fs(this,t.expression,e)
            }
            evaluate(t, e, r, n, i, s) {
                if ("source" === t.kind) {
                    const a = t.evaluate(e, r, n, i, s);
                    return this._calculate(a, a, a, e)
                }
                return "composite" === t.kind ? this._calculate(t.evaluate({
                    zoom: Math.floor(e.zoom) - 1
                }, r, n), t.evaluate({
                    zoom: Math.floor(e.zoom)
                }, r, n), t.evaluate({
                    zoom: Math.floor(e.zoom) + 1
                }, r, n), e) : t.value
            }
            _calculate(t, e, r, n) {
                return n.zoom > n.zoomHistory.lastIntegerZoom ? {
                    from: t,
                    to: e,
                    other: r
                } : {
                    from: r,
                    to: e,
                    other: t
                }
            }
            interpolate(t) {
                return t
            }
        }
        class Os {
            constructor(t) {
                this.specification = t;
            }
            possiblyEvaluate(t, e, r, n) {
                if (void 0 !== t.value) {
                    if ("constant" === t.expression.kind) {
                        const i = t.expression.evaluate(e, null, {}, r, n);
                        return this._calculate(i, i, i, e)
                    }
                    return this._calculate(t.expression.evaluate(new Ts(Math.floor(e.zoom - 1),e)), t.expression.evaluate(new Ts(Math.floor(e.zoom),e)), t.expression.evaluate(new Ts(Math.floor(e.zoom + 1),e)), e)
                }
            }
            _calculate(t, e, r, n) {
                return n.zoom > n.zoomHistory.lastIntegerZoom ? {
                    from: t,
                    to: e
                } : {
                    from: r,
                    to: e
                }
            }
            interpolate(t) {
                return t
            }
        }
        class $s {
            constructor(t) {
                this.specification = t;
            }
            possiblyEvaluate(t, e, r, n) {
                return !!t.expression.evaluate(e, null, {}, r, n)
            }
            interpolate() {
                return !1
            }
        }
        class qs {
            constructor(t) {
                this.properties = t,
                this.defaultPropertyValues = {},
                this.defaultTransitionablePropertyValues = {},
                this.defaultTransitioningPropertyValues = {},
                this.defaultPossiblyEvaluatedValues = {},
                this.overridableProperties = [];
                const e = new Ts(0,{});
                for (const r in t) {
                    const n = t[r];
                    n.specification.overridable && this.overridableProperties.push(r);
                    const i = this.defaultPropertyValues[r] = new Bs(n,void 0)
                      , s = this.defaultTransitionablePropertyValues[r] = new Cs(n);
                    this.defaultTransitioningPropertyValues[r] = s.untransitioned(),
                    this.defaultPossiblyEvaluatedValues[r] = i.possiblyEvaluate(e);
                }
            }
        }
        function Ns(t, e) {
            return 256 * (t = d(Math.floor(t), 0, 255)) + d(Math.floor(e), 0, 255)
        }
        Bi(js, "DataDrivenProperty"),
        Bi(Rs, "DataConstantProperty"),
        Bi(Us, "CrossFadedDataDrivenProperty"),
        Bi(Os, "CrossFadedProperty"),
        Bi($s, "ColorRampProperty");
        const Zs = {
            Int8: Int8Array,
            Uint8: Uint8Array,
            Int16: Int16Array,
            Uint16: Uint16Array,
            Int32: Int32Array,
            Uint32: Uint32Array,
            Float32: Float32Array
        };
        class Gs {
            constructor(t, e) {
                this._structArray = t,
                this._pos1 = e * this.size,
                this._pos2 = this._pos1 / 2,
                this._pos4 = this._pos1 / 4,
                this._pos8 = this._pos1 / 8;
            }
        }
        class Xs {
            constructor() {
                this.isTransferred = !1,
                this.capacity = -1,
                this.resize(0);
            }
            static serialize(t, e) {
                return t._trim(),
                e && (t.isTransferred = !0,
                e.push(t.arrayBuffer)),
                {
                    length: t.length,
                    arrayBuffer: t.arrayBuffer
                }
            }
            static deserialize(t) {
                const e = Object.create(this.prototype);
                return e.arrayBuffer = t.arrayBuffer,
                e.length = t.length,
                e.capacity = t.arrayBuffer.byteLength / e.bytesPerElement,
                e._refreshViews(),
                e
            }
            _trim() {
                this.length !== this.capacity && (this.capacity = this.length,
                this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement),
                this._refreshViews());
            }
            clear() {
                this.length = 0;
            }
            resize(t) {
                this.reserve(t),
                this.length = t;
            }
            reserve(t) {
                if (t > this.capacity) {
                    this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128),
                    this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                    const e = this.uint8;
                    this._refreshViews(),
                    e && this.uint8.set(e);
                }
            }
            _refreshViews() {
                throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")
            }
            destroy() {
                this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null,
                this.arrayBuffer = null;
            }
        }
        function Ys(t, e=1) {
            let r = 0
              , n = 0;
            return {
                members: t.map((t => {
                    const i = Zs[t.type].BYTES_PER_ELEMENT
                      , s = r = Hs(r, Math.max(e, i))
                      , a = t.components || 1;
                    return n = Math.max(n, i),
                    r += i * a,
                    {
                        name: t.name,
                        type: t.type,
                        components: a,
                        offset: s
                    }
                }
                )),
                size: Hs(r, Math.max(n, e)),
                alignment: e
            }
        }
        function Hs(t, e) {
            return Math.ceil(t / e) * e
        }
        class Ks extends Xs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t, e) {
                const r = this.length;
                return this.resize(r + 1),
                this.emplace(r, t, e)
            }
            emplace(t, e, r) {
                const n = 2 * t;
                return this.int16[n + 0] = e,
                this.int16[n + 1] = r,
                t
            }
        }
        Ks.prototype.bytesPerElement = 4,
        Bi(Ks, "StructArrayLayout2i4");
        class Js extends Xs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r) {
                const n = this.length;
                return this.resize(n + 1),
                this.emplace(n, t, e, r)
            }
            emplace(t, e, r, n) {
                const i = 3 * t;
                return this.int16[i + 0] = e,
                this.int16[i + 1] = r,
                this.int16[i + 2] = n,
                t
            }
        }
        Js.prototype.bytesPerElement = 6,
        Bi(Js, "StructArrayLayout3i6");
        class Ws extends Xs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n) {
                const i = this.length;
                return this.resize(i + 1),
                this.emplace(i, t, e, r, n)
            }
            emplace(t, e, r, n, i) {
                const s = 4 * t;
                return this.int16[s + 0] = e,
                this.int16[s + 1] = r,
                this.int16[s + 2] = n,
                this.int16[s + 3] = i,
                t
            }
        }
        Ws.prototype.bytesPerElement = 8,
        Bi(Ws, "StructArrayLayout4i8");
        class Qs extends Xs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.int16 = new Int16Array(this.arrayBuffer),
                this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n, i, s, a) {
                const o = this.length;
                return this.resize(o + 1),
                this.emplace(o, t, e, r, n, i, s, a)
            }
            emplace(t, e, r, n, i, s, a, o) {
                const l = 6 * t
                  , u = 12 * t
                  , c = 3 * t;
                return this.int16[l + 0] = e,
                this.int16[l + 1] = r,
                this.uint8[u + 4] = n,
                this.uint8[u + 5] = i,
                this.uint8[u + 6] = s,
                this.uint8[u + 7] = a,
                this.float32[c + 2] = o,
                t
            }
        }
        Qs.prototype.bytesPerElement = 12,
        Bi(Qs, "StructArrayLayout2i4ub1f12");
        class ta extends Xs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n) {
                const i = this.length;
                return this.resize(i + 1),
                this.emplace(i, t, e, r, n)
            }
            emplace(t, e, r, n, i) {
                const s = 4 * t;
                return this.float32[s + 0] = e,
                this.float32[s + 1] = r,
                this.float32[s + 2] = n,
                this.float32[s + 3] = i,
                t
            }
        }
        ta.prototype.bytesPerElement = 16,
        Bi(ta, "StructArrayLayout4f16");
        class ea extends Xs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n, i, s, a, o, l, u) {
                const c = this.length;
                return this.resize(c + 1),
                this.emplace(c, t, e, r, n, i, s, a, o, l, u)
            }
            emplace(t, e, r, n, i, s, a, o, l, u, c) {
                const h = 10 * t;
                return this.uint16[h + 0] = e,
                this.uint16[h + 1] = r,
                this.uint16[h + 2] = n,
                this.uint16[h + 3] = i,
                this.uint16[h + 4] = s,
                this.uint16[h + 5] = a,
                this.uint16[h + 6] = o,
                this.uint16[h + 7] = l,
                this.uint16[h + 8] = u,
                this.uint16[h + 9] = c,
                t
            }
        }
        ea.prototype.bytesPerElement = 20,
        Bi(ea, "StructArrayLayout10ui20");
        class ra extends Xs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n, i, s, a, o) {
                const l = this.length;
                return this.resize(l + 1),
                this.emplace(l, t, e, r, n, i, s, a, o)
            }
            emplace(t, e, r, n, i, s, a, o, l) {
                const u = 8 * t;
                return this.uint16[u + 0] = e,
                this.uint16[u + 1] = r,
                this.uint16[u + 2] = n,
                this.uint16[u + 3] = i,
                this.uint16[u + 4] = s,
                this.uint16[u + 5] = a,
                this.uint16[u + 6] = o,
                this.uint16[u + 7] = l,
                t
            }
        }
        ra.prototype.bytesPerElement = 16,
        Bi(ra, "StructArrayLayout8ui16");
        class na extends Xs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n, i, s) {
                const a = this.length;
                return this.resize(a + 1),
                this.emplace(a, t, e, r, n, i, s)
            }
            emplace(t, e, r, n, i, s, a) {
                const o = 6 * t;
                return this.int16[o + 0] = e,
                this.int16[o + 1] = r,
                this.int16[o + 2] = n,
                this.int16[o + 3] = i,
                this.int16[o + 4] = s,
                this.int16[o + 5] = a,
                t
            }
        }
        na.prototype.bytesPerElement = 12,
        Bi(na, "StructArrayLayout6i12");
        class ia extends Xs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.int16 = new Int16Array(this.arrayBuffer),
                this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h) {
                const p = this.length;
                return this.resize(p + 1),
                this.emplace(p, t, e, r, n, i, s, a, o, l, u, c, h)
            }
            emplace(t, e, r, n, i, s, a, o, l, u, c, h, p) {
                const f = 12 * t;
                return this.int16[f + 0] = e,
                this.int16[f + 1] = r,
                this.int16[f + 2] = n,
                this.int16[f + 3] = i,
                this.uint16[f + 4] = s,
                this.uint16[f + 5] = a,
                this.uint16[f + 6] = o,
                this.uint16[f + 7] = l,
                this.int16[f + 8] = u,
                this.int16[f + 9] = c,
                this.int16[f + 10] = h,
                this.int16[f + 11] = p,
                t
            }
        }
        ia.prototype.bytesPerElement = 24,
        Bi(ia, "StructArrayLayout4i4ui4i24");
        class sa extends Xs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.int16 = new Int16Array(this.arrayBuffer),
                this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n, i, s) {
                const a = this.length;
                return this.resize(a + 1),
                this.emplace(a, t, e, r, n, i, s)
            }
            emplace(t, e, r, n, i, s, a) {
                const o = 10 * t
                  , l = 5 * t;
                return this.int16[o + 0] = e,
                this.int16[o + 1] = r,
                this.int16[o + 2] = n,
                this.float32[l + 2] = i,
                this.float32[l + 3] = s,
                this.float32[l + 4] = a,
                t
            }
        }
        sa.prototype.bytesPerElement = 20,
        Bi(sa, "StructArrayLayout3i3f20");
        class aa extends Xs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t) {
                const e = this.length;
                return this.resize(e + 1),
                this.emplace(e, t)
            }
            emplace(t, e) {
                return this.uint32[1 * t + 0] = e,
                t
            }
        }
        aa.prototype.bytesPerElement = 4,
        Bi(aa, "StructArrayLayout1ul4");
        class oa extends Xs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.int16 = new Int16Array(this.arrayBuffer),
                this.float32 = new Float32Array(this.arrayBuffer),
                this.uint32 = new Uint32Array(this.arrayBuffer),
                this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p) {
                const f = this.length;
                return this.resize(f + 1),
                this.emplace(f, t, e, r, n, i, s, a, o, l, u, c, h, p)
            }
            emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, f) {
                const d = 20 * t
                  , y = 10 * t;
                return this.int16[d + 0] = e,
                this.int16[d + 1] = r,
                this.int16[d + 2] = n,
                this.int16[d + 3] = i,
                this.int16[d + 4] = s,
                this.float32[y + 3] = a,
                this.float32[y + 4] = o,
                this.float32[y + 5] = l,
                this.float32[y + 6] = u,
                this.int16[d + 14] = c,
                this.uint32[y + 8] = h,
                this.uint16[d + 18] = p,
                this.uint16[d + 19] = f,
                t
            }
        }
        oa.prototype.bytesPerElement = 40,
        Bi(oa, "StructArrayLayout5i4f1i1ul2ui40");
        class la extends Xs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n, i, s, a) {
                const o = this.length;
                return this.resize(o + 1),
                this.emplace(o, t, e, r, n, i, s, a)
            }
            emplace(t, e, r, n, i, s, a, o) {
                const l = 8 * t;
                return this.int16[l + 0] = e,
                this.int16[l + 1] = r,
                this.int16[l + 2] = n,
                this.int16[l + 4] = i,
                this.int16[l + 5] = s,
                this.int16[l + 6] = a,
                this.int16[l + 7] = o,
                t
            }
        }
        la.prototype.bytesPerElement = 16,
        Bi(la, "StructArrayLayout3i2i2i16");
        class ua extends Xs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.float32 = new Float32Array(this.arrayBuffer),
                this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n, i) {
                const s = this.length;
                return this.resize(s + 1),
                this.emplace(s, t, e, r, n, i)
            }
            emplace(t, e, r, n, i, s) {
                const a = 4 * t
                  , o = 8 * t;
                return this.float32[a + 0] = e,
                this.float32[a + 1] = r,
                this.float32[a + 2] = n,
                this.int16[o + 6] = i,
                this.int16[o + 7] = s,
                t
            }
        }
        ua.prototype.bytesPerElement = 16,
        Bi(ua, "StructArrayLayout2f1f2i16");
        class ca extends Xs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n) {
                const i = this.length;
                return this.resize(i + 1),
                this.emplace(i, t, e, r, n)
            }
            emplace(t, e, r, n, i) {
                const s = 12 * t
                  , a = 3 * t;
                return this.uint8[s + 0] = e,
                this.uint8[s + 1] = r,
                this.float32[a + 1] = n,
                this.float32[a + 2] = i,
                t
            }
        }
        ca.prototype.bytesPerElement = 12,
        Bi(ca, "StructArrayLayout2ub2f12");
        class ha extends Xs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r) {
                const n = this.length;
                return this.resize(n + 1),
                this.emplace(n, t, e, r)
            }
            emplace(t, e, r, n) {
                const i = 3 * t;
                return this.float32[i + 0] = e,
                this.float32[i + 1] = r,
                this.float32[i + 2] = n,
                t
            }
        }
        ha.prototype.bytesPerElement = 12,
        Bi(ha, "StructArrayLayout3f12");
        class pa extends Xs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r) {
                const n = this.length;
                return this.resize(n + 1),
                this.emplace(n, t, e, r)
            }
            emplace(t, e, r, n) {
                const i = 3 * t;
                return this.uint16[i + 0] = e,
                this.uint16[i + 1] = r,
                this.uint16[i + 2] = n,
                t
            }
        }
        pa.prototype.bytesPerElement = 6,
        Bi(pa, "StructArrayLayout3ui6");
        class fa extends Xs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.int16 = new Int16Array(this.arrayBuffer),
                this.float32 = new Float32Array(this.arrayBuffer),
                this.uint16 = new Uint16Array(this.arrayBuffer),
                this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b) {
                const _ = this.length;
                return this.resize(_ + 1),
                this.emplace(_, t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b)
            }
            emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, _) {
                const w = 30 * t
                  , A = 15 * t
                  , k = 60 * t;
                return this.int16[w + 0] = e,
                this.int16[w + 1] = r,
                this.int16[w + 2] = n,
                this.float32[A + 2] = i,
                this.float32[A + 3] = s,
                this.uint16[w + 8] = a,
                this.uint16[w + 9] = o,
                this.uint32[A + 5] = l,
                this.uint32[A + 6] = u,
                this.uint32[A + 7] = c,
                this.uint16[w + 16] = h,
                this.uint16[w + 17] = p,
                this.uint16[w + 18] = f,
                this.float32[A + 10] = d,
                this.float32[A + 11] = y,
                this.uint8[k + 48] = m,
                this.uint8[k + 49] = g,
                this.uint8[k + 50] = x,
                this.uint32[A + 13] = v,
                this.int16[w + 28] = b,
                this.uint8[k + 58] = _,
                t
            }
        }
        fa.prototype.bytesPerElement = 60,
        Bi(fa, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
        class da extends Xs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.int16 = new Int16Array(this.arrayBuffer),
                this.float32 = new Float32Array(this.arrayBuffer),
                this.uint16 = new Uint16Array(this.arrayBuffer),
                this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, _, w, A, k, z, S, M, I, T) {
                const B = this.length;
                return this.resize(B + 1),
                this.emplace(B, t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, _, w, A, k, z, S, M, I, T)
            }
            emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, _, w, A, k, z, S, M, I, T, B) {
                const C = 38 * t
                  , V = 19 * t;
                return this.int16[C + 0] = e,
                this.int16[C + 1] = r,
                this.int16[C + 2] = n,
                this.float32[V + 2] = i,
                this.float32[V + 3] = s,
                this.int16[C + 8] = a,
                this.int16[C + 9] = o,
                this.int16[C + 10] = l,
                this.int16[C + 11] = u,
                this.int16[C + 12] = c,
                this.int16[C + 13] = h,
                this.uint16[C + 14] = p,
                this.uint16[C + 15] = f,
                this.uint16[C + 16] = d,
                this.uint16[C + 17] = y,
                this.uint16[C + 18] = m,
                this.uint16[C + 19] = g,
                this.uint16[C + 20] = x,
                this.uint16[C + 21] = v,
                this.uint16[C + 22] = b,
                this.uint16[C + 23] = _,
                this.uint16[C + 24] = w,
                this.uint16[C + 25] = A,
                this.uint16[C + 26] = k,
                this.uint16[C + 27] = z,
                this.uint16[C + 28] = S,
                this.uint32[V + 15] = M,
                this.float32[V + 16] = I,
                this.float32[V + 17] = T,
                this.float32[V + 18] = B,
                t
            }
        }
        da.prototype.bytesPerElement = 76,
        Bi(da, "StructArrayLayout3i2f6i15ui1ul3f76");
        class ya extends Xs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t) {
                const e = this.length;
                return this.resize(e + 1),
                this.emplace(e, t)
            }
            emplace(t, e) {
                return this.float32[1 * t + 0] = e,
                t
            }
        }
        ya.prototype.bytesPerElement = 4,
        Bi(ya, "StructArrayLayout1f4");
        class ma extends Xs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n, i) {
                const s = this.length;
                return this.resize(s + 1),
                this.emplace(s, t, e, r, n, i)
            }
            emplace(t, e, r, n, i, s) {
                const a = 5 * t;
                return this.float32[a + 0] = e,
                this.float32[a + 1] = r,
                this.float32[a + 2] = n,
                this.float32[a + 3] = i,
                this.float32[a + 4] = s,
                t
            }
        }
        ma.prototype.bytesPerElement = 20,
        Bi(ma, "StructArrayLayout5f20");
        class ga extends Xs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.uint32 = new Uint32Array(this.arrayBuffer),
                this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n) {
                const i = this.length;
                return this.resize(i + 1),
                this.emplace(i, t, e, r, n)
            }
            emplace(t, e, r, n, i) {
                const s = 6 * t;
                return this.uint32[3 * t + 0] = e,
                this.uint16[s + 2] = r,
                this.uint16[s + 3] = n,
                this.uint16[s + 4] = i,
                t
            }
        }
        ga.prototype.bytesPerElement = 12,
        Bi(ga, "StructArrayLayout1ul3ui12");
        class xa extends Xs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t, e) {
                const r = this.length;
                return this.resize(r + 1),
                this.emplace(r, t, e)
            }
            emplace(t, e, r) {
                const n = 2 * t;
                return this.uint16[n + 0] = e,
                this.uint16[n + 1] = r,
                t
            }
        }
        xa.prototype.bytesPerElement = 4,
        Bi(xa, "StructArrayLayout2ui4");
        class va extends Xs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t) {
                const e = this.length;
                return this.resize(e + 1),
                this.emplace(e, t)
            }
            emplace(t, e) {
                return this.uint16[1 * t + 0] = e,
                t
            }
        }
        va.prototype.bytesPerElement = 2,
        Bi(va, "StructArrayLayout1ui2");
        class ba extends Xs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t, e) {
                const r = this.length;
                return this.resize(r + 1),
                this.emplace(r, t, e)
            }
            emplace(t, e, r) {
                const n = 2 * t;
                return this.float32[n + 0] = e,
                this.float32[n + 1] = r,
                t
            }
        }
        ba.prototype.bytesPerElement = 8,
        Bi(ba, "StructArrayLayout2f8");
        class _a extends Gs {
            get a_pos_30() {
                return this._structArray.int16[this._pos2 + 0]
            }
            get a_pos_31() {
                return this._structArray.int16[this._pos2 + 1]
            }
            get a_pos_32() {
                return this._structArray.int16[this._pos2 + 2]
            }
            get a_pos_normal_30() {
                return this._structArray.int16[this._pos2 + 3]
            }
            get a_pos_normal_31() {
                return this._structArray.int16[this._pos2 + 4]
            }
            get a_pos_normal_32() {
                return this._structArray.int16[this._pos2 + 5]
            }
        }
        _a.prototype.size = 12;
        class wa extends na {
            get(t) {
                return new _a(this,t)
            }
        }
        Bi(wa, "FillExtrusionExtArray");
        class Aa extends Gs {
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0]
            }
            get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1]
            }
            get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2]
            }
            get tileAnchorX() {
                return this._structArray.int16[this._pos2 + 3]
            }
            get tileAnchorY() {
                return this._structArray.int16[this._pos2 + 4]
            }
            get x1() {
                return this._structArray.float32[this._pos4 + 3]
            }
            get y1() {
                return this._structArray.float32[this._pos4 + 4]
            }
            get x2() {
                return this._structArray.float32[this._pos4 + 5]
            }
            get y2() {
                return this._structArray.float32[this._pos4 + 6]
            }
            get padding() {
                return this._structArray.int16[this._pos2 + 14]
            }
            get featureIndex() {
                return this._structArray.uint32[this._pos4 + 8]
            }
            get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 18]
            }
            get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 19]
            }
        }
        Aa.prototype.size = 40;
        class ka extends oa {
            get(t) {
                return new Aa(this,t)
            }
        }
        Bi(ka, "CollisionBoxArray");
        class za extends Gs {
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0]
            }
            get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1]
            }
            get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2]
            }
            get tileAnchorX() {
                return this._structArray.float32[this._pos4 + 2]
            }
            get tileAnchorY() {
                return this._structArray.float32[this._pos4 + 3]
            }
            get glyphStartIndex() {
                return this._structArray.uint16[this._pos2 + 8]
            }
            get numGlyphs() {
                return this._structArray.uint16[this._pos2 + 9]
            }
            get vertexStartIndex() {
                return this._structArray.uint32[this._pos4 + 5]
            }
            get lineStartIndex() {
                return this._structArray.uint32[this._pos4 + 6]
            }
            get lineLength() {
                return this._structArray.uint32[this._pos4 + 7]
            }
            get segment() {
                return this._structArray.uint16[this._pos2 + 16]
            }
            get lowerSize() {
                return this._structArray.uint16[this._pos2 + 17]
            }
            get upperSize() {
                return this._structArray.uint16[this._pos2 + 18]
            }
            get lineOffsetX() {
                return this._structArray.float32[this._pos4 + 10]
            }
            get lineOffsetY() {
                return this._structArray.float32[this._pos4 + 11]
            }
            get writingMode() {
                return this._structArray.uint8[this._pos1 + 48]
            }
            get placedOrientation() {
                return this._structArray.uint8[this._pos1 + 49]
            }
            set placedOrientation(t) {
                this._structArray.uint8[this._pos1 + 49] = t;
            }
            get hidden() {
                return this._structArray.uint8[this._pos1 + 50]
            }
            set hidden(t) {
                this._structArray.uint8[this._pos1 + 50] = t;
            }
            get crossTileID() {
                return this._structArray.uint32[this._pos4 + 13]
            }
            set crossTileID(t) {
                this._structArray.uint32[this._pos4 + 13] = t;
            }
            get associatedIconIndex() {
                return this._structArray.int16[this._pos2 + 28]
            }
            get flipState() {
                return this._structArray.uint8[this._pos1 + 58]
            }
            set flipState(t) {
                this._structArray.uint8[this._pos1 + 58] = t;
            }
        }
        za.prototype.size = 60;
        class Sa extends fa {
            get(t) {
                return new za(this,t)
            }
        }
        Bi(Sa, "PlacedSymbolArray");
        class Ma extends Gs {
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0]
            }
            get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1]
            }
            get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2]
            }
            get tileAnchorX() {
                return this._structArray.float32[this._pos4 + 2]
            }
            get tileAnchorY() {
                return this._structArray.float32[this._pos4 + 3]
            }
            get rightJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 8]
            }
            get centerJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 9]
            }
            get leftJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 10]
            }
            get verticalPlacedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 11]
            }
            get placedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 12]
            }
            get verticalPlacedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 13]
            }
            get key() {
                return this._structArray.uint16[this._pos2 + 14]
            }
            get textBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 15]
            }
            get textBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 16]
            }
            get verticalTextBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 17]
            }
            get verticalTextBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 18]
            }
            get iconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 19]
            }
            get iconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 20]
            }
            get verticalIconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 21]
            }
            get verticalIconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 22]
            }
            get featureIndex() {
                return this._structArray.uint16[this._pos2 + 23]
            }
            get numHorizontalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 24]
            }
            get numVerticalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 25]
            }
            get numIconVertices() {
                return this._structArray.uint16[this._pos2 + 26]
            }
            get numVerticalIconVertices() {
                return this._structArray.uint16[this._pos2 + 27]
            }
            get useRuntimeCollisionCircles() {
                return this._structArray.uint16[this._pos2 + 28]
            }
            get crossTileID() {
                return this._structArray.uint32[this._pos4 + 15]
            }
            set crossTileID(t) {
                this._structArray.uint32[this._pos4 + 15] = t;
            }
            get textOffset0() {
                return this._structArray.float32[this._pos4 + 16]
            }
            get textOffset1() {
                return this._structArray.float32[this._pos4 + 17]
            }
            get collisionCircleDiameter() {
                return this._structArray.float32[this._pos4 + 18]
            }
        }
        Ma.prototype.size = 76;
        class Ia extends da {
            get(t) {
                return new Ma(this,t)
            }
        }
        Bi(Ia, "SymbolInstanceArray");
        class Ta extends ya {
            getoffsetX(t) {
                return this.float32[1 * t + 0]
            }
        }
        Bi(Ta, "GlyphOffsetArray");
        class Ba extends Js {
            getx(t) {
                return this.int16[3 * t + 0]
            }
            gety(t) {
                return this.int16[3 * t + 1]
            }
            gettileUnitDistanceFromAnchor(t) {
                return this.int16[3 * t + 2]
            }
        }
        Bi(Ba, "SymbolLineVertexArray");
        class Ca extends Gs {
            get featureIndex() {
                return this._structArray.uint32[this._pos4 + 0]
            }
            get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 2]
            }
            get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 3]
            }
            get layoutVertexArrayOffset() {
                return this._structArray.uint16[this._pos2 + 4]
            }
        }
        Ca.prototype.size = 12;
        class Va extends ga {
            get(t) {
                return new Ca(this,t)
            }
        }
        Bi(Va, "FeatureIndexArray");
        class Pa extends Gs {
            get a_centroid_pos0() {
                return this._structArray.uint16[this._pos2 + 0]
            }
            get a_centroid_pos1() {
                return this._structArray.uint16[this._pos2 + 1]
            }
        }
        Pa.prototype.size = 4;
        class Da extends xa {
            get(t) {
                return new Pa(this,t)
            }
        }
        Bi(Da, "FillExtrusionCentroidArray");
        class Ea extends Gs {
            get a_pos_30() {
                return this._structArray.int16[this._pos2 + 0]
            }
            get a_pos_31() {
                return this._structArray.int16[this._pos2 + 1]
            }
            get a_pos_32() {
                return this._structArray.int16[this._pos2 + 2]
            }
            get a_pos_normal_30() {
                return this._structArray.int16[this._pos2 + 3]
            }
            get a_pos_normal_31() {
                return this._structArray.int16[this._pos2 + 4]
            }
            get a_pos_normal_32() {
                return this._structArray.int16[this._pos2 + 5]
            }
        }
        Ea.prototype.size = 12;
        class Fa extends na {
            get(t) {
                return new Ea(this,t)
            }
        }
        Bi(Fa, "CircleGlobeExtArray");
        class La extends Xs {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer),
                this.int16 = new Int16Array(this.arrayBuffer),
                this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n, i, s) {
                const a = this.length;
                return this.resize(a + 1),
                this.emplace(a, t, e, r, n, i, s)
            }
            emplace(t, e, r, n, i, s, a) {
                const o = 10 * t
                  , l = 5 * t;
                return this.int16[o + 0] = e,
                this.int16[o + 1] = r,
                this.float32[l + 1] = n,
                this.float32[l + 2] = i,
                this.float32[l + 3] = s,
                this.float32[l + 4] = a,
                t
            }
        }
        La.prototype.bytesPerElement = 20,
        Bi(La, "StructArrayLayout2i4f20");
        const Ra = Ys([{
            name: "a_pattern_to",
            components: 4,
            type: "Uint16"
        }, {
            name: "a_pattern_from",
            components: 4,
            type: "Uint16"
        }, {
            name: "a_pixel_ratio_to",
            components: 1,
            type: "Uint16"
        }, {
            name: "a_pixel_ratio_from",
            components: 1,
            type: "Uint16"
        }])
          , ja = Ys([{
            name: "a_dash_to",
            components: 4,
            type: "Uint16"
        }, {
            name: "a_dash_from",
            components: 4,
            type: "Uint16"
        }]);
        var Ua = fe((function(t) {
            t.exports = function(t, e) {
                var r, n, i, s, a, o, l, u;
                for (n = t.length - (r = 3 & t.length),
                i = e,
                a = 3432918353,
                o = 461845907,
                u = 0; u < n; )
                    l = 255 & t.charCodeAt(u) | (255 & t.charCodeAt(++u)) << 8 | (255 & t.charCodeAt(++u)) << 16 | (255 & t.charCodeAt(++u)) << 24,
                    ++u,
                    i = 27492 + (65535 & (s = 5 * (65535 & (i = (i ^= l = (65535 & (l = (l = (65535 & l) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295) << 13 | i >>> 19)) + ((5 * (i >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s >>> 16) & 65535) << 16);
                switch (l = 0,
                r) {
                case 3:
                    l ^= (255 & t.charCodeAt(u + 2)) << 16;
                case 2:
                    l ^= (255 & t.charCodeAt(u + 1)) << 8;
                case 1:
                    i ^= l = (65535 & (l = (l = (65535 & (l ^= 255 & t.charCodeAt(u))) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295;
                }
                return i ^= t.length,
                i = 2246822507 * (65535 & (i ^= i >>> 16)) + ((2246822507 * (i >>> 16) & 65535) << 16) & 4294967295,
                i = 3266489909 * (65535 & (i ^= i >>> 13)) + ((3266489909 * (i >>> 16) & 65535) << 16) & 4294967295,
                (i ^= i >>> 16) >>> 0
            }
            ;
        }
        ))
          , Oa = fe((function(t) {
            t.exports = function(t, e) {
                for (var r, n = t.length, i = e ^ n, s = 0; n >= 4; )
                    r = 1540483477 * (65535 & (r = 255 & t.charCodeAt(s) | (255 & t.charCodeAt(++s)) << 8 | (255 & t.charCodeAt(++s)) << 16 | (255 & t.charCodeAt(++s)) << 24)) + ((1540483477 * (r >>> 16) & 65535) << 16),
                    i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16) ^ (r = 1540483477 * (65535 & (r ^= r >>> 24)) + ((1540483477 * (r >>> 16) & 65535) << 16)),
                    n -= 4,
                    ++s;
                switch (n) {
                case 3:
                    i ^= (255 & t.charCodeAt(s + 2)) << 16;
                case 2:
                    i ^= (255 & t.charCodeAt(s + 1)) << 8;
                case 1:
                    i = 1540483477 * (65535 & (i ^= 255 & t.charCodeAt(s))) + ((1540483477 * (i >>> 16) & 65535) << 16);
                }
                return i = 1540483477 * (65535 & (i ^= i >>> 13)) + ((1540483477 * (i >>> 16) & 65535) << 16),
                (i ^= i >>> 15) >>> 0
            }
            ;
        }
        ))
          , $a = Ua
          , qa = Oa;
        $a.murmur3 = Ua,
        $a.murmur2 = qa;
        class Na {
            constructor() {
                this.ids = [],
                this.positions = [],
                this.indexed = !1;
            }
            add(t, e, r, n) {
                this.ids.push(Za(t)),
                this.positions.push(e, r, n);
            }
            getPositions(t) {
                const e = Za(t);
                let r = 0
                  , n = this.ids.length - 1;
                for (; r < n; ) {
                    const t = r + n >> 1;
                    this.ids[t] >= e ? n = t : r = t + 1;
                }
                const i = [];
                for (; this.ids[r] === e; )
                    i.push({
                        index: this.positions[3 * r],
                        start: this.positions[3 * r + 1],
                        end: this.positions[3 * r + 2]
                    }),
                    r++;
                return i
            }
            static serialize(t, e) {
                const r = new Float64Array(t.ids)
                  , n = new Uint32Array(t.positions);
                return Ga(r, n, 0, r.length - 1),
                e && e.push(r.buffer, n.buffer),
                {
                    ids: r,
                    positions: n
                }
            }
            static deserialize(t) {
                const e = new Na;
                return e.ids = t.ids,
                e.positions = t.positions,
                e.indexed = !0,
                e
            }
        }
        function Za(t) {
            const e = +t;
            return !isNaN(e) && Number.MIN_SAFE_INTEGER <= e && e <= Number.MAX_SAFE_INTEGER ? e : $a(String(t))
        }
        function Ga(t, e, r, n) {
            for (; r < n; ) {
                const i = t[r + n >> 1];
                let s = r - 1
                  , a = n + 1;
                for (; ; ) {
                    do {
                        s++;
                    } while (t[s] < i);
                    do {
                        a--;
                    } while (t[a] > i);
                    if (s >= a)
                        break;
                    Xa(t, s, a),
                    Xa(e, 3 * s, 3 * a),
                    Xa(e, 3 * s + 1, 3 * a + 1),
                    Xa(e, 3 * s + 2, 3 * a + 2);
                }
                a - r < n - a ? (Ga(t, e, r, a),
                r = a + 1) : (Ga(t, e, a + 1, n),
                n = a);
            }
        }
        function Xa(t, e, r) {
            const n = t[e];
            t[e] = t[r],
            t[r] = n;
        }
        Bi(Na, "FeaturePositionMap");
        class Ya {
            constructor(t) {
                this.gl = t.gl,
                this.initialized = !1;
            }
            fetchUniformLocation(t, e) {
                return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t, e),
                this.initialized = !0),
                !!this.location
            }
        }
        class Ha extends Ya {
            constructor(t) {
                super(t),
                this.current = 0;
            }
            set(t, e, r) {
                this.fetchUniformLocation(t, e) && this.current !== r && (this.current = r,
                this.gl.uniform1f(this.location, r));
            }
        }
        class Ka extends Ya {
            constructor(t) {
                super(t),
                this.current = [0, 0, 0, 0];
            }
            set(t, e, r) {
                this.fetchUniformLocation(t, e) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] && r[3] === this.current[3] || (this.current = r,
                this.gl.uniform4f(this.location, r[0], r[1], r[2], r[3])));
            }
        }
        class Ja extends Ya {
            constructor(t) {
                super(t),
                this.current = me.transparent;
            }
            set(t, e, r) {
                this.fetchUniformLocation(t, e) && (r.r === this.current.r && r.g === this.current.g && r.b === this.current.b && r.a === this.current.a || (this.current = r,
                this.gl.uniform4f(this.location, r.r, r.g, r.b, r.a)));
            }
        }
        const Wa = new Float32Array(16)
          , Qa = new Float32Array(9)
          , to = new Float32Array(4);
        function eo(t) {
            return [Ns(255 * t.r, 255 * t.g), Ns(255 * t.b, 255 * t.a)]
        }
        class ro {
            constructor(t, e, r) {
                this.value = t,
                this.uniformNames = e.map((t => `u_${t}`)),
                this.type = r;
            }
            setUniform(t, e, r, n, i) {
                e.set(t, i, n.constantOr(this.value));
            }
            getBinding(t, e) {
                return "color" === this.type ? new Ja(t) : new Ha(t)
            }
        }
        class no {
            constructor(t, e) {
                this.uniformNames = e.map((t => `u_${t}`)),
                this.patternFrom = null,
                this.patternTo = null,
                this.pixelRatioFrom = 1,
                this.pixelRatioTo = 1;
            }
            setConstantPatternPositions(t, e) {
                this.pixelRatioFrom = e.pixelRatio || 1,
                this.pixelRatioTo = t.pixelRatio || 1,
                this.patternFrom = e.tl.concat(e.br),
                this.patternTo = t.tl.concat(t.br);
            }
            setUniform(t, e, r, n, i) {
                const s = "u_pattern_to" === i || "u_dash_to" === i ? this.patternTo : "u_pattern_from" === i || "u_dash_from" === i ? this.patternFrom : "u_pixel_ratio_to" === i ? this.pixelRatioTo : "u_pixel_ratio_from" === i ? this.pixelRatioFrom : null;
                s && e.set(t, i, s);
            }
            getBinding(t, e) {
                return "u_pattern_from" === e || "u_pattern_to" === e || "u_dash_from" === e || "u_dash_to" === e ? new Ka(t) : new Ha(t)
            }
        }
        class io {
            constructor(t, e, r, n) {
                this.expression = t,
                this.type = r,
                this.maxValue = 0,
                this.paintVertexAttributes = e.map((t => ({
                    name: `a_${t}`,
                    type: "Float32",
                    components: "color" === r ? 2 : 1,
                    offset: 0
                }))),
                this.paintVertexArray = new n;
            }
            populatePaintArray(t, e, r, n, i, s) {
                const a = this.paintVertexArray.length
                  , o = this.expression.evaluate(new Ts(0), e, {}, i, n, s);
                this.paintVertexArray.resize(t),
                this._setPaintValue(a, t, o);
            }
            updatePaintArray(t, e, r, n, i) {
                const s = this.expression.evaluate({
                    zoom: 0
                }, r, n, void 0, i);
                this._setPaintValue(t, e, s);
            }
            _setPaintValue(t, e, r) {
                if ("color" === this.type) {
                    const n = eo(r);
                    for (let r = t; r < e; r++)
                        this.paintVertexArray.emplace(r, n[0], n[1]);
                } else {
                    for (let n = t; n < e; n++)
                        this.paintVertexArray.emplace(n, r);
                    this.maxValue = Math.max(this.maxValue, Math.abs(r));
                }
            }
            upload(t) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
        }
        class so {
            constructor(t, e, r, n, i, s) {
                this.expression = t,
                this.uniformNames = e.map((t => `u_${t}_t`)),
                this.type = r,
                this.useIntegerZoom = n,
                this.zoom = i,
                this.maxValue = 0,
                this.paintVertexAttributes = e.map((t => ({
                    name: `a_${t}`,
                    type: "Float32",
                    components: "color" === r ? 4 : 2,
                    offset: 0
                }))),
                this.paintVertexArray = new s;
            }
            populatePaintArray(t, e, r, n, i, s) {
                const a = this.expression.evaluate(new Ts(this.zoom), e, {}, i, n, s)
                  , o = this.expression.evaluate(new Ts(this.zoom + 1), e, {}, i, n, s)
                  , l = this.paintVertexArray.length;
                this.paintVertexArray.resize(t),
                this._setPaintValue(l, t, a, o);
            }
            updatePaintArray(t, e, r, n, i) {
                const s = this.expression.evaluate({
                    zoom: this.zoom
                }, r, n, void 0, i)
                  , a = this.expression.evaluate({
                    zoom: this.zoom + 1
                }, r, n, void 0, i);
                this._setPaintValue(t, e, s, a);
            }
            _setPaintValue(t, e, r, n) {
                if ("color" === this.type) {
                    const i = eo(r)
                      , s = eo(n);
                    for (let r = t; r < e; r++)
                        this.paintVertexArray.emplace(r, i[0], i[1], s[0], s[1]);
                } else {
                    for (let i = t; i < e; i++)
                        this.paintVertexArray.emplace(i, r, n);
                    this.maxValue = Math.max(this.maxValue, Math.abs(r), Math.abs(n));
                }
            }
            upload(t) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
            setUniform(t, e, r, n, i) {
                const s = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom
                  , a = d(this.expression.interpolationFactor(s, this.zoom, this.zoom + 1), 0, 1);
                e.set(t, i, a);
            }
            getBinding(t, e) {
                return new Ha(t)
            }
        }
        class ao {
            constructor(t, e, r, n, i, s, a, o) {
                this.expression = t,
                this.type = r,
                this.useIntegerZoom = n,
                this.zoom = i,
                this.layerId = a,
                this.paintVertexAttributes = ("array" === r ? ja : Ra).members;
                for (let t = 0; t < e.length; ++t)
                    ;
                this.zoomInPaintVertexArray = new s,
                this.zoomOutPaintVertexArray = new s,
                this.property = o;
            }
            populatePaintArray(t, e, r) {
                const n = this.zoomInPaintVertexArray.length;
                this.zoomInPaintVertexArray.resize(t),
                this.zoomOutPaintVertexArray.resize(t),
                this._setPaintValues(n, t, e.patterns && e.patterns[this.layerId], r);
            }
            updatePaintArray(t, e, r, n, i, s) {
                this._setPaintValues(t, e, r.patterns && r.patterns[this.layerId], s);
            }
            _setPaintValues(t, e, r, n) {
                if (!n || !r)
                    return;
                let {min: i, mid: s, max: a} = r;
                "line-outline-dasharray" === String(this.property) && (i = r.min_out,
                s = r.mid_out,
                a = r.max_out);
                const o = n[i]
                  , l = n[s]
                  , u = n[a];
                if (o && l && u)
                    for (let r = t; r < e; r++)
                        this._setPaintValue(this.zoomInPaintVertexArray, r, l, o),
                        this._setPaintValue(this.zoomOutPaintVertexArray, r, l, u);
            }
            _setPaintValue(t, e, r, n) {
                t.emplace(e, r.tl[0], r.tl[1], r.br[0], r.br[1], n.tl[0], n.tl[1], n.br[0], n.br[1], r.pixelRatio, n.pixelRatio);
            }
            upload(t) {
                this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent),
                this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
                this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(),
                this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
            }
        }
        class oo {
            constructor(t, e, r=( () => !0)) {
                this.binders = {},
                this._buffers = [];
                const n = [];
                for (const i in t.paint._values) {
                    if (!r(i))
                        continue;
                    const s = t.paint.get(i);
                    if (!(s instanceof Fs && bn(s.property.specification)))
                        continue;
                    const a = co(i, t.type)
                      , o = s.value
                      , l = s.property.specification.type
                      , u = s.property.useIntegerZoom
                      , c = s.property.specification["property-type"]
                      , h = "cross-faded" === c || "cross-faded-data-driven" === c
                      , p = ("line-dasharray" === String(i) || "line-outline-dasharray" === String(i)) && "constant" !== t.layout.get("line-cap").value.kind;
                    if ("constant" !== o.kind || p)
                        if ("source" === o.kind || p || h) {
                            const r = fo(i, l, "source");
                            this.binders[i] = h ? new ao(o,a,l,u,e,r,t.id,i) : new io(o,a,l,r),
                            n.push(`/a_${i}`);
                        } else {
                            const t = fo(i, l, "composite");
                            this.binders[i] = new so(o,a,l,u,e,t),
                            n.push(`/z_${i}`);
                        }
                    else
                        this.binders[i] = h ? new no(o.value,a) : new ro(o.value,a,l),
                        n.push(`/u_${i}`);
                }
                this.cacheKey = n.sort().join("");
            }
            getMaxValue(t) {
                const e = this.binders[t];
                return e instanceof io || e instanceof so ? e.maxValue : 0
            }
            populatePaintArrays(t, e, r, n, i, s) {
                for (const a in this.binders) {
                    const o = this.binders[a];
                    (o instanceof io || o instanceof so || o instanceof ao) && o.populatePaintArray(t, e, r, n, i, s);
                }
            }
            setConstantPatternPositions(t, e) {
                for (const r in this.binders) {
                    const n = this.binders[r];
                    n instanceof no && n.setConstantPatternPositions(t, e);
                }
            }
            updatePaintArrays(t, e, r, n, i, s) {
                let a = !1;
                for (const o in t) {
                    const l = e.getPositions(o);
                    for (const e of l) {
                        const l = r.feature(e.index);
                        for (const r in this.binders) {
                            const u = this.binders[r];
                            if ((u instanceof io || u instanceof so || u instanceof ao) && !0 === u.expression.isStateDependent) {
                                const c = n.paint.get(r);
                                u.expression = c.value,
                                u.updatePaintArray(e.start, e.end, l, t[o], i, s),
                                a = !0;
                            }
                        }
                    }
                }
                return a
            }
            defines() {
                const t = [];
                for (const e in this.binders) {
                    const r = this.binders[e];
                    (r instanceof ro || r instanceof no) && t.push(...r.uniformNames.map((t => `#define HAS_UNIFORM_${t}`)));
                }
                return t
            }
            getBinderAttributes() {
                const t = [];
                for (const e in this.binders) {
                    const r = this.binders[e];
                    if (r instanceof io || r instanceof so || r instanceof ao)
                        for (let e = 0; e < r.paintVertexAttributes.length; e++)
                            t.push(r.paintVertexAttributes[e].name);
                }
                return t
            }
            getBinderUniforms() {
                const t = [];
                for (const e in this.binders) {
                    const r = this.binders[e];
                    if (r instanceof ro || r instanceof no || r instanceof so)
                        for (const e of r.uniformNames)
                            t.push(e);
                }
                return t
            }
            getPaintVertexBuffers() {
                return this._buffers
            }
            getUniforms(t) {
                const e = [];
                for (const r in this.binders) {
                    const n = this.binders[r];
                    if (n instanceof ro || n instanceof no || n instanceof so)
                        for (const i of n.uniformNames)
                            e.push({
                                name: i,
                                property: r,
                                binding: n.getBinding(t, i)
                            });
                }
                return e
            }
            setUniforms(t, e, r, n, i) {
                for (const {name: e, property: s, binding: a} of r)
                    this.binders[s].setUniform(t, a, i, n.get(s), e);
            }
            updatePaintBuffers(t) {
                this._buffers = [];
                for (const e in this.binders) {
                    const r = this.binders[e];
                    if (t && r instanceof ao) {
                        const e = 2 === t.fromScale ? r.zoomInPaintVertexBuffer : r.zoomOutPaintVertexBuffer;
                        e && this._buffers.push(e);
                    } else
                        (r instanceof io || r instanceof so) && r.paintVertexBuffer && this._buffers.push(r.paintVertexBuffer);
                }
            }
            upload(t) {
                for (const e in this.binders) {
                    const r = this.binders[e];
                    (r instanceof io || r instanceof so || r instanceof ao) && r.upload(t);
                }
                this.updatePaintBuffers();
            }
            destroy() {
                for (const t in this.binders) {
                    const e = this.binders[t];
                    (e instanceof io || e instanceof so || e instanceof ao) && e.destroy();
                }
            }
        }
        class lo {
            constructor(t, e, r=( () => !0)) {
                this.programConfigurations = {};
                for (const n of t)
                    this.programConfigurations[n.id] = new oo(n,e,r);
                this.needsUpload = !1,
                this._featureMap = new Na,
                this._bufferOffset = 0;
            }
            populatePaintArrays(t, e, r, n, i, s, a) {
                for (const r in this.programConfigurations)
                    this.programConfigurations[r].populatePaintArrays(t, e, n, i, s, a);
                void 0 !== e.id && this._featureMap.add(e.id, r, this._bufferOffset, t),
                this._bufferOffset = t,
                this.needsUpload = !0;
            }
            updatePaintArrays(t, e, r, n, i) {
                for (const s of r)
                    this.needsUpload = this.programConfigurations[s.id].updatePaintArrays(t, this._featureMap, e, s, n, i) || this.needsUpload;
            }
            get(t) {
                return this.programConfigurations[t]
            }
            upload(t) {
                if (this.needsUpload) {
                    for (const e in this.programConfigurations)
                        this.programConfigurations[e].upload(t);
                    this.needsUpload = !1;
                }
            }
            destroy() {
                for (const t in this.programConfigurations)
                    this.programConfigurations[t].destroy();
            }
        }
        const uo = {
            "text-opacity": ["opacity"],
            "icon-opacity": ["opacity"],
            "text-color": ["fill_color"],
            "icon-color": ["fill_color"],
            "text-halo-color": ["halo_color"],
            "icon-halo-color": ["halo_color"],
            "text-halo-blur": ["halo_blur"],
            "icon-halo-blur": ["halo_blur"],
            "text-halo-width": ["halo_width"],
            "icon-halo-width": ["halo_width"],
            "line-gap-width": ["gapwidth"],
            "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
            "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
            "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
            "line-dasharray": ["dash_to", "dash_from"],
            "line-outline-dasharray": ["dash_to", "dash_from"],
            "line-outline-width": ["width"],
            "line-outline-floorwidth": ["floorwidth"],
            "line-outline-color": ["color"]
        };
        function co(t, e) {
            return "eline" == e && (e = "line"),
            uo[t] || [t.replace(`${e}-`, "").replace(/-/g, "_")]
        }
        const ho = {
            "line-pattern": {
                source: ea,
                composite: ea
            },
            "fill-pattern": {
                source: ea,
                composite: ea
            },
            "fill-extrusion-pattern": {
                source: ea,
                composite: ea
            },
            "line-dasharray": {
                source: ra,
                composite: ra
            },
            "line-outline-dasharray": {
                source: ra,
                composite: ra
            }
        }
          , po = {
            color: {
                source: ba,
                composite: ta
            },
            number: {
                source: ya,
                composite: ba
            }
        };
        function fo(t, e, r) {
            const n = ho[t];
            return n && n[r] || po[e][r]
        }
        Bi(ro, "ConstantBinder"),
        Bi(no, "CrossFadedConstantBinder"),
        Bi(io, "SourceExpressionBinder"),
        Bi(ao, "CrossFadedCompositeBinder"),
        Bi(so, "CompositeExpressionBinder"),
        Bi(oo, "ProgramConfiguration", {
            omit: ["_buffers"]
        }),
        Bi(lo, "ProgramConfigurationSet");
        const yo = "-transition";
        class mo extends $t {
            constructor(t, e) {
                if (super(),
                this.id = t.id,
                this.type = t.type,
                this._featureFilter = {
                    filter: () => !0,
                    needGeometry: !1,
                    needFeature: !1
                },
                this._filterCompiled = !1,
                "custom" !== t.type && (this.metadata = (t = t).metadata,
                this.minzoom = t.minzoom,
                this.maxzoom = t.maxzoom,
                "background" !== t.type && "sky" !== t.type && (this.source = t.source,
                this.sourceLayer = t["source-layer"],
                this.filter = t.filter),
                e.layout && (this._unevaluatedLayout = new Es(e.layout)),
                e.paint)) {
                    this._transitionablePaint = new Vs(e.paint);
                    for (const e in t.paint)
                        this.setPaintProperty(e, t.paint[e], {
                            validate: !1
                        });
                    for (const e in t.layout)
                        this.setLayoutProperty(e, t.layout[e], {
                            validate: !1
                        });
                    this._transitioningPaint = this._transitionablePaint.untransitioned(),
                    this.paint = new Ls(e.paint);
                }
            }
            getCrossfadeParameters() {
                return this._crossfadeParameters
            }
            getLayoutProperty(t) {
                return "visibility" === t ? this.visibility : this._unevaluatedLayout.getValue(t)
            }
            setLayoutProperty(t, e, r={}) {
                null != e && this._validate(ki, `layers.${this.id}.layout.${t}`, t, e, r) || ("visibility" !== t ? this._unevaluatedLayout.setValue(t, e) : this.visibility = e);
            }
            getPaintProperty(t) {
                return z(t, yo) ? this._transitionablePaint.getTransition(t.slice(0, -yo.length)) : this._transitionablePaint.getValue(t)
            }
            setPaintProperty(t, e, r={}) {
                if (null != e && this._validate(Ai, `layers.${this.id}.paint.${t}`, t, e, r))
                    return !1;
                if (z(t, yo))
                    return this._transitionablePaint.setTransition(t.slice(0, -yo.length), e || void 0),
                    !1;
                {
                    const r = this._transitionablePaint._values[t]
                      , n = "cross-faded-data-driven" === r.property.specification["property-type"]
                      , i = r.value.isDataDriven()
                      , s = r.value;
                    this._transitionablePaint.setValue(t, e),
                    this._handleSpecialPaintPropertyUpdate(t);
                    const a = this._transitionablePaint._values[t].value;
                    return a.isDataDriven() || i || n || this._handleOverridablePaintPropertyUpdate(t, s, a)
                }
            }
            _handleSpecialPaintPropertyUpdate(t) {}
            getProgramIds() {
                return null
            }
            getProgramConfiguration(t) {
                return null
            }
            _handleOverridablePaintPropertyUpdate(t, e, r) {
                return !1
            }
            isHidden(t) {
                return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || "none" === this.visibility
            }
            updateTransitions(t) {
                this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);
            }
            hasTransition() {
                return this._transitioningPaint.hasTransition()
            }
            recalculate(t, e) {
                t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()),
                this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, e)),
                this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, e);
            }
            serialize() {
                const t = {
                    id: this.id,
                    type: this.type,
                    source: this.source,
                    "source-layer": this.sourceLayer,
                    metadata: this.metadata,
                    minzoom: this.minzoom,
                    maxzoom: this.maxzoom,
                    filter: this.filter,
                    layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
                    paint: this._transitionablePaint && this._transitionablePaint.serialize()
                };
                return this.visibility && (t.layout = t.layout || {},
                t.layout.visibility = this.visibility),
                M(t, ( (t, e) => !(void 0 === t || "layout" === e && !Object.keys(t).length || "paint" === e && !Object.keys(t).length)))
            }
            _validate(t, e, r, n, i={}) {
                return (!i || !1 !== i.validate) && Si(this, t.call(wi, {
                    key: e,
                    layerType: this.type,
                    objectKey: r,
                    value: n,
                    styleSpec: qt,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    }
                }))
            }
            is3D() {
                return !1
            }
            isSky() {
                return !1
            }
            isTileClipped() {
                return !1
            }
            hasOffscreenPass() {
                return !1
            }
            resize() {}
            isStateDependent() {
                for (const t in this.paint._values) {
                    const e = this.paint.get(t);
                    if (e instanceof Fs && bn(e.property.specification) && ("source" === e.value.kind || "composite" === e.value.kind) && e.value.isStateDependent)
                        return !0
                }
                return !1
            }
            compileFilter() {
                this._filterCompiled || (this._featureFilter = Hn(this.filter),
                this._filterCompiled = !0);
            }
            invalidateCompiledFilter() {
                this._filterCompiled = !1;
            }
            dynamicFilter() {
                return this._featureFilter.dynamicFilter
            }
            dynamicFilterNeedsFeature() {
                return this._featureFilter.needFeature
            }
        }
        const go = Ys([{
            name: "a_pos",
            components: 2,
            type: "Int16"
        }], 4)
          , xo = Ys([{
            name: "a_pos_3",
            components: 3,
            type: "Int16"
        }, {
            name: "a_pos_normal_3",
            components: 3,
            type: "Int16"
        }]);
        class vo {
            constructor(t=[]) {
                this.segments = t;
            }
            prepareSegment(t, e, r, n) {
                let i = this.segments[this.segments.length - 1];
                return t > vo.MAX_VERTEX_ARRAY_LENGTH && B(`Max vertices per segment is ${vo.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}`),
                (!i || i.vertexLength + t > vo.MAX_VERTEX_ARRAY_LENGTH || i.sortKey !== n) && (i = {
                    vertexOffset: e.length,
                    primitiveOffset: r.length,
                    vertexLength: 0,
                    primitiveLength: 0
                },
                void 0 !== n && (i.sortKey = n),
                this.segments.push(i)),
                i
            }
            get() {
                return this.segments
            }
            destroy() {
                for (const t of this.segments)
                    for (const e in t.vaos)
                        t.vaos[e].destroy();
            }
            static simpleSegment(t, e, r, n) {
                return new vo([{
                    vertexOffset: t,
                    primitiveOffset: e,
                    vertexLength: r,
                    primitiveLength: n,
                    vaos: {},
                    sortKey: 0
                }])
            }
        }
        vo.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1,
        Bi(vo, "SegmentVector");
        var bo = 8192;
        class _o {
            constructor(t, e) {
                t && (e ? this.setSouthWest(t).setNorthEast(e) : 4 === t.length ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]]) : this.setSouthWest(t[0]).setNorthEast(t[1]));
            }
            setNorthEast(t) {
                return this._ne = t instanceof Ao ? new Ao(t.lng,t.lat) : Ao.convert(t),
                this
            }
            setSouthWest(t) {
                return this._sw = t instanceof Ao ? new Ao(t.lng,t.lat) : Ao.convert(t),
                this
            }
            extend(t) {
                const e = this._sw
                  , r = this._ne;
                let n, i;
                if (t instanceof Ao)
                    n = t,
                    i = t;
                else {
                    if (!(t instanceof _o))
                        return Array.isArray(t) ? 4 === t.length || t.every(Array.isArray) ? this.extend(_o.convert(t)) : this.extend(Ao.convert(t)) : this;
                    if (n = t._sw,
                    i = t._ne,
                    !n || !i)
                        return this
                }
                return e || r ? (e.lng = Math.min(n.lng, e.lng),
                e.lat = Math.min(n.lat, e.lat),
                r.lng = Math.max(i.lng, r.lng),
                r.lat = Math.max(i.lat, r.lat)) : (this._sw = new Ao(n.lng,n.lat),
                this._ne = new Ao(i.lng,i.lat)),
                this
            }
            getCenter() {
                return new Ao((this._sw.lng + this._ne.lng) / 2,(this._sw.lat + this._ne.lat) / 2)
            }
            getSouthWest() {
                return this._sw
            }
            getNorthEast() {
                return this._ne
            }
            getNorthWest() {
                return new Ao(this.getWest(),this.getNorth())
            }
            getSouthEast() {
                return new Ao(this.getEast(),this.getSouth())
            }
            getWest() {
                return this._sw.lng
            }
            getSouth() {
                return this._sw.lat
            }
            getEast() {
                return this._ne.lng
            }
            getNorth() {
                return this._ne.lat
            }
            toArray() {
                return [this._sw.toArray(), this._ne.toArray()]
            }
            toString() {
                return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`
            }
            isEmpty() {
                return !(this._sw && this._ne)
            }
            contains(t) {
                const {lng: e, lat: r} = Ao.convert(t);
                let n = this._sw.lng <= e && e <= this._ne.lng;
                return this._sw.lng > this._ne.lng && (n = this._sw.lng >= e && e >= this._ne.lng),
                this._sw.lat <= r && r <= this._ne.lat && n
            }
            static convert(t) {
                return !t || t instanceof _o ? t : new _o(t)
            }
        }
        const wo = 6371008.8;
        class Ao {
            constructor(t, e) {
                if (isNaN(t) || isNaN(e))
                    throw new Error(`Invalid LngLat object: (${t}, ${e})`);
                if (this.lng = +t,
                this.lat = +e,
                this.lat > 90 || this.lat < -90)
                    throw new Error("Invalid LngLat latitude value: must be between -90 and 90")
            }
            wrap() {
                return new Ao(m(this.lng, -180, 180),this.lat)
            }
            toArray() {
                return [this.lng, this.lat]
            }
            toString() {
                return `LngLat(${this.lng}, ${this.lat})`
            }
            distanceTo(t) {
                const e = Math.PI / 180
                  , r = this.lat * e
                  , n = t.lat * e
                  , i = Math.sin(r) * Math.sin(n) + Math.cos(r) * Math.cos(n) * Math.cos((t.lng - this.lng) * e);
                return wo * Math.acos(Math.min(i, 1))
            }
            toBounds(t=0) {
                const e = 360 * t / 40075017
                  , r = e / Math.cos(Math.PI / 180 * this.lat);
                return new _o(new Ao(this.lng - r,this.lat - e),new Ao(this.lng + r,this.lat + e))
            }
            static convert(t) {
                if (t instanceof Ao)
                    return t;
                if (Array.isArray(t) && (2 === t.length || 3 === t.length))
                    return new Ao(Number(t[0]),Number(t[1]));
                if (!Array.isArray(t) && "object" == typeof t && null !== t)
                    return new Ao(Number("lng"in t ? t.lng : t.lon),Number(t.lat));
                throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")
            }
        }
        const ko = 2 * Math.PI * wo;
        function zo(t) {
            return ko * Math.cos(t * Math.PI / 180)
        }
        function So(t) {
            return (180 + t) / 360
        }
        function Mo(t) {
            return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t * Math.PI / 360))) / 360
        }
        function Io(t, e) {
            return t / zo(e)
        }
        function To(t) {
            return 360 * t - 180
        }
        function Bo(t) {
            return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t) * Math.PI / 180)) - 90
        }
        function Co(t, e) {
            return t * zo(Bo(e))
        }
        function Vo(t) {
            return 1 / Math.cos(t * Math.PI / 180)
        }
        class Po {
            constructor(t, e, r=0) {
                this.x = +t,
                this.y = +e,
                this.z = +r;
            }
            static fromLngLat(t, e=0) {
                const r = Ao.convert(t);
                return new Po(So(r.lng),Mo(r.lat),Io(e, r.lat))
            }
            toLngLat() {
                return new Ao(To(this.x),Bo(this.y))
            }
            toAltitude() {
                return Co(this.z, this.y)
            }
            meterInMercatorCoordinateUnits() {
                return 1 / ko * Vo(Bo(this.y))
            }
        }
        var Do = Object.freeze({
            __proto__: null,
            circumferenceAtLatitude: zo,
            mercatorXfromLng: So,
            mercatorYfromLat: Mo,
            mercatorZfromAltitude: Io,
            lngFromMercatorX: To,
            latFromMercatorY: Bo,
            altitudeFromMercatorZ: Co,
            MAX_MERCATOR_LATITUDE: 85.051129,
            mercatorScale: Vo,
            default: Po
        });
        const Eo = 2 * Math.PI * 6378137;
        function Fo(t) {
            return Eo * Math.cos(t * Math.PI / 180)
        }
        function Lo(t) {
            return (180 + t) / 360
        }
        function Ro(t) {
            return (90 - t) / 360
        }
        function jo(t, e) {
            return t / Fo(e)
        }
        function Uo(t) {
            return 360 * t - 180
        }
        function Oo(t) {
            return 90 - 360 * t
        }
        function $o(t, e) {
            return t * Fo(Oo(e))
        }
        function qo(t) {
            return 1 / Math.cos(t * Math.PI / 180)
        }
        class No {
            constructor(t, e, r=0) {
                this.x = +t,
                this.y = +e,
                this.z = +r;
            }
            static fromLngLat(t, e=0) {
                const r = Ao.convert(t);
                return new No(Lo(r.lng),Ro(r.lat),jo(e, r.lat))
            }
            toLngLat() {
                return new Ao(Uo(this.x),Oo(this.y))
            }
            toAltitude() {
                return $o(this.z, this.y)
            }
            meterInMercatorCoordinateUnits() {
                return 1 / Eo * qo(Oo(this.y))
            }
        }
        const Zo = {
            "EPSG:3857": Do,
            "EPSG:4326": Object.freeze({
                __proto__: null,
                mercatorXfromLng: Lo,
                mercatorYfromLat: Ro,
                mercatorZfromAltitude: jo,
                lngFromMercatorX: Uo,
                latFromMercatorY: Oo,
                altitudeFromMercatorZ: $o,
                MAX_MERCATOR_LATITUDE: 85.051129,
                mercatorScale: qo,
                default: No
            })
        };
        let Go = "EPSG:3857";
        function Xo(t) {
            t && (Z.crs = t,
            Go = t);
        }
        const Yo = 2 * Math.PI * 6378137;
        function Ho(t) {
            return Zo[Z.crs || Go].mercatorXfromLng(t)
        }
        function Ko(t) {
            return Zo[Z.crs || Go].mercatorYfromLat(t)
        }
        function Jo(t, e) {
            return Zo[Z.crs || Go].mercatorZfromAltitude(t, e)
        }
        function Wo(t) {
            return Zo[Z.crs || Go].lngFromMercatorX(t)
        }
        function Qo(t) {
            return Zo[Z.crs || Go].latFromMercatorY(t)
        }
        function tl(t, e) {
            return Zo[Z.crs || Go].altitudeFromMercatorZ(t, e)
        }
        const el = 85.051129;
        function rl(t) {
            return Zo[Z.crs || Go].mercatorScale(t)
        }
        class nl {
            constructor(t, e, r=0) {
                this.x = +t,
                this.y = +e,
                this.z = +r;
            }
            static fromLngLat(t, e=0) {
                const r = Ao.convert(t);
                return new nl(Ho(r.lng),Ko(r.lat),Jo(e, r.lat))
            }
            toLngLat() {
                return new Ao(Wo(this.x),Qo(this.y))
            }
            toAltitude() {
                return tl(this.z, this.y)
            }
            meterInMercatorCoordinateUnits() {
                return 1 / Yo * rl(Qo(this.y))
            }
        }
        function il(t, e, r, n, s, a, o, l, u) {
            const c = (e + n) / 2
              , h = (r + s) / 2
              , p = new i(c,h);
            l(p),
            function(t, e, r, n, i, s) {
                const a = r - i
                  , o = n - s;
                return Math.abs((n - e) * a - (r - t) * o) / Math.hypot(a, o)
            }(p.x, p.y, a.x, a.y, o.x, o.y) >= u ? (il(t, e, r, c, h, a, p, l, u),
            il(t, c, h, n, s, p, o, l, u)) : t.push(o);
        }
        function sl(t, e, r) {
            let n = t[0]
              , i = n.x
              , s = n.y;
            e(n);
            const a = [n];
            for (let o = 1; o < t.length; o++) {
                const l = t[o]
                  , {x: u, y: c} = l;
                e(l),
                il(a, i, s, u, c, n, l, e, r),
                i = u,
                s = c,
                n = l;
            }
            return a
        }
        function al(t, e, r, n, i) {
            if (i(e, r)) {
                const s = e.add(r).mult(.5);
                n(s),
                al(t, e, s, n, i),
                al(t, s, r, n, i);
            } else
                t.push(r);
        }
        function ol(t, e, r) {
            let n = t[0];
            e(n);
            const i = [n];
            for (let s = 1; s < t.length; s++) {
                const a = t[s];
                e(a),
                al(i, n, a, e, r),
                n = a;
            }
            return i
        }
        const ll = 2147483648
          , ul = function(t) {
            return Math.abs(t - 180) <= 1e-6 ? 2147483647 : parseInt(t * ll / 180 + .5)
        }
          , cl = function(t, e, r, n) {
            let i = parseInt(33 - e - t);
            n < -90 && (n = -90),
            n > 90 && (n = 90),
            r < -180 && (r = -180),
            r > 180 && (r = 180);
            let s = ul(r)
              , a = ul(n)
              , o = s / (1 << i)
              , l = a / (1 << i);
            return s = o > 0 ? parseInt(o + .5) : parseInt(o - .5),
            a = l > 0 ? parseInt(l + .5) : parseInt(l - .5),
            {
                x: s,
                y: a
            }
        }
          , hl = function(t, e, r) {
            let n = {}
              , i = 1 << r
              , s = 360 / i
              , a = 180 / i;
            return e = i - e - 1,
            n.low_lon = s * t - 180,
            n.low_lat = a * e - 90,
            n.high_lon = s * (t + 1) - 180,
            n.high_lat = a * (e + 1) - 90,
            n
        }
          , pl = function(t, e) {
            return 2 == e ? t < 5 ? 11 : t < 14 ? 12 : 13 : 3 == e ? 12 : t <= 3 ? 11 : 12
        }
          , fl = function(t, e, r, n, i, s) {
            let a = parseInt(i + r)
              , o = parseInt(s + n)
              , l = 33 - e - t;
            return i = a << l,
            a > 0 && i < 0 && (i = 2147483647),
            {
                lon: 180 * i / ll,
                lat: 180 * (s = o << l) / ll
            }
        }
          , dl = function(t, e, r, n, i, s, a) {
            let o = a || pl(t, e)
              , l = function(t, e, r, n) {
                let i = hl(r, n, t);
                return cl(t, e, i.low_lon, i.low_lat)
            }(t, o, r, n);
            return fl(t, o, l.x, l.y, i, s)
        }
          , yl = function(t) {
            return -90 == t ? 1 : 90 == t ? 0 : (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t * Math.PI / 360))) / 360
        }
          , ml = function(t, e, r, n) {
            var i = Math.pow(2, r)
              , s = hl(t, e, r)
              , a = yl(s.high_lat);
            if ("all" == n) {
                var o = yl(s.low_lat);
                return {
                    top: a * i,
                    bottom: o * i,
                    height: (o - a) * i
                }
            }
            return a * i
        }
          , gl = function(t, e) {
            return t / bo * (e._tileH || 1) + (e._tileY || e.y)
        }
          , xl = function(t) {
            let e = "Sg4326" == t.reference;
            return {
                top: e ? t._tileY : t.y,
                bottom: e ? t._tileY + t._tileH : t.y + 1
            }
        }
          , vl = Math.pow(2, 14) - 1
          , bl = -vl - 1;
        function _l(t, e) {
            const r = Math.round(t.x * e)
              , n = Math.round(t.y * e);
            return t.x = d(r, bl, vl),
            t.y = d(n, bl, vl),
            (r < t.x || r > t.x + 1 || n < t.y || n > t.y + 1) && B("Geometry exceeds allowed extent, reduce your vector tile buffer size"),
            t
        }
        function wl(t, e, r) {
            let n = t.loadGeometry();
            const s = t.extent
              , a = bo / s;
            if ("Sg4326" == e.reference) {
                const s = !t.properties && 1 !== t.type
                  , a = r && r.projection.isReprojectedInTileSpace;
                var o = e.x
                  , l = e.y
                  , u = e.z
                  , c = Math.pow(2, u)
                  , h = e._tileY
                  , p = e._tileH;
                let f = t.properties && t.properties.resolution || pl(u, t.type)
                  , d = function(t, e, r, n) {
                    let i = hl(r, n, t);
                    return {
                        ws: cl(t, e, i.low_lon, i.low_lat),
                        ne: cl(t, e, i.high_lon, i.high_lat)
                    }
                }(u, f, o, l)
                  , y = d.ws.x
                  , m = d.ws.y
                  , g = Math.PI / 4
                  , x = Math.PI / 360
                  , v = 180 / Math.PI;
                s && (n = [[new i(0,0), new i(d.ne.x - d.ws.x,0), new i(d.ne.x - d.ws.x,d.ne.y - d.ws.y), new i(0,d.ne.y - d.ws.y), new i(0,0)]]);
                const b = t => {
                    var e, n, i = fl(u, f, y, m, t.x, t.y);
                    if (a) {
                        const s = r.projection.project(i.lon, i.lat);
                        e = s.x,
                        n = s.y,
                        t.x = Math.round(bo * (e * r.scale - r.x)),
                        t.y = Math.round(bo * (n * r.scale - r._tileY) / r._tileH),
                        t.y < 0 ? t.y = 0 : t.y > bo && (t.y = bo),
                        t.x < 0 ? t.x = 0 : t.x > bo && (t.x = bo);
                    } else {
                        e = (180 + i.lon) / 360;
                        var s = i.lat;
                        n = -90 == s ? 1 : 90 == s ? 0 : (180 - v * Math.log(Math.tan(g + s * x))) / 360,
                        t.x = Math.round(bo * (e * c - o)),
                        t.y = Math.round(bo * (n * c - h) / p);
                    }
                }
                ;
                for (let e = 0; e < n.length; e++)
                    if (a && 1 !== t.type)
                        n[e] = sl(n[e], b, 1);
                    else {
                        const t = [];
                        for (const r of n[e])
                            b(r),
                            t.push(r);
                        n[e] = t;
                    }
                return n
            }
            if (e && r && r.projection.isReprojectedInTileSpace) {
                const i = 1 << e.z
                  , {scale: a, x: o, y: l, projection: u} = r
                  , c = t => {
                    const r = Wo((e.x + t.x / s) / i)
                      , n = Qo((e.y + t.y / s) / i)
                      , c = u.project(r, n);
                    t.x = (c.x * a - o) * s,
                    t.y = (c.y * a - l) * s;
                }
                ;
                for (let e = 0; e < n.length; e++)
                    if (1 !== t.type)
                        n[e] = sl(n[e], c, 1);
                    else {
                        const t = [];
                        for (const r of n[e])
                            r.x < 0 || r.x >= s || r.y < 0 || r.y >= s || (c(r),
                            t.push(r));
                        n[e] = t;
                    }
            }
            for (const t of n)
                for (const e of t)
                    _l(e, a);
            return n
        }
        function Al(t, e) {
            return {
                type: t.type,
                id: t.id,
                properties: t.properties,
                geometry: e ? wl(t) : []
            }
        }
        function kl(t, e, r, n, i) {
            t.emplaceBack(2 * e + (n + 1) / 2, 2 * r + (i + 1) / 2);
        }
        function zl(t, e, r) {
            const n = 16384;
            t.emplaceBack(e.x, e.y, e.z, r[0] * n, r[1] * n, r[2] * n);
        }
        class Sl {
            constructor(t) {
                this.zoom = t.zoom,
                this.overscaling = t.overscaling,
                this.layers = t.layers,
                this.layerIds = this.layers.map((t => t.id)),
                this.index = t.index,
                this.hasPattern = !1,
                this.projection = t.projection,
                this.layoutVertexArray = new Ks,
                this.indexArray = new pa,
                this.segments = new vo,
                this.programConfigurations = new lo(t.layers,t.zoom),
                this.stateDependentLayerIds = this.layers.filter((t => t.isStateDependent())).map((t => t.id));
            }
            populate(t, e, r, n) {
                const i = this.layers[0]
                  , s = [];
                let a = null;
                "circle" === i.type && (a = i.layout.get("circle-sort-key"));
                for (const {feature: e, id: i, index: o, sourceLayerIndex: l, order: u} of t) {
                    const t = this.layers[0]._featureFilter.needGeometry
                      , c = Al(e, t);
                    if (!this.layers[0]._featureFilter.filter(new Ts(this.zoom), c, r))
                        continue;
                    const h = a ? a.evaluate(c, {}, r) : void 0
                      , p = {
                        id: i,
                        properties: e.properties,
                        type: e.type,
                        sourceLayerIndex: l,
                        index: o,
                        geometry: t ? c.geometry : wl(e, r, n),
                        patterns: {},
                        sortKey: h,
                        order: u
                    };
                    s.push(p);
                }
                a && s.sort(( (t, e) => t.sortKey - e.sortKey));
                let o = null;
                "globe" === n.projection.name && (this.globeExtVertexArray = new Fa,
                o = n.projection);
                for (const n of s) {
                    const {geometry: i, index: s, sourceLayerIndex: a, order: l} = n
                      , u = t[l].feature;
                    this.addFeature(n, i, s, e.availableImages, r, o),
                    e.featureIndex.insert(u, i, s, a, this.index);
                }
            }
            update(t, e, r, n) {
                this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload
            }
            upload(t) {
                this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, go.members),
                this.indexBuffer = t.createIndexBuffer(this.indexArray),
                this.globeExtVertexArray && (this.globeExtVertexBuffer = t.createVertexBuffer(this.globeExtVertexArray, xo.members))),
                this.programConfigurations.upload(t),
                this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                this.indexBuffer.destroy(),
                this.programConfigurations.destroy(),
                this.segments.destroy(),
                this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
            }
            addFeature(t, e, r, n, i, s) {
                for (const r of e)
                    for (const e of r) {
                        const r = e.x
                          , n = e.y;
                        if (r < 0 || r >= bo || n < 0 || n >= bo)
                            continue;
                        if (s) {
                            const t = s.projectTilePoint(r, n, i)
                              , e = s.upVector(i, r, n)
                              , a = this.globeExtVertexArray;
                            zl(a, t, e),
                            zl(a, t, e),
                            zl(a, t, e),
                            zl(a, t, e);
                        }
                        const a = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t.sortKey)
                          , o = a.vertexLength;
                        kl(this.layoutVertexArray, r, n, -1, -1),
                        kl(this.layoutVertexArray, r, n, 1, -1),
                        kl(this.layoutVertexArray, r, n, 1, 1),
                        kl(this.layoutVertexArray, r, n, -1, 1),
                        this.indexArray.emplaceBack(o, o + 1, o + 2),
                        this.indexArray.emplaceBack(o, o + 2, o + 3),
                        a.vertexLength += 4,
                        a.primitiveLength += 2;
                    }
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, {}, n, i);
            }
        }
        function Ml(t, e) {
            for (let r = 0; r < t.length; r++)
                if (Fl(e, t[r]))
                    return !0;
            for (let r = 0; r < e.length; r++)
                if (Fl(t, e[r]))
                    return !0;
            return !!Cl(t, e)
        }
        function Il(t, e, r) {
            return !!Fl(t, e) || !!Pl(e, t, r)
        }
        function Tl(t, e) {
            if (1 === t.length)
                return El(e, t[0]);
            for (let r = 0; r < e.length; r++) {
                const n = e[r];
                for (let e = 0; e < n.length; e++)
                    if (Fl(t, n[e]))
                        return !0
            }
            for (let r = 0; r < t.length; r++)
                if (El(e, t[r]))
                    return !0;
            for (let r = 0; r < e.length; r++)
                if (Cl(t, e[r]))
                    return !0;
            return !1
        }
        function Bl(t, e, r) {
            if (t.length > 1) {
                if (Cl(t, e))
                    return !0;
                for (let n = 0; n < e.length; n++)
                    if (Pl(e[n], t, r))
                        return !0
            }
            for (let n = 0; n < t.length; n++)
                if (Pl(t[n], e, r))
                    return !0;
            return !1
        }
        function Cl(t, e) {
            if (0 === t.length || 0 === e.length)
                return !1;
            for (let r = 0; r < t.length - 1; r++) {
                const n = t[r]
                  , i = t[r + 1];
                for (let t = 0; t < e.length - 1; t++)
                    if (Vl(n, i, e[t], e[t + 1]))
                        return !0
            }
            return !1
        }
        function Vl(t, e, r, n) {
            return C(t, r, n) !== C(e, r, n) && C(t, e, r) !== C(t, e, n)
        }
        function Pl(t, e, r) {
            const n = r * r;
            if (1 === e.length)
                return t.distSqr(e[0]) < n;
            for (let r = 1; r < e.length; r++)
                if (Dl(t, e[r - 1], e[r]) < n)
                    return !0;
            return !1
        }
        function Dl(t, e, r) {
            const n = e.distSqr(r);
            if (0 === n)
                return t.distSqr(e);
            const i = ((t.x - e.x) * (r.x - e.x) + (t.y - e.y) * (r.y - e.y)) / n;
            return t.distSqr(i < 0 ? e : i > 1 ? r : r.sub(e)._mult(i)._add(e))
        }
        function El(t, e) {
            let r, n, i, s = !1;
            for (let a = 0; a < t.length; a++) {
                r = t[a];
                for (let t = 0, a = r.length - 1; t < r.length; a = t++)
                    n = r[t],
                    i = r[a],
                    n.y > e.y != i.y > e.y && e.x < (i.x - n.x) * (e.y - n.y) / (i.y - n.y) + n.x && (s = !s);
            }
            return s
        }
        function Fl(t, e) {
            let r = !1;
            for (let n = 0, i = t.length - 1; n < t.length; i = n++) {
                const s = t[n]
                  , a = t[i];
                s.y > e.y != a.y > e.y && e.x < (a.x - s.x) * (e.y - s.y) / (a.y - s.y) + s.x && (r = !r);
            }
            return r
        }
        function Ll(t, e, r, n, s) {
            for (const i of t)
                if (e <= i.x && r <= i.y && n >= i.x && s >= i.y)
                    return !0;
            const a = [new i(e,r), new i(e,s), new i(n,s), new i(n,r)];
            if (t.length > 2)
                for (const e of a)
                    if (Fl(t, e))
                        return !0;
            for (let e = 0; e < t.length - 1; e++)
                if (Rl(t[e], t[e + 1], a))
                    return !0;
            return !1
        }
        function Rl(t, e, r) {
            const n = r[0]
              , i = r[2];
            if (t.x < n.x && e.x < n.x || t.x > i.x && e.x > i.x || t.y < n.y && e.y < n.y || t.y > i.y && e.y > i.y)
                return !1;
            const s = C(t, e, r[0]);
            return s !== C(t, e, r[1]) || s !== C(t, e, r[2]) || s !== C(t, e, r[3])
        }
        function jl(t, e, r) {
            const n = e.paint.get(t).value;
            return "constant" === n.kind ? n.value : r.programConfigurations.get(e.id).getMaxValue(t)
        }
        function Ul(t) {
            return Math.sqrt(t[0] * t[0] + t[1] * t[1])
        }
        function Ol(t, e, r, n, s) {
            if (!e[0] && !e[1])
                return t;
            const a = i.convert(e)._mult(s);
            "viewport" === r && a._rotate(-n);
            const o = [];
            for (let e = 0; e < t.length; e++)
                o.push(t[e].sub(a));
            return o
        }
        function $l(t, e, r, n) {
            const s = i.convert(t)._mult(n);
            return "viewport" === e && s._rotate(-r),
            s
        }
        Bi(Sl, "CircleBucket", {
            omit: ["layers"]
        });
        const ql = new qs({
            "circle-sort-key": new js(qt.layout_circle["circle-sort-key"])
        });
        var Nl = {
            paint: new qs({
                "circle-radius": new js(qt.paint_circle["circle-radius"]),
                "circle-color": new js(qt.paint_circle["circle-color"]),
                "circle-blur": new js(qt.paint_circle["circle-blur"]),
                "circle-opacity": new js(qt.paint_circle["circle-opacity"]),
                "circle-translate": new Rs(qt.paint_circle["circle-translate"]),
                "circle-translate-anchor": new Rs(qt.paint_circle["circle-translate-anchor"]),
                "circle-pitch-scale": new Rs(qt.paint_circle["circle-pitch-scale"]),
                "circle-pitch-alignment": new Rs(qt.paint_circle["circle-pitch-alignment"]),
                "circle-stroke-width": new js(qt.paint_circle["circle-stroke-width"]),
                "circle-stroke-color": new js(qt.paint_circle["circle-stroke-color"]),
                "circle-stroke-opacity": new js(qt.paint_circle["circle-stroke-opacity"]),
                "circle-minzoom": new js(qt.paint_circle["circle-minzoom"]),
                "circle-maxzoom": new js(qt.paint_circle["circle-maxzoom"])
            }),
            layout: ql
        }
          , Zl = 1e-6
          , Gl = "undefined" != typeof Float32Array ? Float32Array : Array;
        function Xl() {
            var t = new Gl(9);
            return Gl != Float32Array && (t[1] = 0,
            t[2] = 0,
            t[3] = 0,
            t[5] = 0,
            t[6] = 0,
            t[7] = 0),
            t[0] = 1,
            t[4] = 1,
            t[8] = 1,
            t
        }
        function Yl(t, e, r) {
            var n = e[0]
              , i = e[1]
              , s = e[2]
              , a = e[3]
              , o = e[4]
              , l = e[5]
              , u = e[6]
              , c = e[7]
              , h = e[8]
              , p = r[0]
              , f = r[1]
              , d = r[2]
              , y = r[3]
              , m = r[4]
              , g = r[5]
              , x = r[6]
              , v = r[7]
              , b = r[8];
            return t[0] = p * n + f * a + d * u,
            t[1] = p * i + f * o + d * c,
            t[2] = p * s + f * l + d * h,
            t[3] = y * n + m * a + g * u,
            t[4] = y * i + m * o + g * c,
            t[5] = y * s + m * l + g * h,
            t[6] = x * n + v * a + b * u,
            t[7] = x * i + v * o + b * c,
            t[8] = x * s + v * l + b * h,
            t
        }
        function Hl(t) {
            return t[0] = 1,
            t[1] = 0,
            t[2] = 0,
            t[3] = 0,
            t[4] = 0,
            t[5] = 1,
            t[6] = 0,
            t[7] = 0,
            t[8] = 0,
            t[9] = 0,
            t[10] = 1,
            t[11] = 0,
            t[12] = 0,
            t[13] = 0,
            t[14] = 0,
            t[15] = 1,
            t
        }
        function Kl(t, e) {
            var r = e[0]
              , n = e[1]
              , i = e[2]
              , s = e[3]
              , a = e[4]
              , o = e[5]
              , l = e[6]
              , u = e[7]
              , c = e[8]
              , h = e[9]
              , p = e[10]
              , f = e[11]
              , d = e[12]
              , y = e[13]
              , m = e[14]
              , g = e[15]
              , x = r * o - n * a
              , v = r * l - i * a
              , b = r * u - s * a
              , _ = n * l - i * o
              , w = n * u - s * o
              , A = i * u - s * l
              , k = c * y - h * d
              , z = c * m - p * d
              , S = c * g - f * d
              , M = h * m - p * y
              , I = h * g - f * y
              , T = p * g - f * m
              , B = x * T - v * I + b * M + _ * S - w * z + A * k;
            return B ? (t[0] = (o * T - l * I + u * M) * (B = 1 / B),
            t[1] = (i * I - n * T - s * M) * B,
            t[2] = (y * A - m * w + g * _) * B,
            t[3] = (p * w - h * A - f * _) * B,
            t[4] = (l * S - a * T - u * z) * B,
            t[5] = (r * T - i * S + s * z) * B,
            t[6] = (m * b - d * A - g * v) * B,
            t[7] = (c * A - p * b + f * v) * B,
            t[8] = (a * I - o * S + u * k) * B,
            t[9] = (n * S - r * I - s * k) * B,
            t[10] = (d * w - y * b + g * x) * B,
            t[11] = (h * b - c * w - f * x) * B,
            t[12] = (o * z - a * M - l * k) * B,
            t[13] = (r * M - n * z + i * k) * B,
            t[14] = (y * v - d * _ - m * x) * B,
            t[15] = (c * _ - h * v + p * x) * B,
            t) : null
        }
        function Jl(t, e, r) {
            var n = e[0]
              , i = e[1]
              , s = e[2]
              , a = e[3]
              , o = e[4]
              , l = e[5]
              , u = e[6]
              , c = e[7]
              , h = e[8]
              , p = e[9]
              , f = e[10]
              , d = e[11]
              , y = e[12]
              , m = e[13]
              , g = e[14]
              , x = e[15]
              , v = r[0]
              , b = r[1]
              , _ = r[2]
              , w = r[3];
            return t[0] = v * n + b * o + _ * h + w * y,
            t[1] = v * i + b * l + _ * p + w * m,
            t[2] = v * s + b * u + _ * f + w * g,
            t[3] = v * a + b * c + _ * d + w * x,
            t[4] = (v = r[4]) * n + (b = r[5]) * o + (_ = r[6]) * h + (w = r[7]) * y,
            t[5] = v * i + b * l + _ * p + w * m,
            t[6] = v * s + b * u + _ * f + w * g,
            t[7] = v * a + b * c + _ * d + w * x,
            t[8] = (v = r[8]) * n + (b = r[9]) * o + (_ = r[10]) * h + (w = r[11]) * y,
            t[9] = v * i + b * l + _ * p + w * m,
            t[10] = v * s + b * u + _ * f + w * g,
            t[11] = v * a + b * c + _ * d + w * x,
            t[12] = (v = r[12]) * n + (b = r[13]) * o + (_ = r[14]) * h + (w = r[15]) * y,
            t[13] = v * i + b * l + _ * p + w * m,
            t[14] = v * s + b * u + _ * f + w * g,
            t[15] = v * a + b * c + _ * d + w * x,
            t
        }
        function Wl(t, e, r) {
            var n, i, s, a, o, l, u, c, h, p, f, d, y = r[0], m = r[1], g = r[2];
            return e === t ? (t[12] = e[0] * y + e[4] * m + e[8] * g + e[12],
            t[13] = e[1] * y + e[5] * m + e[9] * g + e[13],
            t[14] = e[2] * y + e[6] * m + e[10] * g + e[14],
            t[15] = e[3] * y + e[7] * m + e[11] * g + e[15]) : (i = e[1],
            s = e[2],
            a = e[3],
            o = e[4],
            l = e[5],
            u = e[6],
            c = e[7],
            h = e[8],
            p = e[9],
            f = e[10],
            d = e[11],
            t[0] = n = e[0],
            t[1] = i,
            t[2] = s,
            t[3] = a,
            t[4] = o,
            t[5] = l,
            t[6] = u,
            t[7] = c,
            t[8] = h,
            t[9] = p,
            t[10] = f,
            t[11] = d,
            t[12] = n * y + o * m + h * g + e[12],
            t[13] = i * y + l * m + p * g + e[13],
            t[14] = s * y + u * m + f * g + e[14],
            t[15] = a * y + c * m + d * g + e[15]),
            t
        }
        function Ql(t, e, r) {
            var n = r[0]
              , i = r[1]
              , s = r[2];
            return t[0] = e[0] * n,
            t[1] = e[1] * n,
            t[2] = e[2] * n,
            t[3] = e[3] * n,
            t[4] = e[4] * i,
            t[5] = e[5] * i,
            t[6] = e[6] * i,
            t[7] = e[7] * i,
            t[8] = e[8] * s,
            t[9] = e[9] * s,
            t[10] = e[10] * s,
            t[11] = e[11] * s,
            t[12] = e[12],
            t[13] = e[13],
            t[14] = e[14],
            t[15] = e[15],
            t
        }
        function tu(t, e, r) {
            var n = Math.sin(r)
              , i = Math.cos(r)
              , s = e[4]
              , a = e[5]
              , o = e[6]
              , l = e[7]
              , u = e[8]
              , c = e[9]
              , h = e[10]
              , p = e[11];
            return e !== t && (t[0] = e[0],
            t[1] = e[1],
            t[2] = e[2],
            t[3] = e[3],
            t[12] = e[12],
            t[13] = e[13],
            t[14] = e[14],
            t[15] = e[15]),
            t[4] = s * i + u * n,
            t[5] = a * i + c * n,
            t[6] = o * i + h * n,
            t[7] = l * i + p * n,
            t[8] = u * i - s * n,
            t[9] = c * i - a * n,
            t[10] = h * i - o * n,
            t[11] = p * i - l * n,
            t
        }
        function eu(t, e, r) {
            var n = Math.sin(r)
              , i = Math.cos(r)
              , s = e[0]
              , a = e[1]
              , o = e[2]
              , l = e[3]
              , u = e[8]
              , c = e[9]
              , h = e[10]
              , p = e[11];
            return e !== t && (t[4] = e[4],
            t[5] = e[5],
            t[6] = e[6],
            t[7] = e[7],
            t[12] = e[12],
            t[13] = e[13],
            t[14] = e[14],
            t[15] = e[15]),
            t[0] = s * i - u * n,
            t[1] = a * i - c * n,
            t[2] = o * i - h * n,
            t[3] = l * i - p * n,
            t[8] = s * n + u * i,
            t[9] = a * n + c * i,
            t[10] = o * n + h * i,
            t[11] = l * n + p * i,
            t
        }
        function ru(t, e) {
            return t[0] = e[0],
            t[1] = 0,
            t[2] = 0,
            t[3] = 0,
            t[4] = 0,
            t[5] = e[1],
            t[6] = 0,
            t[7] = 0,
            t[8] = 0,
            t[9] = 0,
            t[10] = e[2],
            t[11] = 0,
            t[12] = 0,
            t[13] = 0,
            t[14] = 0,
            t[15] = 1,
            t
        }
        function nu(t, e, r) {
            var n, i, s, a = r[0], o = r[1], l = r[2], u = Math.hypot(a, o, l);
            return u < Zl ? null : (a *= u = 1 / u,
            o *= u,
            l *= u,
            n = Math.sin(e),
            i = Math.cos(e),
            t[0] = a * a * (s = 1 - i) + i,
            t[1] = o * a * s + l * n,
            t[2] = l * a * s - o * n,
            t[3] = 0,
            t[4] = a * o * s - l * n,
            t[5] = o * o * s + i,
            t[6] = l * o * s + a * n,
            t[7] = 0,
            t[8] = a * l * s + o * n,
            t[9] = o * l * s - a * n,
            t[10] = l * l * s + i,
            t[11] = 0,
            t[12] = 0,
            t[13] = 0,
            t[14] = 0,
            t[15] = 1,
            t)
        }
        Math.hypot || (Math.hypot = function() {
            for (var t = 0, e = arguments.length; e--; )
                t += arguments[e] * arguments[e];
            return Math.sqrt(t)
        }
        );
        var iu = Jl;
        function su() {
            var t = new Gl(3);
            return Gl != Float32Array && (t[0] = 0,
            t[1] = 0,
            t[2] = 0),
            t
        }
        function au(t) {
            var e = new Gl(3);
            return e[0] = t[0],
            e[1] = t[1],
            e[2] = t[2],
            e
        }
        function ou(t) {
            return Math.hypot(t[0], t[1], t[2])
        }
        function lu(t, e, r) {
            var n = new Gl(3);
            return n[0] = t,
            n[1] = e,
            n[2] = r,
            n
        }
        function uu(t, e, r) {
            return t[0] = e[0] + r[0],
            t[1] = e[1] + r[1],
            t[2] = e[2] + r[2],
            t
        }
        function cu(t, e, r) {
            return t[0] = e[0] - r[0],
            t[1] = e[1] - r[1],
            t[2] = e[2] - r[2],
            t
        }
        function hu(t, e, r) {
            return t[0] = e[0] * r[0],
            t[1] = e[1] * r[1],
            t[2] = e[2] * r[2],
            t
        }
        function pu(t, e, r) {
            return t[0] = Math.min(e[0], r[0]),
            t[1] = Math.min(e[1], r[1]),
            t[2] = Math.min(e[2], r[2]),
            t
        }
        function fu(t, e, r) {
            return t[0] = Math.max(e[0], r[0]),
            t[1] = Math.max(e[1], r[1]),
            t[2] = Math.max(e[2], r[2]),
            t
        }
        function du(t, e, r) {
            return t[0] = e[0] * r,
            t[1] = e[1] * r,
            t[2] = e[2] * r,
            t
        }
        function yu(t, e, r, n) {
            return t[0] = e[0] + r[0] * n,
            t[1] = e[1] + r[1] * n,
            t[2] = e[2] + r[2] * n,
            t
        }
        function mu(t, e) {
            var r = e[0]
              , n = e[1]
              , i = e[2]
              , s = r * r + n * n + i * i;
            return s > 0 && (s = 1 / Math.sqrt(s)),
            t[0] = e[0] * s,
            t[1] = e[1] * s,
            t[2] = e[2] * s,
            t
        }
        function gu(t, e) {
            return t[0] * e[0] + t[1] * e[1] + t[2] * e[2]
        }
        function xu(t, e, r) {
            var n = e[0]
              , i = e[1]
              , s = e[2]
              , a = r[0]
              , o = r[1]
              , l = r[2];
            return t[0] = i * l - s * o,
            t[1] = s * a - n * l,
            t[2] = n * o - i * a,
            t
        }
        function vu(t, e, r) {
            var n = e[0]
              , i = e[1]
              , s = e[2]
              , a = r[3] * n + r[7] * i + r[11] * s + r[15];
            return t[0] = (r[0] * n + r[4] * i + r[8] * s + r[12]) / (a = a || 1),
            t[1] = (r[1] * n + r[5] * i + r[9] * s + r[13]) / a,
            t[2] = (r[2] * n + r[6] * i + r[10] * s + r[14]) / a,
            t
        }
        function bu(t, e, r) {
            var n = r[0]
              , i = r[1]
              , s = r[2]
              , a = e[0]
              , o = e[1]
              , l = e[2]
              , u = i * l - s * o
              , c = s * a - n * l
              , h = n * o - i * a
              , p = i * h - s * c
              , f = s * u - n * h
              , d = n * c - i * u
              , y = 2 * r[3];
            return c *= y,
            h *= y,
            f *= 2,
            d *= 2,
            t[0] = a + (u *= y) + (p *= 2),
            t[1] = o + c + f,
            t[2] = l + h + d,
            t
        }
        var _u, wu = cu, Au = hu, ku = ou;
        function zu(t, e, r) {
            return t[0] = e[0] * r,
            t[1] = e[1] * r,
            t[2] = e[2] * r,
            t[3] = e[3] * r,
            t
        }
        function Su(t, e, r) {
            var n = e[0]
              , i = e[1]
              , s = e[2]
              , a = e[3];
            return t[0] = r[0] * n + r[4] * i + r[8] * s + r[12] * a,
            t[1] = r[1] * n + r[5] * i + r[9] * s + r[13] * a,
            t[2] = r[2] * n + r[6] * i + r[10] * s + r[14] * a,
            t[3] = r[3] * n + r[7] * i + r[11] * s + r[15] * a,
            t
        }
        function Mu() {
            var t = new Gl(4);
            return Gl != Float32Array && (t[0] = 0,
            t[1] = 0,
            t[2] = 0),
            t[3] = 1,
            t
        }
        function Iu(t) {
            return t[0] = 0,
            t[1] = 0,
            t[2] = 0,
            t[3] = 1,
            t
        }
        function Tu(t, e, r) {
            r *= .5;
            var n = e[0]
              , i = e[1]
              , s = e[2]
              , a = e[3]
              , o = Math.sin(r)
              , l = Math.cos(r);
            return t[0] = n * l + a * o,
            t[1] = i * l + s * o,
            t[2] = s * l - i * o,
            t[3] = a * l - n * o,
            t
        }
        function Bu(t, e, r) {
            r *= .5;
            var n = e[0]
              , i = e[1]
              , s = e[2]
              , a = e[3]
              , o = Math.sin(r)
              , l = Math.cos(r);
            return t[0] = n * l - s * o,
            t[1] = i * l + a * o,
            t[2] = s * l + n * o,
            t[3] = a * l - i * o,
            t
        }
        function Cu() {
            var t = new Gl(2);
            return Gl != Float32Array && (t[0] = 0,
            t[1] = 0),
            t
        }
        function Vu(t, e, r) {
            return t[0] = e[0] + r[0],
            t[1] = e[1] + r[1],
            t
        }
        function Pu(t, e, r) {
            return t[0] = e[0] - r[0],
            t[1] = e[1] - r[1],
            t
        }
        function Du(t, e, r) {
            return t[0] = e[0] * r,
            t[1] = e[1] * r,
            t
        }
        function Eu(t) {
            return Math.hypot(t[0], t[1])
        }
        function Fu(t, e) {
            var r = e[0]
              , n = e[1]
              , i = r * r + n * n;
            return i > 0 && (i = 1 / Math.sqrt(i)),
            t[0] = e[0] * i,
            t[1] = e[1] * i,
            t
        }
        function Lu(t, e) {
            return t[0] * e[0] + t[1] * e[1]
        }
        su(),
        _u = new Gl(4),
        Gl != Float32Array && (_u[0] = 0,
        _u[1] = 0,
        _u[2] = 0,
        _u[3] = 0),
        su(),
        lu(1, 0, 0),
        lu(0, 1, 0),
        Mu(),
        Mu(),
        Xl();
        var Ru = Pu;
        Cu();
        class ju {
            constructor(t, e) {
                this.pos = t,
                this.dir = e;
            }
            intersectsPlane(t, e, r) {
                const n = gu(e, this.dir);
                if (Math.abs(n) < 1e-6)
                    return !1;
                const i = ((t[0] - this.pos[0]) * e[0] + (t[1] - this.pos[1]) * e[1] + (t[2] - this.pos[2]) * e[2]) / n;
                return r[0] = this.pos[0] + this.dir[0] * i,
                r[1] = this.pos[1] + this.dir[1] * i,
                r[2] = this.pos[2] + this.dir[2] * i,
                !0
            }
            closestPointOnSphere(t, e, r) {
                if (function(t, e) {
                    var r = t[0]
                      , n = t[1]
                      , i = t[2]
                      , s = e[0]
                      , a = e[1]
                      , o = e[2];
                    return Math.abs(r - s) <= Zl * Math.max(1, Math.abs(r), Math.abs(s)) && Math.abs(n - a) <= Zl * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(i - o) <= Zl * Math.max(1, Math.abs(i), Math.abs(o))
                }(this.pos, t) || 0 === e)
                    return r[0] = r[1] = r[2] = 0,
                    !1;
                const [n,i,s] = this.dir
                  , a = this.pos[0] - t[0]
                  , o = this.pos[1] - t[1]
                  , l = this.pos[2] - t[2]
                  , u = n * n + i * i + s * s
                  , c = 2 * (a * n + o * i + l * s)
                  , h = c * c - 4 * u * (a * a + o * o + l * l - e * e);
                if (h < 0) {
                    const t = Math.max(-c / 2, 0)
                      , u = a + n * t
                      , h = o + i * t
                      , p = l + s * t
                      , f = Math.hypot(u, h, p);
                    return r[0] = u * e / f,
                    r[1] = h * e / f,
                    r[2] = p * e / f,
                    !1
                }
                {
                    const t = (-c - Math.sqrt(h)) / (2 * u);
                    if (t < 0) {
                        const t = Math.hypot(a, o, l);
                        return r[0] = a * e / t,
                        r[1] = o * e / t,
                        r[2] = l * e / t,
                        !1
                    }
                    return r[0] = a + n * t,
                    r[1] = o + i * t,
                    r[2] = l + s * t,
                    !0
                }
            }
        }
        class Uu {
            constructor(t, e, r, n, i) {
                this.TL = t,
                this.TR = e,
                this.BR = r,
                this.BL = n,
                this.horizon = i;
            }
            static fromInvProjectionMatrix(t, e, r) {
                const n = [-1, 1, 1]
                  , i = [1, 1, 1]
                  , s = [1, -1, 1]
                  , a = [-1, -1, 1]
                  , o = vu(n, n, t)
                  , l = vu(i, i, t)
                  , u = vu(s, s, t)
                  , c = vu(a, a, t);
                return new Uu(o,l,u,c,e / r)
            }
        }
        class Ou {
            constructor(t, e) {
                this.points = t,
                this.planes = e;
            }
            static fromInvProjectionMatrix(t, e, r, n) {
                const i = Math.pow(2, r)
                  , s = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((r => {
                    const s = Su([], r, t)
                      , a = 1 / s[3] / e * i;
                    return function(t, e, r) {
                        return t[0] = e[0] * r[0],
                        t[1] = e[1] * r[1],
                        t[2] = e[2] * r[2],
                        t[3] = e[3] * r[3],
                        t
                    }(s, s, [a, a, n ? 1 / s[3] : a, a])
                }
                ))
                  , a = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((t => {
                    const e = mu([], xu([], wu([], s[t[0]], s[t[1]]), wu([], s[t[2]], s[t[1]])))
                      , r = -gu(e, s[t[1]]);
                    return e.concat(r)
                }
                ));
                return new Ou(s,a)
            }
        }
        class $u {
            static fromPoints(t) {
                const e = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE]
                  , r = [Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE];
                for (const n of t)
                    e[0] = Math.min(e[0], n[0]),
                    e[1] = Math.min(e[1], n[1]),
                    e[2] = Math.min(e[2], n[2]),
                    r[0] = Math.max(r[0], n[0]),
                    r[1] = Math.max(r[1], n[1]),
                    r[2] = Math.max(r[2], n[2]);
                return new $u(e,r)
            }
            constructor(t, e) {
                this.min = t,
                this.max = e,
                this.center = du([], uu([], this.min, this.max), .5);
            }
            quadrant(t) {
                const e = [t % 2 == 0, t < 2]
                  , r = au(this.min)
                  , n = au(this.max);
                for (let t = 0; t < e.length; t++)
                    r[t] = e[t] ? this.min[t] : this.center[t],
                    n[t] = e[t] ? this.center[t] : this.max[t];
                return n[2] = this.max[2],
                new $u(r,n)
            }
            distanceX(t) {
                return Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0]
            }
            distanceY(t) {
                return Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1]
            }
            distanceZ(t) {
                return Math.max(Math.min(this.max[2], t[2]), this.min[2]) - t[2]
            }
            getCorners() {
                const t = this.min
                  , e = this.max;
                return [[t[0], t[1], t[2]], [e[0], t[1], t[2]], [e[0], e[1], t[2]], [t[0], e[1], t[2]], [t[0], t[1], e[2]], [e[0], t[1], e[2]], [e[0], e[1], e[2]], [t[0], e[1], e[2]]]
            }
            intersects(t) {
                const e = this.getCorners();
                let r = !0;
                for (let n = 0; n < t.planes.length; n++) {
                    const i = t.planes[n];
                    let s = 0;
                    for (let t = 0; t < e.length; t++)
                        s += gu(i, e[t]) + i[3] >= 0;
                    if (0 === s)
                        return 0;
                    s !== e.length && (r = !1);
                }
                if (r)
                    return 2;
                for (let e = 0; e < 3; e++) {
                    let r = Number.MAX_VALUE
                      , n = -Number.MAX_VALUE;
                    for (let i = 0; i < t.points.length; i++) {
                        const s = t.points[i][e] - this.min[e];
                        r = Math.min(r, s),
                        n = Math.max(n, s);
                    }
                    if (n < 0 || r > this.max[e] - this.min[e])
                        return 0
                }
                return 1
            }
        }
        function qu(t, e, r, n, i, s, a, o, l) {
            if (s && t.queryGeometry.isAboveHorizon)
                return !1;
            s && (l *= t.pixelToTileUnitsFactor);
            const u = t.tileID.canonical
              , c = r.projection.upVectorScale(u, r.center.lat, r.worldSize).metersToTile;
            for (const h of e)
                for (const e of h) {
                    const h = e.add(o)
                      , p = i && r.elevation ? r.elevation.exaggeration() * i.getElevationAt(h.x, h.y, !0) : 0
                      , f = r.projection.projectTilePoint(h.x, h.y, u);
                    if (p > 0) {
                        const t = r.projection.upVector(u, h.x, h.y);
                        f.x += t[0] * c * p,
                        f.y += t[1] * c * p,
                        f.z += t[2] * c * p;
                    }
                    const d = s ? h : Nu(f.x, f.y, f.z, n)
                      , y = s ? t.tilespaceRays.map((t => Xu(t, p))) : t.queryGeometry.screenGeometry
                      , m = Su([], [f.x, f.y, f.z, 1], n);
                    if (!a && s ? l *= m[3] / r.cameraToCenterDistance : a && !s && (l *= r.cameraToCenterDistance / m[3]),
                    s) {
                        const t = Qo(gl(e.y, u) / (1 << u.z));
                        l /= r.projection.pixelsPerMeter(t, 1) / Jo(1, t);
                    }
                    if (Il(y, d, l))
                        return !0
                }
            return !1
        }
        function Nu(t, e, r, n) {
            const s = Su([], [t, e, r, 1], n);
            return new i(s[0] / s[3],s[1] / s[3])
        }
        const Zu = lu(0, 0, 0)
          , Gu = lu(0, 0, 1);
        function Xu(t, e) {
            const r = su();
            return Zu[2] = e,
            t.intersectsPlane(Zu, Gu, r),
            new i(r[0],r[1])
        }
        class Yu extends Sl {
        }
        function Hu(t, {width: e, height: r}, n, i) {
            if (i) {
                if (i instanceof Uint8ClampedArray)
                    i = new Uint8Array(i.buffer);
                else if (i.length !== e * r * n)
                    throw new RangeError("mismatched image size")
            } else
                i = new Uint8Array(e * r * n);
            return t.width = e,
            t.height = r,
            t.data = i,
            t
        }
        function Ku(t, e, r) {
            const {width: n, height: i} = e;
            n === t.width && i === t.height || (Ju(t, e, {
                x: 0,
                y: 0
            }, {
                x: 0,
                y: 0
            }, {
                width: Math.min(t.width, n),
                height: Math.min(t.height, i)
            }, r),
            t.width = n,
            t.height = i,
            t.data = e.data);
        }
        function Ju(t, e, r, n, i, s) {
            if (0 === i.width || 0 === i.height)
                return e;
            if (i.width > t.width || i.height > t.height || r.x > t.width - i.width || r.y > t.height - i.height)
                throw new RangeError("out of range source coordinates for image copy");
            if (i.width > e.width || i.height > e.height || n.x > e.width - i.width || n.y > e.height - i.height)
                throw new RangeError("out of range destination coordinates for image copy");
            const a = t.data
              , o = e.data;
            for (let l = 0; l < i.height; l++) {
                const u = ((r.y + l) * t.width + r.x) * s
                  , c = ((n.y + l) * e.width + n.x) * s;
                for (let t = 0; t < i.width * s; t++)
                    o[c + t] = a[u + t];
            }
            return e
        }
        Bi(Yu, "HeatmapBucket", {
            omit: ["layers"]
        });
        class Wu {
            constructor(t, e) {
                Hu(this, t, 1, e);
            }
            resize(t) {
                Ku(this, new Wu(t), 1);
            }
            clone() {
                return new Wu({
                    width: this.width,
                    height: this.height
                },new Uint8Array(this.data))
            }
            static copy(t, e, r, n, i) {
                Ju(t, e, r, n, i, 1);
            }
        }
        class Qu {
            constructor(t, e) {
                Hu(this, t, 4, e);
            }
            resize(t) {
                Ku(this, new Qu(t), 4);
            }
            replace(t, e) {
                e ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t;
            }
            clone() {
                return new Qu({
                    width: this.width,
                    height: this.height
                },new Uint8Array(this.data))
            }
            static copy(t, e, r, n, i) {
                Ju(t, e, r, n, i, 4);
            }
        }
        Bi(Wu, "AlphaImage"),
        Bi(Qu, "RGBAImage");
        var tc = {
            paint: new qs({
                "heatmap-radius": new js(qt.paint_heatmap["heatmap-radius"]),
                "heatmap-weight": new js(qt.paint_heatmap["heatmap-weight"]),
                "heatmap-intensity": new Rs(qt.paint_heatmap["heatmap-intensity"]),
                "heatmap-color": new $s(qt.paint_heatmap["heatmap-color"]),
                "heatmap-opacity": new Rs(qt.paint_heatmap["heatmap-opacity"])
            })
        };
        function ec(t) {
            const e = {}
              , r = t.resolution || 256
              , n = t.clips ? t.clips.length : 1
              , i = t.image || new Qu({
                width: r,
                height: n
            })
              , s = (r, n, s) => {
                e[t.evaluationKey] = s;
                const a = t.expression.evaluate(e);
                i.data[r + n + 0] = Math.floor(255 * a.r / a.a),
                i.data[r + n + 1] = Math.floor(255 * a.g / a.a),
                i.data[r + n + 2] = Math.floor(255 * a.b / a.a),
                i.data[r + n + 3] = Math.floor(255 * a.a);
            }
            ;
            if (t.clips)
                for (let e = 0, i = 0; e < n; ++e,
                i += 4 * r)
                    for (let n = 0, a = 0; n < r; n++,
                    a += 4) {
                        const o = n / (r - 1)
                          , {start: l, end: u} = t.clips[e];
                        s(i, a, l * (1 - o) + u * o);
                    }
            else
                for (let t = 0, e = 0; t < r; t++,
                e += 4)
                    s(0, e, t / (r - 1));
            return i
        }
        var rc = {
            paint: new qs({
                "hillshade-illumination-direction": new Rs(qt.paint_hillshade["hillshade-illumination-direction"]),
                "hillshade-illumination-anchor": new Rs(qt.paint_hillshade["hillshade-illumination-anchor"]),
                "hillshade-exaggeration": new Rs(qt.paint_hillshade["hillshade-exaggeration"]),
                "hillshade-shadow-color": new Rs(qt.paint_hillshade["hillshade-shadow-color"]),
                "hillshade-highlight-color": new Rs(qt.paint_hillshade["hillshade-highlight-color"]),
                "hillshade-accent-color": new Rs(qt.paint_hillshade["hillshade-accent-color"])
            })
        };
        const nc = Ys([{
            name: "a_pos",
            components: 2,
            type: "Int16"
        }], 4)
          , {members: ic} = nc;
        var sc = oc
          , ac = oc;
        function oc(t, e, r) {
            r = r || 2;
            var n, i, s, a, o, l, u, c = e && e.length, h = c ? e[0] * r : t.length, p = lc(t, 0, h, r, !0), f = [];
            if (!p || p.next === p.prev)
                return f;
            if (c && (p = function(t, e, r, n) {
                var i, s, a, o = [];
                for (i = 0,
                s = e.length; i < s; i++)
                    (a = lc(t, e[i] * n, i < s - 1 ? e[i + 1] * n : t.length, n, !1)) === a.next && (a.steiner = !0),
                    o.push(vc(a));
                for (o.sort(yc),
                i = 0; i < o.length; i++)
                    r = mc(o[i], r);
                return r
            }(t, e, p, r)),
            t.length > 80 * r) {
                n = s = t[0],
                i = a = t[1];
                for (var d = r; d < h; d += r)
                    (o = t[d]) < n && (n = o),
                    (l = t[d + 1]) < i && (i = l),
                    o > s && (s = o),
                    l > a && (a = l);
                u = 0 !== (u = Math.max(s - n, a - i)) ? 32767 / u : 0;
            }
            return cc(p, f, r, n, i, u, 0),
            f
        }
        function lc(t, e, r, n, i) {
            var s, a;
            if (i === Pc(t, e, r, n) > 0)
                for (s = e; s < r; s += n)
                    a = Bc(s, t[s], t[s + 1], a);
            else
                for (s = r - n; s >= e; s -= n)
                    a = Bc(s, t[s], t[s + 1], a);
            return a && kc(a, a.next) && (Cc(a),
            a = a.next),
            a
        }
        function uc(t, e) {
            if (!t)
                return t;
            e || (e = t);
            var r, n = t;
            do {
                if (r = !1,
                n.steiner || !kc(n, n.next) && 0 !== wc(n.prev, n, n.next))
                    n = n.next;
                else {
                    if (Cc(n),
                    (n = e = n.prev) === n.next)
                        break;
                    r = !0;
                }
            } while (r || n !== e);
            return e
        }
        function cc(t, e, r, n, i, s, a) {
            if (t) {
                !a && s && function(t, e, r, n) {
                    var i = t;
                    do {
                        0 === i.z && (i.z = xc(i.x, i.y, e, r, n)),
                        i.prevZ = i.prev,
                        i.nextZ = i.next,
                        i = i.next;
                    } while (i !== t);
                    i.prevZ.nextZ = null,
                    i.prevZ = null,
                    function(t) {
                        var e, r, n, i, s, a, o, l, u = 1;
                        do {
                            for (r = t,
                            t = null,
                            s = null,
                            a = 0; r; ) {
                                for (a++,
                                n = r,
                                o = 0,
                                e = 0; e < u && (o++,
                                n = n.nextZ); e++)
                                    ;
                                for (l = u; o > 0 || l > 0 && n; )
                                    0 !== o && (0 === l || !n || r.z <= n.z) ? (i = r,
                                    r = r.nextZ,
                                    o--) : (i = n,
                                    n = n.nextZ,
                                    l--),
                                    s ? s.nextZ = i : t = i,
                                    i.prevZ = s,
                                    s = i;
                                r = n;
                            }
                            s.nextZ = null,
                            u *= 2;
                        } while (a > 1)
                    }(i);
                }(t, n, i, s);
                for (var o, l, u = t; t.prev !== t.next; )
                    if (o = t.prev,
                    l = t.next,
                    s ? pc(t, n, i, s) : hc(t))
                        e.push(o.i / r | 0),
                        e.push(t.i / r | 0),
                        e.push(l.i / r | 0),
                        Cc(t),
                        t = l.next,
                        u = l.next;
                    else if ((t = l) === u) {
                        a ? 1 === a ? cc(t = fc(uc(t), e, r), e, r, n, i, s, 2) : 2 === a && dc(t, e, r, n, i, s) : cc(uc(t), e, r, n, i, s, 1);
                        break
                    }
            }
        }
        function hc(t) {
            var e = t.prev
              , r = t
              , n = t.next;
            if (wc(e, r, n) >= 0)
                return !1;
            for (var i = e.x, s = r.x, a = n.x, o = e.y, l = r.y, u = n.y, c = i < s ? i < a ? i : a : s < a ? s : a, h = o < l ? o < u ? o : u : l < u ? l : u, p = i > s ? i > a ? i : a : s > a ? s : a, f = o > l ? o > u ? o : u : l > u ? l : u, d = n.next; d !== e; ) {
                if (d.x >= c && d.x <= p && d.y >= h && d.y <= f && bc(i, o, s, l, a, u, d.x, d.y) && wc(d.prev, d, d.next) >= 0)
                    return !1;
                d = d.next;
            }
            return !0
        }
        function pc(t, e, r, n) {
            var i = t.prev
              , s = t
              , a = t.next;
            if (wc(i, s, a) >= 0)
                return !1;
            for (var o = i.x, l = s.x, u = a.x, c = i.y, h = s.y, p = a.y, f = o < l ? o < u ? o : u : l < u ? l : u, d = c < h ? c < p ? c : p : h < p ? h : p, y = o > l ? o > u ? o : u : l > u ? l : u, m = c > h ? c > p ? c : p : h > p ? h : p, g = xc(f, d, e, r, n), x = xc(y, m, e, r, n), v = t.prevZ, b = t.nextZ; v && v.z >= g && b && b.z <= x; ) {
                if (v.x >= f && v.x <= y && v.y >= d && v.y <= m && v !== i && v !== a && bc(o, c, l, h, u, p, v.x, v.y) && wc(v.prev, v, v.next) >= 0)
                    return !1;
                if (v = v.prevZ,
                b.x >= f && b.x <= y && b.y >= d && b.y <= m && b !== i && b !== a && bc(o, c, l, h, u, p, b.x, b.y) && wc(b.prev, b, b.next) >= 0)
                    return !1;
                b = b.nextZ;
            }
            for (; v && v.z >= g; ) {
                if (v.x >= f && v.x <= y && v.y >= d && v.y <= m && v !== i && v !== a && bc(o, c, l, h, u, p, v.x, v.y) && wc(v.prev, v, v.next) >= 0)
                    return !1;
                v = v.prevZ;
            }
            for (; b && b.z <= x; ) {
                if (b.x >= f && b.x <= y && b.y >= d && b.y <= m && b !== i && b !== a && bc(o, c, l, h, u, p, b.x, b.y) && wc(b.prev, b, b.next) >= 0)
                    return !1;
                b = b.nextZ;
            }
            return !0
        }
        function fc(t, e, r) {
            var n = t;
            do {
                var i = n.prev
                  , s = n.next.next;
                !kc(i, s) && zc(i, n, n.next, s) && Ic(i, s) && Ic(s, i) && (e.push(i.i / r | 0),
                e.push(n.i / r | 0),
                e.push(s.i / r | 0),
                Cc(n),
                Cc(n.next),
                n = t = s),
                n = n.next;
            } while (n !== t);
            return uc(n)
        }
        function dc(t, e, r, n, i, s) {
            var a = t;
            do {
                for (var o = a.next.next; o !== a.prev; ) {
                    if (a.i !== o.i && _c(a, o)) {
                        var l = Tc(a, o);
                        return a = uc(a, a.next),
                        l = uc(l, l.next),
                        cc(a, e, r, n, i, s, 0),
                        void cc(l, e, r, n, i, s, 0)
                    }
                    o = o.next;
                }
                a = a.next;
            } while (a !== t)
        }
        function yc(t, e) {
            return t.x - e.x
        }
        function mc(t, e) {
            var r = function(t, e) {
                var r, n = e, i = t.x, s = t.y, a = -1 / 0;
                do {
                    if (s <= n.y && s >= n.next.y && n.next.y !== n.y) {
                        var o = n.x + (s - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                        if (o <= i && o > a && (a = o,
                        r = n.x < n.next.x ? n : n.next,
                        o === i))
                            return r
                    }
                    n = n.next;
                } while (n !== e);
                if (!r)
                    return null;
                var l, u = r, c = r.x, h = r.y, p = 1 / 0;
                n = r;
                do {
                    i >= n.x && n.x >= c && i !== n.x && bc(s < h ? i : a, s, c, h, s < h ? a : i, s, n.x, n.y) && (l = Math.abs(s - n.y) / (i - n.x),
                    Ic(n, t) && (l < p || l === p && (n.x > r.x || n.x === r.x && gc(r, n))) && (r = n,
                    p = l)),
                    n = n.next;
                } while (n !== u);
                return r
            }(t, e);
            if (!r)
                return e;
            var n = Tc(r, t);
            return uc(n, n.next),
            uc(r, r.next)
        }
        function gc(t, e) {
            return wc(t.prev, t, e.prev) < 0 && wc(e.next, t, t.next) < 0
        }
        function xc(t, e, r, n, i) {
            return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - r) * i | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * i | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
        }
        function vc(t) {
            var e = t
              , r = t;
            do {
                (e.x < r.x || e.x === r.x && e.y < r.y) && (r = e),
                e = e.next;
            } while (e !== t);
            return r
        }
        function bc(t, e, r, n, i, s, a, o) {
            return (i - a) * (e - o) >= (t - a) * (s - o) && (t - a) * (n - o) >= (r - a) * (e - o) && (r - a) * (s - o) >= (i - a) * (n - o)
        }
        function _c(t, e) {
            return t.next.i !== e.i && t.prev.i !== e.i && !function(t, e) {
                var r = t;
                do {
                    if (r.i !== t.i && r.next.i !== t.i && r.i !== e.i && r.next.i !== e.i && zc(r, r.next, t, e))
                        return !0;
                    r = r.next;
                } while (r !== t);
                return !1
            }(t, e) && (Ic(t, e) && Ic(e, t) && function(t, e) {
                var r = t
                  , n = !1
                  , i = (t.x + e.x) / 2
                  , s = (t.y + e.y) / 2;
                do {
                    r.y > s != r.next.y > s && r.next.y !== r.y && i < (r.next.x - r.x) * (s - r.y) / (r.next.y - r.y) + r.x && (n = !n),
                    r = r.next;
                } while (r !== t);
                return n
            }(t, e) && (wc(t.prev, t, e.prev) || wc(t, e.prev, e)) || kc(t, e) && wc(t.prev, t, t.next) > 0 && wc(e.prev, e, e.next) > 0)
        }
        function wc(t, e, r) {
            return (e.y - t.y) * (r.x - e.x) - (e.x - t.x) * (r.y - e.y)
        }
        function kc(t, e) {
            return t.x === e.x && t.y === e.y
        }
        function zc(t, e, r, n) {
            var i = Mc(wc(t, e, r))
              , s = Mc(wc(t, e, n))
              , a = Mc(wc(r, n, t))
              , o = Mc(wc(r, n, e));
            return i !== s && a !== o || !(0 !== i || !Sc(t, r, e)) || !(0 !== s || !Sc(t, n, e)) || !(0 !== a || !Sc(r, t, n)) || !(0 !== o || !Sc(r, e, n))
        }
        function Sc(t, e, r) {
            return e.x <= Math.max(t.x, r.x) && e.x >= Math.min(t.x, r.x) && e.y <= Math.max(t.y, r.y) && e.y >= Math.min(t.y, r.y)
        }
        function Mc(t) {
            return t > 0 ? 1 : t < 0 ? -1 : 0
        }
        function Ic(t, e) {
            return wc(t.prev, t, t.next) < 0 ? wc(t, e, t.next) >= 0 && wc(t, t.prev, e) >= 0 : wc(t, e, t.prev) < 0 || wc(t, t.next, e) < 0
        }
        function Tc(t, e) {
            var r = new Vc(t.i,t.x,t.y)
              , n = new Vc(e.i,e.x,e.y)
              , i = t.next
              , s = e.prev;
            return t.next = e,
            e.prev = t,
            r.next = i,
            i.prev = r,
            n.next = r,
            r.prev = n,
            s.next = n,
            n.prev = s,
            n
        }
        function Bc(t, e, r, n) {
            var i = new Vc(t,e,r);
            return n ? (i.next = n.next,
            i.prev = n,
            n.next.prev = i,
            n.next = i) : (i.prev = i,
            i.next = i),
            i
        }
        function Cc(t) {
            t.next.prev = t.prev,
            t.prev.next = t.next,
            t.prevZ && (t.prevZ.nextZ = t.nextZ),
            t.nextZ && (t.nextZ.prevZ = t.prevZ);
        }
        function Vc(t, e, r) {
            this.i = t,
            this.x = e,
            this.y = r,
            this.prev = null,
            this.next = null,
            this.z = 0,
            this.prevZ = null,
            this.nextZ = null,
            this.steiner = !1;
        }
        function Pc(t, e, r, n) {
            for (var i = 0, s = e, a = r - n; s < r; s += n)
                i += (t[a] - t[s]) * (t[s + 1] + t[a + 1]),
                a = s;
            return i
        }
        function Dc(t, e, r, n, i) {
            Ec(t, e, r || 0, n || t.length - 1, i || Lc);
        }
        function Ec(t, e, r, n, i) {
            for (; n > r; ) {
                if (n - r > 600) {
                    var s = n - r + 1
                      , a = e - r + 1
                      , o = Math.log(s)
                      , l = .5 * Math.exp(2 * o / 3)
                      , u = .5 * Math.sqrt(o * l * (s - l) / s) * (a - s / 2 < 0 ? -1 : 1);
                    Ec(t, e, Math.max(r, Math.floor(e - a * l / s + u)), Math.min(n, Math.floor(e + (s - a) * l / s + u)), i);
                }
                var c = t[e]
                  , h = r
                  , p = n;
                for (Fc(t, r, e),
                i(t[n], c) > 0 && Fc(t, r, n); h < p; ) {
                    for (Fc(t, h, p),
                    h++,
                    p--; i(t[h], c) < 0; )
                        h++;
                    for (; i(t[p], c) > 0; )
                        p--;
                }
                0 === i(t[r], c) ? Fc(t, r, p) : Fc(t, ++p, n),
                p <= e && (r = p + 1),
                e <= p && (n = p - 1);
            }
        }
        function Fc(t, e, r) {
            var n = t[e];
            t[e] = t[r],
            t[r] = n;
        }
        function Lc(t, e) {
            return t < e ? -1 : t > e ? 1 : 0
        }
        function Rc(t, e) {
            const r = t.length;
            if (r <= 1)
                return [t];
            const n = [];
            let i, s;
            for (let e = 0; e < r; e++) {
                const r = V(t[e]);
                0 !== r && (t[e].area = Math.abs(r),
                void 0 === s && (s = r < 0),
                s === r < 0 ? (i && n.push(i),
                i = [t[e]]) : i.push(t[e]));
            }
            if (i && n.push(i),
            e > 1)
                for (let t = 0; t < n.length; t++)
                    n[t].length <= e || (Dc(n[t], e, 1, n[t].length - 1, jc),
                    n[t] = n[t].slice(0, e));
            return n
        }
        function jc(t, e) {
            return e.area - t.area
        }
        function Uc(t, e, r) {
            const n = r.patternDependencies;
            let i = !1;
            for (const r of e) {
                const e = r.paint.get(`${t}-pattern`);
                e.isConstant() || (i = !0);
                const s = e.constantOr(null);
                s && (i = !0,
                n[s.to] = !0,
                n[s.from] = !0);
            }
            return i
        }
        function Oc(t, e, r, n, i) {
            const s = i.patternDependencies;
            for (const a of e) {
                const e = a.paint.get(`${t}-pattern`).value;
                if ("constant" !== e.kind) {
                    let t = e.evaluate({
                        zoom: n - 1
                    }, r, {}, i.availableImages)
                      , o = e.evaluate({
                        zoom: n
                    }, r, {}, i.availableImages)
                      , l = e.evaluate({
                        zoom: n + 1
                    }, r, {}, i.availableImages);
                    t = t && t.name ? t.name : t,
                    o = o && o.name ? o.name : o,
                    l = l && l.name ? l.name : l,
                    s[t] = !0,
                    s[o] = !0,
                    s[l] = !0,
                    r.patterns[a.id] = {
                        min: t,
                        mid: o,
                        max: l
                    };
                }
            }
            return r
        }
        oc.deviation = function(t, e, r, n) {
            var i = e && e.length
              , s = Math.abs(Pc(t, 0, i ? e[0] * r : t.length, r));
            if (i)
                for (var a = 0, o = e.length; a < o; a++)
                    s -= Math.abs(Pc(t, e[a] * r, a < o - 1 ? e[a + 1] * r : t.length, r));
            var l = 0;
            for (a = 0; a < n.length; a += 3) {
                var u = n[a] * r
                  , c = n[a + 1] * r
                  , h = n[a + 2] * r;
                l += Math.abs((t[u] - t[h]) * (t[c + 1] - t[u + 1]) - (t[u] - t[c]) * (t[h + 1] - t[u + 1]));
            }
            return 0 === s && 0 === l ? 0 : Math.abs((l - s) / s)
        }
        ,
        oc.flatten = function(t) {
            for (var e = t[0][0].length, r = {
                vertices: [],
                holes: [],
                dimensions: e
            }, n = 0, i = 0; i < t.length; i++) {
                for (var s = 0; s < t[i].length; s++)
                    for (var a = 0; a < e; a++)
                        r.vertices.push(t[i][s][a]);
                i > 0 && r.holes.push(n += t[i - 1].length);
            }
            return r
        }
        ,
        sc.default = ac;
        class $c {
            constructor(t) {
                this.zoom = t.zoom,
                this.overscaling = t.overscaling,
                this.layers = t.layers,
                this.layerIds = this.layers.map((t => t.id)),
                this.index = t.index,
                this.hasPattern = !1,
                this.patternFeatures = [],
                this.layoutVertexArray = new Ks,
                this.indexArray = new pa,
                this.indexArray2 = new xa,
                this.programConfigurations = new lo(t.layers,t.zoom),
                this.segments = new vo,
                this.segments2 = new vo,
                this.stateDependentLayerIds = this.layers.filter((t => t.isStateDependent())).map((t => t.id)),
                this.projection = t.projection;
            }
            populate(t, e, r, n) {
                this.hasPattern = Uc("fill", this.layers, e);
                const i = this.layers[0].layout.get("fill-sort-key")
                  , s = [];
                for (const {feature: a, id: o, index: l, sourceLayerIndex: u, order: c} of t) {
                    const t = this.layers[0]._featureFilter.needGeometry
                      , h = Al(a, t);
                    if (!this.layers[0]._featureFilter.filter(new Ts(this.zoom), h, r))
                        continue;
                    const p = i ? i.evaluate(h, {}, r, e.availableImages) : void 0
                      , f = {
                        id: o,
                        properties: a.properties,
                        type: a.type,
                        sourceLayerIndex: u,
                        index: l,
                        geometry: t ? h.geometry : wl(a, r, n),
                        patterns: {},
                        sortKey: p,
                        order: c
                    };
                    s.push(f);
                }
                i && s.sort(( (t, e) => t.sortKey - e.sortKey));
                for (const n of s) {
                    const {geometry: i, index: s, sourceLayerIndex: a, order: o} = n;
                    if (this.hasPattern) {
                        const t = Oc("fill", this.layers, n, this.zoom, e);
                        this.patternFeatures.push(t);
                    } else
                        this.addFeature(n, i, s, r, {}, e.availableImages);
                    e.featureIndex.insert(t[o].feature, i, s, a, this.index);
                }
            }
            update(t, e, r, n) {
                this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n);
            }
            addFeatures(t, e, r, n, i) {
                for (const t of this.patternFeatures)
                    this.addFeature(t, t.geometry, t.index, e, r, n);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload
            }
            upload(t) {
                this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, ic),
                this.indexBuffer = t.createIndexBuffer(this.indexArray),
                this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)),
                this.programConfigurations.upload(t),
                this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                this.indexBuffer.destroy(),
                this.indexBuffer2.destroy(),
                this.programConfigurations.destroy(),
                this.segments.destroy(),
                this.segments2.destroy());
            }
            addFeature(t, e, r, n, i, s=[]) {
                for (const t of Rc(e, 500)) {
                    let e = 0;
                    for (const r of t)
                        e += r.length;
                    const r = this.segments.prepareSegment(e, this.layoutVertexArray, this.indexArray)
                      , n = r.vertexLength
                      , i = []
                      , s = [];
                    for (const e of t) {
                        if (0 === e.length)
                            continue;
                        e !== t[0] && s.push(i.length / 2);
                        const r = this.segments2.prepareSegment(e.length, this.layoutVertexArray, this.indexArray2)
                          , n = r.vertexLength;
                        this.layoutVertexArray.emplaceBack(e[0].x, e[0].y),
                        this.indexArray2.emplaceBack(n + e.length - 1, n),
                        i.push(e[0].x),
                        i.push(e[0].y);
                        for (let t = 1; t < e.length; t++)
                            this.layoutVertexArray.emplaceBack(e[t].x, e[t].y),
                            this.indexArray2.emplaceBack(n + t - 1, n + t),
                            i.push(e[t].x),
                            i.push(e[t].y);
                        r.vertexLength += e.length,
                        r.primitiveLength += e.length;
                    }
                    const a = sc(i, s);
                    for (let t = 0; t < a.length; t += 3)
                        this.indexArray.emplaceBack(n + a[t], n + a[t + 1], n + a[t + 2]);
                    r.vertexLength += e,
                    r.primitiveLength += a.length / 3;
                }
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, s, n);
            }
        }
        Bi($c, "FillBucket", {
            omit: ["layers", "patternFeatures"]
        });
        const qc = new qs({
            "fill-sort-key": new js(qt.layout_fill["fill-sort-key"])
        });
        var Nc = {
            paint: new qs({
                "fill-antialias": new Rs(qt.paint_fill["fill-antialias"]),
                "fill-opacity": new js(qt.paint_fill["fill-opacity"]),
                "fill-color": new js(qt.paint_fill["fill-color"]),
                "fill-outline-color": new js(qt.paint_fill["fill-outline-color"]),
                "fill-translate": new Rs(qt.paint_fill["fill-translate"]),
                "fill-translate-anchor": new Rs(qt.paint_fill["fill-translate-anchor"]),
                "fill-pattern": new Us(qt.paint_fill["fill-pattern"]),
                "fill-minzoom": new js(qt.paint_fill["fill-minzoom"]),
                "fill-maxzoom": new js(qt.paint_fill["fill-maxzoom"])
            }),
            layout: qc
        };
        const Zc = Ys([{
            name: "a_pos_normal_ed",
            components: 4,
            type: "Int16"
        }])
          , Gc = Ys([{
            name: "a_centroid_pos",
            components: 2,
            type: "Uint16"
        }])
          , Xc = Ys([{
            name: "a_pos_3",
            components: 3,
            type: "Int16"
        }, {
            name: "a_pos_normal_3",
            components: 3,
            type: "Int16"
        }])
          , {members: Yc} = Zc;
        var Hc = Kc;
        function Kc(t, e, r, n, i) {
            this.properties = {},
            this.extent = r,
            this.type = 0,
            this._pbf = t,
            this._geometry = -1,
            this._keys = n,
            this._values = i,
            t.readFields(Jc, this, e);
        }
        function Jc(t, e, r) {
            1 == t ? e.id = r.readVarint() : 2 == t ? function(t, e) {
                for (var r = t.readVarint() + t.pos; t.pos < r; ) {
                    var n = e._keys[t.readVarint()]
                      , i = e._values[t.readVarint()];
                    e.properties[n] = i;
                    console.log(n, i, 2);
                }
            }(r, e) : 3 == t ? e.type = r.readVarint() : 4 == t && (e._geometry = r.pos);
        }
        function Wc(t) {
            for (var e, r, n = 0, i = 0, s = t.length, a = s - 1; i < s; a = i++)
                n += ((r = t[a]).x - (e = t[i]).x) * (e.y + r.y);
            return n
        }
        Kc.types = ["Unknown", "Point", "LineString", "Polygon"],
        Kc.prototype.loadGeometry = function() {
            var t = this._pbf;
            t.pos = this._geometry;
            for (var e, r = t.readVarint() + t.pos, n = 1, s = 0, a = 0, o = 0, l = []; t.pos < r; ) {
                if (s <= 0) {
                    var u = t.readVarint();
                    n = 7 & u,
                    s = u >> 3;
                }
                if (s--,
                1 === n || 2 === n)
                    a += t.readSVarint(),
                    o += t.readSVarint(),
                    1 === n && (e && l.push(e),
                    e = []),
                    e.push(new i(a,o));
                else {
                    if (7 !== n)
                        throw new Error("unknown command " + n);
                    e && e.push(e[0].clone());
                }
            }
            return e && l.push(e),
            l
        }
        ,
        Kc.prototype.bbox = function() {
            var t = this._pbf;
            t.pos = this._geometry;
            for (var e = t.readVarint() + t.pos, r = 1, n = 0, i = 0, s = 0, a = 1 / 0, o = -1 / 0, l = 1 / 0, u = -1 / 0; t.pos < e; ) {
                if (n <= 0) {
                    var c = t.readVarint();
                    r = 7 & c,
                    n = c >> 3;
                }
                if (n--,
                1 === r || 2 === r)
                    (i += t.readSVarint()) < a && (a = i),
                    i > o && (o = i),
                    (s += t.readSVarint()) < l && (l = s),
                    s > u && (u = s);
                else if (7 !== r)
                    throw new Error("unknown command " + r)
            }
            return [a, l, o, u]
        }
        ,
        Kc.prototype.toGeoJSON = function(t, e, r) {
            var n, i, s = this.extent * Math.pow(2, r), a = this.extent * t, o = this.extent * e, l = this.loadGeometry(), u = Kc.types[this.type];
            function c(t) {
                for (var e = 0; e < t.length; e++) {
                    var r = t[e];
                    t[e] = [360 * (r.x + a) / s - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r.y + o) / s) * Math.PI / 180)) - 90];
                }
            }
            switch (this.type) {
            case 1:
                var h = [];
                for (n = 0; n < l.length; n++)
                    h[n] = l[n][0];
                c(l = h);
                break;
            case 2:
                for (n = 0; n < l.length; n++)
                    c(l[n]);
                break;
            case 3:
                for (l = function(t) {
                    var e = t.length;
                    if (e <= 1)
                        return [t];
                    for (var r, n, i = [], s = 0; s < e; s++) {
                        var a = Wc(t[s]);
                        0 !== a && (void 0 === n && (n = a < 0),
                        n === a < 0 ? (r && i.push(r),
                        r = [t[s]]) : r.push(t[s]));
                    }
                    return r && i.push(r),
                    i
                }(l),
                n = 0; n < l.length; n++)
                    for (i = 0; i < l[n].length; i++)
                        c(l[n][i]);
            }
            1 === l.length ? l = l[0] : u = "Multi" + u;
            var p = {
                type: "Feature",
                geometry: {
                    type: u,
                    coordinates: l
                },
                properties: this.properties
            };
            return "id"in this && (p.id = this.id),
            p
        }
        ;
        var Qc = th;
        function th(t, e) {
            this.version = 1,
            this.name = null,
            this.extent = 4096,
            this.length = 0,
            this._pbf = t,
            this._keys = [],
            this._values = [],
            this._features = [],
            t.readFields(eh, this, e),
            this.length = this._features.length;
        }
        function eh(t, e, r) {
            15 === t ? e.version = r.readVarint() : 1 === t ? e.name = r.readString() : 5 === t ? e.extent = r.readVarint() : 2 === t ? e._features.push(r.pos) : 3 === t ? e._keys.push(r.readString()) : 4 === t && e._values.push(function(t) {
                for (var e = null, r = t.readVarint() + t.pos; t.pos < r; ) {
                    var n = t.readVarint() >> 3;
                    e = 1 === n ? t.readString() : 2 === n ? t.readFloat() : 3 === n ? t.readDouble() : 4 === n ? t.readVarint64() : 5 === n ? t.readVarint() : 6 === n ? t.readSVarint() : 7 === n ? t.readBoolean() : null;
                }
                return e
            }(r));
        }
        function rh(t, e, r) {
            if (3 === t) {
                var n = new Qc(r,r.readVarint() + r.pos);
                n.length && (e[n.name] = n);
            }
        }
        th.prototype.feature = function(t) {
            if (t < 0 || t >= this._features.length)
                throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t];
            var e = this._pbf.readVarint() + this._pbf.pos;
            return new Hc(this._pbf,e,this.extent,this._keys,this._values)
        }
        ;
        var nh = {
            VectorTile: function(t, e) {
                this.layers = t.readFields(rh, {}, e);
            },
            VectorTileFeature: Hc,
            VectorTileLayer: Qc
        };
        function ih(t, e, r, n) {
            const s = []
              , a = 0 === n ? (t, e, r, n, s, a) => {
                t.push(new i(a,r + (a - e) / (n - e) * (s - r)));
            }
            : (t, e, r, n, s, a) => {
                t.push(new i(e + (a - r) / (s - r) * (n - e),a));
            }
            ;
            for (const i of t) {
                const t = [];
                for (const s of i) {
                    if (s.length <= 2)
                        continue;
                    const i = [];
                    for (let t = 0; t < s.length - 1; t++) {
                        const o = s[t].x
                          , l = s[t].y
                          , u = s[t + 1].x
                          , c = s[t + 1].y
                          , h = 0 === n ? o : l
                          , p = 0 === n ? u : c;
                        h < e ? p > e && a(i, o, l, u, c, e) : h > r ? p < r && a(i, o, l, u, c, r) : i.push(s[t]),
                        p < e && h >= e && a(i, o, l, u, c, e),
                        p > r && h <= r && a(i, o, l, u, c, r);
                    }
                    let o = s[s.length - 1];
                    const l = 0 === n ? o.x : o.y;
                    l >= e && l <= r && i.push(o),
                    i.length && (o = i[i.length - 1],
                    i[0].x === o.x && i[0].y === o.y || i.push(i[0]),
                    t.push(i));
                }
                t.length && s.push(t);
            }
            return s
        }
        const sh = nh.VectorTileFeature.types
          , ah = Math.pow(2, 13);
        function oh(t, e, r, n, i, s, a, o) {
            t.emplaceBack((e << 1) + a, (r << 1) + s, (Math.floor(n * ah) << 1) + i, Math.round(o));
        }
        function lh(t, e, r) {
            const n = 16384;
            t.emplaceBack(e.x, e.y, e.z, r[0] * n, r[1] * n, r[2] * n);
        }
        class uh {
            constructor() {
                this.acc = new i(0,0),
                this.polyCount = [];
            }
            startRing(t) {
                this.currentPolyCount = {
                    edges: 0,
                    top: 0
                },
                this.polyCount.push(this.currentPolyCount),
                this.min || (this.min = new i(t.x,t.y),
                this.max = new i(t.x,t.y));
            }
            append(t, e) {
                this.currentPolyCount.edges++,
                this.acc._add(t);
                const r = this.min
                  , n = this.max;
                t.x < r.x ? r.x = t.x : t.x > n.x && (n.x = t.x),
                t.y < r.y ? r.y = t.y : t.y > n.y && (n.y = t.y),
                ((0 === t.x || t.x === bo) && t.x === e.x) != ((0 === t.y || t.y === bo) && t.y === e.y) && this.processBorderOverlap(t, e),
                e.x < 0 != t.x < 0 && this.addBorderIntersection(0, mr(e.y, t.y, (0 - e.x) / (t.x - e.x))),
                e.x > bo != t.x > bo && this.addBorderIntersection(1, mr(e.y, t.y, (bo - e.x) / (t.x - e.x))),
                e.y < 0 != t.y < 0 && this.addBorderIntersection(2, mr(e.x, t.x, (0 - e.y) / (t.y - e.y))),
                e.y > bo != t.y > bo && this.addBorderIntersection(3, mr(e.x, t.x, (bo - e.y) / (t.y - e.y)));
            }
            addBorderIntersection(t, e) {
                this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
                const r = this.borders[t];
                e < r[0] && (r[0] = e),
                e > r[1] && (r[1] = e);
            }
            processBorderOverlap(t, e) {
                if (t.x === e.x) {
                    if (t.y === e.y)
                        return;
                    const r = 0 === t.x ? 0 : 1;
                    this.addBorderIntersection(r, e.y),
                    this.addBorderIntersection(r, t.y);
                } else {
                    const r = 0 === t.y ? 2 : 3;
                    this.addBorderIntersection(r, e.x),
                    this.addBorderIntersection(r, t.x);
                }
            }
            centroid() {
                const t = this.polyCount.reduce(( (t, e) => t + e.edges), 0);
                return 0 !== t ? this.acc.div(t)._round() : new i(0,0)
            }
            span() {
                return new i(this.max.x - this.min.x,this.max.y - this.min.y)
            }
            intersectsCount() {
                return this.borders.reduce(( (t, e) => t + +(e[0] !== Number.MAX_VALUE)), 0)
            }
        }
        class ch {
            constructor(t) {
                this.zoom = t.zoom,
                this.canonical = t.canonical,
                this.overscaling = t.overscaling,
                this.layers = t.layers,
                this.layerIds = this.layers.map((t => t.id)),
                this.index = t.index,
                this.hasPattern = !1,
                this.edgeRadius = 0,
                this.projection = t.projection,
                this.layoutVertexArray = new Ws,
                this.centroidVertexArray = new Da,
                this.indexArray = new pa,
                this.programConfigurations = new lo(t.layers,t.zoom),
                this.segments = new vo,
                this.stateDependentLayerIds = this.layers.filter((t => t.isStateDependent())).map((t => t.id)),
                this.enableTerrain = t.enableTerrain;
            }
            populate(t, e, r, n) {
                this.features = [],
                this.hasPattern = Uc("fill-extrusion", this.layers, e),
                this.featuresOnBorder = [],
                this.borders = [[], [], [], []],
                this.borderDoneWithNeighborZ = [-1, -1, -1, -1],
                this.tileToMeter = function(t) {
                    const e = Math.exp(Math.PI * (1 - t.y / (1 << t.z) * 2));
                    return 80150034 * e / (e * e + 1) / bo / (1 << t.z)
                }(r),
                this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter;
                for (const {feature: i, id: s, index: a, sourceLayerIndex: o} of t) {
                    const t = this.layers[0]._featureFilter.needGeometry
                      , l = Al(i, t);
                    if (!this.layers[0]._featureFilter.filter(new Ts(this.zoom), l, r))
                        continue;
                    const u = {
                        id: s,
                        sourceLayerIndex: o,
                        index: a,
                        geometry: t ? l.geometry : wl(i, r, n),
                        properties: i.properties,
                        type: i.type,
                        patterns: {}
                    }
                      , c = this.layoutVertexArray.length;
                    this.hasPattern ? this.features.push(Oc("fill-extrusion", this.layers, u, this.zoom, e)) : this.addFeature(u, u.geometry, a, r, {}, e.availableImages, n),
                    e.featureIndex.insert(i, u.geometry, a, o, this.index, c);
                }
                this.sortBorders();
            }
            addFeatures(t, e, r, n, i) {
                for (const t of this.features) {
                    const {geometry: s} = t;
                    this.addFeature(t, s, t.index, e, r, n, i);
                }
                this.sortBorders();
            }
            update(t, e, r, n) {
                this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload
            }
            upload(t) {
                this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Yc),
                this.indexBuffer = t.createIndexBuffer(this.indexArray),
                this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t.createVertexBuffer(this.layoutVertexExtArray, Xc.members, !0))),
                this.programConfigurations.upload(t),
                this.uploaded = !0;
            }
            uploadCentroid(t) {
                0 !== this.centroidVertexArray.length && (this.centroidVertexBuffer ? this.needsCentroidUpdate && this.centroidVertexBuffer.updateData(this.centroidVertexArray) : this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, Gc.members, !0),
                this.needsCentroidUpdate = !1);
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(),
                this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(),
                this.indexBuffer.destroy(),
                this.programConfigurations.destroy(),
                this.segments.destroy());
            }
            addFeature(t, e, r, n, s, a, o) {
                const l = "Sg4326" == n.reference
                  , u = [new i(0,0), new i(bo,bo)]
                  , c = o.projection
                  , h = "globe" === c.name
                  , p = this.enableTerrain && !h ? new uh : null
                  , f = "Polygon" === sh[t.type];
                h && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new wa);
                const d = Rc(e, 500);
                for (let t = d.length - 1; t >= 0; t--) {
                    const e = d[t];
                    (0 === e.length || (y = e[0]).every((t => t.x <= 0)) || y.every((t => t.x >= bo)) || y.every((t => t.y <= 0)) || y.every((t => t.y >= bo))) && d.splice(t, 1);
                }
                var y;
                let m;
                if (h)
                    m = xh(d, u, n);
                else {
                    m = [];
                    for (const t of d)
                        m.push({
                            polygon: t,
                            bounds: u
                        });
                }
                const g = f ? this.edgeRadius : 0;
                for (const {polygon: t, bounds: e} of m) {
                    let r = 0
                      , i = 0;
                    for (const e of t)
                        f && !e[0].equals(e[e.length - 1]) && e.push(e[0]),
                        i += f ? e.length - 1 : e.length;
                    const s = this.segments.prepareSegment((f ? 5 : 4) * i, this.layoutVertexArray, this.indexArray);
                    if (f) {
                        const e = []
                          , i = [];
                        r = s.vertexLength;
                        for (const r of t) {
                            let a, o;
                            r.length && r !== t[0] && i.push(e.length / 2),
                            a = r[1].sub(r[0])._perp()._unit();
                            for (let t = 1; t < r.length; t++) {
                                const i = r[t]
                                  , l = r[t === r.length - 1 ? 1 : t + 1];
                                let {x: u, y: p} = i;
                                if (g) {
                                    o = l.sub(i)._perp()._unit();
                                    const t = a.add(o)._unit()
                                      , e = g * Math.min(4, 1 / (a.x * t.x + a.y * t.y));
                                    u += e * t.x,
                                    p += e * t.y,
                                    a = o;
                                }
                                oh(this.layoutVertexArray, u, p, 0, 0, 1, 1, 0),
                                s.vertexLength++,
                                e.push(i.x, i.y),
                                h && lh(this.layoutVertexExtArray, c.projectTilePoint(u, p, n), c.upVector(n, u, p));
                            }
                        }
                        const a = sc(e, i);
                        for (let t = 0; t < a.length; t += 3)
                            this.indexArray.emplaceBack(r + a[t], r + a[t + 2], r + a[t + 1]),
                            s.primitiveLength++;
                    }
                    for (const i of t) {
                        p && i.length && p.startRing(i[0]);
                        let t, a, o, u = i.length > 4 && yh(i[i.length - 2], i[0], i[1]), d = g ? ph(i[i.length - 2], i[0], i[1], g) : 0;
                        a = i[1].sub(i[0])._perp()._unit();
                        for (let y = 1, m = 0; y < i.length; y++) {
                            let x = i[y - 1]
                              , v = i[y];
                            const b = i[y === i.length - 1 ? 1 : y + 1];
                            if (p && f && p.currentPolyCount.top++,
                            dh(v, x, e)) {
                                g && (a = b.sub(v)._perp()._unit());
                                continue
                            }
                            p && p.append(v, x);
                            let _ = v.sub(x)._perp();
                            l && (_ = _._mult(-1));
                            const w = _.x / (Math.abs(_.x) + Math.abs(_.y))
                              , A = _.y > 0 ? 1 : 0
                              , k = x.dist(v);
                            if (m + k > 32768 && (m = 0),
                            g) {
                                o = b.sub(v)._perp()._unit();
                                let t = fh(x, v, b, hh(a, o), g);
                                isNaN(t) && (t = 0);
                                const e = v.sub(x)._unit();
                                x = x.add(e.mult(d))._round(),
                                v = v.add(e.mult(-t))._round(),
                                d = t,
                                a = o;
                            }
                            const z = s.vertexLength
                              , S = i.length > 4 && yh(x, v, b);
                            let M = mh(m, u, !0);
                            if (oh(this.layoutVertexArray, x.x, x.y, w, A, 0, 0, M),
                            oh(this.layoutVertexArray, x.x, x.y, w, A, 0, 1, M),
                            m += k,
                            M = mh(m, S, !1),
                            u = S,
                            oh(this.layoutVertexArray, v.x, v.y, w, A, 0, 0, M),
                            oh(this.layoutVertexArray, v.x, v.y, w, A, 0, 1, M),
                            s.vertexLength += 4,
                            l ? (this.indexArray.emplaceBack(z + 0, z + 2, z + 1),
                            this.indexArray.emplaceBack(z + 1, z + 2, z + 3)) : (this.indexArray.emplaceBack(z + 0, z + 1, z + 2),
                            this.indexArray.emplaceBack(z + 1, z + 3, z + 2)),
                            s.primitiveLength += 2,
                            g) {
                                const n = r + (1 === y ? i.length - 2 : y - 2)
                                  , a = 1 === y ? r : n + 1;
                                if (this.indexArray.emplaceBack(z + 1, n, z + 3),
                                this.indexArray.emplaceBack(n, a, z + 3),
                                s.primitiveLength += 2,
                                void 0 === t && (t = z),
                                !dh(b, i[y], e)) {
                                    const e = y === i.length - 1 ? t : s.vertexLength;
                                    this.indexArray.emplaceBack(z + 2, z + 3, e),
                                    this.indexArray.emplaceBack(z + 3, e + 1, e),
                                    this.indexArray.emplaceBack(z + 3, a, e + 1),
                                    s.primitiveLength += 3;
                                }
                            }
                            if (h) {
                                const t = this.layoutVertexExtArray
                                  , e = c.projectTilePoint(x.x, x.y, n)
                                  , r = c.projectTilePoint(v.x, v.y, n)
                                  , i = c.upVector(n, x.x, x.y)
                                  , s = c.upVector(n, v.x, v.y);
                                lh(t, e, i),
                                lh(t, e, i),
                                lh(t, r, s),
                                lh(t, r, s);
                            }
                        }
                        f && (r += i.length - 1);
                    }
                }
                if (p && p.polyCount.length > 0) {
                    if (p.borders) {
                        p.vertexArrayOffset = this.centroidVertexArray.length;
                        const t = p.borders
                          , e = this.featuresOnBorder.push(p) - 1;
                        for (let r = 0; r < 4; r++)
                            t[r][0] !== Number.MAX_VALUE && this.borders[r].push(e);
                    }
                    this.encodeCentroid(p.borders ? void 0 : p.centroid(), p);
                }
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, s, a, n);
            }
            sortBorders() {
                for (let t = 0; t < 4; t++)
                    this.borders[t].sort(( (e, r) => this.featuresOnBorder[e].borders[t][0] - this.featuresOnBorder[r].borders[t][0]));
            }
            encodeCentroid(t, e, r=!0) {
                let n, i;
                if (t)
                    if (0 !== t.y) {
                        const r = e.span()._mult(this.tileToMeter);
                        n = (Math.max(t.x, 1) << 3) + Math.min(7, Math.round(r.x / 10)),
                        i = (Math.max(t.y, 1) << 3) + Math.min(7, Math.round(r.y / 10));
                    } else
                        n = Math.ceil(7 * (t.x + 450)),
                        i = 0;
                else
                    n = 0,
                    i = +r;
                let s = r ? this.centroidVertexArray.length : e.vertexArrayOffset;
                for (const t of e.polyCount) {
                    r && this.centroidVertexArray.resize(this.centroidVertexArray.length + 4 * t.edges + t.top);
                    for (let e = 0; e < t.top; e++)
                        this.centroidVertexArray.emplace(s++, n, i);
                    for (let e = 0; e < 2 * t.edges; e++)
                        this.centroidVertexArray.emplace(s++, 0, i),
                        this.centroidVertexArray.emplace(s++, n, i);
                }
            }
        }
        function hh(t, e) {
            const r = t.add(e)._unit();
            return t.x * r.x + t.y * r.y
        }
        function ph(t, e, r, n) {
            const i = e.sub(t)._perp()._unit()
              , s = r.sub(e)._perp()._unit();
            return fh(t, e, r, hh(i, s), n)
        }
        function fh(t, e, r, n, i) {
            const s = Math.sqrt(1 - n * n);
            return Math.min(t.dist(e) / 3, e.dist(r) / 3, i * s / n)
        }
        function dh(t, e, r) {
            return t.x < r[0].x && e.x < r[0].x || t.x > r[1].x && e.x > r[1].x || t.y < r[0].y && e.y < r[0].y || t.y > r[1].y && e.y > r[1].y
        }
        function yh(t, e, r) {
            if (t.x < 0 || t.x >= bo || e.x < 0 || e.x >= bo || r.x < 0 || r.x >= bo)
                return !1;
            const n = r.sub(e)
              , i = n.perp()
              , s = t.sub(e);
            return (n.x * s.x + n.y * s.y) / Math.sqrt((n.x * n.x + n.y * n.y) * (s.x * s.x + s.y * s.y)) > -.866 && i.x * s.x + i.y * s.y < 0
        }
        function mh(t, e, r) {
            const n = e ? 2 | t : -3 & t;
            return r ? 1 | n : -2 & n
        }
        function gh() {
            const t = Math.PI / 32
              , e = Math.tan(t)
              , r = wo;
            return r * Math.sqrt(1 + 2 * e * e) - r
        }
        function xh(t, e, r) {
            const n = 1 << r.z
              , s = Wo(r.x / n)
              , a = Wo((r.x + 1) / n)
              , o = xl(r)
              , l = Qo(o.top / n)
              , u = Qo(o.bottom / n);
            return function(t, e, r, n, s=0, a) {
                const o = [];
                if (!t.length || !r || !n)
                    return o;
                const l = (t, e) => {
                    for (const r of t)
                        o.push({
                            polygon: r,
                            bounds: e
                        });
                }
                  , u = Math.ceil(Math.log2(r))
                  , c = Math.ceil(Math.log2(n))
                  , h = u - c
                  , p = [];
                for (let t = 0; t < Math.abs(h); t++)
                    p.push(h > 0 ? 0 : 1);
                for (let t = 0; t < Math.min(u, c); t++)
                    p.push(0),
                    p.push(1);
                let f = t;
                if (f = ih(f, e[0].y - s, e[1].y + s, 1),
                f = ih(f, e[0].x - s, e[1].x + s, 0),
                !f.length)
                    return o;
                const d = [];
                for (p.length ? d.push({
                    polygons: f,
                    bounds: e,
                    depth: 0
                }) : l(f, e); d.length; ) {
                    const t = d.pop()
                      , e = t.depth
                      , r = p[e]
                      , n = t.bounds[0]
                      , o = t.bounds[1]
                      , u = 0 === r ? n.x : n.y
                      , c = 0 === r ? o.x : o.y
                      , h = a ? a(r, u, c) : .5 * (u + c)
                      , f = ih(t.polygons, u - s, h + s, r)
                      , y = ih(t.polygons, h - s, c + s, r);
                    if (f.length) {
                        const t = [n, new i(0 === r ? h : o.x,1 === r ? h : o.y)];
                        p.length > e + 1 ? d.push({
                            polygons: f,
                            bounds: t,
                            depth: e + 1
                        }) : l(f, t);
                    }
                    if (y.length) {
                        const t = [new i(0 === r ? h : n.x,1 === r ? h : n.y), o];
                        p.length > e + 1 ? d.push({
                            polygons: y,
                            bounds: t,
                            depth: e + 1
                        }) : l(y, t);
                    }
                }
                return o
            }(t, e, Math.ceil((a - s) / 11.25), Math.ceil((l - u) / 11.25), 1, ( (t, e, i) => {
                if (0 === t)
                    return .5 * (e + i);
                {
                    const t = Qo(gl(e, r) / n);
                    return (Ko(.5 * (Qo(gl(i, r) / n) + t)) * n - r.y) * bo
                }
            }
            ))
        }
        Bi(ch, "FillExtrusionBucket", {
            omit: ["layers", "features"]
        }),
        Bi(uh, "PartMetadata");
        const vh = new qs({
            "fill-extrusion-edge-radius": new Rs(qt["layout_fill-extrusion"]["fill-extrusion-edge-radius"])
        });
        var bh = {
            paint: new qs({
                "fill-extrusion-opacity": new Rs(qt["paint_fill-extrusion"]["fill-extrusion-opacity"]),
                "fill-extrusion-color": new js(qt["paint_fill-extrusion"]["fill-extrusion-color"]),
                "fill-extrusion-translate": new Rs(qt["paint_fill-extrusion"]["fill-extrusion-translate"]),
                "fill-extrusion-translate-anchor": new Rs(qt["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
                "fill-extrusion-pattern": new Us(qt["paint_fill-extrusion"]["fill-extrusion-pattern"]),
                "fill-extrusion-height": new js(qt["paint_fill-extrusion"]["fill-extrusion-height"]),
                "fill-extrusion-base": new js(qt["paint_fill-extrusion"]["fill-extrusion-base"]),
                "fill-extrusion-vertical-gradient": new Rs(qt["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]),
                "fill-extrusion-ambient-occlusion-intensity": new Rs(qt["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]),
                "fill-extrusion-ambient-occlusion-radius": new Rs(qt["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]),
                "fill-extrusion-minzoom": new js(qt["paint_fill-extrusion"]["fill-extrusion-minzoom"]),
                "fill-extrusion-maxzoom": new js(qt["paint_fill-extrusion"]["fill-extrusion-maxzoom"]),
                "fill-extrusion-topcolor": new js(qt["paint_fill-extrusion"]["fill-extrusion-topcolor"])
            }),
            layout: vh
        };
        function _h(t, e, r) {
            var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);
            return [t * n - 2 * Math.PI * 6378137 / 2, e * n - 2 * Math.PI * 6378137 / 2]
        }
        class wh {
            constructor(t, e, r, n) {
                this.z = t,
                this.x = e,
                this.y = r,
                this.reference = n && n.reference,
                this.sourceID = n && n.sourceID,
                this._tileY = n && null != n._tileY && null != n._tileY ? n._tileY : r,
                this._tileH = n && null != n._tileH && null != n._tileH ? n._tileH : 1,
                this.key = zh(0, t, t, e, r, this.sourceID);
            }
            equals(t) {
                var e = this.sourceID;
                return e ? this.z === t.z && this.x === t.x && this.y === t.y && e === t.sourceID : this.z === t.z && this.x === t.x && this.y === t.y
            }
            url(t, e) {
                const r = function(t, e, r) {
                    var n = _h(256 * t, 256 * (e = Math.pow(2, r) - e - 1), r)
                      , i = _h(256 * (t + 1), 256 * (e + 1), r);
                    return n[0] + "," + n[1] + "," + i[0] + "," + i[1]
                }(this.x, this.y, this.z)
                  , n = function(t, e, r) {
                    let n, i = "";
                    for (let s = t; s > 0; s--)
                        n = 1 << s - 1,
                        i += (e & n ? 1 : 0) + (r & n ? 2 : 0);
                    return i
                }(this.z, this.x, this.y);
                return t[(this.x + this.y) % t.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === e ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n).replace("{bbox-epsg-3857}", r)
            }
            toString() {
                return `${this.z}/${this.x}/${this.y}`
            }
        }
        class Ah {
            constructor(t, e) {
                this.wrap = t,
                this.canonical = e,
                this.key = zh(t, e.z, e.z, e.x, e.y, e.sourceID);
            }
        }
        class kh {
            constructor(t, e, r, n, i, s) {
                if (this.reference = s && s.reference,
                this.sourceID = s && s.sourceID,
                this.zoomRule = s && s.zoomRule,
                this._tileY = s && s._tileY,
                this._tileH = s && s._tileH,
                this._mapZoom = s && s._mapZoom,
                !this._tileY && 0 != this._tileY || !this._tileH && 0 != this._tileH) {
                    let t = function(t, e, r, n) {
                        let i = r
                          , s = 1;
                        if ("Sg4326" == t) {
                            let t = ml(e, r, n, "all");
                            i = t.top,
                            s = t.height;
                        }
                        return {
                            _tileY: i,
                            _tileH: s
                        }
                    }(this.reference, n, i, r);
                    this._tileY = t._tileY,
                    this._tileH = t._tileH;
                }
                this.overscaledZ = t,
                this.wrap = e,
                this.canonical = new wh(r,+n,+i,this),
                this.key = 0 === e && t === r ? this.canonical.key : zh(e, t, r, n, i, this.sourceID);
            }
            equals(t) {
                return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical)
            }
            scaledTo(t, e) {
                e || (e = 0),
                t += e;
                var r = this.zoomRule;
                if (r && r.length > 0) {
                    r = JSON.parse(r);
                    var n = 0;
                    for (var i in r) {
                        if (0 == n && i.indexOf(t) >= 0) {
                            n = 1;
                            break
                        }
                        if (1 == n) {
                            t = r[i] || 0,
                            n = 2;
                            break
                        }
                    }
                }
                const s = this.canonical.z - t;
                if (t > this.canonical.z)
                    return new kh(t,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y,this);
                {
                    const {reference: e, sourceID: r, zoomRule: n, _mapZoom: i} = this;
                    return new kh(t,this.wrap,t,this.canonical.x >> s,this.canonical.y >> s,{
                        reference: e,
                        sourceID: r,
                        zoomRule: n,
                        _mapZoom: i
                    })
                }
            }
            calculateScaledKey(t, e=!0) {
                if (this.overscaledZ === t && e)
                    return this.key;
                if (t > this.canonical.z)
                    return zh(this.wrap * +e, t, this.canonical.z, this.canonical.x, this.canonical.y, this.sourceID);
                {
                    const r = this.canonical.z - t;
                    return zh(this.wrap * +e, t, t, this.canonical.x >> r, this.canonical.y >> r, this.sourceID)
                }
            }
            isChildOf(t) {
                if (t.wrap !== this.wrap)
                    return !1;
                const e = this.canonical.z - t.canonical.z;
                return 0 === t.overscaledZ || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> e && t.canonical.y === this.canonical.y >> e
            }
            children(t) {
                if (this.overscaledZ >= t)
                    return [new kh(this.overscaledZ + 1,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y,this)];
                const e = this.canonical.z + 1
                  , r = 2 * this.canonical.x
                  , n = 2 * this.canonical.y
                  , {reference: i, sourceID: s, zoomRule: a, _mapZoom: o} = this
                  , l = {
                    reference: i,
                    sourceID: s,
                    zoomRule: a,
                    _mapZoom: o
                };
                return [new kh(e,this.wrap,e,r,n,this), new kh(e,this.wrap,e,r + 1,n,l), new kh(e,this.wrap,e,r,n + 1,l), new kh(e,this.wrap,e,r + 1,n + 1,l)]
            }
            isLessThan(t) {
                return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y))
            }
            wrapped() {
                return new kh(this.overscaledZ,0,this.canonical.z,this.canonical.x,this.canonical.y,this)
            }
            unwrapTo(t) {
                return new kh(this.overscaledZ,t,this.canonical.z,this.canonical.x,this.canonical.y,this)
            }
            overscaleFactor() {
                return Math.pow(2, this.overscaledZ - this.canonical.z)
            }
            toUnwrapped() {
                return new Ah(this.wrap,this.canonical)
            }
            toString() {
                return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`
            }
        }
        function zh(t, e, r, n, i, s) {
            let a = [t, e, r, n, i].join("_");
            return s && (a += s.toString(36)),
            a
        }
        function Sh(t, e) {
            return t.x * e.x + t.y * e.y
        }
        function Mh(t, e) {
            if (1 === t.length) {
                let r = 0;
                const n = e[r++];
                let i;
                for (; !i || n.equals(i); )
                    if (i = e[r++],
                    !i)
                        return 1 / 0;
                for (; r < e.length; r++) {
                    const s = e[r]
                      , a = t[0]
                      , o = i.sub(n)
                      , l = s.sub(n)
                      , u = a.sub(n)
                      , c = Sh(o, o)
                      , h = Sh(o, l)
                      , p = Sh(l, l)
                      , f = Sh(u, o)
                      , d = Sh(u, l)
                      , y = c * p - h * h
                      , m = (p * f - h * d) / y
                      , g = (c * d - h * f) / y
                      , x = n.z * (1 - m - g) + i.z * m + s.z * g;
                    if (isFinite(x))
                        return x
                }
                return 1 / 0
            }
            {
                let t = 1 / 0;
                for (const r of e)
                    t = Math.min(t, r.z);
                return t
            }
        }
        function Ih(t) {
            const e = new i(t[0],t[1]);
            return e.z = t[2],
            e
        }
        function Th(t, e, r, n, i, s, a, o) {
            const l = a * i.getElevationAt(t, e, !0, !0)
              , u = 0 !== s[0]
              , c = u ? 0 === s[1] ? a * (s[0] / 7 - 450) : a * function(t, e, r) {
                const n = Math.floor(e[0] / 8)
                  , i = Math.floor(e[1] / 8)
                  , s = 10 * (e[0] - 8 * n)
                  , a = 10 * (e[1] - 8 * i)
                  , o = t.getElevationAt(n, i, !0, !0)
                  , l = t.getMeterToDEM(r)
                  , u = Math.floor(.5 * (s * l - 1))
                  , c = Math.floor(.5 * (a * l - 1))
                  , h = t.tileCoordToPixel(n, i)
                  , p = 2 * u + 1
                  , f = 2 * c + 1
                  , d = function(t, e, r, n, i) {
                    return [t.getElevationAtPixel(e, r, !0), t.getElevationAtPixel(e + i, r, !0), t.getElevationAtPixel(e, r + i, !0), t.getElevationAtPixel(e + n, r + i, !0)]
                }(t, h.x - u, h.y - c, p, f)
                  , y = Math.abs(d[0] - d[1])
                  , m = Math.abs(d[2] - d[3])
                  , g = Math.abs(d[0] - d[2]) + Math.abs(d[1] - d[3])
                  , x = Math.min(.25, .5 * l * (y + m) / p)
                  , v = Math.min(.25, .5 * l * g / f);
                return o + Math.max(x * s, v * a)
            }(i, s, o) : l;
            return {
                base: l + (0 === r) ? -1 : r,
                top: u ? Math.max(c + n, l + r + 2) : l + n
            }
        }
        Bi(wh, "CanonicalTileID"),
        Bi(kh, "OverscaledTileID", {
            omit: ["projMatrix"]
        });
        const Bh = Ys([{
            name: "a_pos_normal",
            components: 2,
            type: "Int16"
        }, {
            name: "a_data",
            components: 4,
            type: "Uint8"
        }, {
            name: "a_linesofar",
            components: 1,
            type: "Float32"
        }], 4)
          , {members: Ch} = Bh
          , Vh = Ys([{
            name: "a_packed",
            components: 4,
            type: "Float32"
        }])
          , {members: Ph} = Vh
          , Dh = nh.VectorTileFeature.types
          , Eh = Math.cos(Math.PI / 180 * 37.5);
        class Fh {
            constructor(t) {
                this.zoom = t.zoom,
                this.overscaling = t.overscaling,
                this.layers = t.layers,
                this.layerIds = this.layers.map((t => t.id)),
                this.index = t.index,
                this.projection = t.projection,
                this.hasPattern = !1,
                this.patternFeatures = [],
                this.lineClipsArray = [],
                this.gradients = {},
                this.layers.forEach((t => {
                    this.gradients[t.id] = {};
                }
                )),
                this.layoutVertexArray = new Qs,
                this.layoutVertexArray2 = new ta,
                this.indexArray = new pa,
                this.programConfigurations = new lo(t.layers,t.zoom,(t => t.indexOf("line-outline") < 0));
                var e = ["line-color", "line-floorwidth", "line-width", "line-dasharray", "line-pattern"];
                this.programConfigurations_outline = new lo(t.layers,t.zoom,(t => e.indexOf(t) < 0)),
                this.segments = new vo,
                this.maxLineLength = 0,
                this.stateDependentLayerIds = this.layers.filter((t => t.isStateDependent())).map((t => t.id));
            }
            populate(t, e, r, n) {
                this.hasPattern = Uc("line", this.layers, e);
                const i = this.layers[0].layout.get("line-sort-key")
                  , s = [];
                for (const {feature: e, id: a, index: o, sourceLayerIndex: l, order: u} of t) {
                    const t = this.layers[0]._featureFilter.needGeometry
                      , c = Al(e, t);
                    if (!this.layers[0]._featureFilter.filter(new Ts(this.zoom), c, r))
                        continue;
                    const h = i ? i.evaluate(c, {}, r) : void 0
                      , p = {
                        id: a,
                        properties: e.properties,
                        type: e.type,
                        sourceLayerIndex: l,
                        index: o,
                        geometry: t ? c.geometry : wl(e, r, n),
                        patterns: {},
                        sortKey: h,
                        order: u
                    };
                    s.push(p);
                }
                i && s.sort(( (t, e) => t.sortKey - e.sortKey));
                const {lineAtlas: a, featureIndex: o} = e
                  , l = this.addConstantDashes(a);
                for (const n of s) {
                    const {geometry: i, index: s, sourceLayerIndex: u, order: c} = n;
                    if (l && this.addFeatureDashes(n, a),
                    this.hasPattern) {
                        const t = Oc("line", this.layers, n, this.zoom, e);
                        this.patternFeatures.push(t);
                    } else
                        this.addFeature(n, i, s, r, a.positions, e.availableImages);
                    o.insert(t[c].feature, i, s, u, this.index);
                }
            }
            addConstantDashes(t) {
                let e = !1;
                for (const r of this.layers) {
                    const n = r.paint.get("line-dasharray").value
                      , i = r.paint.get("line-outline-dasharray").value
                      , s = r.layout.get("line-cap").value;
                    if ("constant" !== n.kind || "constant" !== i.kind || "constant" !== s.kind)
                        e = !0;
                    else {
                        const e = s.value
                          , r = n.value;
                        r && (t.addDash(r.from, e),
                        t.addDash(r.to, e),
                        r.other && t.addDash(r.other, e));
                        const a = i.value;
                        a && (t.addDash(a.from, e),
                        t.addDash(a.to, e),
                        a.other && t.addDash(a.other, e));
                    }
                }
                return e
            }
            addFeatureDashes(t, e) {
                const r = this.zoom;
                function n(t, e, r, n, i) {
                    const s = r.paint.get(i).value
                      , a = r.layout.get("line-cap").value;
                    if ("constant" === s.kind && "constant" === a.kind)
                        return null;
                    let o, l, u, c, h, p;
                    if ("constant" === s.kind) {
                        const t = s.value;
                        if (!t)
                            return null;
                        o = t.other || t.to,
                        l = t.to,
                        u = t.from;
                    } else
                        o = s.evaluate({
                            zoom: e - 1
                        }, n),
                        l = s.evaluate({
                            zoom: e
                        }, n),
                        u = s.evaluate({
                            zoom: e + 1
                        }, n);
                    return "constant" === a.kind ? c = h = p = a.value : (c = a.evaluate({
                        zoom: e - 1
                    }, n),
                    h = a.evaluate({
                        zoom: e
                    }, n),
                    p = a.evaluate({
                        zoom: e + 1
                    }, n)),
                    t.addDash(o, c),
                    t.addDash(l, h),
                    t.addDash(u, p),
                    {
                        min: t.getKey(o, c),
                        mid: t.getKey(l, h),
                        max: t.getKey(u, p)
                    }
                }
                for (const a of this.layers) {
                    var i = n(e, r, a, t, "line-dasharray")
                      , s = n(e, r, a, t, "line-outline-dasharray");
                    t.patterns[a.id] = {},
                    null != i && (t.patterns[a.id].min = i.min,
                    t.patterns[a.id].mid = i.mid,
                    t.patterns[a.id].max = i.max),
                    null != s && (t.patterns[a.id].min_out = s.min,
                    t.patterns[a.id].mid_out = s.mid,
                    t.patterns[a.id].max_out = s.max);
                }
            }
            update(t, e, r, n) {
                this.stateDependentLayers.length && (this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n),
                this.programConfigurations_outline.updatePaintArrays(t, e, this.stateDependentLayers, r, n));
            }
            addFeatures(t, e, r, n, i) {
                for (const t of this.patternFeatures)
                    this.addFeature(t, t.geometry, t.index, e, r, n);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations_outline.needsUpload || this.programConfigurations.needsUpload
            }
            upload(t) {
                this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, Ph)),
                this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Ch),
                this.indexBuffer = t.createIndexBuffer(this.indexArray)),
                this.programConfigurations.upload(t),
                this.programConfigurations_outline.upload(t),
                this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                this.indexBuffer.destroy(),
                this.programConfigurations.destroy(),
                this.programConfigurations_outline.destroy(),
                this.segments.destroy());
            }
            lineFeatureClips(t) {
                if (t.properties && t.properties.hasOwnProperty("sgmap_clip_start") && t.properties.hasOwnProperty("sgmap_clip_end"))
                    return {
                        start: +t.properties.sgmap_clip_start,
                        end: +t.properties.sgmap_clip_end
                    }
            }
            addFeature(t, e, r, n, i, s) {
                const a = this.layers[0].layout
                  , o = a.get("line-join").evaluate(t, {})
                  , l = a.get("line-cap").evaluate(t, {})
                  , u = a.get("line-miter-limit")
                  , c = a.get("line-round-limit");
                this.lineClips = this.lineFeatureClips(t);
                var h = this.layers[0].paint.get("line-offset").evaluate(t, {});
                for (const r of e)
                    this.addLine(r, t, o, l, u, c, h);
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, s, n),
                this.programConfigurations_outline.populatePaintArrays(this.layoutVertexArray.length, t, r, i, s, n);
            }
            addLine(t, e, r, n, i, s, a) {
                if (this.distance = 0,
                this.scaledDistance = 0,
                this.totalDistance = 0,
                this.lineSoFar = 0,
                this.lineClips) {
                    this.lineClipsArray.push(this.lineClips);
                    for (let e = 0; e < t.length - 1; e++)
                        this.totalDistance += t[e].dist(t[e + 1]);
                    this.updateScaledDistance(),
                    this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
                }
                const o = "Polygon" === Dh[e.type];
                let l = t.length;
                for (; l >= 2 && t[l - 1].equals(t[l - 2]); )
                    l--;
                let u = 0;
                for (; u < l - 1 && t[u].equals(t[u + 1]); )
                    u++;
                if (l < (o ? 3 : 2))
                    return;
                "bevel" === r && (i = 1.05);
                const c = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0
                  , h = this.segments.prepareSegment(10 * l, this.layoutVertexArray, this.indexArray);
                let p, f, d, y, m;
                this.e1 = this.e2 = -1,
                o && (p = t[l - 2],
                m = t[u].sub(p)._unit()._perp());
                for (let e = u; e < l; e++) {
                    if (d = e === l - 1 ? o ? t[u + 1] : void 0 : t[e + 1],
                    d && t[e].equals(d))
                        continue;
                    m && (y = m),
                    p && (f = p),
                    p = t[e],
                    m = d ? d.sub(p)._unit()._perp() : y,
                    y = y || m;
                    let g = y.add(m);
                    0 === g.x && 0 === g.y || g._unit();
                    const x = y.x * m.x + y.y * m.y
                      , v = g.x * m.x + g.y * m.y
                      , b = 0 !== v ? 1 / v : 1 / 0
                      , _ = 2 * Math.sqrt(2 - 2 * v)
                      , w = v < Eh && f && d
                      , A = y.x * m.y - y.y * m.x > 0;
                    if (w && e > u) {
                        const t = p.dist(f);
                        if (t > 2 * c) {
                            const e = p.sub(p.sub(f)._mult(c / t)._round());
                            this.updateDistance(f, e),
                            this.addCurrentVertex(e, y, 0, 0, h),
                            f = e;
                        }
                    }
                    const k = f && d;
                    let z = k ? r : o ? "butt" : n;
                    if (k && "round" === z && (b < s ? z = "miter" : b <= 2 && (z = "fakeround")),
                    "miter" === z && b > i && (z = "bevel"),
                    "bevel" === z && (b > 2 && (z = "flipbevel"),
                    b < i && (z = "miter")),
                    f && this.updateDistance(f, p),
                    "miter" === z)
                        g._mult(b),
                        this.addCurrentVertex(p, g, 0, 0, h);
                    else if ("flipbevel" === z) {
                        if (b > 100)
                            g = m.mult(-1);
                        else if (a)
                            g = y.add(m)._mult(b),
                            this.addCurrentVertex(p, g, 0, 0, h);
                        else {
                            const t = b * y.add(m).mag() / y.sub(m).mag();
                            g._perp()._mult(t * (A ? -1 : 1));
                        }
                        this.addCurrentVertex(p, g, 0, 0, h),
                        this.addCurrentVertex(p, g.mult(-1), 0, 0, h);
                    } else if ("bevel" === z || "fakeround" === z) {
                        const t = -Math.sqrt(b * b - 1)
                          , e = A ? t : 0
                          , r = A ? 0 : t;
                        if (f && this.addCurrentVertex(p, y, e, r, h),
                        "fakeround" === z) {
                            const t = Math.round(180 * _ / Math.PI / 20);
                            for (let e = 1; e < t; e++) {
                                let r = e / t;
                                if (.5 !== r) {
                                    const t = r - .5;
                                    r += r * t * (r - 1) * ((1.0904 + x * (x * (3.55645 - 1.43519 * x) - 3.2452)) * t * t + (.848013 + x * (.215638 * x - 1.06021)));
                                }
                                const n = m.sub(y)._mult(r)._add(y)._unit()._mult(A ? -1 : 1);
                                this.addHalfVertex(p, n.x, n.y, !1, A, 0, h);
                            }
                        }
                        d && this.addCurrentVertex(p, m, -e, -r, h);
                    } else if ("butt" === z)
                        this.addCurrentVertex(p, g, 0, 0, h);
                    else if ("square" === z) {
                        const t = f ? 1 : -1;
                        f || this.addCurrentVertex(p, g, t, t, h),
                        this.addCurrentVertex(p, g, 0, 0, h),
                        f && this.addCurrentVertex(p, g, t, t, h);
                    } else
                        "round" === z && (f && (this.addCurrentVertex(p, y, 0, 0, h),
                        this.addCurrentVertex(p, y, 1, 1, h, !0)),
                        d && (this.addCurrentVertex(p, m, -1, -1, h, !0),
                        this.addCurrentVertex(p, m, 0, 0, h)));
                    if (w && e < l - 1) {
                        const t = p.dist(d);
                        if (t > 2 * c) {
                            const e = p.add(d.sub(p)._mult(c / t)._round());
                            this.updateDistance(p, e),
                            this.addCurrentVertex(e, m, 0, 0, h),
                            p = e;
                        }
                    }
                }
            }
            addCurrentVertex(t, e, r, n, i, s=!1) {
                const a = e.y * n - e.x
                  , o = -e.y - e.x * n;
                this.addHalfVertex(t, e.x + e.y * r, e.y - e.x * r, s, !1, r, i),
                this.addHalfVertex(t, a, o, s, !0, -n, i);
            }
            addHalfVertex({x: t, y: e}, r, n, i, s, a, o) {
                this.layoutVertexArray.emplaceBack((t << 1) + (i ? 1 : 0), (e << 1) + (s ? 1 : 0), Math.round(63 * r) + 128, Math.round(63 * n) + 128, 1 + (0 === a ? 0 : a < 0 ? -1 : 1), 0, this.lineSoFar),
                this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);
                const l = o.vertexLength++;
                this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l),
                o.primitiveLength++),
                s ? this.e2 = l : this.e1 = l;
            }
            updateScaledDistance() {
                if (this.lineClips) {
                    const t = this.totalDistance / (this.lineClips.end - this.lineClips.start);
                    this.scaledDistance = this.distance / this.totalDistance,
                    this.lineSoFar = t * this.lineClips.start + this.distance;
                } else
                    this.lineSoFar = this.distance;
            }
            updateDistance(t, e) {
                this.distance += t.dist(e),
                this.updateScaledDistance();
            }
        }
        Bi(Fh, "LineBucket", {
            omit: ["layers", "patternFeatures"]
        });
        const Lh = new qs({
            "line-cap": new js(qt.layout_line["line-cap"]),
            "line-join": new js(qt.layout_line["line-join"]),
            "line-miter-limit": new Rs(qt.layout_line["line-miter-limit"]),
            "line-round-limit": new Rs(qt.layout_line["line-round-limit"]),
            "line-sort-key": new js(qt.layout_line["line-sort-key"]),
            "esymbol-id": new js(qt.layout_line["esymbol-id"])
        });
        var Rh = {
            paint: new qs({
                "line-opacity": new js(qt.paint_line["line-opacity"]),
                "line-color": new js(qt.paint_line["line-color"]),
                "line-translate": new Rs(qt.paint_line["line-translate"]),
                "line-translate-anchor": new Rs(qt.paint_line["line-translate-anchor"]),
                "line-width": new js(qt.paint_line["line-width"]),
                "line-gap-width": new js(qt.paint_line["line-gap-width"]),
                "line-offset": new js(qt.paint_line["line-offset"]),
                "line-blur": new js(qt.paint_line["line-blur"]),
                "line-dasharray": new Us(qt.paint_line["line-dasharray"]),
                "line-pattern": new Us(qt.paint_line["line-pattern"]),
                "line-gradient": new $s(qt.paint_line["line-gradient"]),
                "line-trim-offset": new Rs(qt.paint_line["line-trim-offset"]),
                "line-outline-color": new js(qt.paint_line["line-outline-color"]),
                "line-outline-width": new js(qt.paint_line["line-outline-width"]),
                "line-outline-dasharray": new Us(qt.paint_line["line-outline-dasharray"]),
                "line-minzoom": new js(qt.paint_line["line-minzoom"]),
                "line-maxzoom": new js(qt.paint_line["line-maxzoom"])
            }),
            layout: Lh
        };
        const jh = new class extends js {
            possiblyEvaluate(t, e) {
                return e = new Ts(Math.floor(e.zoom),{
                    now: e.now,
                    fadeDuration: e.fadeDuration,
                    zoomHistory: e.zoomHistory,
                    transition: e.transition
                }),
                super.possiblyEvaluate(t, e)
            }
            evaluate(t, e, r, n) {
                return e = v({}, e, {
                    zoom: Math.floor(e.zoom)
                }),
                super.evaluate(t, e, r, n)
            }
        }
        (Rh.paint.properties["line-width"].specification);
        jh.useIntegerZoom = !0;
        class Uh extends mo {
            constructor(t) {
                t && t.layout && "eline" == t.type && t.layout["esymbol-id"] && (t.paint["line-pattern"] = t.layout["esymbol-id"]),
                super(t, Rh),
                this.gradientVersion = 0;
            }
            _handleSpecialPaintPropertyUpdate(t) {
                if ("line-gradient" === t) {
                    const t = this._transitionablePaint._values["line-gradient"].value.expression;
                    this.stepInterpolant = t._styleExpression && t._styleExpression.expression instanceof yr,
                    this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
                }
            }
            gradientExpression() {
                return this._transitionablePaint._values["line-gradient"].value.expression
            }
            recalculate(t, e) {
                super.recalculate(t, e),
                this.paint._values["line-floorwidth"] = jh.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t),
                this.paint._values["line-outline-floorwidth"] = jh.possiblyEvaluate(this._transitioningPaint._values["line-outline-width"].value, t);
            }
            createBucket(t) {
                return new Fh(t)
            }
            getProgramIds() {
                return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"]
            }
            getProgramConfiguration(t) {
                return new oo(this,t)
            }
            queryRadius(t) {
                const e = t
                  , r = Oh(Math.max(jl("line-width", this, e), jl("line-outline-width", this, e)), jl("line-gap-width", this, e))
                  , n = jl("line-offset", this, e);
                return r / 2 + Math.abs(n) + Ul(this.paint.get("line-translate"))
            }
            queryIntersectsFeature(t, e, r, n, s, a) {
                if (t.queryGeometry.isAboveHorizon)
                    return !1;
                const o = Ol(t.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), a.angle, t.pixelToTileUnitsFactor)
                  , l = t.pixelToTileUnitsFactor / 2 * Oh(this.paint.get("line-width").evaluate(e, r) + this.paint.get("line-outline-width").evaluate(e, r), this.paint.get("line-gap-width").evaluate(e, r))
                  , u = this.paint.get("line-offset").evaluate(e, r);
                return u && (n = function(t, e) {
                    const r = []
                      , n = new i(0,0);
                    for (let i = 0; i < t.length; i++) {
                        const s = t[i]
                          , a = [];
                        for (let t = 0; t < s.length; t++) {
                            const r = s[t - 1]
                              , i = s[t]
                              , o = s[t + 1]
                              , l = 0 === t ? n : i.sub(r)._unit()._perp()
                              , u = t === s.length - 1 ? n : o.sub(i)._unit()._perp()
                              , c = l._add(u)._unit();
                            c._mult(1 / (c.x * u.x + c.y * u.y)),
                            a.push(c._mult(e)._add(i));
                        }
                        r.push(a);
                    }
                    return r
                }(n, u * t.pixelToTileUnitsFactor)),
                function(t, e, r) {
                    for (let n = 0; n < e.length; n++) {
                        const i = e[n];
                        if (t.length >= 3)
                            for (let e = 0; e < i.length; e++)
                                if (Fl(t, i[e]))
                                    return !0;
                        if (Bl(t, i, r))
                            return !0
                    }
                    return !1
                }(o, n, l)
            }
            isTileClipped() {
                return !0
            }
        }
        function Oh(t, e) {
            return e > 0 ? e + 2 * t : t
        }
        const $h = Ys([{
            name: "a_pos_offset",
            components: 4,
            type: "Int16"
        }, {
            name: "a_tex_size",
            components: 4,
            type: "Uint16"
        }, {
            name: "a_pixeloffset",
            components: 4,
            type: "Int16"
        }], 4)
          , qh = Ys([{
            name: "a_globe_anchor",
            components: 3,
            type: "Int16"
        }, {
            name: "a_globe_normal",
            components: 3,
            type: "Float32"
        }], 4)
          , Nh = Ys([{
            name: "a_projected_pos",
            components: 4,
            type: "Float32"
        }], 4);
        Ys([{
            name: "a_fade_opacity",
            components: 1,
            type: "Uint32"
        }], 4);
        const Zh = Ys([{
            name: "a_placed",
            components: 2,
            type: "Uint8"
        }, {
            name: "a_shift",
            components: 2,
            type: "Float32"
        }])
          , Gh = Ys([{
            name: "a_size_scale",
            components: 1,
            type: "Float32"
        }, {
            name: "a_padding",
            components: 2,
            type: "Float32"
        }]);
        Ys([{
            type: "Int16",
            name: "projectedAnchorX"
        }, {
            type: "Int16",
            name: "projectedAnchorY"
        }, {
            type: "Int16",
            name: "projectedAnchorZ"
        }, {
            type: "Int16",
            name: "tileAnchorX"
        }, {
            type: "Int16",
            name: "tileAnchorY"
        }, {
            type: "Float32",
            name: "x1"
        }, {
            type: "Float32",
            name: "y1"
        }, {
            type: "Float32",
            name: "x2"
        }, {
            type: "Float32",
            name: "y2"
        }, {
            type: "Int16",
            name: "padding"
        }, {
            type: "Uint32",
            name: "featureIndex"
        }, {
            type: "Uint16",
            name: "sourceLayerIndex"
        }, {
            type: "Uint16",
            name: "bucketIndex"
        }]);
        const Xh = Ys([{
            name: "a_pos",
            components: 3,
            type: "Int16"
        }, {
            name: "a_anchor_pos",
            components: 2,
            type: "Int16"
        }, {
            name: "a_extrude",
            components: 2,
            type: "Int16"
        }], 4)
          , Yh = Ys([{
            name: "a_pos_2f",
            components: 2,
            type: "Float32"
        }, {
            name: "a_radius",
            components: 1,
            type: "Float32"
        }, {
            name: "a_flags",
            components: 2,
            type: "Int16"
        }], 4);
        Ys([{
            name: "triangle",
            components: 3,
            type: "Uint16"
        }]),
        Ys([{
            type: "Int16",
            name: "projectedAnchorX"
        }, {
            type: "Int16",
            name: "projectedAnchorY"
        }, {
            type: "Int16",
            name: "projectedAnchorZ"
        }, {
            type: "Float32",
            name: "tileAnchorX"
        }, {
            type: "Float32",
            name: "tileAnchorY"
        }, {
            type: "Uint16",
            name: "glyphStartIndex"
        }, {
            type: "Uint16",
            name: "numGlyphs"
        }, {
            type: "Uint32",
            name: "vertexStartIndex"
        }, {
            type: "Uint32",
            name: "lineStartIndex"
        }, {
            type: "Uint32",
            name: "lineLength"
        }, {
            type: "Uint16",
            name: "segment"
        }, {
            type: "Uint16",
            name: "lowerSize"
        }, {
            type: "Uint16",
            name: "upperSize"
        }, {
            type: "Float32",
            name: "lineOffsetX"
        }, {
            type: "Float32",
            name: "lineOffsetY"
        }, {
            type: "Uint8",
            name: "writingMode"
        }, {
            type: "Uint8",
            name: "placedOrientation"
        }, {
            type: "Uint8",
            name: "hidden"
        }, {
            type: "Uint32",
            name: "crossTileID"
        }, {
            type: "Int16",
            name: "associatedIconIndex"
        }, {
            type: "Uint8",
            name: "flipState"
        }]),
        Ys([{
            type: "Int16",
            name: "projectedAnchorX"
        }, {
            type: "Int16",
            name: "projectedAnchorY"
        }, {
            type: "Int16",
            name: "projectedAnchorZ"
        }, {
            type: "Float32",
            name: "tileAnchorX"
        }, {
            type: "Float32",
            name: "tileAnchorY"
        }, {
            type: "Int16",
            name: "rightJustifiedTextSymbolIndex"
        }, {
            type: "Int16",
            name: "centerJustifiedTextSymbolIndex"
        }, {
            type: "Int16",
            name: "leftJustifiedTextSymbolIndex"
        }, {
            type: "Int16",
            name: "verticalPlacedTextSymbolIndex"
        }, {
            type: "Int16",
            name: "placedIconSymbolIndex"
        }, {
            type: "Int16",
            name: "verticalPlacedIconSymbolIndex"
        }, {
            type: "Uint16",
            name: "key"
        }, {
            type: "Uint16",
            name: "textBoxStartIndex"
        }, {
            type: "Uint16",
            name: "textBoxEndIndex"
        }, {
            type: "Uint16",
            name: "verticalTextBoxStartIndex"
        }, {
            type: "Uint16",
            name: "verticalTextBoxEndIndex"
        }, {
            type: "Uint16",
            name: "iconBoxStartIndex"
        }, {
            type: "Uint16",
            name: "iconBoxEndIndex"
        }, {
            type: "Uint16",
            name: "verticalIconBoxStartIndex"
        }, {
            type: "Uint16",
            name: "verticalIconBoxEndIndex"
        }, {
            type: "Uint16",
            name: "featureIndex"
        }, {
            type: "Uint16",
            name: "numHorizontalGlyphVertices"
        }, {
            type: "Uint16",
            name: "numVerticalGlyphVertices"
        }, {
            type: "Uint16",
            name: "numIconVertices"
        }, {
            type: "Uint16",
            name: "numVerticalIconVertices"
        }, {
            type: "Uint16",
            name: "useRuntimeCollisionCircles"
        }, {
            type: "Uint32",
            name: "crossTileID"
        }, {
            type: "Float32",
            components: 2,
            name: "textOffset"
        }, {
            type: "Float32",
            name: "collisionCircleDiameter"
        }]),
        Ys([{
            type: "Float32",
            name: "offsetX"
        }]),
        Ys([{
            type: "Int16",
            name: "x"
        }, {
            type: "Int16",
            name: "y"
        }, {
            type: "Int16",
            name: "tileUnitDistanceFromAnchor"
        }]);
        var Hh = 24;
        const Kh = 128;
        function Jh(t, e) {
            const {expression: r} = e;
            if ("constant" === r.kind)
                return {
                    kind: "constant",
                    layoutSize: r.evaluate(new Ts(t + 1))
                };
            if ("source" === r.kind)
                return {
                    kind: "source"
                };
            {
                const {zoomStops: e, interpolationType: n} = r;
                let i = 0;
                for (; i < e.length && e[i] <= t; )
                    i++;
                i = Math.max(0, i - 1);
                let s = i;
                for (; s < e.length && e[s] < t + 1; )
                    s++;
                s = Math.min(e.length - 1, s);
                const a = e[i]
                  , o = e[s];
                return "composite" === r.kind ? {
                    kind: "composite",
                    minZoom: a,
                    maxZoom: o,
                    interpolationType: n
                } : {
                    kind: "camera",
                    minZoom: a,
                    maxZoom: o,
                    minSize: r.evaluate(new Ts(a)),
                    maxSize: r.evaluate(new Ts(o)),
                    interpolationType: n
                }
            }
        }
        function Wh(t, {uSize: e, uSizeT: r}, {lowerSize: n, upperSize: i}) {
            return "source" === t.kind ? n / Kh : "composite" === t.kind ? mr(n / Kh, i / Kh, r) : e
        }
        function Qh(t, e) {
            let r = 0
              , n = 0;
            if ("constant" === t.kind)
                n = t.layoutSize;
            else if ("source" !== t.kind) {
                const {interpolationType: i, minZoom: s, maxZoom: a} = t
                  , o = i ? d(Lr.interpolationFactor(i, e, s, a), 0, 1) : 0;
                "camera" === t.kind ? n = mr(t.minSize, t.maxSize, o) : r = o;
            }
            return {
                uSizeT: r,
                uSize: n
            }
        }
        var tp = Object.freeze({
            __proto__: null,
            getSizeData: Jh,
            evaluateSizeForFeature: Wh,
            evaluateSizeForZoom: Qh,
            SIZE_PACK_FACTOR: Kh
        });
        function ep(t, e, r) {
            return t.sections.forEach((t => {
                t.text = function(t, e, r) {
                    const n = e.layout.get("text-transform").evaluate(r, {});
                    return "uppercase" === n ? t = t.toLocaleUpperCase() : "lowercase" === n && (t = t.toLocaleLowerCase()),
                    Is.applyArabicShaping && (t = Is.applyArabicShaping(t)),
                    t
                }(t.text, e, r);
            }
            )),
            t
        }
        const rp = {
            "!": "︕",
            "#": "＃",
            $: "＄",
            "%": "％",
            "&": "＆",
            "(": "︵",
            ")": "︶",
            "*": "＊",
            "+": "＋",
            ",": "︐",
            "-": "︲",
            ".": "・",
            "/": "／",
            ":": "︓",
            ";": "︔",
            "<": "︿",
            "=": "＝",
            ">": "﹀",
            "?": "︖",
            "@": "＠",
            "[": "﹇",
            "\\": "＼",
            "]": "﹈",
            "^": "＾",
            _: "︳",
            "`": "｀",
            "{": "︷",
            "|": "―",
            "}": "︸",
            "~": "～",
            "¢": "￠",
            "£": "￡",
            "¥": "￥",
            "¦": "￤",
            "¬": "￢",
            "¯": "￣",
            "–": "︲",
            "—": "︱",
            "‘": "﹃",
            "’": "﹄",
            "“": "﹁",
            "”": "﹂",
            "…": "︙",
            "‧": "・",
            "₩": "￦",
            "、": "︑",
            "。": "︒",
            "〈": "︿",
            "〉": "﹀",
            "《": "︽",
            "》": "︾",
            "「": "﹁",
            "」": "﹂",
            "『": "﹃",
            "』": "﹄",
            "【": "︻",
            "】": "︼",
            "〔": "︹",
            "〕": "︺",
            "〖": "︗",
            "〗": "︘",
            "！": "︕",
            "（": "︵",
            "）": "︶",
            "，": "︐",
            "－": "︲",
            "．": "・",
            "：": "︓",
            "；": "︔",
            "＜": "︿",
            "＞": "﹀",
            "？": "︖",
            "［": "﹇",
            "］": "﹈",
            "＿": "︳",
            "｛": "︷",
            "｜": "―",
            "｝": "︸",
            "｟": "︵",
            "｠": "︶",
            "｡": "︒",
            "｢": "﹁",
            "｣": "﹂"
        };
        function np(t) {
            return "︶" === t || "﹈" === t || "︸" === t || "﹄" === t || "﹂" === t || "︾" === t || "︼" === t || "︺" === t || "︘" === t || "﹀" === t || "︐" === t || "︓" === t || "︔" === t || "｀" === t || "￣" === t || "︑" === t || "︒" === t
        }
        function ip(t) {
            return "︵" === t || "﹇" === t || "︷" === t || "﹃" === t || "﹁" === t || "︽" === t || "︻" === t || "︹" === t || "︗" === t || "︿" === t
        }
        var sp = function(t, e, r, n, i) {
            var s, a, o = 8 * i - n - 1, l = (1 << o) - 1, u = l >> 1, c = -7, h = r ? i - 1 : 0, p = r ? -1 : 1, f = t[e + h];
            for (h += p,
            s = f & (1 << -c) - 1,
            f >>= -c,
            c += o; c > 0; s = 256 * s + t[e + h],
            h += p,
            c -= 8)
                ;
            for (a = s & (1 << -c) - 1,
            s >>= -c,
            c += n; c > 0; a = 256 * a + t[e + h],
            h += p,
            c -= 8)
                ;
            if (0 === s)
                s = 1 - u;
            else {
                if (s === l)
                    return a ? NaN : 1 / 0 * (f ? -1 : 1);
                a += Math.pow(2, n),
                s -= u;
            }
            return (f ? -1 : 1) * a * Math.pow(2, s - n)
        }
          , ap = function(t, e, r, n, i, s) {
            var a, o, l, u = 8 * s - i - 1, c = (1 << u) - 1, h = c >> 1, p = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = n ? 0 : s - 1, d = n ? 1 : -1, y = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;
            for (e = Math.abs(e),
            isNaN(e) || e === 1 / 0 ? (o = isNaN(e) ? 1 : 0,
            a = c) : (a = Math.floor(Math.log(e) / Math.LN2),
            e * (l = Math.pow(2, -a)) < 1 && (a--,
            l *= 2),
            (e += a + h >= 1 ? p / l : p * Math.pow(2, 1 - h)) * l >= 2 && (a++,
            l /= 2),
            a + h >= c ? (o = 0,
            a = c) : a + h >= 1 ? (o = (e * l - 1) * Math.pow(2, i),
            a += h) : (o = e * Math.pow(2, h - 1) * Math.pow(2, i),
            a = 0)); i >= 8; t[r + f] = 255 & o,
            f += d,
            o /= 256,
            i -= 8)
                ;
            for (a = a << i | o,
            u += i; u > 0; t[r + f] = 255 & a,
            f += d,
            a /= 256,
            u -= 8)
                ;
            t[r + f - d] |= 128 * y;
        }
          , op = lp;
        function lp(t) {
            this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t) ? t : new Uint8Array(t || 0),
            this.pos = 0,
            this.type = 0,
            this.length = this.buf.length;
        }
        lp.Varint = 0,
        lp.Fixed64 = 1,
        lp.Bytes = 2,
        lp.Fixed32 = 5;
        var up = 4294967296
          , cp = 1 / up
          , hp = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
        function pp(t) {
            return t.type === lp.Bytes ? t.readVarint() + t.pos : t.pos + 1
        }
        function fp(t, e, r) {
            return r ? 4294967296 * e + (t >>> 0) : 4294967296 * (e >>> 0) + (t >>> 0)
        }
        function dp(t, e, r) {
            var n = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2));
            r.realloc(n);
            for (var i = r.pos - 1; i >= t; i--)
                r.buf[i + n] = r.buf[i];
        }
        function yp(t, e) {
            for (var r = 0; r < t.length; r++)
                e.writeVarint(t[r]);
        }
        function mp(t, e) {
            for (var r = 0; r < t.length; r++)
                e.writeSVarint(t[r]);
        }
        function gp(t, e) {
            for (var r = 0; r < t.length; r++)
                e.writeFloat(t[r]);
        }
        function xp(t, e) {
            for (var r = 0; r < t.length; r++)
                e.writeDouble(t[r]);
        }
        function vp(t, e) {
            for (var r = 0; r < t.length; r++)
                e.writeBoolean(t[r]);
        }
        function bp(t, e) {
            for (var r = 0; r < t.length; r++)
                e.writeFixed32(t[r]);
        }
        function _p(t, e) {
            for (var r = 0; r < t.length; r++)
                e.writeSFixed32(t[r]);
        }
        function wp(t, e) {
            for (var r = 0; r < t.length; r++)
                e.writeFixed64(t[r]);
        }
        function Ap(t, e) {
            for (var r = 0; r < t.length; r++)
                e.writeSFixed64(t[r]);
        }
        function kp(t, e) {
            return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + 16777216 * t[e + 3]
        }
        function zp(t, e, r) {
            t[r] = e,
            t[r + 1] = e >>> 8,
            t[r + 2] = e >>> 16,
            t[r + 3] = e >>> 24;
        }
        function Sp(t, e) {
            return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + (t[e + 3] << 24)
        }
        function Mp(t, e, r) {
            e.glyphs = [],
            1 === t && r.readMessage(Ip, e);
        }
        function Ip(t, e, r) {
            if (3 === t) {
                const {id: t, bitmap: n, width: i, height: s, left: a, top: o, advance: l} = r.readMessage(Tp, {});
                e.glyphs.push({
                    id: t,
                    bitmap: new Wu({
                        width: i + 6,
                        height: s + 6
                    },n),
                    metrics: {
                        width: i,
                        height: s,
                        left: a,
                        top: o,
                        advance: l
                    }
                });
            } else
                4 === t ? e.ascender = r.readSVarint() : 5 === t && (e.descender = r.readSVarint());
        }
        function Tp(t, e, r) {
            1 === t ? e.id = r.readVarint() : 2 === t ? e.bitmap = r.readBytes() : 3 === t ? e.width = r.readVarint() : 4 === t ? e.height = r.readVarint() : 5 === t ? e.left = r.readSVarint() : 6 === t ? e.top = r.readSVarint() : 7 === t && (e.advance = r.readVarint());
        }
        function Bp(t) {
            let e = 0
              , r = 0;
            for (const n of t)
                e += n.w * n.h,
                r = Math.max(r, n.w);
            t.sort(( (t, e) => e.h - t.h));
            const n = [{
                x: 0,
                y: 0,
                w: Math.max(Math.ceil(Math.sqrt(e / .95)), r),
                h: 1 / 0
            }];
            let i = 0
              , s = 0;
            for (const e of t)
                for (let t = n.length - 1; t >= 0; t--) {
                    const r = n[t];
                    if (!(e.w > r.w || e.h > r.h)) {
                        if (e.x = r.x,
                        e.y = r.y,
                        s = Math.max(s, e.y + e.h),
                        i = Math.max(i, e.x + e.w),
                        e.w === r.w && e.h === r.h) {
                            const e = n.pop();
                            t < n.length && (n[t] = e);
                        } else
                            e.h === r.h ? (r.x += e.w,
                            r.w -= e.w) : e.w === r.w ? (r.y += e.h,
                            r.h -= e.h) : (n.push({
                                x: r.x + e.w,
                                y: r.y,
                                w: r.w - e.w,
                                h: e.h
                            }),
                            r.y += e.h,
                            r.h -= e.h);
                        break
                    }
                }
            return {
                w: i,
                h: s,
                fill: e / (i * s) || 0
            }
        }
        lp.prototype = {
            destroy: function() {
                this.buf = null;
            },
            readFields: function(t, e, r) {
                for (r = r || this.length; this.pos < r; ) {
                    var n = this.readVarint()
                      , i = n >> 3
                      , s = this.pos;
                    this.type = 7 & n,
                    t(i, e, this),
                    this.pos === s && this.skip(n);
                }
                return e
            },
            readMessage: function(t, e) {
                return this.readFields(t, e, this.readVarint() + this.pos)
            },
            readFixed32: function() {
                var t = kp(this.buf, this.pos);
                return this.pos += 4,
                t
            },
            readSFixed32: function() {
                var t = Sp(this.buf, this.pos);
                return this.pos += 4,
                t
            },
            readFixed64: function() {
                var t = kp(this.buf, this.pos) + kp(this.buf, this.pos + 4) * up;
                return this.pos += 8,
                t
            },
            readSFixed64: function() {
                var t = kp(this.buf, this.pos) + Sp(this.buf, this.pos + 4) * up;
                return this.pos += 8,
                t
            },
            readFloat: function() {
                var t = sp(this.buf, this.pos, !0, 23, 4);
                return this.pos += 4,
                t
            },
            readDouble: function() {
                var t = sp(this.buf, this.pos, !0, 52, 8);
                return this.pos += 8,
                t
            },
            readVarint: function(t) {
                var e, r, n = this.buf;
                return e = 127 & (r = n[this.pos++]),
                r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 7,
                r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 14,
                r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 21,
                r < 128 ? e : function(t, e, r) {
                    var n, i, s = r.buf;
                    if (n = (112 & (i = s[r.pos++])) >> 4,
                    i < 128)
                        return fp(t, n, e);
                    if (n |= (127 & (i = s[r.pos++])) << 3,
                    i < 128)
                        return fp(t, n, e);
                    if (n |= (127 & (i = s[r.pos++])) << 10,
                    i < 128)
                        return fp(t, n, e);
                    if (n |= (127 & (i = s[r.pos++])) << 17,
                    i < 128)
                        return fp(t, n, e);
                    if (n |= (127 & (i = s[r.pos++])) << 24,
                    i < 128)
                        return fp(t, n, e);
                    if (n |= (1 & (i = s[r.pos++])) << 31,
                    i < 128)
                        return fp(t, n, e);
                    throw new Error("Expected varint not more than 10 bytes")
                }(e |= (15 & (r = n[this.pos])) << 28, t, this))))
            },
            readVarint64: function() {
                return this.readVarint(!0)
            },
            readSVarint: function() {
                var t = this.readVarint();
                return t % 2 == 1 ? (t + 1) / -2 : t / 2
            },
            readBoolean: function() {
                return Boolean(this.readVarint())
            },
            readString: function() {
                var t = this.readVarint() + this.pos
                  , e = this.pos;
                return this.pos = t,
                t - e >= 12 && hp ? function(t, e, r) {
                    return hp.decode(t.subarray(e, r))
                }(this.buf, e, t) : function(t, e, r) {
                    for (var n = "", i = e; i < r; ) {
                        var s, a, o, l = t[i], u = null, c = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;
                        if (i + c > r)
                            break;
                        1 === c ? l < 128 && (u = l) : 2 === c ? 128 == (192 & (s = t[i + 1])) && (u = (31 & l) << 6 | 63 & s) <= 127 && (u = null) : 3 === c ? (a = t[i + 2],
                        128 == (192 & (s = t[i + 1])) && 128 == (192 & a) && ((u = (15 & l) << 12 | (63 & s) << 6 | 63 & a) <= 2047 || u >= 55296 && u <= 57343) && (u = null)) : 4 === c && (a = t[i + 2],
                        o = t[i + 3],
                        128 == (192 & (s = t[i + 1])) && 128 == (192 & a) && 128 == (192 & o) && ((u = (15 & l) << 18 | (63 & s) << 12 | (63 & a) << 6 | 63 & o) <= 65535 || u >= 1114112) && (u = null)),
                        null === u ? (u = 65533,
                        c = 1) : u > 65535 && (u -= 65536,
                        n += String.fromCharCode(u >>> 10 & 1023 | 55296),
                        u = 56320 | 1023 & u),
                        n += String.fromCharCode(u),
                        i += c;
                    }
                    return n
                }(this.buf, e, t)
            },
            readBytes: function() {
                var t = this.readVarint() + this.pos
                  , e = this.buf.subarray(this.pos, t);
                return this.pos = t,
                e
            },
            readPackedVarint: function(t, e) {
                if (this.type !== lp.Bytes)
                    return t.push(this.readVarint(e));
                var r = pp(this);
                for (t = t || []; this.pos < r; )
                    t.push(this.readVarint(e));
                return t
            },
            readPackedSVarint: function(t) {
                if (this.type !== lp.Bytes)
                    return t.push(this.readSVarint());
                var e = pp(this);
                for (t = t || []; this.pos < e; )
                    t.push(this.readSVarint());
                return t
            },
            readPackedBoolean: function(t) {
                if (this.type !== lp.Bytes)
                    return t.push(this.readBoolean());
                var e = pp(this);
                for (t = t || []; this.pos < e; )
                    t.push(this.readBoolean());
                return t
            },
            readPackedFloat: function(t) {
                if (this.type !== lp.Bytes)
                    return t.push(this.readFloat());
                var e = pp(this);
                for (t = t || []; this.pos < e; )
                    t.push(this.readFloat());
                return t
            },
            readPackedDouble: function(t) {
                if (this.type !== lp.Bytes)
                    return t.push(this.readDouble());
                var e = pp(this);
                for (t = t || []; this.pos < e; )
                    t.push(this.readDouble());
                return t
            },
            readPackedFixed32: function(t) {
                if (this.type !== lp.Bytes)
                    return t.push(this.readFixed32());
                var e = pp(this);
                for (t = t || []; this.pos < e; )
                    t.push(this.readFixed32());
                return t
            },
            readPackedSFixed32: function(t) {
                if (this.type !== lp.Bytes)
                    return t.push(this.readSFixed32());
                var e = pp(this);
                for (t = t || []; this.pos < e; )
                    t.push(this.readSFixed32());
                return t
            },
            readPackedFixed64: function(t) {
                if (this.type !== lp.Bytes)
                    return t.push(this.readFixed64());
                var e = pp(this);
                for (t = t || []; this.pos < e; )
                    t.push(this.readFixed64());
                return t
            },
            readPackedSFixed64: function(t) {
                if (this.type !== lp.Bytes)
                    return t.push(this.readSFixed64());
                var e = pp(this);
                for (t = t || []; this.pos < e; )
                    t.push(this.readSFixed64());
                return t
            },
            skip: function(t) {
                var e = 7 & t;
                if (e === lp.Varint)
                    for (; this.buf[this.pos++] > 127; )
                        ;
                else if (e === lp.Bytes)
                    this.pos = this.readVarint() + this.pos;
                else if (e === lp.Fixed32)
                    this.pos += 4;
                else {
                    if (e !== lp.Fixed64)
                        throw new Error("Unimplemented type: " + e);
                    this.pos += 8;
                }
            },
            writeTag: function(t, e) {
                this.writeVarint(t << 3 | e);
            },
            realloc: function(t) {
                for (var e = this.length || 16; e < this.pos + t; )
                    e *= 2;
                if (e !== this.length) {
                    var r = new Uint8Array(e);
                    r.set(this.buf),
                    this.buf = r,
                    this.length = e;
                }
            },
            finish: function() {
                return this.length = this.pos,
                this.pos = 0,
                this.buf.subarray(0, this.length)
            },
            writeFixed32: function(t) {
                this.realloc(4),
                zp(this.buf, t, this.pos),
                this.pos += 4;
            },
            writeSFixed32: function(t) {
                this.realloc(4),
                zp(this.buf, t, this.pos),
                this.pos += 4;
            },
            writeFixed64: function(t) {
                this.realloc(8),
                zp(this.buf, -1 & t, this.pos),
                zp(this.buf, Math.floor(t * cp), this.pos + 4),
                this.pos += 8;
            },
            writeSFixed64: function(t) {
                this.realloc(8),
                zp(this.buf, -1 & t, this.pos),
                zp(this.buf, Math.floor(t * cp), this.pos + 4),
                this.pos += 8;
            },
            writeVarint: function(t) {
                (t = +t || 0) > 268435455 || t < 0 ? function(t, e) {
                    var r, n;
                    if (t >= 0 ? (r = t % 4294967296 | 0,
                    n = t / 4294967296 | 0) : (n = ~(-t / 4294967296),
                    4294967295 ^ (r = ~(-t % 4294967296)) ? r = r + 1 | 0 : (r = 0,
                    n = n + 1 | 0)),
                    t >= 0x10000000000000000 || t < -0x10000000000000000)
                        throw new Error("Given varint doesn't fit into 10 bytes");
                    e.realloc(10),
                    function(t, e, r) {
                        r.buf[r.pos++] = 127 & t | 128,
                        t >>>= 7,
                        r.buf[r.pos++] = 127 & t | 128,
                        t >>>= 7,
                        r.buf[r.pos++] = 127 & t | 128,
                        t >>>= 7,
                        r.buf[r.pos++] = 127 & t | 128,
                        r.buf[r.pos] = 127 & (t >>>= 7);
                    }(r, 0, e),
                    function(t, e) {
                        var r = (7 & t) << 4;
                        e.buf[e.pos++] |= r | ((t >>>= 3) ? 128 : 0),
                        t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0),
                        t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0),
                        t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0),
                        t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0),
                        t && (e.buf[e.pos++] = 127 & t)))));
                    }(n, e);
                }(t, this) : (this.realloc(4),
                this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0),
                t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0),
                t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0),
                t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))));
            },
            writeSVarint: function(t) {
                this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);
            },
            writeBoolean: function(t) {
                this.writeVarint(Boolean(t));
            },
            writeString: function(t) {
                t = String(t),
                this.realloc(4 * t.length),
                this.pos++;
                var e = this.pos;
                this.pos = function(t, e, r) {
                    for (var n, i, s = 0; s < e.length; s++) {
                        if ((n = e.charCodeAt(s)) > 55295 && n < 57344) {
                            if (!i) {
                                n > 56319 || s + 1 === e.length ? (t[r++] = 239,
                                t[r++] = 191,
                                t[r++] = 189) : i = n;
                                continue
                            }
                            if (n < 56320) {
                                t[r++] = 239,
                                t[r++] = 191,
                                t[r++] = 189,
                                i = n;
                                continue
                            }
                            n = i - 55296 << 10 | n - 56320 | 65536,
                            i = null;
                        } else
                            i && (t[r++] = 239,
                            t[r++] = 191,
                            t[r++] = 189,
                            i = null);
                        n < 128 ? t[r++] = n : (n < 2048 ? t[r++] = n >> 6 | 192 : (n < 65536 ? t[r++] = n >> 12 | 224 : (t[r++] = n >> 18 | 240,
                        t[r++] = n >> 12 & 63 | 128),
                        t[r++] = n >> 6 & 63 | 128),
                        t[r++] = 63 & n | 128);
                    }
                    return r
                }(this.buf, t, this.pos);
                var r = this.pos - e;
                r >= 128 && dp(e, r, this),
                this.pos = e - 1,
                this.writeVarint(r),
                this.pos += r;
            },
            writeFloat: function(t) {
                this.realloc(4),
                ap(this.buf, t, this.pos, !0, 23, 4),
                this.pos += 4;
            },
            writeDouble: function(t) {
                this.realloc(8),
                ap(this.buf, t, this.pos, !0, 52, 8),
                this.pos += 8;
            },
            writeBytes: function(t) {
                var e = t.length;
                this.writeVarint(e),
                this.realloc(e);
                for (var r = 0; r < e; r++)
                    this.buf[this.pos++] = t[r];
            },
            writeRawMessage: function(t, e) {
                this.pos++;
                var r = this.pos;
                t(e, this);
                var n = this.pos - r;
                n >= 128 && dp(r, n, this),
                this.pos = r - 1,
                this.writeVarint(n),
                this.pos += n;
            },
            writeMessage: function(t, e, r) {
                this.writeTag(t, lp.Bytes),
                this.writeRawMessage(e, r);
            },
            writePackedVarint: function(t, e) {
                e.length && this.writeMessage(t, yp, e);
            },
            writePackedSVarint: function(t, e) {
                e.length && this.writeMessage(t, mp, e);
            },
            writePackedBoolean: function(t, e) {
                e.length && this.writeMessage(t, vp, e);
            },
            writePackedFloat: function(t, e) {
                e.length && this.writeMessage(t, gp, e);
            },
            writePackedDouble: function(t, e) {
                e.length && this.writeMessage(t, xp, e);
            },
            writePackedFixed32: function(t, e) {
                e.length && this.writeMessage(t, bp, e);
            },
            writePackedSFixed32: function(t, e) {
                e.length && this.writeMessage(t, _p, e);
            },
            writePackedFixed64: function(t, e) {
                e.length && this.writeMessage(t, wp, e);
            },
            writePackedSFixed64: function(t, e) {
                e.length && this.writeMessage(t, Ap, e);
            },
            writeBytesField: function(t, e) {
                this.writeTag(t, lp.Bytes),
                this.writeBytes(e);
            },
            writeFixed32Field: function(t, e) {
                this.writeTag(t, lp.Fixed32),
                this.writeFixed32(e);
            },
            writeSFixed32Field: function(t, e) {
                this.writeTag(t, lp.Fixed32),
                this.writeSFixed32(e);
            },
            writeFixed64Field: function(t, e) {
                this.writeTag(t, lp.Fixed64),
                this.writeFixed64(e);
            },
            writeSFixed64Field: function(t, e) {
                this.writeTag(t, lp.Fixed64),
                this.writeSFixed64(e);
            },
            writeVarintField: function(t, e) {
                this.writeTag(t, lp.Varint),
                this.writeVarint(e);
            },
            writeSVarintField: function(t, e) {
                this.writeTag(t, lp.Varint),
                this.writeSVarint(e);
            },
            writeStringField: function(t, e) {
                this.writeTag(t, lp.Bytes),
                this.writeString(e);
            },
            writeFloatField: function(t, e) {
                this.writeTag(t, lp.Fixed32),
                this.writeFloat(e);
            },
            writeDoubleField: function(t, e) {
                this.writeTag(t, lp.Fixed64),
                this.writeDouble(e);
            },
            writeBooleanField: function(t, e) {
                this.writeVarintField(t, Boolean(e));
            }
        };
        class Cp {
            constructor(t, {pixelRatio: e, version: r, stretchX: n, stretchY: i, content: s}) {
                this.paddedRect = t,
                this.pixelRatio = e,
                this.stretchX = n,
                this.stretchY = i,
                this.content = s,
                this.version = r;
            }
            get tl() {
                return [this.paddedRect.x + 1, this.paddedRect.y + 1]
            }
            get br() {
                return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1]
            }
            get displaySize() {
                return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio]
            }
        }
        class Vp {
            constructor(t, e) {
                const r = {}
                  , n = {};
                this.haveRenderCallbacks = [];
                const i = [];
                this.addImages(t, r, i),
                this.addImages(e, n, i);
                const {w: s, h: a} = Bp(i)
                  , o = new Qu({
                    width: s || 1,
                    height: a || 1
                });
                for (const e in t) {
                    const n = t[e]
                      , i = r[e].paddedRect;
                    Qu.copy(n.data, o, {
                        x: 0,
                        y: 0
                    }, {
                        x: i.x + 1,
                        y: i.y + 1
                    }, n.data);
                }
                for (const t in e) {
                    const r = e[t]
                      , i = n[t].paddedRect
                      , s = i.x + 1
                      , a = i.y + 1
                      , l = r.data.width
                      , u = r.data.height;
                    Qu.copy(r.data, o, {
                        x: 0,
                        y: 0
                    }, {
                        x: s,
                        y: a
                    }, r.data),
                    Qu.copy(r.data, o, {
                        x: 0,
                        y: u - 1
                    }, {
                        x: s,
                        y: a - 1
                    }, {
                        width: l,
                        height: 1
                    }),
                    Qu.copy(r.data, o, {
                        x: 0,
                        y: 0
                    }, {
                        x: s,
                        y: a + u
                    }, {
                        width: l,
                        height: 1
                    }),
                    Qu.copy(r.data, o, {
                        x: l - 1,
                        y: 0
                    }, {
                        x: s - 1,
                        y: a
                    }, {
                        width: 1,
                        height: u
                    }),
                    Qu.copy(r.data, o, {
                        x: 0,
                        y: 0
                    }, {
                        x: s + l,
                        y: a
                    }, {
                        width: 1,
                        height: u
                    });
                }
                this.image = o,
                this.iconPositions = r,
                this.patternPositions = n;
            }
            addImages(t, e, r) {
                for (const n in t) {
                    const i = t[n]
                      , s = {
                        x: 0,
                        y: 0,
                        w: i.data.width + 2,
                        h: i.data.height + 2
                    };
                    r.push(s),
                    e[n] = new Cp(s,i),
                    i.hasRenderCallback && this.haveRenderCallbacks.push(n);
                }
            }
            patchUpdatedImages(t, e) {
                this.haveRenderCallbacks = this.haveRenderCallbacks.filter((e => t.hasImage(e))),
                t.dispatchRenderCallbacks(this.haveRenderCallbacks);
                for (const r in t.updatedImages)
                    this.patchUpdatedImage(this.iconPositions[r], t.getImage(r), e),
                    this.patchUpdatedImage(this.patternPositions[r], t.getImage(r), e);
            }
            patchUpdatedImage(t, e, r) {
                if (!t || !e)
                    return;
                if (t.version === e.version)
                    return;
                t.version = e.version;
                const [n,i] = t.tl;
                r.update(e.data, void 0, {
                    x: n,
                    y: i
                });
            }
        }
        Bi(Cp, "ImagePosition"),
        Bi(Vp, "ImageAtlas");
        const Pp = {
            horizontal: 1,
            vertical: 2,
            horizontalOnly: 3
        };
        class Dp {
            constructor() {
                this.scale = 1,
                this.fontStack = "",
                this.imageName = null;
            }
            static forText(t, e) {
                const r = new Dp;
                return r.scale = t || 1,
                r.fontStack = e,
                r
            }
            static forImage(t) {
                const e = new Dp;
                return e.imageName = t,
                e
            }
        }
        class Ep {
            constructor() {
                this.text = "",
                this.sectionIndex = [],
                this.sections = [],
                this.imageSectionID = null;
            }
            static fromFeature(t, e) {
                const r = new Ep;
                for (let n = 0; n < t.sections.length; n++) {
                    const i = t.sections[n];
                    i.image ? r.addImageSection(i) : r.addTextSection(i, e);
                }
                return r
            }
            length() {
                return this.text.length
            }
            getSection(t) {
                return this.sections[this.sectionIndex[t]]
            }
            getSections() {
                return this.sections
            }
            getSectionIndex(t) {
                return this.sectionIndex[t]
            }
            getCharCode(t) {
                return this.text.charCodeAt(t)
            }
            verticalizePunctuation(t) {
                this.text = function(t, e) {
                    let r = "";
                    for (let n = 0; n < t.length; n++) {
                        const i = t.charCodeAt(n + 1) || null
                          , s = t.charCodeAt(n - 1) || null;
                        r += !e && (i && fs(i) && !rp[t[n + 1]] || s && fs(s) && !rp[t[n - 1]]) || !rp[t[n]] ? t[n] : rp[t[n]];
                    }
                    return r
                }(this.text, t);
            }
            trim() {
                let t = 0;
                for (let e = 0; e < this.text.length && Lp[this.text.charCodeAt(e)]; e++)
                    t++;
                let e = this.text.length;
                for (let r = this.text.length - 1; r >= 0 && r >= t && Lp[this.text.charCodeAt(r)]; r--)
                    e--;
                this.text = this.text.substring(t, e),
                this.sectionIndex = this.sectionIndex.slice(t, e);
            }
            substring(t, e) {
                const r = new Ep;
                return r.text = this.text.substring(t, e),
                r.sectionIndex = this.sectionIndex.slice(t, e),
                r.sections = this.sections,
                r
            }
            toString() {
                return this.text
            }
            getMaxScale() {
                return this.sectionIndex.reduce(( (t, e) => Math.max(t, this.sections[e].scale)), 0)
            }
            addTextSection(t, e) {
                this.text += t.text,
                this.sections.push(Dp.forText(t.scale, t.fontStack || e));
                const r = this.sections.length - 1;
                for (let e = 0; e < t.text.length; ++e)
                    this.sectionIndex.push(r);
            }
            addImageSection(t) {
                const e = t.image ? t.image.name : "";
                if (0 === e.length)
                    return void B("Can't add FormattedSection with an empty image.");
                const r = this.getNextImageSectionCharCode();
                r ? (this.text += String.fromCharCode(r),
                this.sections.push(Dp.forImage(e)),
                this.sectionIndex.push(this.sections.length - 1)) : B("Reached maximum number of images 6401");
            }
            getNextImageSectionCharCode() {
                return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344,
                this.imageSectionID)
            }
        }
        function Fp(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y) {
            const m = Ep.fromFeature(t, i);
            let g;
            h === Pp.vertical && m.verticalizePunctuation(p);
            const {processBidirectionalText: x, processStyledBidirectionalText: v} = Is;
            if (x && 1 === m.sections.length) {
                g = [];
                const t = x(m.toString(), Np(m, u, s, e, n, f, d));
                for (const e of t) {
                    const t = new Ep;
                    t.text = e,
                    t.sections = m.sections;
                    for (let r = 0; r < e.length; r++)
                        t.sectionIndex.push(0);
                    g.push(t);
                }
            } else if (v) {
                g = [];
                const t = v(m.text, m.sectionIndex, Np(m, u, s, e, n, f, d));
                for (const e of t) {
                    const t = new Ep;
                    t.text = e[0],
                    t.sectionIndex = e[1],
                    t.sections = m.sections,
                    g.push(t);
                }
            } else
                g = function(t, e) {
                    const r = []
                      , n = t.text;
                    let i = 0;
                    for (const n of e)
                        r.push(t.substring(i, n)),
                        i = n;
                    return i < n.length && r.push(t.substring(i, n.length)),
                    r
                }(m, Np(m, u, s, e, n, f, d));
            const b = []
              , _ = {
                positionedLines: b,
                text: m.toString(),
                top: c[1],
                bottom: c[1],
                left: c[0],
                right: c[0],
                writingMode: h,
                iconsInText: !1,
                verticalizable: !1,
                hasBaseline: !1
            };
            return function(t, e, r, n, i, s, a, o, l, u, c, h) {
                let p = 0
                  , f = 0
                  , d = 0;
                const y = "right" === o ? 1 : "left" === o ? 0 : .5;
                let m = !1;
                for (const t of i) {
                    const r = t.getSections();
                    for (const t of r) {
                        if (t.imageName)
                            continue;
                        const r = e[t.fontStack];
                        if (r && (m = void 0 !== r.ascender && void 0 !== r.descender,
                        !m))
                            break
                    }
                    if (!m)
                        break
                }
                let g = 0;
                for (const a of i) {
                    a.trim();
                    const i = a.getMaxScale()
                      , o = (i - 1) * Hh
                      , v = {
                        positionedGlyphs: [],
                        lineOffset: 0
                    };
                    t.positionedLines[g] = v;
                    const b = v.positionedGlyphs;
                    let _ = 0;
                    if (!a.length()) {
                        f += s,
                        ++g;
                        continue
                    }
                    let w = 0
                      , A = 0;
                    for (let s = 0; s < a.length(); s++) {
                        const o = a.getSection(s)
                          , d = a.getSectionIndex(s)
                          , y = a.getCharCode(s);
                        let g = o.scale
                          , v = null
                          , k = null
                          , z = null
                          , S = Hh
                          , M = 0;
                        const I = !(l === Pp.horizontal || !c && !ps(y) || c && (Lp[y] || (x = y,
                        Fi(x) || Li(x) || Ri(x) || ns(x) || os(x))));
                        if (o.imageName) {
                            const e = n[o.imageName];
                            if (!e)
                                continue;
                            z = o.imageName,
                            t.iconsInText = t.iconsInText || !0,
                            k = e.paddedRect;
                            const r = e.displaySize;
                            g = g * Hh / h,
                            v = {
                                width: r[0],
                                height: r[1],
                                left: 1,
                                top: -3,
                                advance: I ? r[1] : r[0],
                                localGlyph: !1
                            },
                            M = m ? -v.height * g : i * Hh - 17 - r[1] * g,
                            S = v.advance;
                            const s = (I ? r[0] : r[1]) * g - Hh * i;
                            s > 0 && s > _ && (_ = s);
                        } else {
                            const t = r[o.fontStack];
                            if (!t)
                                continue;
                            t[y] && (k = t[y]);
                            const n = e[o.fontStack];
                            if (!n)
                                continue;
                            const s = n.glyphs[y];
                            if (!s)
                                continue;
                            if (v = s.metrics,
                            S = 8203 !== y ? Hh : 0,
                            m) {
                                const t = void 0 !== n.ascender ? Math.abs(n.ascender) : 0
                                  , e = void 0 !== n.descender ? Math.abs(n.descender) : 0
                                  , r = (t + e) * g;
                                w < r && (w = r,
                                A = (t - e) / 2 * g),
                                M = -t * g;
                            } else
                                M = (i - g) * Hh - 17;
                        }
                        I ? (t.verticalizable = !0,
                        b.push({
                            glyph: y,
                            imageName: z,
                            x: p,
                            y: f + M,
                            vertical: I,
                            scale: g,
                            localGlyph: v.localGlyph,
                            fontStack: o.fontStack,
                            sectionIndex: d,
                            metrics: v,
                            rect: k
                        }),
                        p += S * g + u) : (b.push({
                            glyph: y,
                            imageName: z,
                            x: p,
                            y: f + M,
                            vertical: I,
                            scale: g,
                            localGlyph: v.localGlyph,
                            fontStack: o.fontStack,
                            sectionIndex: d,
                            metrics: v,
                            rect: k
                        }),
                        p += v.advance * g + u);
                    }
                    0 !== b.length && (d = Math.max(p - u, d),
                    m ? Gp(b, y, _, A, s * i / 2) : Gp(b, y, _, 0, s / 2)),
                    p = 0;
                    const k = s * i + _;
                    v.lineOffset = Math.max(_, o),
                    f += k,
                    ++g;
                }
                var x;
                const v = f
                  , {horizontalAlign: b, verticalAlign: _} = Zp(a);
                ((function(t, e, r, n, i, s) {
                    const a = (e - r) * i
                      , o = -s * n;
                    for (const e of t)
                        for (const t of e.positionedGlyphs)
                            t.x += a,
                            t.y += o;
                }
                ))(t.positionedLines, y, b, _, d, v),
                t.top += -_ * v,
                t.bottom = t.top + v,
                t.left += -b * d,
                t.right = t.left + d,
                t.hasBaseline = m;
            }(_, e, r, n, g, a, o, l, h, u, p, y),
            !function(t) {
                for (const e of t)
                    if (0 !== e.positionedGlyphs.length)
                        return !1;
                return !0
            }(b) && _
        }
        const Lp = {
            9: !0,
            10: !0,
            11: !0,
            12: !0,
            13: !0,
            32: !0
        }
          , Rp = {
            10: !0,
            32: !0,
            38: !0,
            40: !0,
            41: !0,
            43: !0,
            45: !0,
            47: !0,
            173: !0,
            183: !0,
            8203: !0,
            8208: !0,
            8211: !0,
            8231: !0
        };
        function jp(t, e, r, n, i, s) {
            if (e.imageName) {
                const t = n[e.imageName];
                return t ? t.displaySize[0] * e.scale * Hh / s + i : 0
            }
            {
                const n = r[e.fontStack]
                  , s = n && n.glyphs[t];
                return s ? s.metrics.advance * e.scale + i : 0
            }
        }
        function Up(t, e, r, n) {
            const i = Math.pow(t - e, 2);
            return n ? t < e ? i / 2 : 2 * i : i + Math.abs(r) * r
        }
        function Op(t, e, r) {
            let n = 0;
            return 10 === t && (n -= 1e4),
            r && (n += 150),
            40 !== t && 65288 !== t || (n += 50),
            41 !== e && 65289 !== e || (n += 50),
            n
        }
        function $p(t, e, r, n, i, s) {
            let a = null
              , o = Up(e, r, i, s);
            for (const t of n) {
                const n = Up(e - t.x, r, i, s) + t.badness;
                n <= o && (a = t,
                o = n);
            }
            return {
                index: t,
                x: e,
                priorBreak: a,
                badness: o
            }
        }
        function qp(t) {
            return t ? qp(t.priorBreak).concat(t.index) : []
        }
        function Np(t, e, r, n, i, s, a) {
            if ("point" !== s)
                return [];
            if (!t)
                return [];
            const o = []
              , l = function(t, e, r, n, i, s) {
                let a = 0;
                for (let r = 0; r < t.length(); r++) {
                    const o = t.getSection(r);
                    a += jp(t.getCharCode(r), o, n, i, e, s);
                }
                return a / Math.max(1, Math.ceil(a / r))
            }(t, e, r, n, i, a)
              , u = t.text.indexOf("​") >= 0;
            let c = 0;
            for (let r = 0; r < t.length(); r++) {
                const s = t.getSection(r)
                  , p = t.getCharCode(r);
                if (Lp[p] || (c += jp(p, s, n, i, e, a)),
                r < t.length() - 1) {
                    const e = !((h = p) < 11904 || !(Gi(h) || Zi(h) || ss(h) || rs(h) || Ki(h) || ji(h) || Xi(h) || $i(h) || Ji(h) || Wi(h) || Hi(h) || ls(h) || qi(h) || Oi(h) || Ui(h) || Yi(h) || Ni(h) || is(h) || ts(h) || Qi(h)));
                    (Rp[p] || e || s.imageName) && o.push($p(r + 1, c, l, o, Op(p, t.getCharCode(r + 1), e && u), !1));
                }
            }
            var h;
            return qp($p(t.length(), c, l, o, 0, !0))
        }
        function Zp(t) {
            let e = .5
              , r = .5;
            switch (t) {
            case "right":
            case "top-right":
            case "bottom-right":
                e = 1;
                break;
            case "left":
            case "top-left":
            case "bottom-left":
                e = 0;
            }
            switch (t) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
                r = 1;
                break;
            case "top":
            case "top-right":
            case "top-left":
                r = 0;
            }
            return {
                horizontalAlign: e,
                verticalAlign: r
            }
        }
        function Gp(t, e, r, n, i) {
            if (!(e || r || n || i))
                return;
            const s = t.length - 1
              , a = t[s]
              , o = (a.x + a.metrics.advance * a.scale) * e;
            for (let e = 0; e <= s; e++)
                t[e].x -= o,
                t[e].y += r + n + i;
        }
        function Xp(t, e, r) {
            const {horizontalAlign: n, verticalAlign: i} = Zp(r)
              , s = e[0] - t.displaySize[0] * n
              , a = e[1] - t.displaySize[1] * i;
            return {
                image: t,
                top: a,
                bottom: a + t.displaySize[1],
                left: s,
                right: s + t.displaySize[0]
            }
        }
        function Yp(t, e, r, n, i, s) {
            const a = t.image;
            let o;
            if (a.content) {
                const t = a.content
                  , e = a.pixelRatio || 1;
                o = [t[0] / e, t[1] / e, a.displaySize[0] - t[2] / e, a.displaySize[1] - t[3] / e];
            }
            const l = e.left * s
              , u = e.right * s;
            let c, h, p, f;
            "width" === r || "both" === r ? (f = i[0] + l - n[3],
            h = i[0] + u + n[1]) : (f = i[0] + (l + u - a.displaySize[0]) / 2,
            h = f + a.displaySize[0]);
            const d = e.top * s
              , y = e.bottom * s;
            return "height" === r || "both" === r ? (c = i[1] + d - n[0],
            p = i[1] + y + n[2]) : (c = i[1] + (d + y - a.displaySize[1]) / 2,
            p = c + a.displaySize[1]),
            {
                image: a,
                top: c,
                right: h,
                bottom: p,
                left: f,
                collisionPadding: o
            }
        }
        class Hp extends i {
            constructor(t, e, r, n, i) {
                super(t, e),
                this.angle = n,
                this.z = r,
                void 0 !== i && (this.segment = i);
            }
            clone() {
                return new Hp(this.x,this.y,this.z,this.angle,this.segment)
            }
        }
        function Kp(t, e, r, n, i) {
            if (void 0 === e.segment)
                return !0;
            let s = e
              , a = e.segment + 1
              , o = 0;
            for (; o > -r / 2; ) {
                if (a--,
                a < 0)
                    return !1;
                o -= t[a].dist(s),
                s = t[a];
            }
            o += t[a].dist(t[a + 1]),
            a++;
            const l = [];
            let u = 0;
            for (; o < r / 2; ) {
                const e = t[a]
                  , r = t[a + 1];
                if (!r)
                    return !1;
                let s = t[a - 1].angleTo(e) - e.angleTo(r);
                for (s = Math.abs((s + 3 * Math.PI) % (2 * Math.PI) - Math.PI),
                l.push({
                    distance: o,
                    angleDelta: s
                }),
                u += s; o - l[0].distance > n; )
                    u -= l.shift().angleDelta;
                if (u > i)
                    return !1;
                a++,
                o += e.dist(r);
            }
            return !0
        }
        function Jp(t) {
            let e = 0;
            for (let r = 0; r < t.length - 1; r++)
                e += t[r].dist(t[r + 1]);
            return e
        }
        function Wp(t, e, r) {
            return t ? .6 * e * r : 0
        }
        function Qp(t, e) {
            return Math.max(t ? t.right - t.left : 0, e ? e.right - e.left : 0)
        }
        function tf(t, e, r, n, i, s) {
            const a = Wp(r, i, s)
              , o = Qp(r, n) * s;
            let l = 0;
            const u = Jp(t) / 2;
            for (let r = 0; r < t.length - 1; r++) {
                const n = t[r]
                  , i = t[r + 1]
                  , s = n.dist(i);
                if (l + s > u) {
                    const c = (u - l) / s
                      , h = mr(n.x, i.x, c)
                      , p = mr(n.y, i.y, c)
                      , f = new Hp(h,p,0,i.angleTo(n),r);
                    return !a || Kp(t, f, o, a, e) ? f : void 0
                }
                l += s;
            }
        }
        function ef(t, e, r, n, i, s, a, o, l) {
            const u = Wp(n, s, a)
              , c = Qp(n, i)
              , h = c * a
              , p = 0 === t[0].x || t[0].x === l || 0 === t[0].y || t[0].y === l;
            return e - h < e / 4 && (e = h + e / 4),
            rf(t, p ? e / 2 * o % e : (c / 2 + 2 * s) * a * o % e, e, u, r, h, p, !1, l)
        }
        function rf(t, e, r, n, i, s, a, o, l) {
            const u = s / 2
              , c = Jp(t);
            let h = 0
              , p = e - r
              , f = [];
            for (let e = 0; e < t.length - 1; e++) {
                const a = t[e]
                  , o = t[e + 1]
                  , d = a.dist(o)
                  , y = o.angleTo(a);
                for (; p + r < h + d; ) {
                    p += r;
                    const m = (p - h) / d
                      , g = mr(a.x, o.x, m)
                      , x = mr(a.y, o.y, m);
                    if (g >= 0 && g < l && x >= 0 && x < l && p - u >= 0 && p + u <= c) {
                        const r = new Hp(g,x,0,y,e);
                        r._round(),
                        n && !Kp(t, r, s, n, i) || f.push(r);
                    }
                }
                h += d;
            }
            return o || f.length || a || (f = rf(t, h / 2, r, n, i, s, a, !0, l)),
            f
        }
        function nf(t, e, r, n, s) {
            const a = [];
            for (let o = 0; o < t.length; o++) {
                const l = t[o];
                let u;
                for (let t = 0; t < l.length - 1; t++) {
                    let o = l[t]
                      , c = l[t + 1];
                    o.x < e && c.x < e || (o.x < e ? o = new i(e,o.y + (e - o.x) / (c.x - o.x) * (c.y - o.y))._round() : c.x < e && (c = new i(e,o.y + (e - o.x) / (c.x - o.x) * (c.y - o.y))._round()),
                    o.y < r && c.y < r || (o.y < r ? o = new i(o.x + (r - o.y) / (c.y - o.y) * (c.x - o.x),r)._round() : c.y < r && (c = new i(o.x + (r - o.y) / (c.y - o.y) * (c.x - o.x),r)._round()),
                    o.x >= n && c.x >= n || (o.x >= n ? o = new i(n,o.y + (n - o.x) / (c.x - o.x) * (c.y - o.y))._round() : c.x >= n && (c = new i(n,o.y + (n - o.x) / (c.x - o.x) * (c.y - o.y))._round()),
                    o.y >= s && c.y >= s || (o.y >= s ? o = new i(o.x + (s - o.y) / (c.y - o.y) * (c.x - o.x),s)._round() : c.y >= s && (c = new i(o.x + (s - o.y) / (c.y - o.y) * (c.x - o.x),s)._round()),
                    u && o.equals(u[u.length - 1]) || (u = [o],
                    a.push(u)),
                    u.push(c)))));
                }
            }
            return a
        }
        Bi(Hp, "Anchor");
        const sf = 1e20;
        function af(t, e, r, n, i, s, a, o, l) {
            for (let u = e; u < e + n; u++)
                of(t, r * s + u, s, i, a, o, l);
            for (let u = r; u < r + i; u++)
                of(t, u * s + e, 1, n, a, o, l);
        }
        function of(t, e, r, n, i, s, a) {
            s[0] = 0,
            a[0] = -sf,
            a[1] = sf,
            i[0] = t[e];
            for (let o = 1, l = 0, u = 0; o < n; o++) {
                i[o] = t[e + o * r];
                const n = o * o;
                do {
                    const t = s[l];
                    u = (i[o] - i[t] + n - t * t) / (o - t) / 2;
                } while (u <= a[l] && --l > -1);
                l++,
                s[l] = o,
                a[l] = u,
                a[l + 1] = sf;
            }
            for (let o = 0, l = 0; o < n; o++) {
                for (; a[l + 1] < o; )
                    l++;
                const n = s[l]
                  , u = o - n;
                t[e + o * r] = i[n] + u * u;
            }
        }
        const lf = {
            none: 0,
            ideographs: 1,
            all: 2
        };
        class uf {
            constructor(t, e, r) {
                this.requestManager = t,
                this.localGlyphMode = e,
                this.localFontFamily = r,
                this.entries = {},
                this.localGlyphs = {
                    200: {},
                    400: {},
                    500: {},
                    900: {}
                };
            }
            setURL(t) {
                this.url = t;
            }
            setURLData(t) {
                this.urlData = t;
            }
            getGlyphs(t, e) {
                const r = [];
                for (const e in t)
                    for (const n of t[e])
                        r.push({
                            stack: e,
                            id: n
                        });
                g(r, ( ({stack: t, id: e}, r) => {
                    let n = this.entries[t];
                    n || (n = this.entries[t] = {
                        glyphs: {},
                        requests: {},
                        ranges: {},
                        ascender: void 0,
                        descender: void 0
                    });
                    let i = n.glyphs[e];
                    if (void 0 !== i)
                        return void r(null, {
                            stack: t,
                            id: e,
                            glyph: i
                        });
                    if (i = this._tinySDF(n, t, e),
                    i)
                        return n.glyphs[e] = i,
                        void r(null, {
                            stack: t,
                            id: e,
                            glyph: i
                        });
                    const s = Math.floor(e / 256);
                    if (256 * s > 65535)
                        return void r(new Error("glyphs > 65535 not supported"));
                    if (n.ranges[s])
                        return void r(null, {
                            stack: t,
                            id: e,
                            glyph: i
                        });
                    let a = n.requests[s];
                    if (!a) {
                        a = n.requests[s] = [];
                        let e = this.url;
                        "Microsoft YaHei Regular" != t && (e = this.urlData && this.urlData[t] || this.url),
                        uf.loadGlyphRange(t, s, e, this.requestManager, ( (t, e) => {
                            if (e) {
                                n.ascender = e.ascender,
                                n.descender = e.descender;
                                for (const t in e.glyphs)
                                    this._doesCharSupportLocalGlyph(+t) || (n.glyphs[+t] = e.glyphs[+t],
                                    t >= 19968 && t <= 40943 && (n.glyphs[+t].metrics.top = -4));
                                n.ranges[s] = !0;
                            }
                            for (const r of a)
                                r(t, e);
                            delete n.requests[s];
                        }
                        ));
                    }
                    a.push(( (n, i) => {
                        n ? r(n) : i && r(null, {
                            stack: t,
                            id: e,
                            glyph: i.glyphs[e] || null
                        });
                    }
                    ));
                }
                ), ( (t, r) => {
                    if (t)
                        e(t);
                    else if (r) {
                        const t = {};
                        for (const {stack: e, id: n, glyph: i} of r)
                            void 0 === t[e] && (t[e] = {}),
                            void 0 === t[e].glyphs && (t[e].glyphs = {}),
                            t[e].glyphs[n] = i && {
                                id: i.id,
                                bitmap: i.bitmap.clone(),
                                metrics: i.metrics
                            },
                            t[e].ascender = this.entries[e].ascender,
                            t[e].descender = this.entries[e].descender;
                        e(null, t);
                    }
                }
                ));
            }
            _doesCharSupportLocalGlyph(t) {
                return this.localGlyphMode !== lf.none && (this.localGlyphMode === lf.all ? !!this.localFontFamily : !!this.localFontFamily && (Wi(t) || es(t) || qi(t) || Ni(t) || $i(t)))
            }
            _tinySDF(t, e, r) {
                const n = this.localFontFamily;
                if (!n || !this._doesCharSupportLocalGlyph(r))
                    return;
                let i = t.tinySDF;
                if (!i) {
                    let r = "400";
                    /bold/i.test(e) ? r = "900" : /medium/i.test(e) ? r = "500" : /light/i.test(e) && (r = "200"),
                    i = t.tinySDF = new uf.TinySDF({
                        fontFamily: n,
                        fontWeight: r,
                        fontSize: 48,
                        buffer: 6,
                        radius: 16,
                        cutoff: .23
                    }),
                    i.fontWeight = r;
                }
                if (this.localGlyphs[i.fontWeight][r])
                    return this.localGlyphs[i.fontWeight][r];
                const s = String.fromCharCode(r)
                  , {data: a, width: o, height: l, glyphWidth: u, glyphHeight: c, glyphLeft: h, glyphTop: p, glyphAdvance: f} = i.draw(s);
                return this.localGlyphs[i.fontWeight][r] = {
                    id: r,
                    bitmap: new Wu({
                        width: o,
                        height: l
                    },a),
                    metrics: {
                        width: u / 2,
                        height: c / 2,
                        left: h / 2,
                        top: p / 2 - 27 + (r >= 19968 && r <= 40943 ? 4 : 0),
                        advance: f / 2,
                        localGlyph: !0
                    }
                }
            }
        }
        function cf(t, e, r, n) {
            const s = []
              , a = t.image
              , o = a.pixelRatio
              , l = a.paddedRect.w - 2
              , u = a.paddedRect.h - 2
              , c = t.right - t.left
              , h = t.bottom - t.top
              , p = a.stretchX || [[0, l]]
              , f = a.stretchY || [[0, u]]
              , d = (t, e) => t + e[1] - e[0]
              , y = p.reduce(d, 0)
              , m = f.reduce(d, 0)
              , g = l - y
              , x = u - m;
            let v = 0
              , b = y
              , _ = 0
              , w = m
              , A = 0
              , k = g
              , z = 0
              , S = x;
            if (a.content && n) {
                const t = a.content;
                v = hf(p, 0, t[0]),
                _ = hf(f, 0, t[1]),
                b = hf(p, t[0], t[2]),
                w = hf(f, t[1], t[3]),
                A = t[0] - v,
                z = t[1] - _,
                k = t[2] - t[0] - b,
                S = t[3] - t[1] - w;
            }
            const M = (n, s, l, u) => {
                const p = ff(n.stretch - v, b, c, t.left)
                  , f = df(n.fixed - A, k, n.stretch, y)
                  , d = ff(s.stretch - _, w, h, t.top)
                  , g = df(s.fixed - z, S, s.stretch, m)
                  , x = ff(l.stretch - v, b, c, t.left)
                  , M = df(l.fixed - A, k, l.stretch, y)
                  , I = ff(u.stretch - _, w, h, t.top)
                  , T = df(u.fixed - z, S, u.stretch, m)
                  , B = new i(p,d)
                  , C = new i(x,d)
                  , V = new i(x,I)
                  , P = new i(p,I)
                  , D = new i(f / o,g / o)
                  , E = new i(M / o,T / o)
                  , F = e * Math.PI / 180;
                if (F) {
                    const t = Math.sin(F)
                      , e = Math.cos(F)
                      , r = [e, -t, t, e];
                    B._matMult(r),
                    C._matMult(r),
                    P._matMult(r),
                    V._matMult(r);
                }
                const L = n.stretch + n.fixed
                  , R = s.stretch + s.fixed;
                return {
                    tl: B,
                    tr: C,
                    bl: P,
                    br: V,
                    tex: {
                        x: a.paddedRect.x + 1 + L,
                        y: a.paddedRect.y + 1 + R,
                        w: l.stretch + l.fixed - L,
                        h: u.stretch + u.fixed - R
                    },
                    writingMode: void 0,
                    glyphOffset: [0, 0],
                    sectionIndex: 0,
                    pixelOffsetTL: D,
                    pixelOffsetBR: E,
                    minFontScaleX: k / o / c,
                    minFontScaleY: S / o / h,
                    isSDF: r
                }
            }
            ;
            if (n && (a.stretchX || a.stretchY)) {
                const t = pf(p, g, y)
                  , e = pf(f, x, m);
                for (let r = 0; r < t.length - 1; r++) {
                    const n = t[r]
                      , i = t[r + 1];
                    for (let t = 0; t < e.length - 1; t++)
                        s.push(M(n, e[t], i, e[t + 1]));
                }
            } else
                s.push(M({
                    fixed: 0,
                    stretch: -1
                }, {
                    fixed: 0,
                    stretch: -1
                }, {
                    fixed: 0,
                    stretch: l + 1
                }, {
                    fixed: 0,
                    stretch: u + 1
                }));
            return s
        }
        function hf(t, e, r) {
            let n = 0;
            for (const i of t)
                n += Math.max(e, Math.min(r, i[1])) - Math.max(e, Math.min(r, i[0]));
            return n
        }
        function pf(t, e, r) {
            const n = [{
                fixed: -1,
                stretch: 0
            }];
            for (const [e,r] of t) {
                const t = n[n.length - 1];
                n.push({
                    fixed: e - t.stretch,
                    stretch: t.stretch
                }),
                n.push({
                    fixed: e - t.stretch,
                    stretch: t.stretch + (r - e)
                });
            }
            return n.push({
                fixed: e + 1,
                stretch: r
            }),
            n
        }
        function ff(t, e, r, n) {
            return t / e * r + n
        }
        function df(t, e, r, n) {
            return t - e * r / n
        }
        function yf(t, e, r, n) {
            const i = e + t.positionedLines[n].lineOffset;
            return 0 === n ? r + i / 2 : r + (i + (e + t.positionedLines[n - 1].lineOffset)) / 2
        }
        uf.loadGlyphRange = function(t, e, r, n, i) {
            const s = 256 * e
              , a = s + 255
              , o = n.transformRequest(n.normalizeGlyphsURL(r).replace("{fontstack}", t).replace("{range}", `${s}-${a}`), zt.Glyphs);
            Vt(o, ( (t, e) => {
                if (t)
                    i(t);
                else if (e) {
                    const t = {}
                      , r = function(t) {
                        return new op(t).readFields(Mp, {})
                    }(e);
                    for (const e of r.glyphs)
                        t[e.id] = e;
                    i(null, {
                        glyphs: t,
                        ascender: r.ascender,
                        descender: r.descender
                    });
                }
            }
            ));
        }
        ,
        uf.TinySDF = class {
            constructor({fontSize: t=24, buffer: e=3, radius: r=8, cutoff: n=.25, fontFamily: i="sans-serif", fontWeight: s="normal", fontStyle: a="normal"}) {
                this.buffer = e,
                this.cutoff = n,
                this.radius = r;
                const o = this.size = t + 4 * e
                  , l = this._createCanvas(o)
                  , u = this.ctx = l.getContext("2d", {
                    willReadFrequently: !0
                });
                u.font = `${a} ${s} ${t}px ${i}`,
                u.textBaseline = "alphabetic",
                u.textAlign = "left",
                u.fillStyle = "black",
                this.gridOuter = new Float64Array(o * o),
                this.gridInner = new Float64Array(o * o),
                this.f = new Float64Array(o),
                this.z = new Float64Array(o + 1),
                this.v = new Uint16Array(o);
            }
            _createCanvas(t) {
                const e = document.createElement("canvas");
                return e.width = e.height = t,
                e
            }
            draw(t) {
                const {width: e, actualBoundingBoxAscent: r, actualBoundingBoxDescent: n, actualBoundingBoxLeft: i, actualBoundingBoxRight: s} = this.ctx.measureText(t);
                let a, o, l, u, c;
                r ? (a = Math.floor(r),
                o = Math.min(this.size - this.buffer, Math.ceil(s - i)),
                l = Math.min(this.size - this.buffer, Math.ceil(r) + Math.ceil(n)),
                u = o + 2 * this.buffer,
                c = l + 2 * this.buffer) : (a = Math.round(this.size / 2 * (navigator.userAgent.indexOf("Gecko/") >= 0 ? 1.2 : 1)),
                o = this.size - this.buffer,
                l = this.size - this.buffer,
                u = o,
                c = l);
                const h = u * c
                  , p = new Uint8ClampedArray(h)
                  , f = {
                    data: p,
                    width: u,
                    height: c,
                    glyphWidth: o,
                    glyphHeight: l,
                    glyphTop: a,
                    glyphLeft: 0,
                    glyphAdvance: e
                };
                if (0 === o || 0 === l)
                    return f;
                const {ctx: d, buffer: y, gridInner: m, gridOuter: g} = this;
                d.clearRect(y, y, o, l),
                d.fillText(t, y, y + a + 1);
                const x = d.getImageData(y, y, o, l);
                g.fill(sf, 0, h),
                m.fill(0, 0, h);
                for (let t = 0; t < l; t++)
                    for (let e = 0; e < o; e++) {
                        const r = x.data[4 * (t * o + e) + 3] / 255;
                        if (0 === r)
                            continue;
                        const n = (t + y) * u + e + y;
                        if (1 === r)
                            g[n] = 0,
                            m[n] = sf;
                        else {
                            const t = .5 - r;
                            g[n] = t > 0 ? t * t : 0,
                            m[n] = t < 0 ? t * t : 0;
                        }
                    }
                af(g, 0, 0, u, c, u, this.f, this.v, this.z),
                af(m, y, y, o, l, u, this.f, this.v, this.z);
                for (let t = 0; t < h; t++) {
                    const e = Math.sqrt(g[t]) - Math.sqrt(m[t]);
                    p[t] = Math.round(255 - 255 * (e / this.radius + this.cutoff));
                }
                return f
            }
        }
        ;
        class mf {
            constructor(t=[], e=gf) {
                if (this.data = t,
                this.length = this.data.length,
                this.compare = e,
                this.length > 0)
                    for (let t = (this.length >> 1) - 1; t >= 0; t--)
                        this._down(t);
            }
            push(t) {
                this.data.push(t),
                this.length++,
                this._up(this.length - 1);
            }
            pop() {
                if (0 === this.length)
                    return;
                const t = this.data[0]
                  , e = this.data.pop();
                return this.length--,
                this.length > 0 && (this.data[0] = e,
                this._down(0)),
                t
            }
            peek() {
                return this.data[0]
            }
            _up(t) {
                const {data: e, compare: r} = this
                  , n = e[t];
                for (; t > 0; ) {
                    const i = t - 1 >> 1
                      , s = e[i];
                    if (r(n, s) >= 0)
                        break;
                    e[t] = s,
                    t = i;
                }
                e[t] = n;
            }
            _down(t) {
                const {data: e, compare: r} = this
                  , n = this.length >> 1
                  , i = e[t];
                for (; t < n; ) {
                    let n = 1 + (t << 1)
                      , s = e[n];
                    const a = n + 1;
                    if (a < this.length && r(e[a], s) < 0 && (n = a,
                    s = e[a]),
                    r(s, i) >= 0)
                        break;
                    e[t] = s,
                    t = n;
                }
                e[t] = i;
            }
        }
        function gf(t, e) {
            return t < e ? -1 : t > e ? 1 : 0
        }
        function xf(t, e=1, r=!1) {
            let n = 1 / 0
              , s = 1 / 0
              , a = -1 / 0
              , o = -1 / 0;
            const l = t[0];
            for (let t = 0; t < l.length; t++) {
                const e = l[t];
                (!t || e.x < n) && (n = e.x),
                (!t || e.y < s) && (s = e.y),
                (!t || e.x > a) && (a = e.x),
                (!t || e.y > o) && (o = e.y);
            }
            const u = Math.min(a - n, o - s);
            let c = u / 2;
            const h = new mf([],vf);
            if (0 === u)
                return new i(n,s);
            for (let e = n; e < a; e += u)
                for (let r = s; r < o; r += u)
                    h.push(new bf(e + c,r + c,c,t));
            let p = function(t) {
                let e = 0
                  , r = 0
                  , n = 0;
                const i = t[0];
                for (let t = 0, s = i.length, a = s - 1; t < s; a = t++) {
                    const s = i[t]
                      , o = i[a]
                      , l = s.x * o.y - o.x * s.y;
                    r += (s.x + o.x) * l,
                    n += (s.y + o.y) * l,
                    e += 3 * l;
                }
                return new bf(r / e,n / e,0,t)
            }(t)
              , f = h.length;
            for (; h.length; ) {
                const n = h.pop();
                (n.d > p.d || !p.d) && (p = n,
                r && console.log("found best %d after %d probes", Math.round(1e4 * n.d) / 1e4, f)),
                n.max - p.d <= e || (c = n.h / 2,
                h.push(new bf(n.p.x - c,n.p.y - c,c,t)),
                h.push(new bf(n.p.x + c,n.p.y - c,c,t)),
                h.push(new bf(n.p.x - c,n.p.y + c,c,t)),
                h.push(new bf(n.p.x + c,n.p.y + c,c,t)),
                f += 4);
            }
            return r && (console.log(`num probes: ${f}`),
            console.log(`best distance: ${p.d}`)),
            p.p
        }
        function vf(t, e) {
            return e.max - t.max
        }
        function bf(t, e, r, n) {
            this.p = new i(t,e),
            this.h = r,
            this.d = function(t, e) {
                let r = !1
                  , n = 1 / 0;
                for (let i = 0; i < e.length; i++) {
                    const s = e[i];
                    for (let e = 0, i = s.length, a = i - 1; e < i; a = e++) {
                        const i = s[e]
                          , o = s[a];
                        i.y > t.y != o.y > t.y && t.x < (o.x - i.x) * (t.y - i.y) / (o.y - i.y) + i.x && (r = !r),
                        n = Math.min(n, Dl(t, i, o));
                    }
                }
                return (r ? 1 : -1) * Math.sqrt(n)
            }(this.p, n),
            this.max = this.d + this.h * Math.SQRT2;
        }
        const _f = Number.POSITIVE_INFINITY
          , wf = Math.sqrt(2);
        function Af(t, e) {
            return e[1] !== _f ? function(t, e, r) {
                let n = 0
                  , i = 0;
                switch (e = Math.abs(e),
                r = Math.abs(r),
                t) {
                case "top-right":
                case "top-left":
                case "top":
                    i = r - 7;
                    break;
                case "bottom-right":
                case "bottom-left":
                case "bottom":
                    i = 7 - r;
                }
                switch (t) {
                case "top-right":
                case "bottom-right":
                case "right":
                    n = -e;
                    break;
                case "top-left":
                case "bottom-left":
                case "left":
                    n = e;
                }
                return [n, i]
            }(t, e[0], e[1]) : function(t, e) {
                let r = 0
                  , n = 0;
                e < 0 && (e = 0);
                const i = e / wf;
                switch (t) {
                case "top-right":
                case "top-left":
                    n = i - 7;
                    break;
                case "bottom-right":
                case "bottom-left":
                    n = 7 - i;
                    break;
                case "bottom":
                    n = 7 - e;
                    break;
                case "top":
                    n = e - 7;
                }
                switch (t) {
                case "top-right":
                case "bottom-right":
                    r = -i;
                    break;
                case "top-left":
                case "bottom-left":
                    r = i;
                    break;
                case "left":
                    r = e;
                    break;
                case "right":
                    r = -e;
                }
                return [r, n]
            }(t, e[0])
        }
        function kf(t, e, r, n, i, s, a, o, l, u) {
            t.createArrays(),
            t.tilePixelRatio = bo / (512 * t.overscaling),
            t.compareText = {},
            t.iconsNeedLinear = !1;
            const c = t.layers[0].layout
              , h = t.layers[0]._unevaluatedLayout._values
              , p = {};
            if ("composite" === t.textSizeData.kind) {
                const {minZoom: e, maxZoom: r} = t.textSizeData;
                p.compositeTextSizes = [h["text-size"].possiblyEvaluate(new Ts(e), o), h["text-size"].possiblyEvaluate(new Ts(r), o)];
            }
            if ("composite" === t.iconSizeData.kind) {
                const {minZoom: e, maxZoom: r} = t.iconSizeData;
                p.compositeIconSizes = [h["icon-size"].possiblyEvaluate(new Ts(e), o), h["icon-size"].possiblyEvaluate(new Ts(r), o)];
            }
            p.layoutTextSize = h["text-size"].possiblyEvaluate(new Ts(l + 1), o),
            p.layoutIconSize = h["icon-size"].possiblyEvaluate(new Ts(l + 1), o),
            p.textMaxSize = h["text-size"].possiblyEvaluate(new Ts(18), o);
            const f = "map" === c.get("text-rotation-alignment") && "point" !== c.get("symbol-placement")
              , d = c.get("text-size");
            for (const s of t.features) {
                const l = c.get("text-font").evaluate(s, {}, o).join(",")
                  , h = d.evaluate(s, {}, o)
                  , y = p.layoutTextSize.evaluate(s, {}, o)
                  , m = (p.layoutIconSize.evaluate(s, {}, o),
                {
                    horizontal: {},
                    vertical: void 0
                })
                  , g = s.text;
                let x, v = [0, 0];
                if (g) {
                    const n = g.toString()
                      , a = c.get("text-letter-spacing").evaluate(s, {}, o) * Hh
                      , u = c.get("text-line-height").evaluate(s, {}, o) * Hh
                      , p = cs(n) ? a : 0
                      , d = c.get("text-anchor").evaluate(s, {}, o)
                      , x = c.get("text-variable-anchor");
                    if (!x) {
                        const t = c.get("text-radial-offset").evaluate(s, {}, o);
                        v = t ? Af(d, [t * Hh, _f]) : c.get("text-offset").evaluate(s, {}, o).map((t => t * Hh));
                    }
                    let b = f ? "center" : c.get("text-justify").evaluate(s, {}, o);
                    const _ = c.get("symbol-placement")
                      , w = "point" === _
                      , A = "point" === _ ? c.get("text-max-width").evaluate(s, {}, o) * Hh : 0
                      , k = s => {
                        t.allowVerticalPlacement && us(n) && (m.vertical = Fp(g, e, r, i, l, A, u, d, s, p, v, Pp.vertical, !0, _, y, h));
                    }
                    ;
                    if (!f && x) {
                        const t = "auto" === b ? x.map((t => zf(t))) : [b];
                        let n = !1;
                        for (let s = 0; s < t.length; s++) {
                            const a = t[s];
                            if (!m.horizontal[a])
                                if (n)
                                    m.horizontal[a] = m.horizontal[0];
                                else {
                                    const t = Fp(g, e, r, i, l, A, u, "center", a, p, v, Pp.horizontal, !1, _, y, h);
                                    t && (m.horizontal[a] = t,
                                    n = 1 === t.positionedLines.length);
                                }
                        }
                        k("left");
                    } else {
                        if ("auto" === b && (b = zf(d)),
                        w || c.get("text-writing-mode").indexOf("horizontal") >= 0 || !us(n)) {
                            const t = Fp(g, e, r, i, l, A, u, d, b, p, v, Pp.horizontal, !1, _, y, h);
                            t && (m.horizontal[b] = t);
                        }
                        k("point" === _ ? "left" : b);
                    }
                }
                let b = !1;
                if (s.icon && s.icon.name) {
                    const e = n[s.icon.name];
                    e && (x = Xp(i[s.icon.name], c.get("icon-offset").evaluate(s, {}, o), c.get("icon-anchor").evaluate(s, {}, o)),
                    b = e.sdf,
                    void 0 === t.sdfIcons ? t.sdfIcons = e.sdf : t.sdfIcons !== e.sdf && B("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"),
                    (e.pixelRatio !== t.pixelRatio || 0 !== c.get("icon-rotate").constantOr(1)) && (t.iconsNeedLinear = !0));
                }
                const _ = Tf(m.horizontal) || m.vertical;
                t.iconsInText || (t.iconsInText = !!_ && _.iconsInText),
                (_ || x) && Sf(t, s, m, x, n, p, y, 0, v, b, a, o, u);
            }
            s && t.generateCollisionDebugBuffers(l, t.collisionBoxArray);
        }
        function zf(t) {
            switch (t) {
            case "right":
            case "top-right":
            case "bottom-right":
                return "right";
            case "left":
            case "top-left":
            case "bottom-left":
                return "left"
            }
            return "center"
        }
        function Sf(t, e, r, n, i, s, a, o, u, c, h, p, f) {
            let d = s.textMaxSize.evaluate(e, {}, p);
            void 0 === d && (d = a);
            const y = t.layers[0].layout
              , m = y.get("icon-offset").evaluate(e, {}, p)
              , g = Tf(r.horizontal) || r.vertical
              , x = "globe" === f.name
              , v = a / 24
              , b = t.tilePixelRatio * d / 24
              , _ = (T = t.overscaling,
            t.zoom > 18 && T > 2 && (T >>= 1),
            Math.max(bo / (512 * T), 1) * y.get("symbol-spacing"))
              , w = y.get("text-padding") * t.tilePixelRatio
              , A = y.get("icon-padding") * t.tilePixelRatio
              , k = l(y.get("text-max-angle"))
              , z = "map" === y.get("text-rotation-alignment") && "point" !== y.get("symbol-placement")
              , S = "map" === y.get("icon-rotation-alignment") && "point" !== y.get("symbol-placement")
              , M = y.get("symbol-placement")
              , I = _ / 2;
            var T;
            const C = y.get("icon-text-fit");
            let V;
            n && "none" !== C && (t.allowVerticalPlacement && r.vertical && (V = Yp(n, r.vertical, C, y.get("icon-text-fit-padding"), m, v)),
            g && (n = Yp(n, g, C, y.get("icon-text-fit-padding"), m, v)));
            const P = (a, o, l) => {
                if (o.x < 0 || o.x >= bo || o.y < 0 || o.y >= bo)
                    return;
                let d = null;
                if (x) {
                    const {x: t, y: e, z: r} = f.projectTilePoint(o.x, o.y, l);
                    d = {
                        anchor: new Hp(t,e,r,0,void 0),
                        up: f.upVector(l, o.x, o.y)
                    };
                }
                !function(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, _, w, A, k) {
                    const z = t.addToLineVertexArray(e, n);
                    let S, M, I, T, C, V, P, D = 0, E = 0, F = 0, L = 0, R = -1, j = -1;
                    const U = {};
                    let O = $a("");
                    const $ = r ? r.anchor : e;
                    let q = 0
                      , N = 0;
                    if (void 0 === l._unevaluatedLayout.getValue("text-radial-offset") ? [q,N] = l.layout.get("text-offset").evaluate(b, {}, k).map((t => t * Hh)) : (q = l.layout.get("text-radial-offset").evaluate(b, {}, k) * Hh,
                    N = _f),
                    t.allowVerticalPlacement && i.vertical) {
                        const t = i.vertical;
                        if (d)
                            V = Cf(t),
                            o && (P = Cf(o));
                        else {
                            const r = l.layout.get("text-rotate").evaluate(b, {}, k) + 90;
                            I = Bf(u, $, e, c, h, p, t, f, r, y),
                            o && (T = Bf(u, $, e, c, h, p, o, g, r));
                        }
                    }
                    if (s) {
                        const n = l.layout.get("icon-rotate").evaluate(b, {}, k)
                          , i = "none" !== l.layout.get("icon-text-fit")
                          , a = cf(s, n, w, i)
                          , f = o ? cf(o, n, w, i) : void 0;
                        M = Bf(u, $, e, c, h, p, s, g, n),
                        D = 4 * a.length;
                        const d = t.iconSizeData;
                        let y = null;
                        "source" === d.kind ? (y = [Kh * l.layout.get("icon-size").evaluate(b, {}, k)],
                        y[0] > Mf && B(`${t.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : "composite" === d.kind && (y = [Kh * _.compositeIconSizes[0].evaluate(b, {}, k), Kh * _.compositeIconSizes[1].evaluate(b, {}, k)],
                        (y[0] > Mf || y[1] > Mf) && B(`${t.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)),
                        t.addSymbols(t.icon, a, y, v, x, b, !1, r, e, z.lineStartIndex, z.lineLength, -1, A, k),
                        R = t.icon.placedSymbolArray.length - 1,
                        f && (E = 4 * f.length,
                        t.addSymbols(t.icon, f, y, v, x, b, Pp.vertical, r, e, z.lineStartIndex, z.lineLength, -1, A, k),
                        j = t.icon.placedSymbolArray.length - 1);
                    }
                    for (const n in i.horizontal) {
                        const s = i.horizontal[n];
                        S || (O = $a(s.text),
                        d ? C = Cf(s) : S = Bf(u, $, e, c, h, p, s, f, l.layout.get("text-rotate").evaluate(b, {}, k), y));
                        const o = 1 === s.positionedLines.length;
                        if (F += If(t, r, e, s, a, l, d, b, y, z, i.vertical ? Pp.horizontal : Pp.horizontalOnly, o ? Object.keys(i.horizontal) : [n], U, R, _, A, k),
                        o)
                            break
                    }
                    i.vertical && (L += If(t, r, e, i.vertical, a, l, d, b, y, z, Pp.vertical, ["vertical"], U, j, _, A, k));
                    let Z = -1;
                    const G = (t, e) => t ? Math.max(t, e) : e;
                    Z = G(C, Z),
                    Z = G(V, Z),
                    Z = G(P, Z);
                    const X = Z > -1 ? 1 : 0;
                    t.glyphOffsetArray.length >= Nd.MAX_GLYPHS && B("Too many glyphs being rendered in a tile. See https://github.com/sgmap/sgmap-js/issues/2907"),
                    void 0 !== b.sortKey && t.addToSortKeyRanges(t.symbolInstances.length, b.sortKey),
                    t.symbolInstances.emplaceBack($.x, $.y, $.z, e.x, e.y, U.right >= 0 ? U.right : -1, U.center >= 0 ? U.center : -1, U.left >= 0 ? U.left : -1, U.vertical >= 0 ? U.vertical : -1, R, j, O, void 0 !== S ? S : t.collisionBoxArray.length, void 0 !== S ? S + 1 : t.collisionBoxArray.length, void 0 !== I ? I : t.collisionBoxArray.length, void 0 !== I ? I + 1 : t.collisionBoxArray.length, void 0 !== M ? M : t.collisionBoxArray.length, void 0 !== M ? M + 1 : t.collisionBoxArray.length, T || t.collisionBoxArray.length, T ? T + 1 : t.collisionBoxArray.length, c, F, L, D, E, X, 0, q, N, Z);
                }(t, o, d, a, r, n, i, V, t.layers[0], t.collisionBoxArray, e.index, e.sourceLayerIndex, t.index, w, z, u, 0, A, S, m, e, s, c, h, p);
            }
            ;
            if ("line" === M)
                for (const i of nf(e.geometry, 0, 0, bo, bo)) {
                    const e = ef(i, _, k, r.vertical || g, n, 24, b, t.overscaling, bo);
                    for (const r of e) {
                        const e = g;
                        e && Vf(t, e.text, I, r) || P(i, r, p);
                    }
                }
            else if ("line-center" === M) {
                for (const t of e.geometry)
                    if (t.length > 1) {
                        const e = tf(t, k, r.vertical || g, n, 24, b);
                        e && P(t, e, p);
                    }
            } else if ("Polygon" === e.type)
                for (const t of Rc(e.geometry, 0)) {
                    const e = xf(t, 16);
                    P(t[0], new Hp(e.x,e.y,0,0,void 0), p);
                }
            else if ("LineString" === e.type)
                for (const t of e.geometry)
                    P(t, new Hp(t[0].x,t[0].y,0,0,void 0), p);
            else if ("Point" === e.type)
                for (const t of e.geometry)
                    for (const e of t)
                        P([e], new Hp(e.x,e.y,0,0,void 0), p);
        }
        const Mf = 32640;
        function If(t, e, r, n, s, a, o, l, u, c, h, p, f, d, y, m, g) {
            const x = function(t, e, r, n, s, a, o, l) {
                const u = [];
                if (0 === e.positionedLines.length)
                    return u;
                const c = n.layout.get("text-rotate").evaluate(a, {}) * Math.PI / 180
                  , h = function(t) {
                    const e = t[0]
                      , r = t[1]
                      , n = e * r;
                    return n > 0 ? [e, -r] : n < 0 ? [-e, r] : 0 === e ? [r, e] : [r, -e]
                }(r);
                let p = Math.abs(e.top - e.bottom);
                for (const t of e.positionedLines)
                    p -= t.lineOffset;
                const f = e.positionedLines.length
                  , d = p / f;
                let y = e.top - r[1];
                for (let t = 0; t < f; ++t) {
                    const n = e.positionedLines[t];
                    y = yf(e, d, y, t);
                    for (const t of n.positionedGlyphs) {
                        if (!t.rect)
                            continue;
                        const n = t.rect || {};
                        let a = 4
                          , p = !0
                          , f = 1
                          , d = 0;
                        if (t.imageName) {
                            const e = o[t.imageName];
                            if (!e)
                                continue;
                            if (e.sdf) {
                                B("SDF images are not supported in formatted text and will be ignored.");
                                continue
                            }
                            p = !1,
                            f = e.pixelRatio,
                            a = 1 / f;
                        }
                        const m = (s || l) && t.vertical
                          , g = t.metrics.advance * t.scale / 2
                          , x = t.metrics
                          , v = t.rect;
                        if (null === v)
                            continue;
                        l && e.verticalizable && (d = t.imageName ? g - t.metrics.width * t.scale / 2 : 0);
                        const b = s ? [t.x + g, t.y] : [0, 0];
                        let _ = [0, 0]
                          , w = [0, 0]
                          , A = !1;
                        s || (m ? (w = [t.x + g + h[0], t.y + h[1] - d],
                        A = !0) : _ = [t.x + g + r[0], t.y + r[1] - d]);
                        const k = v.w * t.scale / (f * (t.localGlyph ? 2 : 1))
                          , z = v.h * t.scale / (f * (t.localGlyph ? 2 : 1));
                        let S, M, I, T;
                        if (m) {
                            const e = t.y - y
                              , r = new i(-g,g - e)
                              , n = -Math.PI / 2
                              , s = new i(...w);
                            S = new i(-g + _[0],_[1]),
                            S._rotateAround(n, r)._add(s),
                            S.x += -e + g,
                            S.y -= (x.left - a) * t.scale;
                            const o = t.imageName ? x.advance * t.scale : Hh * t.scale
                              , l = String.fromCharCode(t.glyph);
                            np(l) ? S.x += (1 - a) * t.scale : ip(l) ? S.x += o - x.height * t.scale + (-a - 1) * t.scale : S.x += t.imageName || x.width + 2 * a === v.w && x.height + 2 * a === v.h ? (o - z) / 2 : (o - (x.height + 2 * a) * t.scale) / 2,
                            M = new i(S.x,S.y - k),
                            I = new i(S.x + z,S.y),
                            T = new i(S.x + z,S.y - k);
                        } else {
                            const e = (x.left - a) * t.scale - g + _[0]
                              , r = (-x.top - a) * t.scale + _[1]
                              , n = e + k
                              , s = r + z;
                            S = new i(e,r),
                            M = new i(n,r),
                            I = new i(e,s),
                            T = new i(n,s);
                        }
                        if (c) {
                            let t;
                            t = s ? new i(0,0) : A ? new i(h[0],h[1]) : new i(r[0],r[1]),
                            S._rotateAround(c, t),
                            M._rotateAround(c, t),
                            I._rotateAround(c, t),
                            T._rotateAround(c, t);
                        }
                        const C = new i(0,0)
                          , V = new i(0,0);
                        u.push({
                            tl: S,
                            tr: M,
                            bl: I,
                            br: T,
                            tex: n,
                            writingMode: e.writingMode,
                            glyphOffset: b,
                            sectionIndex: t.sectionIndex,
                            isSDF: p,
                            pixelOffsetTL: C,
                            pixelOffsetBR: V,
                            minFontScaleX: 0,
                            minFontScaleY: 0
                        });
                    }
                }
                return u
            }(0, n, u, a, o, l, s, t.allowVerticalPlacement)
              , v = t.textSizeData;
            let b = null;
            "source" === v.kind ? (b = [Kh * a.layout.get("text-size").evaluate(l, {}, g)],
            b[0] > Mf && B(`${t.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : "composite" === v.kind && (b = [Kh * y.compositeTextSizes[0].evaluate(l, {}, g), Kh * y.compositeTextSizes[1].evaluate(l, {}, g)],
            (b[0] > Mf || b[1] > Mf) && B(`${t.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)),
            t.addSymbols(t.text, x, b, u, o, l, h, e, r, c.lineStartIndex, c.lineLength, d, m, g);
            for (const e of p)
                f[e] = t.text.placedSymbolArray.length - 1;
            return 4 * x.length
        }
        function Tf(t) {
            for (const e in t)
                return t[e];
            return null
        }
        function Bf(t, e, r, n, s, a, o, u, c, h) {
            let p = o.top
              , f = o.bottom
              , d = o.left
              , y = o.right;
            const m = o.collisionPadding;
            if (m && (d -= m[0],
            p -= m[1],
            y += m[2],
            f += m[3]),
            c) {
                const t = new i(d,p)
                  , e = new i(y,p)
                  , r = new i(d,f)
                  , n = new i(y,f)
                  , s = l(c);
                let a = new i(0,0);
                h && (a = new i(h[0],h[1])),
                t._rotateAround(s, a),
                e._rotateAround(s, a),
                r._rotateAround(s, a),
                n._rotateAround(s, a),
                d = Math.min(t.x, e.x, r.x, n.x),
                y = Math.max(t.x, e.x, r.x, n.x),
                p = Math.min(t.y, e.y, r.y, n.y),
                f = Math.max(t.y, e.y, r.y, n.y);
            }
            return t.emplaceBack(e.x, e.y, e.z, r.x, r.y, d, p, y, f, u, n, s, a),
            t.length - 1
        }
        function Cf(t) {
            t.collisionPadding && (t.top -= t.collisionPadding[1],
            t.bottom += t.collisionPadding[3]);
            const e = t.bottom - t.top;
            return e > 0 ? Math.max(10, e) : null
        }
        function Vf(t, e, r, n) {
            const i = t.compareText;
            if (e in i) {
                const t = i[e];
                for (let e = t.length - 1; e >= 0; e--)
                    if (n.dist(t[e]) < r)
                        return !0
            } else
                i[e] = [];
            return i[e].push(n),
            !1
        }
        const Pf = Ys([{
            type: "Float32",
            name: "a_globe_pos",
            components: 3
        }, {
            type: "Float32",
            name: "a_uv",
            components: 2
        }])
          , {members: Df} = Pf
          , Ef = Ys([{
            name: "a_pos_3",
            components: 3,
            type: "Int16"
        }]);
        var Ff = Ys([{
            name: "a_pos",
            type: "Int16",
            components: 2
        }]);
        const Lf = bo / Math.PI / 2
          , Rf = 2 * Jo(1, 0) * Lf * Math.PI
          , jf = 64
          , Uf = [jf, 32, 16]
          , Of = -Lf
          , $f = Lf
          , qf = [new $u([Of, Of, Of],[$f, $f, $f]), new $u([Of, Of, Of],[0, 0, $f]), new $u([0, Of, Of],[$f, 0, $f]), new $u([Of, 0, Of],[0, $f, $f]), new $u([0, 0, Of],[$f, $f, $f])];
        function Nf(t, e, r, n=!0) {
            const i = du([], t._camera.position, t.worldSize)
              , s = [e, r, 1, 1];
            Su(s, s, t.pixelMatrixInverse),
            zu(s, s, 1 / s[3]);
            const a = mu([], wu([], s, i))
              , o = t.globeMatrix
              , l = [o[12], o[13], o[14]]
              , c = wu([], l, i)
              , h = ou(c)
              , p = mu([], c)
              , f = t.worldSize / (2 * Math.PI)
              , y = gu(p, a)
              , m = Math.asin(f / h);
            if (m < Math.acos(y)) {
                if (!n)
                    return null;
                const t = []
                  , e = [];
                du(t, a, h / y),
                mu(e, wu(e, t, c)),
                mu(a, uu(a, c, du(a, e, Math.tan(m) * h)));
            }
            const g = [];
            new ju(i,a).closestPointOnSphere(l, f, g);
            const x = mu([], L(o, 0))
              , v = mu([], L(o, 1))
              , b = mu([], L(o, 2))
              , _ = gu(x, g)
              , w = gu(v, g)
              , A = gu(b, g)
              , k = u(Math.asin(-w / f));
            let z = u(Math.atan2(_, A));
            z = t.center.lng + function(t, e) {
                const r = (e - t + 180) % 360 - 180;
                return r < -180 ? r + 360 : r
            }(t.center.lng, z);
            const S = Ho(z)
              , M = d(Ko(k), 0, 1);
            return new nl(S,M)
        }
        class Zf {
            constructor(t, e, r) {
                this.a = wu([], t, r),
                this.b = wu([], e, r),
                this.center = r;
                const n = mu([], this.a)
                  , i = mu([], this.b);
                this.angle = Math.acos(gu(n, i));
            }
        }
        function Gf(t, e) {
            if (0 === t.angle)
                return null;
            let r;
            return r = 0 === t.a[e] ? 1 / t.angle * .5 * Math.PI : 1 / t.angle * Math.atan(t.b[e] / t.a[e] / Math.sin(t.angle) - 1 / Math.tan(t.angle)),
            r < 0 || r > 1 ? null : function(t, e, r, n) {
                const i = Math.sin(r);
                return t * (Math.sin((1 - n) * r) / i) + e * (Math.sin(n * r) / i)
            }(t.a[e], t.b[e], t.angle, d(r, 0, 1)) + t.center[e]
        }
        function Xf(t) {
            if (t.z <= 1)
                return qf[t.z + 2 * t.y + t.x];
            const e = Qf(Wf(t));
            return $u.fromPoints(e)
        }
        function Yf(t, e, r) {
            return du(t, t, 1 - r),
            yu(t, t, e, r)
        }
        function Hf(t, e) {
            const r = ld(e.zoom);
            if (0 === r)
                return Xf(t);
            const n = Wf(t)
              , i = Qf(n)
              , s = Ho(n.getWest()) * e.worldSize
              , a = Ho(n.getEast()) * e.worldSize
              , o = Ko(n.getNorth()) * e.worldSize
              , l = Ko(n.getSouth()) * e.worldSize
              , u = [s, o, 0]
              , c = [a, o, 0]
              , h = [s, l, 0]
              , p = [a, l, 0]
              , f = Kl([], e.globeMatrix);
            return vu(u, u, f),
            vu(c, c, f),
            vu(h, h, f),
            vu(p, p, f),
            i[0] = Yf(i[0], h, r),
            i[1] = Yf(i[1], p, r),
            i[2] = Yf(i[2], c, r),
            i[3] = Yf(i[3], u, r),
            $u.fromPoints(i)
        }
        function Kf(t, e, r) {
            for (const n of t)
                vu(n, n, e),
                du(n, n, r);
        }
        function Jf(t, e, r) {
            const n = e / t.worldSize
              , i = t.globeMatrix;
            if (r.z <= 1) {
                const t = Xf(r).getCorners();
                return Kf(t, i, n),
                $u.fromPoints(t)
            }
            const s = Wf(r)
              , a = Qf(s);
            Kf(a, i, n);
            const o = Number.MAX_VALUE
              , u = [-o, -o, -o]
              , c = [o, o, o];
            if (s.contains(t.center)) {
                for (const t of a)
                    pu(c, c, t),
                    fu(u, u, t);
                u[2] = 0;
                const e = t.point
                  , r = [e.x * n, e.y * n, 0];
                return pu(c, c, r),
                fu(u, u, r),
                new $u(c,u)
            }
            const h = [i[12] * n, i[13] * n, i[14] * n]
              , p = s.getCenter()
              , f = d(t.center.lat, -85.051129, el)
              , y = d(p.lat, -85.051129, el)
              , m = Ho(t.center.lng)
              , g = Ko(f);
            let x = m - Ho(p.lng);
            const v = g - Ko(y);
            x > .5 ? x -= 1 : x < -.5 && (x += 1);
            let b = 0;
            Math.abs(x) > Math.abs(v) ? b = x >= 0 ? 1 : 3 : (b = v >= 0 ? 0 : 2,
            yu(h, h, [i[4] * n, i[5] * n, i[6] * n], -Math.sin(l(v >= 0 ? s.getSouth() : s.getNorth())) * Lf));
            const _ = a[b]
              , w = a[(b + 1) % 4]
              , A = new Zf(_,w,h)
              , k = [Gf(A, 0) || _[0], Gf(A, 1) || _[1], Gf(A, 2) || _[2]]
              , z = ld(t.zoom);
            if (z > 0) {
                const n = function(t, e, r, n, i) {
                    const {x: s, z: a} = t
                      , o = 1 / (1 << a);
                    let l = s * o
                      , u = l + o
                      , c = t._tileY * o
                      , h = (t._tileY + t._tileH) * o
                      , p = 0;
                    const f = (l + u) / 2 - n;
                    return f > .5 ? p = -1 : f < -.5 && (p = 1),
                    l = ((l + p) * e - (n *= e)) * r + n,
                    u = ((u + p) * e - n) * r + n,
                    c = (c * e - (i *= e)) * r + i,
                    h = (h * e - i) * r + i,
                    [[l, h, 0], [u, h, 0], [u, c, 0], [l, c, 0]]
                }(r, e, t._pixelsPerMercatorPixel, m, g);
                for (let t = 0; t < a.length; t++)
                    Yf(a[t], n[t], z);
                const i = uu([], n[b], n[(b + 1) % 4]);
                du(i, i, .5),
                Yf(k, i, z);
            }
            for (const t of a)
                pu(c, c, t),
                fu(u, u, t);
            return c[2] = Math.min(_[2], w[2]),
            pu(c, c, k),
            fu(u, u, k),
            new $u(c,u)
        }
        function Wf(t) {
            const {x: e, z: r} = t
              , n = 1 / (1 << r)
              , i = xl(t)
              , s = new Ao(Wo(e * n),Qo(i.bottom * n))
              , a = new Ao(Wo((e + 1) * n),Qo(i.top * n));
            return new _o(s,a)
        }
        function Qf(t) {
            const e = l(t.getNorth())
              , r = l(t.getSouth())
              , n = Math.cos(e)
              , i = Math.cos(r)
              , s = Math.sin(e)
              , a = Math.sin(r)
              , o = t.getWest()
              , u = t.getEast();
            return [td(i, a, o), td(i, a, u), td(n, s, u), td(n, s, o)]
        }
        function td(t, e, r, n=Lf) {
            return r = l(r),
            [t * Math.sin(r) * n, -e * n, t * Math.cos(r) * n]
        }
        function ed(t, e, r) {
            return td(Math.cos(l(t)), Math.sin(l(t)), e, r)
        }
        function rd(t, e, r, n) {
            const i = 1 << r.z
              , s = (t / bo + r.x) / i;
            return ed(Qo(gl(e, r) / i), Wo(s), n)
        }
        function nd({min: t, max: e}) {
            return 16383 / Math.max(e[0] - t[0], e[1] - t[1], e[2] - t[2])
        }
        const id = new Float64Array(16);
        function sd(t) {
            const e = nd(t)
              , r = ru(id, [e, e, e]);
            return Wl(r, r, ((n = [])[0] = -(i = t.min)[0],
            n[1] = -i[1],
            n[2] = -i[2],
            n));
            var n, i;
        }
        function ad(t) {
            const e = (n = t.min,
            (r = id)[0] = 1,
            r[1] = 0,
            r[2] = 0,
            r[3] = 0,
            r[4] = 0,
            r[5] = 1,
            r[6] = 0,
            r[7] = 0,
            r[8] = 0,
            r[9] = 0,
            r[10] = 1,
            r[11] = 0,
            r[12] = n[0],
            r[13] = n[1],
            r[14] = n[2],
            r[15] = 1,
            r);
            var r, n;
            const i = 1 / nd(t);
            return Ql(e, e, [i, i, i])
        }
        function od(t, e, r, n, i) {
            const s = function(t) {
                const e = bo / (2 * Math.PI);
                return t / (2 * Math.PI) / e
            }(r)
              , a = [t, e, -r / (2 * Math.PI)]
              , o = Hl(new Float64Array(16));
            return Wl(o, o, a),
            Ql(o, o, [s, s, s]),
            tu(o, o, l(-i)),
            eu(o, o, l(-n)),
            o
        }
        function ld(t) {
            return y(5, 6, t)
        }
        function ud(t, e) {
            const r = ed(e.lat, e.lng);
            return s = (n = cu([], function(t) {
                const e = ed(t._center.lat, t._center.lng);
                let r = xu([], lu(0, 1, 0), e);
                const n = nu([], -t.angle, e);
                r = vu(r, r, n),
                nu(n, -t._pitch, r);
                const i = mu([], e);
                return du(i, i, t.cameraToCenterDistance / t.pixelsPerMeter * Rf),
                vu(i, i, n),
                uu([], e, i)
            }(t), r))[0],
            a = n[1],
            o = n[2],
            l = (i = r)[0],
            u = i[1],
            c = i[2],
            p = (h = Math.sqrt(s * s + a * a + o * o) * Math.sqrt(l * l + u * u + c * c)) && gu(n, i) / h,
            Math.acos(Math.min(Math.max(p, -1), 1));
            var n, i, s, a, o, l, u, c, h, p;
        }
        const cd = l(85)
          , hd = Math.cos(cd)
          , pd = Math.sin(cd);
        function fd(t, e) {
            const r = t.fovAboveCenter
              , n = t.elevation ? t.elevation.getMinElevationBelowMSL() * e : 0
              , i = (t._camera.position[2] * t.worldSize - n) / Math.cos(t._pitch)
              , s = Math.sin(r) * i / Math.sin(Math.max(Math.PI / 2 - t._pitch - r, .01))
              , a = Math.sin(t._pitch) * s + i;
            return Math.min(1.01 * a, i * (1 / t._horizonShift))
        }
        function dd(t, e) {
            if (!e.isReprojectedInTileSpace) {
                const r = xl(t);
                return {
                    scale: 1 << t.z,
                    x: t.x,
                    y: r.top,
                    x2: t.x + 1,
                    y2: r.bottom,
                    projection: e,
                    reference: t.reference,
                    _tileY: t._tileY,
                    _tileH: t._tileH
                }
            }
            const r = Math.pow(2, -t.z)
              , n = t.x * r
              , i = (t.x + 1) * r
              , s = xl(t)
              , a = s.top * r
              , o = s.bottom * r
              , l = Wo(n)
              , u = Wo(i)
              , c = Qo(a)
              , h = Qo(o)
              , p = e.project(l, c)
              , f = e.project(u, c)
              , d = e.project(u, h)
              , y = e.project(l, h);
            let m = Math.min(p.x, f.x, d.x, y.x)
              , g = Math.min(p.y, f.y, d.y, y.y)
              , x = Math.max(p.x, f.x, d.x, y.x)
              , v = Math.max(p.y, f.y, d.y, y.y);
            const b = r / 16;
            function _(t, r, n, i, s, a) {
                const o = (n + s) / 2
                  , l = (i + a) / 2
                  , u = e.project(Wo(o), Qo(l))
                  , c = Math.max(0, m - u.x, g - u.y, u.x - x, u.y - v);
                m = Math.min(m, u.x),
                x = Math.max(x, u.x),
                g = Math.min(g, u.y),
                v = Math.max(v, u.y),
                c > b && (_(t, u, n, i, o, l),
                _(u, r, o, l, s, a));
            }
            _(p, f, n, a, i, a),
            _(f, d, i, a, i, o),
            _(d, y, i, o, n, o),
            _(y, p, n, o, n, a),
            m -= b,
            g -= b,
            x += b,
            v += b;
            const w = 1 / Math.max(x - m, v - g);
            return {
                scale: w,
                x: m * w,
                y: g * w,
                x2: x * w,
                y2: v * w,
                projection: e,
                _tileY: g * w,
                _tileH: v * w - g * w
            }
        }
        const yd = Hl(new Float32Array(16));
        class md {
            constructor(t) {
                this.spec = t,
                this.name = t.name,
                this.wrap = !1,
                this.requiresDraping = !1,
                this.supportsWorldCopies = !1,
                this.supportsTerrain = !1,
                this.supportsFog = !1,
                this.supportsFreeCamera = !1,
                this.zAxisUnit = "meters",
                this.isReprojectedInTileSpace = !0,
                this.unsupportedLayers = ["custom"],
                this.center = [0, 0],
                this.range = [3.5, 7];
            }
            project(t, e) {
                return {
                    x: 0,
                    y: 0,
                    z: 0
                }
            }
            unproject(t, e) {
                return new Ao(0,0)
            }
            projectTilePoint(t, e, r) {
                return {
                    x: t,
                    y: e,
                    z: 0
                }
            }
            locationPoint(t, e, r=!0) {
                return t._coordinatePoint(t.locationCoordinate(e), r)
            }
            pixelsPerMeter(t, e) {
                return Jo(1, t) * e
            }
            pixelSpaceConversion(t, e, r) {
                return 1
            }
            farthestPixelDistance(t) {
                return fd(t, t.pixelsPerMeter)
            }
            pointCoordinate(t, e, r, n) {
                const s = t.horizonLineFromTop(!1)
                  , a = new i(e,Math.max(s, r));
                return t.rayIntersectionCoordinate(t.pointRayIntersection(a, n))
            }
            pointCoordinate3D(t, e, r) {
                const n = new i(e,r);
                if (t.elevation)
                    return t.elevation.pointCoordinate(n);
                {
                    const e = this.pointCoordinate(t, n.x, n.y, 0);
                    return [e.x, e.y, e.z]
                }
            }
            isPointAboveHorizon(t, e) {
                if (t.elevation)
                    return !this.pointCoordinate3D(t, e.x, e.y);
                const r = t.horizonLineFromTop();
                return e.y < r
            }
            createInversionMatrix(t, e) {
                return yd
            }
            createTileMatrix(t, e, r) {
                let n, i, s;
                const a = r.canonical
                  , o = Hl(new Float64Array(16));
                let l = a._tileY
                  , u = a._tileH;
                if (this.isReprojectedInTileSpace) {
                    const c = dd(a, this);
                    n = 1,
                    i = c.x + r.wrap * c.scale,
                    s = c.y,
                    l = c._tileY,
                    u = c._tileH,
                    Ql(o, o, [n / c.scale, n / c.scale, t.pixelsPerMeter / e]);
                } else
                    n = e / t.zoomScale(a.z),
                    i = (a.x + Math.pow(2, a.z) * r.wrap) * n,
                    s = a.y * n;
                return "Sg4326" == a.reference ? (Wl(o, o, [i, l * n, 0]),
                Ql(o, o, [1, u, 1])) : Wl(o, o, [i, s, 0]),
                Ql(o, o, [n / bo, n / bo, 1]),
                o
            }
            upVector(t, e, r) {
                return [0, 0, 1]
            }
            upVectorScale(t, e, r) {
                return {
                    metersToTile: 1
                }
            }
        }
        class gd extends md {
            constructor(t) {
                super(t),
                this.range = [4, 7],
                this.center = t.center || [-96, 37.5];
                const [e,r] = this.parallels = t.parallels || [29.5, 45.5]
                  , n = Math.sin(l(e));
                this.n = (n + Math.sin(l(r))) / 2,
                this.c = 1 + n * (2 * this.n - n),
                this.r0 = Math.sqrt(this.c) / this.n;
            }
            project(t, e) {
                const {n: r, c: n, r0: i} = this
                  , s = l(t - this.center[0])
                  , a = l(e)
                  , o = Math.sqrt(n - 2 * r * Math.sin(a)) / r;
                return {
                    x: o * Math.sin(s * r),
                    y: o * Math.cos(s * r) - i,
                    z: 0
                }
            }
            unproject(t, e) {
                const {n: r, c: n, r0: i} = this
                  , s = i + e;
                let a = Math.atan2(t, Math.abs(s)) * Math.sign(s);
                s * r < 0 && (a -= Math.PI * Math.sign(t) * Math.sign(s));
                const o = l(this.center[0]) * r;
                a = m(a, -Math.PI - o, Math.PI - o);
                const c = u(a / r) + this.center[0]
                  , h = Math.asin(d((n - (t * t + s * s) * r * r) / (2 * r), -1, 1))
                  , p = d(u(h), -85.051129, el);
                return new Ao(c,p)
            }
        }
        const xd = 1.340264
          , vd = -.081106
          , bd = 893e-6
          , _d = .003796
          , wd = Math.sqrt(3) / 2;
        class Ad extends md {
            project(t, e) {
                e = e / 180 * Math.PI,
                t = t / 180 * Math.PI;
                const r = Math.asin(wd * Math.sin(e))
                  , n = r * r
                  , i = n * n * n;
                return {
                    x: .5 * (t * Math.cos(r) / (wd * (xd + 3 * vd * n + i * (7 * bd + 9 * _d * n))) / Math.PI + .5),
                    y: 1 - .5 * (r * (xd + vd * n + i * (bd + _d * n)) / Math.PI + 1),
                    z: 0
                }
            }
            unproject(t, e) {
                t = (2 * t - .5) * Math.PI;
                let r = e = (2 * (1 - e) - 1) * Math.PI
                  , n = r * r
                  , i = n * n * n;
                for (let t, s, a, o = 0; o < 12 && (s = r * (xd + vd * n + i * (bd + _d * n)) - e,
                a = xd + 3 * vd * n + i * (7 * bd + 9 * _d * n),
                t = s / a,
                r = d(r - t, -Math.PI / 3, Math.PI / 3),
                n = r * r,
                i = n * n * n,
                !(Math.abs(t) < 1e-12)); ++o)
                    ;
                const s = wd * t * (xd + 3 * vd * n + i * (7 * bd + 9 * _d * n)) / Math.cos(r)
                  , a = Math.asin(Math.sin(r) / wd)
                  , o = d(180 * s / Math.PI, -180, 180)
                  , l = d(180 * a / Math.PI, -85.051129, el);
                return new Ao(o,l)
            }
        }
        class kd extends md {
            constructor(t) {
                super(t),
                this.wrap = !0,
                this.supportsWorldCopies = !0;
            }
            project(t, e) {
                return {
                    x: .5 + t / 360,
                    y: .5 - e / 360,
                    z: 0
                }
            }
            unproject(t, e) {
                const r = 360 * (t - .5)
                  , n = d(360 * (.5 - e), -85.051129, el);
                return new Ao(r,n)
            }
        }
        const zd = Math.PI / 2;
        function Sd(t) {
            return Math.tan((zd + t) / 2)
        }
        class Md extends md {
            constructor(t) {
                super(t),
                this.center = t.center || [0, 30];
                const [e,r] = this.parallels = t.parallels || [30, 30];
                let n = l(e)
                  , i = l(r);
                this.southernCenter = n + i < 0,
                this.southernCenter && (n = -n,
                i = -i);
                const s = Math.cos(n)
                  , a = Sd(n);
                this.n = n === i ? Math.sin(n) : Math.log(s / Math.cos(i)) / Math.log(Sd(i) / a),
                this.f = s * Math.pow(Sd(n), this.n) / this.n;
            }
            project(t, e) {
                e = l(e),
                this.southernCenter && (e = -e),
                t = l(t - this.center[0]);
                const r = 1e-6
                  , {n: n, f: i} = this;
                i > 0 ? e < -zd + r && (e = -zd + r) : e > zd - r && (e = zd - r);
                const s = i / Math.pow(Sd(e), n);
                let a = s * Math.sin(n * t)
                  , o = i - s * Math.cos(n * t);
                return a = .5 * (a / Math.PI + .5),
                o = .5 * (o / Math.PI + .5),
                {
                    x: a,
                    y: this.southernCenter ? o : 1 - o,
                    z: 0
                }
            }
            unproject(t, e) {
                t = (2 * t - .5) * Math.PI,
                this.southernCenter && (e = 1 - e),
                e = (2 * (1 - e) - .5) * Math.PI;
                const {n: r, f: n} = this
                  , i = n - e
                  , s = Math.sign(i)
                  , a = Math.sign(r) * Math.sqrt(t * t + i * i);
                let o = Math.atan2(t, Math.abs(i)) * s;
                i * r < 0 && (o -= Math.PI * Math.sign(t) * s);
                const l = d(u(o / r) + this.center[0], -180, 180)
                  , c = d(u(2 * Math.atan(Math.pow(n / a, 1 / r)) - zd), -85.051129, el);
                return new Ao(l,this.southernCenter ? -c : c)
            }
        }
        class Id extends md {
            constructor(t) {
                super(t),
                this.wrap = !0,
                this.supportsWorldCopies = !0,
                this.supportsTerrain = !0,
                this.supportsFog = !0,
                this.supportsFreeCamera = !0,
                this.isReprojectedInTileSpace = !1,
                this.unsupportedLayers = [],
                this.range = null;
            }
            project(t, e) {
                return {
                    x: Ho(t),
                    y: Ko(e),
                    z: 0
                }
            }
            unproject(t, e) {
                const r = Wo(t)
                  , n = Qo(e);
                return new Ao(r,n)
            }
        }
        const Td = l(el);
        class Bd extends md {
            project(t, e) {
                const r = (e = l(e)) * e
                  , n = r * r;
                return {
                    x: .5 * ((t = l(t)) * (.8707 - .131979 * r + n * (n * (.003971 * r - .001529 * n) - .013791)) / Math.PI + .5),
                    y: 1 - .5 * (e * (1.007226 + r * (.015085 + n * (.028874 * r - .044475 - .005916 * n))) / Math.PI + 1),
                    z: 0
                }
            }
            unproject(t, e) {
                t = (2 * t - .5) * Math.PI;
                let r = e = (2 * (1 - e) - 1) * Math.PI
                  , n = 25
                  , i = 0
                  , s = r * r;
                do {
                    s = r * r;
                    const t = s * s;
                    i = (r * (1.007226 + s * (.015085 + t * (.028874 * s - .044475 - .005916 * t))) - e) / (1.007226 + s * (.045255 + t * (.259866 * s - .311325 - .005916 * 11 * t))),
                    r = d(r - i, -Td, Td);
                } while (Math.abs(i) > 1e-6 && --n > 0);
                s = r * r;
                const a = d(u(t / (.8707 + s * (s * (s * s * s * (.003971 - .001529 * s) - .013791) - .131979))), -180, 180)
                  , o = u(r);
                return new Ao(a,o)
            }
        }
        const Cd = l(el);
        class Vd extends md {
            project(t, e) {
                e = l(e),
                t = l(t);
                const r = Math.cos(e)
                  , n = 2 / Math.PI
                  , i = Math.acos(r * Math.cos(t / 2))
                  , s = Math.sin(i) / i
                  , a = .5 * (t * n + 2 * r * Math.sin(t / 2) / s) || 0
                  , o = .5 * (e + Math.sin(e) / s) || 0;
                return {
                    x: .5 * (a / Math.PI + .5),
                    y: 1 - .5 * (o / Math.PI + 1),
                    z: 0
                }
            }
            unproject(t, e) {
                let r = t = (2 * t - .5) * Math.PI
                  , n = e = (2 * (1 - e) - 1) * Math.PI
                  , i = 25;
                const s = 1e-6;
                let a = 0
                  , o = 0;
                do {
                    const i = Math.cos(n)
                      , s = Math.sin(n)
                      , l = 2 * s * i
                      , u = s * s
                      , c = i * i
                      , h = Math.cos(r / 2)
                      , p = Math.sin(r / 2)
                      , f = 2 * h * p
                      , y = p * p
                      , m = 1 - c * h * h
                      , g = m ? 1 / m : 0
                      , x = m ? Math.acos(i * h) * Math.sqrt(1 / m) : 0
                      , v = .5 * (2 * x * i * p + 2 * r / Math.PI) - t
                      , b = .5 * (x * s + n) - e
                      , _ = .5 * g * (c * y + x * i * h * u) + 1 / Math.PI
                      , w = g * (f * l / 4 - x * s * p)
                      , A = .125 * g * (l * p - x * s * c * f)
                      , k = .5 * g * (u * h + x * y * i) + .5
                      , z = w * A - k * _;
                    a = (b * w - v * k) / z,
                    o = (v * A - b * _) / z,
                    r = d(r - a, -Math.PI, Math.PI),
                    n = d(n - o, -Cd, Cd);
                } while ((Math.abs(a) > s || Math.abs(o) > s) && --i > 0);
                return new Ao(u(r),u(n))
            }
        }
        class Pd extends md {
            constructor(t) {
                super(t),
                this.center = t.center || [0, 0],
                this.parallels = t.parallels || [0, 0],
                this.cosPhi = Math.max(.01, Math.cos(l(this.parallels[0]))),
                this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)),
                this.wrap = !0,
                this.supportsWorldCopies = !0;
            }
            project(t, e) {
                const {scale: r, cosPhi: n} = this;
                return {
                    x: l(t) * n * r + .5,
                    y: -Math.sin(l(e)) / n * r + .5,
                    z: 0
                }
            }
            unproject(t, e) {
                const {scale: r, cosPhi: n} = this
                  , i = -(e - .5) / r
                  , s = d(u((t - .5) / r) / n, -180, 180)
                  , a = Math.asin(d(i * n, -1, 1))
                  , o = d(u(a), -85.051129, el);
                return new Ao(s,o)
            }
        }
        class Dd extends Id {
            constructor(t) {
                super(t),
                this.requiresDraping = !0,
                this.supportsWorldCopies = !1,
                this.supportsFog = !0,
                this.zAxisUnit = "pixels",
                this.unsupportedLayers = ["debug", "custom"],
                this.range = [3, 5];
            }
            projectTilePoint(t, e, r) {
                const n = rd(t, e, r);
                return vu(n, n, sd(Xf(r))),
                {
                    x: n[0],
                    y: n[1],
                    z: n[2]
                }
            }
            locationPoint(t, e) {
                const r = ed(e.lat, e.lng)
                  , n = mu([], r)
                  , s = t.elevation ? t.elevation.getAtPointOrZero(t.locationCoordinate(e), t._centerAltitude) : t._centerAltitude;
                yu(r, r, n, Jo(1, 0) * bo * s);
                const a = Hl(new Float64Array(16));
                return Jl(a, t.pixelMatrix, t.globeMatrix),
                vu(r, r, a),
                new i(r[0],r[1])
            }
            pixelsPerMeter(t, e) {
                return Jo(1, 0) * e
            }
            pixelSpaceConversion(t, e, r) {
                const n = mr(Jo(1, 45) * e, Jo(1, t) * e, r);
                return this.pixelsPerMeter(t, e) / n
            }
            createTileMatrix(t, e, r) {
                const n = ad(Xf(r.canonical));
                return Jl(new Float64Array(16), t.globeMatrix, n)
            }
            createInversionMatrix(t, e) {
                const {center: r} = t
                  , n = sd(Xf(e));
                return eu(n, n, l(r.lng)),
                tu(n, n, l(r.lat)),
                Ql(n, n, [t._pixelsPerMercatorPixel, t._pixelsPerMercatorPixel, 1]),
                Float32Array.from(n)
            }
            pointCoordinate(t, e, r, n) {
                return Nf(t, e, r, !0) || new nl(0,0)
            }
            pointCoordinate3D(t, e, r) {
                const n = this.pointCoordinate(t, e, r, 0);
                return [n.x, n.y, n.z]
            }
            isPointAboveHorizon(t, e) {
                return !Nf(t, e.x, e.y, !1)
            }
            farthestPixelDistance(t) {
                const e = function(t, e) {
                    const r = t.cameraToCenterDistance
                      , n = t._centerAltitude * e
                      , i = t._camera
                      , s = t._camera.forward()
                      , a = uu([], du([], s, -r), [0, 0, n])
                      , o = t.worldSize / (2 * Math.PI)
                      , l = [0, 0, -o]
                      , u = t.width / t.height
                      , c = Math.tan(t.fovAboveCenter)
                      , h = du([], i.up(), c)
                      , p = du([], i.right(), c * u)
                      , f = mu([], uu([], uu([], s, h), p))
                      , d = [];
                    let y;
                    if (new ju(a,f).closestPointOnSphere(l, o, d)) {
                        const e = uu([], d, l)
                          , r = wu([], e, a);
                        y = Math.cos(t.fovAboveCenter) * ou(r);
                    } else {
                        const t = wu([], a, l)
                          , e = wu([], l, a);
                        mu(e, e);
                        const r = ou(t) - o;
                        y = Math.sqrt(r * (r + 2 * o));
                        const n = Math.acos(y / (o + r)) - Math.acos(gu(s, e));
                        y *= Math.cos(n);
                    }
                    return 1.01 * y
                }(t, this.pixelsPerMeter(t.center.lat, t.worldSize))
                  , r = ld(t.zoom);
                if (r > 0) {
                    const n = fd(t, Jo(1, t.center.lat) * t.worldSize)
                      , i = t.worldSize / (2 * Math.PI)
                      , s = Math.max(t.width, t.height) / t.worldSize * Math.PI;
                    return mr(e, n + i * (1 - Math.cos(s)), Math.pow(r, 10))
                }
                return e
            }
            upVector(t, e, r) {
                return rd(e, r, t, 1)
            }
            upVectorScale(t) {
                return {
                    metersToTile: Rf * nd(Xf(t))
                }
            }
        }
        function Ed(t) {
            const e = t.parallels
              , r = !!e && Math.abs(e[0] + e[1]) < .01;
            switch (t.name) {
            case "mercator":
                return new Id(t);
            case "equirectangular":
                return new kd(t);
            case "naturalEarth":
                return new Bd(t);
            case "equalEarth":
                return new Ad(t);
            case "winkelTripel":
                return new Vd(t);
            case "albers":
                return r ? new Pd(t) : new gd(t);
            case "lambertConformalConic":
                return r ? new Pd(t) : new Md(t);
            case "globe":
                return new Dd(t)
            }
            throw new Error(`Invalid projection name: ${t.name}`)
        }
        const Fd = nh.VectorTileFeature.types
          , Ld = [{
            name: "a_fade_opacity",
            components: 1,
            type: "Uint8",
            offset: 0
        }];
        function Rd(t, e, r, n, i, s, a, o, l, u, c, h, p) {
            const f = o ? Math.min(Mf, Math.round(o[0])) : 0
              , d = o ? Math.min(Mf, Math.round(o[1])) : 0;
            t.emplaceBack(e, r, Math.round(32 * n), Math.round(32 * i), s, a, (f << 1) + (l ? 1 : 0), d, 16 * u, 16 * c, 256 * h, 256 * p);
        }
        function jd(t, e, r, n, i, s, a) {
            t.emplaceBack(e, r, n, i, s, a);
        }
        function Ud(t, e, r, n, i, s) {
            s && (i = -1 * (i + 100)),
            t.emplaceBack(e, r, n, i),
            t.emplaceBack(e, r, n, i),
            t.emplaceBack(e, r, n, i),
            t.emplaceBack(e, r, n, i);
        }
        function Od(t) {
            for (const e of t.sections)
                if (ms(e.text))
                    return !0;
            return !1
        }
        class $d {
            constructor(t) {
                this.layoutVertexArray = new ia,
                this.indexArray = new pa,
                this.programConfigurations = t,
                this.segments = new vo,
                this.dynamicLayoutVertexArray = new ta,
                this.opacityVertexArray = new aa,
                this.placedSymbolArray = new Sa,
                this.globeExtVertexArray = new sa;
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length
            }
            upload(t, e, r, n) {
                this.isEmpty() || (r && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, $h.members),
                this.indexBuffer = t.createIndexBuffer(this.indexArray, e),
                this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, Nh.members, !0),
                this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, Ld, !0),
                this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t.createVertexBuffer(this.globeExtVertexArray, qh.members, !0)),
                this.opacityVertexBuffer.itemSize = 1),
                (r || n) && this.programConfigurations.upload(t));
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                this.indexBuffer.destroy(),
                this.programConfigurations.destroy(),
                this.segments.destroy(),
                this.dynamicLayoutVertexBuffer.destroy(),
                this.opacityVertexBuffer.destroy(),
                this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
            }
        }
        Bi($d, "SymbolBuffers");
        class qd {
            constructor(t, e, r) {
                this.layoutVertexArray = new t,
                this.layoutAttributes = e,
                this.indexArray = new r,
                this.segments = new vo,
                this.collisionVertexArray = new ca,
                this.collisionVertexArrayExt = new ha;
            }
            upload(t) {
                this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes),
                this.indexBuffer = t.createIndexBuffer(this.indexArray),
                this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, Zh.members, !0),
                this.collisionVertexBufferExt = t.createVertexBuffer(this.collisionVertexArrayExt, Gh.members, !0);
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                this.indexBuffer.destroy(),
                this.segments.destroy(),
                this.collisionVertexBuffer.destroy(),
                this.collisionVertexBufferExt.destroy());
            }
        }
        Bi(qd, "CollisionBuffers");
        class Nd {
            constructor(t) {
                this.collisionBoxArray = t.collisionBoxArray,
                this.zoom = t.zoom,
                this.overscaling = t.overscaling,
                this.layers = t.layers,
                this.layerIds = this.layers.map((t => t.id)),
                this.index = t.index,
                this.pixelRatio = t.pixelRatio,
                this.sourceLayerIndex = t.sourceLayerIndex,
                this.hasPattern = !1,
                this.hasRTLText = !1,
                this.fullyClipped = !1,
                this.sortKeyRanges = [],
                this.collisionCircleArray = [],
                this.placementInvProjMatrix = Hl([]),
                this.placementViewportMatrix = Hl([]);
                const e = this.layers[0]._unevaluatedLayout._values;
                this.textSizeData = Jh(this.zoom, e["text-size"]),
                this.iconSizeData = Jh(this.zoom, e["icon-size"]);
                const r = this.layers[0].layout
                  , n = r.get("symbol-sort-key")
                  , i = r.get("symbol-z-order");
                this.canOverlap = r.get("text-allow-overlap") || r.get("icon-allow-overlap") || r.get("text-ignore-placement") || r.get("icon-ignore-placement"),
                this.sortFeaturesByKey = "viewport-y" !== i && void 0 !== n.constantOr(1),
                this.sortFeaturesByY = ("viewport-y" === i || "auto" === i && !this.sortFeaturesByKey) && this.canOverlap,
                this.writingModes = r.get("text-writing-mode").map((t => Pp[t])),
                this.stateDependentLayerIds = this.layers.filter((t => t.isStateDependent())).map((t => t.id)),
                this.sourceID = t.sourceID,
                this.projection = t.projection,
                this.feature_values = {};
            }
            createArrays() {
                this.text = new $d(new lo(this.layers,this.zoom,(t => /^text/.test(t) || /symbol-minzoom/.test(t) || /symbol-maxzoom/.test(t)))),
                this.icon = new $d(new lo(this.layers,this.zoom,(t => /^icon/.test(t) || /symbol-minzoom/.test(t) || /symbol-maxzoom/.test(t)))),
                this.glyphOffsetArray = new Ta,
                this.lineVertexArray = new Ba,
                this.symbolInstances = new Ia;
            }
            calculateGlyphDependencies(t, e, r, n, i) {
                for (let r = 0; r < t.length; r++)
                    if (e[t.charCodeAt(r)] = !0,
                    n && i) {
                        const n = rp[t.charAt(r)];
                        n && (e[n.charCodeAt(0)] = !0);
                    }
            }
            populate(t, e, r, n) {
                const i = this.layers[0]
                  , s = i.layout
                  , a = i.paint
                  , o = "globe" === this.projection.name
                  , l = s.get("text-font")
                  , u = s.get("text-field")
                  , c = s.get("icon-image")
                  , h = ("constant" !== u.value.kind || u.value.value instanceof ve && !u.value.value.isEmpty() || u.value.value.toString().length > 0) && ("constant" !== l.value.kind || l.value.value.length > 0)
                  , p = "constant" !== c.value.kind || !!c.value.value || Object.keys(c.parameters).length > 0
                  , f = s.get("symbol-sort-key");
                this.features = [],
                this.feature_values = [];
                const d = a.get("symbol-minzoom")
                  , y = a.get("symbol-maxzoom");
                if (!h && !p)
                    return;
                const m = e.iconDependencies
                  , g = e.glyphDependencies
                  , x = e.availableImages
                  , v = new Ts(this.zoom);
                for (const {feature: e, id: a, index: u, sourceLayerIndex: c} of t) {
                    const t = i._featureFilter.needGeometry
                      , w = Al(e, t);
                    if (!i._featureFilter.filter(v, w, r))
                        continue;
                    if (t || (w.geometry = wl(e, r, n)),
                    o && 1 !== e.type && r.z <= 5) {
                        const t = w.geometry
                          , e = .98078528056;
                        for (let n = 0; n < t.length; n++)
                            t[n] = ol(t[n], (t => t), ( (t, n) => gu(rd(t.x, t.y, r, 1), rd(n.x, n.y, r, 1)) < e));
                    }
                    let A, k;
                    if (h) {
                        const t = i.getValueAndResolveTokens("text-field", w, r, x)
                          , e = ve.factory(t);
                        Od(e) && (this.hasRTLText = !0),
                        (!this.hasRTLText || "unavailable" === Ss() || this.hasRTLText && Is.isParsed()) && (A = ep(e, i, w));
                    }
                    if (p) {
                        const t = i.getValueAndResolveTokens("icon-image", w, r, x);
                        k = t instanceof be ? t : be.fromString(t);
                    }
                    if (!A && !k)
                        continue;
                    const z = this.sortFeaturesByKey ? f.evaluate(w, {}, r) : void 0;
                    if (this.features.push({
                        id: a,
                        text: A,
                        icon: k,
                        index: u,
                        sourceLayerIndex: c,
                        geometry: w.geometry,
                        properties: e.properties,
                        type: Fd[e.type],
                        sortKey: z
                    }),
                    d && y && 0 != d.constantOr(1) && 24 != y.constantOr(1)) {
                        var b = d.evaluate(w)
                          , _ = y.evaluate(w);
                        this.feature_values.push([u, b = b <= 3 ? 0 : b - 1, _ = _ >= 19 ? 25 : _ > b ? _ : b + 1]);
                    }
                    if (k && (m[k.name] = !0),
                    A) {
                        const t = l.evaluate(w, {}, r).join(",")
                          , e = "map" === s.get("text-rotation-alignment") && "point" !== s.get("symbol-placement");
                        this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Pp.vertical) >= 0;
                        for (const r of A.sections)
                            if (r.image)
                                m[r.image.name] = !0;
                            else {
                                const n = us(A.toString())
                                  , i = r.fontStack || t
                                  , s = g[i] = g[i] || {};
                                this.calculateGlyphDependencies(r.text, s, e, this.allowVerticalPlacement, n);
                            }
                    }
                }
                "line" === s.get("symbol-placement") && (this.features = function(t) {
                    const e = {}
                      , r = {}
                      , n = [];
                    let i = 0;
                    function s(e) {
                        n.push(t[e]),
                        i++;
                    }
                    function a(t, e, i) {
                        const s = r[t];
                        return delete r[t],
                        r[e] = s,
                        n[s].geometry[0].pop(),
                        n[s].geometry[0] = n[s].geometry[0].concat(i[0]),
                        s
                    }
                    function o(t, r, i) {
                        const s = e[r];
                        return delete e[r],
                        e[t] = s,
                        n[s].geometry[0].shift(),
                        n[s].geometry[0] = i[0].concat(n[s].geometry[0]),
                        s
                    }
                    function l(t, e, r) {
                        const n = r ? e[0][e[0].length - 1] : e[0][0];
                        return `${t}:${n.x}:${n.y}`
                    }
                    for (let u = 0; u < t.length; u++) {
                        const c = t[u]
                          , h = c.geometry
                          , p = c.text ? c.text.toString() : null;
                        if (!p) {
                            s(u);
                            continue
                        }
                        const f = l(p, h)
                          , d = l(p, h, !0);
                        if (f in r && d in e && r[f] !== e[d]) {
                            const t = o(f, d, h)
                              , i = a(f, d, n[t].geometry);
                            delete e[f],
                            delete r[d],
                            r[l(p, n[i].geometry, !0)] = i,
                            n[t].geometry = null;
                        } else
                            f in r ? a(f, d, h) : d in e ? o(f, d, h) : (s(u),
                            e[f] = i - 1,
                            r[d] = i - 1);
                    }
                    return n.filter((t => t.geometry))
                }(this.features)),
                this.sortFeaturesByKey && this.features.sort(( (t, e) => t.sortKey - e.sortKey));
            }
            update(t, e, r, n) {
                this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, e, this.layers, r, n),
                this.icon.programConfigurations.updatePaintArrays(t, e, this.layers, r, n));
            }
            isEmpty() {
                return 0 === this.symbolInstances.length && !this.hasRTLText
            }
            uploadPending() {
                return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload
            }
            upload(t) {
                !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t),
                this.iconCollisionBox.upload(t)),
                this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload),
                this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload),
                this.uploaded = !0;
            }
            destroyDebugData() {
                this.textCollisionBox.destroy(),
                this.iconCollisionBox.destroy();
            }
            getProjection() {
                return this.projectionInstance || (this.projectionInstance = Ed(this.projection)),
                this.projectionInstance
            }
            destroy() {
                this.text.destroy(),
                this.icon.destroy(),
                this.hasDebugData() && this.destroyDebugData();
            }
            addToLineVertexArray(t, e) {
                const r = this.lineVertexArray.length
                  , n = t.segment;
                if (void 0 !== n) {
                    let r = t.dist(e[n + 1])
                      , i = t.dist(e[n]);
                    const s = {};
                    for (let t = n + 1; t < e.length; t++)
                        s[t] = {
                            x: e[t].x,
                            y: e[t].y,
                            tileUnitDistanceFromAnchor: r
                        },
                        t < e.length - 1 && (r += e[t + 1].dist(e[t]));
                    for (let t = n || 0; t >= 0; t--)
                        s[t] = {
                            x: e[t].x,
                            y: e[t].y,
                            tileUnitDistanceFromAnchor: i
                        },
                        t > 0 && (i += e[t - 1].dist(e[t]));
                    for (let t = 0; t < e.length; t++) {
                        const e = s[t];
                        this.lineVertexArray.emplaceBack(e.x, e.y, e.tileUnitDistanceFromAnchor);
                    }
                }
                return {
                    lineStartIndex: r,
                    lineLength: this.lineVertexArray.length - r
                }
            }
            addSymbols(t, e, r, n, i, s, a, o, l, u, c, h, p, f) {
                const d = t.indexArray
                  , y = t.layoutVertexArray
                  , m = t.globeExtVertexArray
                  , g = t.segments.prepareSegment(4 * e.length, y, d, this.canOverlap ? s.sortKey : void 0)
                  , x = this.glyphOffsetArray.length
                  , v = g.vertexLength
                  , b = this.allowVerticalPlacement && a === Pp.vertical ? Math.PI / 2 : 0
                  , _ = s.text && s.text.sections;
                let w = this.layers[0].layout.get("symbol-scaleable").evaluate(s, {});
                for (let n = 0; n < e.length; n++) {
                    const {tl: i, tr: a, bl: u, br: c, tex: h, pixelOffsetTL: x, pixelOffsetBR: v, minFontScaleX: A, minFontScaleY: k, glyphOffset: z, isSDF: S, sectionIndex: M} = e[n]
                      , I = g.vertexLength
                      , T = z[1];
                    if (Rd(y, l.x, l.y, i.x, T + i.y, h.x, h.y, r, S, x.x, x.y, A, k),
                    Rd(y, l.x, l.y, a.x, T + a.y, h.x + h.w, h.y, r, S, v.x, x.y, A, k),
                    Rd(y, l.x, l.y, u.x, T + u.y, h.x, h.y + h.h, r, S, x.x, v.y, A, k),
                    Rd(y, l.x, l.y, c.x, T + c.y, h.x + h.w, h.y + h.h, r, S, v.x, v.y, A, k),
                    o) {
                        const e = o.anchor
                          , r = o.up;
                        jd(m, e.x, e.y, e.z, r[0], r[1], r[2]),
                        jd(m, e.x, e.y, e.z, r[0], r[1], r[2]),
                        jd(m, e.x, e.y, e.z, r[0], r[1], r[2]),
                        jd(m, e.x, e.y, e.z, r[0], r[1], r[2]),
                        Ud(t.dynamicLayoutVertexArray, e.x, e.y, e.z, b);
                    } else
                        Ud(t.dynamicLayoutVertexArray, l.x, l.y, l.z, b, w);
                    d.emplaceBack(I, I + 1, I + 2),
                    d.emplaceBack(I + 1, I + 2, I + 3),
                    g.vertexLength += 4,
                    g.primitiveLength += 2,
                    this.glyphOffsetArray.emplaceBack(z[0]),
                    n !== e.length - 1 && M === e[n + 1].sectionIndex || t.programConfigurations.populatePaintArrays(y.length, s, s.index, {}, p, f, _ && _[M]);
                }
                const A = o ? o.anchor : l;
                t.placedSymbolArray.emplaceBack(A.x, A.y, A.z, l.x, l.y, x, this.glyphOffsetArray.length - x, v, u, c, l.segment, r ? r[0] : 0, r ? r[1] : 0, n[0], n[1], a, 0, !1, 0, h, 0);
            }
            _commitLayoutVertex(t, e, r, n, i, s, a) {
                t.emplaceBack(e, r, n, i, s, Math.round(a.x), Math.round(a.y));
            }
            _addCollisionDebugVertices(t, e, r, n, s, a, o) {
                const l = r.segments.prepareSegment(4, r.layoutVertexArray, r.indexArray)
                  , u = l.vertexLength
                  , c = o.tileAnchorX
                  , h = o.tileAnchorY;
                for (let t = 0; t < 4; t++)
                    r.collisionVertexArray.emplaceBack(0, 0, 0, 0);
                r.collisionVertexArrayExt.emplaceBack(e, -t.padding, -t.padding),
                r.collisionVertexArrayExt.emplaceBack(e, t.padding, -t.padding),
                r.collisionVertexArrayExt.emplaceBack(e, t.padding, t.padding),
                r.collisionVertexArrayExt.emplaceBack(e, -t.padding, t.padding),
                this._commitLayoutVertex(r.layoutVertexArray, n, s, a, c, h, new i(t.x1,t.y1)),
                this._commitLayoutVertex(r.layoutVertexArray, n, s, a, c, h, new i(t.x2,t.y1)),
                this._commitLayoutVertex(r.layoutVertexArray, n, s, a, c, h, new i(t.x2,t.y2)),
                this._commitLayoutVertex(r.layoutVertexArray, n, s, a, c, h, new i(t.x1,t.y2)),
                l.vertexLength += 4;
                const p = r.indexArray;
                p.emplaceBack(u, u + 1),
                p.emplaceBack(u + 1, u + 2),
                p.emplaceBack(u + 2, u + 3),
                p.emplaceBack(u + 3, u),
                l.primitiveLength += 4;
            }
            _addTextDebugCollisionBoxes(t, e, r, n, i, s) {
                for (let a = n; a < i; a++) {
                    const n = r.get(a)
                      , i = this.getSymbolInstanceTextSize(t, s, e, a);
                    this._addCollisionDebugVertices(n, i, this.textCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, s);
                }
            }
            _addIconDebugCollisionBoxes(t, e, r, n, i, s) {
                for (let a = n; a < i; a++) {
                    const n = r.get(a)
                      , i = this.getSymbolInstanceIconSize(t, e, a);
                    this._addCollisionDebugVertices(n, i, this.iconCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, s);
                }
            }
            generateCollisionDebugBuffers(t, e) {
                this.hasDebugData() && this.destroyDebugData(),
                this.textCollisionBox = new qd(la,Xh.members,xa),
                this.iconCollisionBox = new qd(la,Xh.members,xa);
                const r = Qh(this.iconSizeData, t)
                  , n = Qh(this.textSizeData, t);
                for (let i = 0; i < this.symbolInstances.length; i++) {
                    const s = this.symbolInstances.get(i);
                    this._addTextDebugCollisionBoxes(n, t, e, s.textBoxStartIndex, s.textBoxEndIndex, s),
                    this._addTextDebugCollisionBoxes(n, t, e, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s),
                    this._addIconDebugCollisionBoxes(r, t, e, s.iconBoxStartIndex, s.iconBoxEndIndex, s),
                    this._addIconDebugCollisionBoxes(r, t, e, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex, s);
                }
            }
            getSymbolInstanceTextSize(t, e, r, n) {
                const i = this.text.placedSymbolArray.get(e.rightJustifiedTextSymbolIndex >= 0 ? e.rightJustifiedTextSymbolIndex : e.centerJustifiedTextSymbolIndex >= 0 ? e.centerJustifiedTextSymbolIndex : e.leftJustifiedTextSymbolIndex >= 0 ? e.leftJustifiedTextSymbolIndex : e.verticalPlacedTextSymbolIndex >= 0 ? e.verticalPlacedTextSymbolIndex : n)
                  , s = Wh(this.textSizeData, t, i) / Hh;
                return this.tilePixelRatio * s
            }
            getSymbolInstanceIconSize(t, e, r) {
                const n = this.symbolInstances.get(r)
                  , i = this.icon.placedSymbolArray.get(n.placedIconSymbolIndex >= 0 ? n.placedIconSymbolIndex : r)
                  , s = Wh(this.iconSizeData, t, i);
                return this.tilePixelRatio * s
            }
            _commitDebugCollisionVertexUpdate(t, e, r) {
                t.emplaceBack(e, -r, -r),
                t.emplaceBack(e, r, -r),
                t.emplaceBack(e, r, r),
                t.emplaceBack(e, -r, r);
            }
            _updateTextDebugCollisionBoxes(t, e, r, n, i, s) {
                for (let a = n; a < i; a++) {
                    const n = r.get(a)
                      , i = this.getSymbolInstanceTextSize(t, s, e, a);
                    this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i, n.padding);
                }
            }
            _updateIconDebugCollisionBoxes(t, e, r, n, i) {
                for (let s = n; s < i; s++) {
                    const n = r.get(s)
                      , i = this.getSymbolInstanceIconSize(t, e, s);
                    this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i, n.padding);
                }
            }
            updateCollisionDebugBuffers(t, e) {
                if (!this.hasDebugData())
                    return;
                this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(),
                this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
                const r = Qh(this.iconSizeData, t)
                  , n = Qh(this.textSizeData, t);
                for (let i = 0; i < this.symbolInstances.length; i++) {
                    const s = this.symbolInstances.get(i);
                    this._updateTextDebugCollisionBoxes(n, t, e, s.textBoxStartIndex, s.textBoxEndIndex, s),
                    this._updateTextDebugCollisionBoxes(n, t, e, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s),
                    this._updateIconDebugCollisionBoxes(r, t, e, s.iconBoxStartIndex, s.iconBoxEndIndex),
                    this._updateIconDebugCollisionBoxes(r, t, e, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex);
                }
                this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt),
                this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
            }
            _deserializeCollisionBoxesForSymbol(t, e, r, n, i, s, a, o, l) {
                const u = {};
                for (let n = e; n < r; n++) {
                    const e = t.get(n);
                    u.textBox = {
                        x1: e.x1,
                        y1: e.y1,
                        x2: e.x2,
                        y2: e.y2,
                        padding: e.padding,
                        projectedAnchorX: e.projectedAnchorX,
                        projectedAnchorY: e.projectedAnchorY,
                        projectedAnchorZ: e.projectedAnchorZ,
                        tileAnchorX: e.tileAnchorX,
                        tileAnchorY: e.tileAnchorY
                    },
                    u.textFeatureIndex = e.featureIndex;
                    break
                }
                for (let e = n; e < i; e++) {
                    const r = t.get(e);
                    u.verticalTextBox = {
                        x1: r.x1,
                        y1: r.y1,
                        x2: r.x2,
                        y2: r.y2,
                        padding: r.padding,
                        projectedAnchorX: r.projectedAnchorX,
                        projectedAnchorY: r.projectedAnchorY,
                        projectedAnchorZ: r.projectedAnchorZ,
                        tileAnchorX: r.tileAnchorX,
                        tileAnchorY: r.tileAnchorY
                    },
                    u.verticalTextFeatureIndex = r.featureIndex;
                    break
                }
                for (let e = s; e < a; e++) {
                    const r = t.get(e);
                    u.iconBox = {
                        x1: r.x1,
                        y1: r.y1,
                        x2: r.x2,
                        y2: r.y2,
                        padding: r.padding,
                        projectedAnchorX: r.projectedAnchorX,
                        projectedAnchorY: r.projectedAnchorY,
                        projectedAnchorZ: r.projectedAnchorZ,
                        tileAnchorX: r.tileAnchorX,
                        tileAnchorY: r.tileAnchorY
                    },
                    u.iconFeatureIndex = r.featureIndex;
                    break
                }
                for (let e = o; e < l; e++) {
                    const r = t.get(e);
                    u.verticalIconBox = {
                        x1: r.x1,
                        y1: r.y1,
                        x2: r.x2,
                        y2: r.y2,
                        padding: r.padding,
                        projectedAnchorX: r.projectedAnchorX,
                        projectedAnchorY: r.projectedAnchorY,
                        projectedAnchorZ: r.projectedAnchorZ,
                        tileAnchorX: r.tileAnchorX,
                        tileAnchorY: r.tileAnchorY
                    },
                    u.verticalIconFeatureIndex = r.featureIndex;
                    break
                }
                return u
            }
            deserializeCollisionBoxes(t) {
                this.collisionArrays = [];
                for (let e = 0; e < this.symbolInstances.length; e++) {
                    const r = this.symbolInstances.get(e);
                    this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, r.textBoxStartIndex, r.textBoxEndIndex, r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r.iconBoxStartIndex, r.iconBoxEndIndex, r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex));
                }
            }
            hasTextData() {
                return this.text.segments.get().length > 0
            }
            hasIconData() {
                return this.icon.segments.get().length > 0
            }
            hasDebugData() {
                return this.textCollisionBox && this.iconCollisionBox
            }
            hasTextCollisionBoxData() {
                return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0
            }
            hasIconCollisionBoxData() {
                return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0
            }
            addIndicesForPlacedSymbol(t, e) {
                const r = t.placedSymbolArray.get(e)
                  , n = r.vertexStartIndex + 4 * r.numGlyphs;
                for (let e = r.vertexStartIndex; e < n; e += 4)
                    t.indexArray.emplaceBack(e, e + 1, e + 2),
                    t.indexArray.emplaceBack(e + 1, e + 2, e + 3);
            }
            getSortedSymbolIndexes(t) {
                if (this.sortedAngle === t && void 0 !== this.symbolInstanceIndexes)
                    return this.symbolInstanceIndexes;
                const e = Math.sin(t)
                  , r = Math.cos(t)
                  , n = []
                  , i = []
                  , s = [];
                for (let t = 0; t < this.symbolInstances.length; ++t) {
                    s.push(t);
                    const a = this.symbolInstances.get(t);
                    n.push(0 | Math.round(e * a.tileAnchorX + r * a.tileAnchorY)),
                    i.push(a.featureIndex);
                }
                return s.sort(( (t, e) => n[t] - n[e] || i[e] - i[t])),
                s
            }
            addToSortKeyRanges(t, e) {
                const r = this.sortKeyRanges[this.sortKeyRanges.length - 1];
                r && r.sortKey === e ? r.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({
                    sortKey: e,
                    symbolInstanceStart: t,
                    symbolInstanceEnd: t + 1
                });
            }
            sortFeatures(t) {
                if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                    this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t),
                    this.sortedAngle = t,
                    this.text.indexArray.clear(),
                    this.icon.indexArray.clear(),
                    this.featureSortOrder = [];
                    for (const t of this.symbolInstanceIndexes) {
                        const e = this.symbolInstances.get(t);
                        this.featureSortOrder.push(e.featureIndex),
                        [e.rightJustifiedTextSymbolIndex, e.centerJustifiedTextSymbolIndex, e.leftJustifiedTextSymbolIndex].forEach(( (t, e, r) => {
                            t >= 0 && r.indexOf(t) === e && this.addIndicesForPlacedSymbol(this.text, t);
                        }
                        )),
                        e.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e.verticalPlacedTextSymbolIndex),
                        e.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e.placedIconSymbolIndex),
                        e.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e.verticalPlacedIconSymbolIndex);
                    }
                    this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray),
                    this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
                }
            }
        }
        Bi(Nd, "SymbolBucket", {
            omit: ["layers", "collisionBoxArray", "features", "compareText"]
        }),
        Nd.MAX_GLYPHS = 65535,
        Nd.addDynamicAttributes = Ud;
        const Zd = new qs({
            "symbol-placement": new Rs(qt.layout_symbol["symbol-placement"]),
            "symbol-spacing": new Rs(qt.layout_symbol["symbol-spacing"]),
            "symbol-avoid-edges": new Rs(qt.layout_symbol["symbol-avoid-edges"]),
            "symbol-sort-key": new js(qt.layout_symbol["symbol-sort-key"]),
            "symbol-z-order": new Rs(qt.layout_symbol["symbol-z-order"]),
            "icon-allow-overlap": new Rs(qt.layout_symbol["icon-allow-overlap"]),
            "icon-ignore-placement": new Rs(qt.layout_symbol["icon-ignore-placement"]),
            "icon-optional": new Rs(qt.layout_symbol["icon-optional"]),
            "icon-rotation-alignment": new Rs(qt.layout_symbol["icon-rotation-alignment"]),
            "icon-size": new js(qt.layout_symbol["icon-size"]),
            "icon-text-fit": new Rs(qt.layout_symbol["icon-text-fit"]),
            "icon-text-fit-padding": new Rs(qt.layout_symbol["icon-text-fit-padding"]),
            "icon-image": new js(qt.layout_symbol["icon-image"]),
            "icon-rotate": new js(qt.layout_symbol["icon-rotate"]),
            "icon-padding": new Rs(qt.layout_symbol["icon-padding"]),
            "icon-keep-upright": new Rs(qt.layout_symbol["icon-keep-upright"]),
            "icon-offset": new js(qt.layout_symbol["icon-offset"]),
            "icon-anchor": new js(qt.layout_symbol["icon-anchor"]),
            "icon-pitch-alignment": new Rs(qt.layout_symbol["icon-pitch-alignment"]),
            "text-pitch-alignment": new Rs(qt.layout_symbol["text-pitch-alignment"]),
            "text-rotation-alignment": new Rs(qt.layout_symbol["text-rotation-alignment"]),
            "text-field": new js(qt.layout_symbol["text-field"]),
            "text-font": new js(qt.layout_symbol["text-font"]),
            "text-size": new js(qt.layout_symbol["text-size"]),
            "text-max-width": new js(qt.layout_symbol["text-max-width"]),
            "text-line-height": new js(qt.layout_symbol["text-line-height"]),
            "text-letter-spacing": new js(qt.layout_symbol["text-letter-spacing"]),
            "text-justify": new js(qt.layout_symbol["text-justify"]),
            "text-radial-offset": new js(qt.layout_symbol["text-radial-offset"]),
            "text-variable-anchor": new Rs(qt.layout_symbol["text-variable-anchor"]),
            "text-anchor": new js(qt.layout_symbol["text-anchor"]),
            "text-max-angle": new Rs(qt.layout_symbol["text-max-angle"]),
            "text-writing-mode": new Rs(qt.layout_symbol["text-writing-mode"]),
            "text-rotate": new js(qt.layout_symbol["text-rotate"]),
            "text-padding": new Rs(qt.layout_symbol["text-padding"]),
            "text-keep-upright": new Rs(qt.layout_symbol["text-keep-upright"]),
            "text-transform": new js(qt.layout_symbol["text-transform"]),
            "text-offset": new js(qt.layout_symbol["text-offset"]),
            "text-allow-overlap": new Rs(qt.layout_symbol["text-allow-overlap"]),
            "text-ignore-placement": new Rs(qt.layout_symbol["text-ignore-placement"]),
            "text-optional": new Rs(qt.layout_symbol["text-optional"]),
            "symbol-scaleable": new js(qt.layout_symbol["symbol-scaleable"])
        });
        var Gd = {
            paint: new qs({
                "icon-opacity": new js(qt.paint_symbol["icon-opacity"]),
                "icon-color": new js(qt.paint_symbol["icon-color"]),
                "icon-halo-color": new js(qt.paint_symbol["icon-halo-color"]),
                "icon-halo-width": new js(qt.paint_symbol["icon-halo-width"]),
                "icon-halo-blur": new js(qt.paint_symbol["icon-halo-blur"]),
                "icon-translate": new Rs(qt.paint_symbol["icon-translate"]),
                "icon-translate-anchor": new Rs(qt.paint_symbol["icon-translate-anchor"]),
                "text-opacity": new js(qt.paint_symbol["text-opacity"]),
                "text-color": new js(qt.paint_symbol["text-color"],{
                    runtimeType: ee,
                    getOverride: t => t.textColor,
                    hasOverride: t => !!t.textColor
                }),
                "text-halo-color": new js(qt.paint_symbol["text-halo-color"]),
                "text-halo-width": new js(qt.paint_symbol["text-halo-width"]),
                "text-halo-blur": new js(qt.paint_symbol["text-halo-blur"]),
                "text-translate": new Rs(qt.paint_symbol["text-translate"]),
                "text-translate-anchor": new Rs(qt.paint_symbol["text-translate-anchor"]),
                "symbol-minzoom": new js(qt.paint_symbol["symbol-minzoom"]),
                "symbol-maxzoom": new js(qt.paint_symbol["symbol-maxzoom"])
            }),
            layout: Zd
        };
        class Xd {
            constructor(t) {
                this.type = t.property.overrides ? t.property.overrides.runtimeType : Jt,
                this.defaultValue = t;
            }
            evaluate(t) {
                if (t.formattedSection) {
                    const e = this.defaultValue.property.overrides;
                    if (e && e.hasOverride(t.formattedSection))
                        return e.getOverride(t.formattedSection)
                }
                return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default
            }
            eachChild(t) {
                this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);
            }
            outputDefined() {
                return !1
            }
            serialize() {
                return null
            }
        }
        Bi(Xd, "FormatSectionOverride", {
            omit: ["defaultValue"]
        });
        class Yd extends mo {
            constructor(t) {
                super(t, Gd);
            }
            recalculate(t, e) {
                super.recalculate(t, e),
                "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"),
                "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"),
                "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")),
                "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
                const r = this.layout.get("text-writing-mode");
                if (r) {
                    const t = [];
                    for (const e of r)
                        t.indexOf(e) < 0 && t.push(e);
                    this.layout._values["text-writing-mode"] = t;
                } else
                    this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? ["horizontal"] : ["horizontal", "vertical"];
                this._setPaintOverrides();
            }
            getValueAndResolveTokens(t, e, r, n) {
                const i = this.layout.get(t).evaluate(e, {}, r, n)
                  , s = this._unevaluatedLayout._values[t];
                return s.isDataDriven() || Pn(s.value) || !i ? i : function(t, e) {
                    return e.replace(/{([^{}]+)}/g, ( (e, r) => r in t ? String(t[r]) : ""))
                }(e.properties, i)
            }
            createBucket(t) {
                return new Nd(t)
            }
            queryRadius() {
                return 0
            }
            queryIntersectsFeature() {
                return !1
            }
            _setPaintOverrides() {
                for (const t of Gd.paint.overridableProperties) {
                    if (!Yd.hasPaintOverride(this.layout, t))
                        continue;
                    const e = this.paint.get(t)
                      , r = new Xd(e)
                      , n = new Vn(r,e.property.specification);
                    let i = null;
                    i = "constant" === e.value.kind || "source" === e.value.kind ? new En("source",n) : new Fn("composite",n,e.value.zoomStops,e.value._interpolationType),
                    this.paint._values[t] = new Fs(e.property,i,e.parameters);
                }
            }
            _handleOverridablePaintPropertyUpdate(t, e, r) {
                return !(!this.layout || e.isDataDriven() || r.isDataDriven()) && Yd.hasPaintOverride(this.layout, t)
            }
            static hasPaintOverride(t, e) {
                const r = t.get("text-field")
                  , n = Gd.paint.properties[e];
                let i = !1;
                const s = t => {
                    for (const e of t)
                        if (n.overrides && n.overrides.hasOverride(e))
                            return void (i = !0)
                }
                ;
                if ("constant" === r.value.kind && r.value.value instanceof ve)
                    s(r.value.value.sections);
                else if ("source" === r.value.kind) {
                    const t = e => {
                        i || (e instanceof Se && Ae(e.value) === se ? s(e.value.sections) : e instanceof Ce ? s(e.sections) : e.eachChild(t));
                    }
                      , e = r.value;
                    e._styleExpression && t(e._styleExpression.expression);
                }
                return i
            }
            getProgramConfiguration(t) {
                return new oo(this,t)
            }
        }
        var Hd = {
            paint: new qs({
                "background-color": new Rs(qt.paint_background["background-color"]),
                "background-pattern": new Os(qt.paint_background["background-pattern"]),
                "background-opacity": new Rs(qt.paint_background["background-opacity"])
            })
        }
          , Kd = {
            paint: new qs({
                "raster-opacity": new Rs(qt.paint_raster["raster-opacity"]),
                "raster-hue-rotate": new Rs(qt.paint_raster["raster-hue-rotate"]),
                "raster-brightness-min": new Rs(qt.paint_raster["raster-brightness-min"]),
                "raster-brightness-max": new Rs(qt.paint_raster["raster-brightness-max"]),
                "raster-saturation": new Rs(qt.paint_raster["raster-saturation"]),
                "raster-contrast": new Rs(qt.paint_raster["raster-contrast"]),
                "raster-resampling": new Rs(qt.paint_raster["raster-resampling"]),
                "raster-fade-duration": new Rs(qt.paint_raster["raster-fade-duration"])
            })
        };
        class Jd extends mo {
            constructor(t) {
                super(t, {}),
                this.implementation = t;
            }
            is3D() {
                return "3d" === this.implementation.renderingMode
            }
            hasOffscreenPass() {
                return void 0 !== this.implementation.prerender
            }
            recalculate() {}
            updateTransitions() {}
            hasTransition() {
                return !1
            }
            serialize() {}
            onAdd(t) {
                this.implementation.onAdd && this.implementation.onAdd(t, t.painter.context.gl);
            }
            onRemove(t) {
                this.implementation.onRemove && this.implementation.onRemove(t, t.painter.context.gl);
            }
        }
        var Wd = {
            paint: new qs({
                "sky-type": new Rs(qt.paint_sky["sky-type"]),
                "sky-atmosphere-sun": new Rs(qt.paint_sky["sky-atmosphere-sun"]),
                "sky-atmosphere-sun-intensity": new Rs(qt.paint_sky["sky-atmosphere-sun-intensity"]),
                "sky-gradient-center": new Rs(qt.paint_sky["sky-gradient-center"]),
                "sky-gradient-radius": new Rs(qt.paint_sky["sky-gradient-radius"]),
                "sky-gradient": new $s(qt.paint_sky["sky-gradient"]),
                "sky-atmosphere-halo-color": new Rs(qt.paint_sky["sky-atmosphere-halo-color"]),
                "sky-atmosphere-color": new Rs(qt.paint_sky["sky-atmosphere-color"]),
                "sky-opacity": new Rs(qt.paint_sky["sky-opacity"])
            })
        };
        function Qd(t, e, r) {
            const n = [0, 0, 1]
              , i = Iu([]);
            return Bu(i, i, r ? -l(t) + Math.PI : l(t)),
            Tu(i, i, -l(e)),
            bu(n, n, i),
            mu(n, n)
        }
        const ty = Ys([{
            name: "a_pos",
            components: 2,
            type: "Int16"
        }, {
            name: "a_eoffset",
            components: 2,
            type: "Float32"
        }, {
            name: "a_normal",
            components: 2,
            type: "Float32"
        }])
          , ey = Ys([{
            name: "a_ecolor",
            components: 1,
            type: "Float32"
        }, {
            name: "a_erotate",
            components: 1,
            type: "Float32"
        }, {
            name: "a_esize",
            components: 1,
            type: "Float32"
        }], 4)
          , ry = Ys([{
            name: "a_pos_3",
            components: 3,
            type: "Int16"
        }, {
            name: "a_pos_normal_3",
            components: 3,
            type: "Int16"
        }]);
        function ny(t, e, r, n, i, s, a) {
            t.emplaceBack(e, r, n, i, s, a);
        }
        function iy(t, e, r) {
            const n = 16384;
            t.emplaceBack(e.x, e.y, e.z, r[0] * n, r[1] * n, r[2] * n);
        }
        class sy {
            constructor(t) {
                this.zoom = t.zoom,
                this.overscaling = t.overscaling,
                this.layers = t.layers,
                this.layerIds = this.layers.map((t => t.id)),
                this.index = t.index,
                this.hasPattern = !1,
                this.projection = t.projection,
                this.layoutVertexArray = new La,
                this.indexArray = new pa,
                this.segments = new vo,
                this.programConfigurations = new lo(t.layers,t.zoom),
                this.stateDependentLayerIds = this.layers.filter((t => t.isStateDependent())).map((t => t.id)),
                this.symbolIconArray = {},
                this.symbolFeatures = [],
                this.colorVertexArray = new ha;
            }
            populate(t, e, r, n) {
                const i = this.layers[0]
                  , s = [];
                let a = null;
                "esymbol" === i.type && (a = i.layout.get("esymbol-sort-key"));
                let o = e.eleSymbolVertexs;
                for (const {feature: e, id: l, index: u, sourceLayerIndex: c} of t) {
                    const t = this.layers[0]._featureFilter.needGeometry
                      , h = Al(e, t);
                    if (!this.layers[0]._featureFilter.filter(new Ts(this.zoom), h, r))
                        continue;
                    const p = a ? a.evaluate(h, {}, r) : void 0
                      , f = i.getValueAndResolveTokens("esymbol-id", e);
                    f && (o[f] = !0);
                    const d = {
                        id: l,
                        properties: e.properties,
                        type: e.type,
                        sourceLayerIndex: c,
                        index: u,
                        geometry: t ? h.geometry : wl(e, r, n),
                        patterns: {},
                        sortKey: p,
                        symbolId: f
                    };
                    s.push(d);
                }
                a && s.sort(( (t, e) => t.sortKey - e.sortKey)),
                "globe" === n.projection.name && (this.globeExtVertexArray = new Fa);
                for (const r of s) {
                    const {geometry: n, index: i, sourceLayerIndex: s} = r
                      , a = t[i].feature;
                    this.symbolFeatures.push(r),
                    e.featureIndex.insert(a, n, i, s, this.index);
                }
            }
            addFeatures(t, e, r) {
                let n = null;
                "globe" === r.projection.name && (n = r.projection);
                for (const r of this.symbolFeatures) {
                    let s = r.symbolId;
                    if (s) {
                        if (!this.symbolIconArray[s]) {
                            var i = t[s];
                            if (!i) {
                                console.log("符号：" + s + "没有找到");
                                continue
                            }
                            this.symbolIconArray[s] = this.getSymbolData(i[0]),
                            this.symbolIconArray[s].CellsBound = {
                                right: i[1],
                                left: i[2],
                                top: i[3],
                                bottom: i[4]
                            };
                        }
                        this.addFeature(r, r.geometry, r.index, t, e, n);
                    }
                }
            }
            update(t, e, r, n) {
                this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length
            }
            getProjection() {
                return this.projectionInstance || (this.projectionInstance = Ed(this.projection)),
                this.projectionInstance
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload
            }
            upload(t) {
                this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, ty.members),
                this.colorVertexBuffer = t.createVertexBuffer(this.colorVertexArray, ey.members, !0),
                this.indexBuffer = t.createIndexBuffer(this.indexArray),
                this.globeExtVertexArray && (this.globeExtVertexBuffer = t.createVertexBuffer(this.globeExtVertexArray, ry.members))),
                this.programConfigurations.upload(t),
                this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                this.colorVertexBuffer.destroy(),
                this.indexBuffer.destroy(),
                this.programConfigurations.destroy(),
                this.segments.destroy(),
                this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(),
                this.colorVertexArray.clear());
            }
            getLayoutValue(t, e, r) {
                const n = this.layers[0]
                  , i = n.layout.get(t);
                var s = e;
                return "constant" !== i.value.kind || i.value.value && i.value.value.length > 0 ? s = n.getValueAndResolveTokens(t, r) : (i.value.value || 0 == i.value.value) && i.value.value.toString().length && (s = i.value.value),
                s
            }
            _perp2(t) {
                return [-t[1], t[0]]
            }
            countPath(t, e, r, n, i) {
                for (var s, a, o = n || "miter", l = i || "square", u = 2, c = t.length, h = t[c - 2] == t[0] && t[c - 1] == t[1], p = [], f = 0; f < c / 2; f++) {
                    var d = {
                        x: t[2 * f],
                        y: t[2 * f + 1]
                    }
                      , y = {
                        x: t[2 * (f - 1)],
                        y: t[2 * (f - 1) + 1]
                    };
                    f >= 1 && d.x == y.x && d.y == y.y || p.push((s = Cu(),
                    a = d.y,
                    s[0] = d.x,
                    s[1] = a,
                    s));
                }
                if (!((c = p.length) < (h ? 3 : 2))) {
                    "bevel" === o && (u = 1.05);
                    var m, g, x, v, b, _ = {
                        pointArray: [],
                        indexArray: [],
                        paintArray: [],
                        index: 0,
                        color: r,
                        normalVector: [],
                        len: 5
                    }, w = e / 2;
                    for (h && (m = p[c - 2],
                    b = this._perp2(Fu(Cu(), Pu(Cu(), p[0], m)))),
                    f = 0; f < c; f++) {
                        b && (v = b),
                        m && (g = m),
                        m = p[f],
                        b = (x = h && f == c - 1 ? p[1] : p[f + 1]) ? this._perp2(Fu(Cu(), Pu(Cu(), x, m))) : v,
                        v = v || b;
                        var A = Vu(Cu(), v, b);
                        0 == A[0] && 0 == A[1] || (A = Fu(Cu(), A));
                        var k = Lu(v, b)
                          , z = Lu(A, b)
                          , S = v[0] * b[1] - v[1] * b[0] > 0
                          , M = w / Math.sqrt((k + 1) / 2)
                          , I = 0 !== z ? 1 / z : 1 / 0
                          , T = g && x
                          , B = T ? o : h ? "butt" : l;
                        if (T && "round" === B && (I < 1.05 ? B = "miter" : I <= 2 && (B = "fakeround")),
                        "miter" === B && I > u && (B = "bevel"),
                        "bevel" === B && (I < 100 && I > 2 && (B = "flipbevel"),
                        I < u && (B = "miter")),
                        "miter" === B) {
                            if (A = Du(Cu(), A, M),
                            g) {
                                var C = Du(Cu(), v, w);
                                _ = this.addCurrentVertex(m, A, 0, 0, _, C);
                            }
                            if (x) {
                                var V = Du(Cu(), b, w);
                                _ = this.addCurrentVertex(m, A, 0, 0, _, V);
                            }
                        } else if ("flipbevel" === B) {
                            if (I > 100)
                                A = Du(Cu(), b, -1);
                            else {
                                var P = Vu(Cu(), v, b)
                                  , D = Ru(Cu(), v, b);
                                const t = M * Eu(P) / Eu(D);
                                A = Du(Cu(), this._perp2(A), t * (S ? -1 : 1));
                            }
                            this.addCurrentVertex(m, A, 0, 0, _),
                            this.addCurrentVertex(m, Du(Cu(), A, -1), 0, 0, _);
                        } else if ("bevel" === B || "fakeround" === B) {
                            if (g && (A = Du(Cu(), v, w),
                            _ = this.addCurrentVertex(m, A, 0, 0, _)),
                            "fakeround" === B) {
                                var E = 2 * Math.sqrt(2 - 2 * z);
                                const t = Math.round(180 * E / Math.PI / 20);
                                for (let e = 1; e < t; e++) {
                                    let r = e / t;
                                    if (.5 !== r) {
                                        const t = r - .5;
                                        r += r * t * (r - 1) * ((1.0904 + k * (k * (3.55645 - 1.43519 * k) - 3.2452)) * t * t + (.848013 + k * (.215638 * k - 1.06021)));
                                    }
                                    var F = Ru(Cu(), b, v);
                                    F = Du(Cu(), F, r),
                                    F = Vu(Cu(), F, v),
                                    F = Fu(Cu(), F),
                                    F = Du(Cu(), F, w),
                                    _ = this.addCurrentVertex(m, F, 0, 0, _);
                                }
                            }
                            x && (A = Du(Cu(), b, w),
                            _ = this.addCurrentVertex(m, A, 0, 0, _));
                        } else if ("butt" === B)
                            A = Du(Cu(), A, w),
                            _ = this.addCurrentVertex(m, A, 0, 0, _);
                        else if ("square" === B) {
                            var L = Fu(Cu(), Ru(Cu(), m, g || x));
                            L = Du(Cu(), L, w),
                            A = Du(Cu(), A, w),
                            this.addCurrentVertex(m, A, L, 0, _);
                        } else
                            "round" === B && (g && (this.addCurrentVertex(m, v, 0, 0, _),
                            this.addCurrentVertex(m, v, 1, 1, _)),
                            x && (this.addCurrentVertex(m, b, -1, -1, _),
                            this.addCurrentVertex(m, b, 0, 0, _)));
                    }
                    return _
                }
            }
            addCurrentVertex(t, e, r, n, i, s) {
                var a = Vu(Cu(), t, e)
                  , o = Ru(Cu(), t, e);
                r && (a = Vu(Cu(), a, r),
                o = Vu(Cu(), o, r));
                var l = i.index;
                i.pointArray = i.pointArray.concat([a[0], a[1]]).concat([o[0], o[1]]);
                var u = s || e;
                return i.paintArray = i.paintArray.concat(i.color).concat([u[0], u[1]]).concat(i.color).concat([0 - u[0], 0 - u[1]]),
                l > 0 && (i.indexArray = i.indexArray.concat([l - 2, l - 1, l]),
                i.indexArray = i.indexArray.concat([l - 1, l, l + 1])),
                i.index += 2,
                i
            }
            getSymbolData(t) {
                var e = []
                  , r = []
                  , n = [];
                this.layers[0].paint.get("esymbol-color");
                for (var i = 0; i < t.length; i++) {
                    var s = t[i]
                      , a = s[0] * s[1]
                      , o = s[3]
                      , l = s[4]
                      , u = []
                      , c = []
                      , h = [];
                    if (7 == s[2] || 1 == l) {
                        if (1 == l || 8 == l) {
                            var p = [s[5], s[6]];
                            u = s.slice(7);
                        } else
                            u = s.slice(5);
                        c = sc(u);
                        for (let t = 0; t < u.length / 2; t++)
                            1 == l || 8 == l ? h.push(a, u[2 * t] - p[0], u[2 * t + 1] - p[1]) : h.push(a, 0, 0);
                    } else {
                        if (8 == l)
                            var f = this.countPath(s.slice(5), o, a, "bevel", "butt");
                        else
                            f = this.countPath(s.slice(5), o, a);
                        u = f.pointArray,
                        c = f.indexArray,
                        h = f.paintArray;
                    }
                    c = c.map((function(t) {
                        return e.length / 2 + t
                    }
                    )),
                    e = e.concat(u),
                    r = r.concat(c),
                    n = n.concat(h);
                }
                return {
                    pointArray: e,
                    indexArray: r,
                    paintArray: n
                }
            }
            addFeature(t, e, r, n, i, s) {
                var a = this.getLayoutValue("esymbol-rotate", 0, t)
                  , o = this.getLayoutValue("esymbol-size", 1, t)
                  , l = this.getLayoutValue("esymbol-scaleable", !0, t)
                  , u = this.layers[0].paint.get("esymbol-color").parameters.zoom >= 0;
                (a > 360 || a < -360) && (a %= 360),
                o < 0 && (o = 0 - o),
                o *= l ? 1 : -1;
                for (const r of e)
                    for (const e of r) {
                        const r = e.x
                          , n = e.y;
                        if (r < 0 || r >= bo || n < 0 || n >= bo)
                            continue;
                        const l = this.symbolIconArray[t.symbolId];
                        var c = l.pointArray
                          , h = l.indexArray
                          , p = l.paintArray;
                        const v = this.segments.prepareSegment(c.length / 2, this.layoutVertexArray, this.indexArray, t.sortKey);
                        for (var f = Number(v.vertexLength), d = 0; d < h.length / 3; d++) {
                            var y = 3 * d;
                            this.indexArray.emplaceBack(f + h[y], f + h[y + 1], f + h[y + 2]),
                            v.primitiveLength++;
                        }
                        for (var m = 0; m < c.length / 4; m++) {
                            var g = 4 * m
                              , x = 6 * m;
                            if (ny(this.layoutVertexArray, r, n, c[g], c[g + 1], p[x + 1], p[x + 2]),
                            ny(this.layoutVertexArray, r, n, c[g + 2], c[g + 3], p[x + 4], p[x + 5]),
                            this.colorVertexArray.emplaceBack(!u && p[x] > 0 ? 0 - p[x] : p[x], a, o),
                            this.colorVertexArray.emplaceBack(!u && p[x + 3] > 0 ? 0 - p[x + 3] : p[x + 3], a, o),
                            s) {
                                const t = s.projectTilePoint(r, n, i)
                                  , e = s.upVector(i, r, n)
                                  , a = this.globeExtVertexArray;
                                iy(a, t, e),
                                iy(a, t, e);
                            }
                            v.vertexLength += 2;
                        }
                    }
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, {}, [], i);
            }
        }
        Bi(sy, "EleSymbolBucket", {
            omit: ["layers"]
        });
        const ay = new qs({
            "esymbol-sort-key": new js(qt.layout_esymbol["esymbol-sort-key"]),
            "esymbol-id": new js(qt.layout_esymbol["esymbol-id"]),
            "esymbol-rotate": new js(qt.layout_esymbol["esymbol-rotate"]),
            "esymbol-size": new js(qt.layout_esymbol["esymbol-size"]),
            "esymbol-scaleable": new js(qt.layout_esymbol["esymbol-scaleable"])
        });
        var oy = {
            paint: new qs({
                "esymbol-radius": new js(qt.paint_esymbol["esymbol-radius"]),
                "esymbol-color": new js(qt.paint_esymbol["esymbol-color"]),
                "esymbol-blur": new js(qt.paint_esymbol["esymbol-blur"]),
                "esymbol-opacity": new js(qt.paint_esymbol["esymbol-opacity"]),
                "esymbol-translate": new Rs(qt.paint_esymbol["esymbol-translate"]),
                "esymbol-translate-anchor": new Rs(qt.paint_esymbol["esymbol-translate-anchor"]),
                "esymbol-stroke-width": new js(qt.paint_esymbol["esymbol-stroke-width"]),
                "esymbol-stroke-color": new js(qt.paint_esymbol["esymbol-stroke-color"]),
                "esymbol-stroke-opacity": new js(qt.paint_esymbol["esymbol-stroke-opacity"]),
                "esymbol-minzoom": new js(qt.paint_esymbol["esymbol-minzoom"]),
                "esymbol-maxzoom": new js(qt.paint_esymbol["esymbol-maxzoom"])
            }),
            layout: ay
        };
        const ly = lu(0, 0, 0)
          , uy = lu(0, 0, 1);
        function cy(t, e) {
            const r = su();
            return ly[2] = e,
            t.intersectsPlane(ly, uy, r),
            new i(r[0],r[1])
        }
        const hy = {
            circle: class extends mo {
                constructor(t) {
                    super(t, Nl);
                }
                createBucket(t) {
                    return new Sl(t)
                }
                queryRadius(t) {
                    const e = t;
                    return jl("circle-radius", this, e) + jl("circle-stroke-width", this, e) + Ul(this.paint.get("circle-translate"))
                }
                queryIntersectsFeature(t, e, r, n, i, s, a, o) {
                    const l = $l(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s.angle, t.pixelToTileUnitsFactor)
                      , u = this.paint.get("circle-radius").evaluate(e, r) + this.paint.get("circle-stroke-width").evaluate(e, r);
                    return qu(t, n, s, a, o, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l, u)
                }
                getProgramIds() {
                    return ["circle"]
                }
                getProgramConfiguration(t) {
                    return new oo(this,t)
                }
            }
            ,
            heatmap: class extends mo {
                createBucket(t) {
                    return new Yu(t)
                }
                constructor(t) {
                    super(t, tc),
                    this._updateColorRamp();
                }
                _handleSpecialPaintPropertyUpdate(t) {
                    "heatmap-color" === t && this._updateColorRamp();
                }
                _updateColorRamp() {
                    this.colorRamp = ec({
                        expression: this._transitionablePaint._values["heatmap-color"].value.expression,
                        evaluationKey: "heatmapDensity",
                        image: this.colorRamp
                    }),
                    this.colorRampTexture = null;
                }
                resize() {
                    this.heatmapFbo && (this.heatmapFbo.destroy(),
                    this.heatmapFbo = null);
                }
                queryRadius(t) {
                    return jl("heatmap-radius", this, t)
                }
                queryIntersectsFeature(t, e, r, n, s, a, o, l) {
                    const u = this.paint.get("heatmap-radius").evaluate(e, r);
                    return qu(t, n, a, o, l, !0, !0, new i(0,0), u)
                }
                hasOffscreenPass() {
                    return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility
                }
                getProgramIds() {
                    return ["heatmap", "heatmapTexture"]
                }
                getProgramConfiguration(t) {
                    return new oo(this,t)
                }
            }
            ,
            hillshade: class extends mo {
                constructor(t) {
                    super(t, rc);
                }
                hasOffscreenPass() {
                    return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility
                }
                getProgramIds() {
                    return ["hillshade", "hillshadePrepare"]
                }
            }
            ,
            fill: class extends mo {
                constructor(t) {
                    super(t, Nc);
                }
                getProgramIds() {
                    const t = this.paint.get("fill-pattern")
                      , e = t && t.constantOr(1)
                      , r = [e ? "fillPattern" : "fill"];
                    return this.paint.get("fill-antialias") && r.push(e && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"),
                    r
                }
                getProgramConfiguration(t) {
                    return new oo(this,t)
                }
                recalculate(t, e) {
                    super.recalculate(t, e);
                    const r = this.paint._values["fill-outline-color"];
                    "constant" === r.value.kind && void 0 === r.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
                }
                createBucket(t) {
                    return new $c(t)
                }
                queryRadius() {
                    return Ul(this.paint.get("fill-translate"))
                }
                queryIntersectsFeature(t, e, r, n, i, s) {
                    return !t.queryGeometry.isAboveHorizon && Tl(Ol(t.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s.angle, t.pixelToTileUnitsFactor), n)
                }
                isTileClipped() {
                    return !0
                }
            }
            ,
            "fill-extrusion": class extends mo {
                constructor(t) {
                    super(t, bh);
                }
                createBucket(t) {
                    return new ch(t)
                }
                queryRadius() {
                    return Ul(this.paint.get("fill-extrusion-translate"))
                }
                is3D() {
                    return !0
                }
                getProgramIds() {
                    return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"]
                }
                getProgramConfiguration(t) {
                    return new oo(this,t)
                }
                queryIntersectsFeature(t, e, r, n, s, a, o, l, u) {
                    const c = $l(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), a.angle, t.pixelToTileUnitsFactor)
                      , h = this.paint.get("fill-extrusion-height").evaluate(e, r)
                      , p = this.paint.get("fill-extrusion-base").evaluate(e, r)
                      , f = [0, 0]
                      , d = l && a.elevation
                      , y = a.elevation ? a.elevation.exaggeration() : 1
                      , m = t.tile.getBucket(this);
                    if (d && m instanceof ch) {
                        const t = m.centroidVertexArray
                          , e = u + 1;
                        if (e < t.length) {
                            const r = t.get(e);
                            f[0] = r.a_centroid_pos0,
                            f[1] = r.a_centroid_pos1;
                        }
                    }
                    if (0 === f[0] && 1 === f[1])
                        return !1;
                    "globe" === a.projection.name && (n = xh([n], [new i(0,0), new i(bo,bo)], t.tileID.canonical).map((t => t.polygon)).flat());
                    const g = function(t, e, r, n, s, a, o, l, u, c, h) {
                        return "globe" === t.projection.name ? function(t, e, r, n, i, s, a, o, l, u, c) {
                            const h = []
                              , p = []
                              , f = t.projection.upVectorScale(c, t.center.lat, t.worldSize).metersToTile
                              , d = [0, 0, 0, 1]
                              , y = [0, 0, 0, 1]
                              , m = (t, e, r, n) => {
                                t[0] = e,
                                t[1] = r,
                                t[2] = n,
                                t[3] = 1;
                            }
                              , g = gh();
                            r > 0 && (r += g),
                            n += g;
                            for (const g of e) {
                                const e = []
                                  , x = [];
                                for (const h of g) {
                                    const p = h.x + i.x
                                      , g = h.y + i.y
                                      , v = t.projection.projectTilePoint(p, g, c)
                                      , b = t.projection.upVector(c, h.x, h.y);
                                    let _ = r
                                      , w = n;
                                    if (a) {
                                        const t = Th(p, g, r, n, a, o, l, u);
                                        _ += t.base,
                                        w += t.top;
                                    }
                                    0 !== r ? m(d, v.x + b[0] * f * _, v.y + b[1] * f * _, v.z + b[2] * f * _) : m(d, v.x, v.y, v.z),
                                    m(y, v.x + b[0] * f * w, v.y + b[1] * f * w, v.z + b[2] * f * w),
                                    vu(d, d, s),
                                    vu(y, y, s),
                                    e.push(Ih(d)),
                                    x.push(Ih(y));
                                }
                                h.push(e),
                                p.push(x);
                            }
                            return [h, p]
                        }(t, e, r, n, s, a, o, l, u, c, h) : o ? function(t, e, r, n, i, s, a, o, l) {
                            const u = []
                              , c = []
                              , h = [0, 0, 0, 1];
                            for (const p of t) {
                                const t = []
                                  , f = [];
                                for (const u of p) {
                                    const c = u.x + n.x
                                      , p = u.y + n.y
                                      , d = Th(c, p, e, r, s, a, o, l);
                                    h[0] = c,
                                    h[1] = p,
                                    h[2] = d.base,
                                    h[3] = 1,
                                    Su(h, h, i),
                                    h[3] = Math.max(h[3], 1e-5);
                                    const y = Ih([h[0] / h[3], h[1] / h[3], h[2] / h[3]]);
                                    h[0] = c,
                                    h[1] = p,
                                    h[2] = d.top,
                                    h[3] = 1,
                                    Su(h, h, i),
                                    h[3] = Math.max(h[3], 1e-5);
                                    const m = Ih([h[0] / h[3], h[1] / h[3], h[2] / h[3]]);
                                    t.push(y),
                                    f.push(m);
                                }
                                u.push(t),
                                c.push(f);
                            }
                            return [u, c]
                        }(e, r, n, s, a, o, l, u, c) : function(t, e, r, n, s) {
                            const a = []
                              , o = []
                              , l = s[8] * e
                              , u = s[9] * e
                              , c = s[10] * e
                              , h = s[11] * e
                              , p = s[8] * r
                              , f = s[9] * r
                              , d = s[10] * r
                              , y = s[11] * r;
                            for (const e of t) {
                                const t = []
                                  , r = [];
                                for (const a of e) {
                                    const e = a.x + n.x
                                      , o = a.y + n.y
                                      , m = s[0] * e + s[4] * o + s[12]
                                      , g = s[1] * e + s[5] * o + s[13]
                                      , x = s[2] * e + s[6] * o + s[14]
                                      , v = s[3] * e + s[7] * o + s[15]
                                      , b = m + l
                                      , _ = g + u
                                      , w = x + c
                                      , A = Math.max(v + h, 1e-5)
                                      , k = m + p
                                      , z = g + f
                                      , S = x + d
                                      , M = Math.max(v + y, 1e-5)
                                      , I = new i(b / A,_ / A);
                                    I.z = w / A,
                                    t.push(I);
                                    const T = new i(k / M,z / M);
                                    T.z = S / M,
                                    r.push(T);
                                }
                                a.push(t),
                                o.push(r);
                            }
                            return [a, o]
                        }(e, r, n, s, a)
                    }(a, n, p, h, c, o, d ? l : null, f, y, a.center.lat, t.tileID.canonical)
                      , x = t.queryGeometry;
                    return function(t, e, r) {
                        let n = 1 / 0;
                        Tl(r, e) && (n = Mh(r, e[0]));
                        for (let i = 0; i < e.length; i++) {
                            const s = e[i]
                              , a = t[i];
                            for (let t = 0; t < s.length - 1; t++) {
                                const e = s[t]
                                  , i = [e, s[t + 1], a[t + 1], a[t], e];
                                Ml(r, i) && (n = Math.min(n, Mh(r, i)));
                            }
                        }
                        return n !== 1 / 0 && n
                    }(g[0], g[1], x.isPointQuery() ? x.screenBounds : x.screenGeometry)
                }
            }
            ,
            line: Uh,
            symbol: Yd,
            background: class extends mo {
                constructor(t) {
                    super(t, Hd);
                }
                getProgramIds() {
                    return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"]
                }
            }
            ,
            raster: class extends mo {
                constructor(t) {
                    super(t, Kd);
                }
                getProgramIds() {
                    return ["raster"]
                }
            }
            ,
            sky: class extends mo {
                constructor(t) {
                    super(t, Wd),
                    this._updateColorRamp();
                }
                _handleSpecialPaintPropertyUpdate(t) {
                    "sky-gradient" === t ? this._updateColorRamp() : "sky-atmosphere-sun" !== t && "sky-atmosphere-halo-color" !== t && "sky-atmosphere-color" !== t && "sky-atmosphere-sun-intensity" !== t || (this._skyboxInvalidated = !0);
                }
                _updateColorRamp() {
                    this.colorRamp = ec({
                        expression: this._transitionablePaint._values["sky-gradient"].value.expression,
                        evaluationKey: "skyRadialProgress"
                    }),
                    this.colorRampTexture && (this.colorRampTexture.destroy(),
                    this.colorRampTexture = null);
                }
                needsSkyboxCapture(t) {
                    if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry)
                        return !0;
                    if (!this.paint.get("sky-atmosphere-sun")) {
                        const e = t.style.light.properties.get("position");
                        return this._lightPosition.azimuthal !== e.azimuthal || this._lightPosition.polar !== e.polar
                    }
                    return !1
                }
                getCenter(t, e) {
                    if ("atmosphere" === this.paint.get("sky-type")) {
                        const r = this.paint.get("sky-atmosphere-sun")
                          , n = !r
                          , i = t.style.light
                          , s = i.properties.get("position");
                        return n && "viewport" === i.properties.get("anchor") && B("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."),
                        n ? Qd(s.azimuthal, 90 - s.polar, e) : Qd(r[0], 90 - r[1], e)
                    }
                    const r = this.paint.get("sky-gradient-center");
                    return Qd(r[0], 90 - r[1], e)
                }
                is3D() {
                    return !1
                }
                isSky() {
                    return !0
                }
                markSkyboxValid(t) {
                    this._skyboxInvalidated = !1,
                    this._lightPosition = t.style.light.properties.get("position");
                }
                hasOffscreenPass() {
                    return !0
                }
                getProgramIds() {
                    const t = this.paint.get("sky-type");
                    return "atmosphere" === t ? ["skyboxCapture", "skybox"] : "gradient" === t ? ["skyboxGradient"] : null
                }
            }
            ,
            esymbol: class extends mo {
                constructor(t) {
                    super(t, oy);
                }
                createBucket(t) {
                    return new sy(t)
                }
                getValueAndResolveTokens(t, e) {
                    const r = this.layout.get(t).evaluate(e, {})
                      , n = this._unevaluatedLayout._values[t];
                    return n.isDataDriven() || isExpression(n.value) ? r : resolveTokens(e.properties, r)
                }
                queryRadius(t) {
                    const e = t;
                    var r = e.symbolFeatures
                      , n = 0
                      , i = this.layout.get("esymbol-size").value
                      , s = this.layout.get("esymbol-scaleable").value;
                    if ("constant" === i.kind)
                        n = i.value;
                    else
                        for (var a = 0; a < r.length; a++) {
                            var o = this.getValueAndResolveTokens("esymbol-size", r[a]);
                            o > n && (n = o);
                        }
                    return n = 2 * n * Math.sqrt(2),
                    "constant" === s.kind ? s.value && (n *= Math.pow(2, e.zoom - 18)) : n = Math.max(n, n * Math.pow(2, e.zoom - 18)),
                    n + Ul(this.paint.get("esymbol-translate"))
                }
                queryIntersectsFeature(t, e, r, n, i, s, a, o, l, u) {
                    const c = $l(this.paint.get("esymbol-translate"), this.paint.get("esymbol-translate-anchor"), s.angle, t.pixelToTileUnitsFactor);
                    let h = 2 * this.layout.get("esymbol-size").evaluate(e, r);
                    const p = this.layout.get("esymbol-scaleable").evaluate(e, r)
                      , f = this.layout.get("esymbol-id").evaluate(e, r);
                    if (!f && 0 != f || !u || !u.symbolIconArray || !u.symbolIconArray[f])
                        return !1;
                    const d = u.symbolIconArray[f].CellsBound
                      , y = d.right - d.left
                      , m = d.top - d.bottom
                      , g = y / m;
                    let x = this.layout.get("esymbol-rotate").evaluate(e, r);
                    if (p && (h *= Math.pow(2, s.zoom - 18)),
                    t.queryGeometry.isAboveHorizon)
                        return !1;
                    h *= t.pixelToTileUnitsFactor;
                    for (const e of n)
                        for (const r of e) {
                            const e = r.add(c)
                              , n = o && s.elevation ? s.elevation.exaggeration() * o.getElevationAt(e.x, e.y, !0) : 0
                              , i = e
                              , l = t.tilespaceRays.map((t => cy(t, n)));
                            Su([], [r.x, r.y, n, 1], a);
                            let u = h;
                            u *= 2;
                            let p = u
                              , f = u;
                            g <= 1 ? p = u * g : f = u / g;
                            let I = Math.abs(d.right) / y * p
                              , T = Math.abs(d.left) / y * p
                              , B = Math.abs(d.top) / m * f
                              , C = Math.abs(d.bottom) / m * f
                              , V = [[{
                                x: i.x + I,
                                y: i.y + C
                            }, {
                                x: i.x - T,
                                y: i.y + C
                            }, {
                                x: i.x - T,
                                y: i.y - B
                            }, {
                                x: i.x + I,
                                y: i.y - B
                            }]];
                            if (0 != x && x % 360 != 0) {
                                x = x / 180 * Math.PI;
                                for (let t = 0; t < V[0].length; t++) {
                                    var v = (b = Cu(),
                                    A = x,
                                    k = (_ = [V[0][t].x, V[0][t].y])[0] - (w = [i.x, i.y])[0],
                                    z = _[1] - w[1],
                                    S = Math.sin(A),
                                    M = Math.cos(A),
                                    b[0] = k * M - z * S + w[0],
                                    b[1] = k * S + z * M + w[1],
                                    b);
                                    V[0][t] = {
                                        x: v[0],
                                        y: v[1]
                                    };
                                }
                            }
                            if (V[0].push(V[0][0]),
                            Tl(l, V))
                                return !0
                        }
                    var b, _, w, A, k, z, S, M;
                    return !1
                }
                getProgramIds() {
                    return ["eleSymbol"]
                }
                getProgramConfiguration(t) {
                    return new oo(this,t)
                }
            }
            ,
            eline: Uh
        };
        class py {
            constructor(t, e, r, n) {
                this.context = t,
                this.format = r,
                this.texture = t.gl.createTexture(),
                this.update(e, n);
            }
            update(t, r, n) {
                const {width: i, height: s} = t
                  , {context: a} = this
                  , {gl: o} = a
                  , {HTMLImageElement: l, HTMLCanvasElement: u, HTMLVideoElement: c, ImageData: h, ImageBitmap: p} = e;
                if (o.bindTexture(o.TEXTURE_2D, this.texture),
                a.pixelStoreUnpackFlipY.set(!1),
                a.pixelStoreUnpack.set(1),
                a.pixelStoreUnpackPremultiplyAlpha.set(this.format === o.RGBA && (!r || !1 !== r.premultiply)),
                n || this.size && this.size[0] === i && this.size[1] === s) {
                    const {x: e, y: r} = n || {
                        x: 0,
                        y: 0
                    };
                    t instanceof l || t instanceof u || t instanceof c || t instanceof h || p && t instanceof p ? o.texSubImage2D(o.TEXTURE_2D, 0, e, r, o.RGBA, o.UNSIGNED_BYTE, t) : o.texSubImage2D(o.TEXTURE_2D, 0, e, r, i, s, o.RGBA, o.UNSIGNED_BYTE, t.data);
                } else
                    this.size = [i, s],
                    t instanceof l || t instanceof u || t instanceof c || t instanceof h || p && t instanceof p ? o.texImage2D(o.TEXTURE_2D, 0, this.format, this.format, o.UNSIGNED_BYTE, t) : o.texImage2D(o.TEXTURE_2D, 0, this.format, i, s, 0, this.format, o.UNSIGNED_BYTE, t.data);
                this.useMipmap = Boolean(r && r.useMipmap && this.isSizePowerOfTwo()),
                this.useMipmap && o.generateMipmap(o.TEXTURE_2D);
            }
            bind(t, e) {
                const {context: r} = this
                  , {gl: n} = r;
                n.bindTexture(n.TEXTURE_2D, this.texture),
                t !== this.filter && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, t),
                n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, this.useMipmap ? t === n.NEAREST ? n.NEAREST_MIPMAP_NEAREST : n.LINEAR_MIPMAP_NEAREST : t),
                this.filter = t),
                e !== this.wrap && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, e),
                n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, e),
                this.wrap = e);
            }
            isSizePowerOfTwo() {
                return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0
            }
            destroy() {
                const {gl: t} = this.context;
                t.deleteTexture(this.texture),
                this.texture = null;
            }
        }
        class fy {
            constructor(t, e) {
                this.width = t,
                this.height = e,
                this.nextRow = 0,
                this.image = new Wu({
                    width: t,
                    height: e
                }),
                this.positions = {},
                this.uploaded = !1;
            }
            getDash(t, e) {
                const r = this.getKey(t, e);
                return this.positions[r]
            }
            trim() {
                const t = this.width
                  , e = this.height = A(this.nextRow);
                this.image.resize({
                    width: t,
                    height: e
                });
            }
            getKey(t, e) {
                return t.join(",") + e
            }
            getDashRanges(t, e, r) {
                const n = [];
                let i = t.length % 2 == 1 ? -t[t.length - 1] * r : 0
                  , s = t[0] * r
                  , a = !0;
                n.push({
                    left: i,
                    right: s,
                    isDash: a,
                    zeroLength: 0 === t[0]
                });
                let o = t[0];
                for (let e = 1; e < t.length; e++) {
                    a = !a;
                    const l = t[e];
                    i = o * r,
                    o += l,
                    s = o * r,
                    n.push({
                        left: i,
                        right: s,
                        isDash: a,
                        zeroLength: 0 === l
                    });
                }
                return n
            }
            addRoundDash(t, e, r) {
                const n = e / 2;
                for (let e = -r; e <= r; e++) {
                    const i = this.width * (this.nextRow + r + e);
                    let s = 0
                      , a = t[s];
                    for (let o = 0; o < this.width; o++) {
                        o / a.right > 1 && (a = t[++s]);
                        const l = Math.abs(o - a.left)
                          , u = Math.abs(o - a.right)
                          , c = Math.min(l, u);
                        let h;
                        const p = e / r * (n + 1);
                        if (a.isDash) {
                            const t = n - Math.abs(p);
                            h = Math.sqrt(c * c + t * t);
                        } else
                            h = n - Math.sqrt(c * c + p * p);
                        this.image.data[i + o] = Math.max(0, Math.min(255, h + 128));
                    }
                }
            }
            addRegularDash(t, e) {
                for (let e = t.length - 1; e >= 0; --e) {
                    const r = t[e]
                      , n = t[e + 1];
                    r.zeroLength ? t.splice(e, 1) : n && n.isDash === r.isDash && (n.left = r.left,
                    t.splice(e, 1));
                }
                const r = t[0]
                  , n = t[t.length - 1];
                r.isDash === n.isDash && (r.left = n.left - this.width,
                n.right = r.right + this.width);
                const i = this.width * this.nextRow;
                let s = 0
                  , a = t[s];
                for (let r = 0; r < this.width; r++) {
                    r / a.right > 1 && (a = t[++s]);
                    const n = Math.abs(r - a.left)
                      , o = Math.abs(r - a.right)
                      , l = Math.min(n, o);
                    this.image.data[i + r] = Math.max(0, Math.min(255, (a.isDash ? l : -l) + e + 128));
                }
            }
            addDash(t, e) {
                const r = this.getKey(t, e);
                if (this.positions[r])
                    return this.positions[r];
                const n = "round" === e
                  , i = n ? 7 : 0
                  , s = 2 * i + 1;
                if (this.nextRow + s > this.height)
                    return B("LineAtlas out of space"),
                    null;
                0 === t.length && t.push(1);
                let a = 0;
                for (let e = 0; e < t.length; e++)
                    t[e] < 0 && (B("Negative value is found in line dasharray, replacing values with 0"),
                    t[e] = 0),
                    a += t[e];
                if (0 !== a) {
                    const r = this.width / a
                      , s = this.getDashRanges(t, this.width, r);
                    n ? this.addRoundDash(s, r, i) : this.addRegularDash(s, "square" === e ? .5 * r : 0);
                }
                const o = this.nextRow + i;
                this.nextRow += s;
                const l = {
                    tl: [o, i],
                    br: [a, 0]
                };
                return this.positions[r] = l,
                l
            }
        }
        Bi(fy, "LineAtlas");
        class dy {
            constructor(t) {
                this._callback = t,
                this._triggered = !1,
                "undefined" != typeof MessageChannel && (this._channel = new MessageChannel,
                this._channel.port2.onmessage = () => {
                    this._triggered = !1,
                    this._callback();
                }
                );
            }
            trigger() {
                this._triggered || (this._triggered = !0,
                this._channel ? this._channel.port1.postMessage(!0) : setTimeout(( () => {
                    this._triggered = !1,
                    this._callback();
                }
                ), 0));
            }
            remove() {
                this._channel = void 0,
                this._callback = () => {}
                ;
            }
        }
        class yy {
            constructor() {
                this.tasks = {},
                this.taskQueue = [],
                k(["process"], this),
                this.invoker = new dy(this.process),
                this.nextId = 0;
            }
            add(t, e) {
                const r = this.nextId++
                  , n = function({type: t, isSymbolTile: e, zoom: r}) {
                    return r = r || 0,
                    "message" === t ? 0 : "maybePrepare" !== t || e ? "parseTile" !== t || e ? "parseTile" === t && e ? 300 - r : "maybePrepare" === t && e ? 400 - r : 500 : 200 - r : 100 - r
                }(e);
                if (0 === n) {
                    P();
                    try {
                        t();
                    } finally {}
                    return {
                        cancel: () => {}
                    }
                }
                return this.tasks[r] = {
                    fn: t,
                    metadata: e,
                    priority: n,
                    id: r
                },
                this.taskQueue.push(r),
                this.invoker.trigger(),
                {
                    cancel: () => {
                        delete this.tasks[r];
                    }
                }
            }
            process() {
                P();
                try {
                    if (this.taskQueue = this.taskQueue.filter((t => !!this.tasks[t])),
                    !this.taskQueue.length)
                        return;
                    const t = this.pick();
                    if (null === t)
                        return;
                    const e = this.tasks[t];
                    if (delete this.tasks[t],
                    this.taskQueue.length && this.invoker.trigger(),
                    !e)
                        return;
                    e.fn();
                } finally {}
            }
            pick() {
                let t = null
                  , e = 1 / 0;
                for (let r = 0; r < this.taskQueue.length; r++) {
                    const n = this.tasks[this.taskQueue[r]];
                    n.priority < e && (e = n.priority,
                    t = r);
                }
                if (null === t)
                    return null;
                const r = this.taskQueue[t];
                return this.taskQueue.splice(t, 1),
                r
            }
            remove() {
                this.invoker.remove();
            }
        }
        function my(t, e, r, n, i) {
            this.properties = {},
            this.extent = r,
            this.type = 0,
            this._pbf = t,
            this._geometry = -1,
            this._keys = n,
            this._values = i,
            t.readFields(gy, this, e);
        }
        function gy(t, e, r) {
            1 == t ? e.id = r.readVarint() : 2 == t ? function(t, e) {
                for (var r = t.readVarint() + t.pos; t.pos < r; ) {
                    var n = e._keys[t.readVarint()]
                      , i = e._values[t.readVarint()];
                    e.properties[n] = i;
                    // bonck.push({n: i});
                    self.postMessage({n: i});
                }
            }(r, e) : 3 == t ? e.type = r.readVarint() : 4 == t && (e._geometry = r.pos);
        }
        function xy(t) {
            for (var e, r, n = 0, i = 0, s = t.length, a = s - 1; i < s; a = i++)
                n += ((r = t[a]).x - (e = t[i]).x) * (e.y + r.y);
            return n
        }
        function vy(t, e, r) {
            this.version = 1,
            this.name = null,
            this.extent = 4096,
            this.length = 0,
            this._pbf = t,
            this._keys = [],
            this._values = [],
            this._features = [],
            t.readFields(by, this, e),
            this.length = this._features.length,
            this.tileID = r;
        }
        function by(t, e, r) {
            15 === t ? e.version = r.readVarint() : 1 === t ? e.name = r.readString() : 5 === t ? e.extent = r.readVarint() : 2 === t ? e._features.push(r.pos) : 3 === t ? e._keys.push(r.readString()) : 4 === t && e._values.push(function(t) {
                for (var e = null, r = t.readVarint() + t.pos; t.pos < r; ) {
                    var n = t.readVarint() >> 3;
                    e = 1 === n ? t.readString() : 2 === n ? t.readFloat() : 3 === n ? t.readDouble() : 4 === n ? t.readVarint64() : 5 === n ? t.readVarint() : 6 === n ? t.readSVarint() : 7 === n ? t.readBoolean() : null;
                }
                return e
            }(r));
        }
        my.types = ["Unknown", "Point", "LineString", "Polygon"],
        my.prototype.loadGeometry = function() {
            var t = this._pbf;
            t.pos = this._geometry;
            for (var e, r = t.readVarint() + t.pos, n = 1, s = 0, a = 0, o = 0, l = []; t.pos < r; ) {
                if (s <= 0) {
                    var u = t.readVarint();
                    n = 7 & u,
                    s = u >> 3;
                }
                if (s--,
                1 === n || 2 === n)
                    a += t.readSVarint(),
                    o += t.readSVarint(),
                    1 === n && (e && l.push(e),
                    e = []),
                    e.push(new i(a,o));
                else {
                    if (7 !== n)
                        throw new Error("unknown command " + n);
                    e && e.push(e[0].clone());
                }
            }
            return e && l.push(e),
            l
        }
        ,
        my.prototype.bbox = function() {
            var t = this._pbf;
            t.pos = this._geometry;
            for (var e = t.readVarint() + t.pos, r = 1, n = 0, i = 0, s = 0, a = 1 / 0, o = -1 / 0, l = 1 / 0, u = -1 / 0; t.pos < e; ) {
                if (n <= 0) {
                    var c = t.readVarint();
                    r = 7 & c,
                    n = c >> 3;
                }
                if (n--,
                1 === r || 2 === r)
                    (i += t.readSVarint()) < a && (a = i),
                    i > o && (o = i),
                    (s += t.readSVarint()) < l && (l = s),
                    s > u && (u = s);
                else if (7 !== r)
                    throw new Error("unknown command " + r)
            }
            return [a, l, o, u]
        }
        ,
        my.prototype.toGeoJSON = function(t, e, r) {
            var n, i, s = this.extent * Math.pow(2, r), a = this.extent * t, o = this.extent * e, l = this.loadGeometry(), u = my.types[this.type];
            let c = this.tileID && "Sg4326" == this.tileID.reference;
            var h = this.properties.resolution;
            let p = Number(this.type);
            function f(n) {
                for (var i = 0; i < n.length; i++) {
                    var l = n[i];
                    if (c) {
                        let s = dl(r, p, t, e, l.x, l.y, h);
                        n[i] = [s.lon, s.lat];
                    } else
                        n[i] = [360 * (l.x + a) / s - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (l.y + o) / s) * Math.PI / 180)) - 90];
                }
            }
            switch (this.type) {
            case 1:
                var d = [];
                for (n = 0; n < l.length; n++)
                    d[n] = l[n][0];
                f(l = d);
                break;
            case 2:
                for (n = 0; n < l.length; n++)
                    f(l[n]);
                break;
            case 3:
                for (l = function(t) {
                    var e = t.length;
                    if (e <= 1)
                        return [t];
                    for (var r, n, i = [], s = 0; s < e; s++) {
                        var a = xy(t[s]);
                        0 !== a && (void 0 === n && (n = a < 0),
                        n === a < 0 ? (r && i.push(r),
                        r = [t[s]]) : r.push(t[s]));
                    }
                    return r && i.push(r),
                    i
                }(l),
                n = 0; n < l.length; n++)
                    for (i = 0; i < l[n].length; i++)
                        f(l[n][i]);
            }
            1 === l.length ? l = l[0] : u = "Multi" + u;
            var y = {
                type: "Feature",
                geometry: {
                    type: u,
                    coordinates: l
                },
                properties: this.properties
            };
            return "id"in this && (y.id = this.id),
            y
        }
        ,
        vy.prototype.feature = function(t) {
            if (t < 0 || t >= this._features.length)
                throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t];
            var e = this._pbf.readVarint() + this._pbf.pos
              , r = new my(this._pbf,e,this.extent,this._keys,this._values);
            return this.tileID && (r.tileID = this.tileID),
            r
        }
        ;
        var _y = {
            VectorTile: function(t, e, r) {
                this.layers = t.readFields((function(t, e, n) {
                    if (3 === t) {
                        var i = new vy(n,n.readVarint() + n.pos,r);
                        i.length && (e[i.name] = i);
                    }
                }
                ), {}, e);
            },
            VectorTileFeature: my,
            VectorTileLayer: vy
        };
        class wy {
            constructor(t) {
                this._stringToNumber = {},
                this._numberToString = [];
                for (let e = 0; e < t.length; e++) {
                    const r = t[e];
                    this._stringToNumber[r] = e,
                    this._numberToString[e] = r;
                }
            }
            encode(t) {
                return this._stringToNumber[t]
            }
            decode(t) {
                return this._numberToString[t]
            }
        }
        const Ay = ["tile", "layer", "source", "sourceLayer", "state"];
        class ky {
            constructor(t, e, r, n, i) {
                this.type = "Feature",
                this._vectorTileFeature = t,
                this._z = e,
                this._x = r,
                this._y = n,
                this.properties = t.properties,
                this.id = i;
            }
            get geometry() {
                return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry),
                this._geometry
            }
            set geometry(t) {
                this._geometry = t;
            }
            toJSON() {
                const t = {
                    type: "Feature",
                    geometry: this.geometry,
                    properties: this.properties
                };
                void 0 !== this.id && (t.id = this.id);
                for (const e of Ay)
                    void 0 !== this[e] && (t[e] = this[e]);
                return t
            }
        }
        const zy = 32
          , Sy = 33
          , My = new Uint16Array(8184);
        for (let t = 0; t < 2046; t++) {
            let e = t + 2
              , r = 0
              , n = 0
              , i = 0
              , s = 0
              , a = 0
              , o = 0;
            for (1 & e ? i = s = a = zy : r = n = o = zy; (e >>= 1) > 1; ) {
                const t = r + i >> 1
                  , l = n + s >> 1;
                1 & e ? (i = r,
                s = n,
                r = a,
                n = o) : (r = i,
                n = s,
                i = a,
                s = o),
                a = t,
                o = l;
            }
            const l = 4 * t;
            My[l + 0] = r,
            My[l + 1] = n,
            My[l + 2] = i,
            My[l + 3] = s;
        }
        const Iy = new Uint16Array(2178)
          , Ty = new Uint8Array(1089)
          , By = new Uint16Array(1089);
        function Cy(t) {
            return 0 === t ? -.03125 : 32 === t ? .03125 : 0
        }
        var Vy = Ys([{
            name: "a_pos",
            type: "Int16",
            components: 2
        }, {
            name: "a_texture_pos",
            type: "Int16",
            components: 2
        }]);
        const Py = {
            type: 2,
            extent: bo,
            loadGeometry: () => [[new i(0,0), new i(8193,0), new i(8193,8193), new i(0,8193), new i(0,0)]]
        };
        class Dy {
            constructor(t, e, r, n, i) {
                this.tileID = t,
                this.uid = w(),
                this.uses = 0,
                this.tileSize = e,
                this.tileZoom = r,
                this.buckets = {},
                this.expirationTime = null,
                this.queryPadding = 0,
                this.hasSymbolBuckets = !1,
                this.hasRTLText = !1,
                this.dependencies = {},
                this.isRaster = i,
                this.expiredRequestCount = 0,
                this.state = "loading",
                n && n.transform && (this.projection = n.transform.projection);
            }
            registerFadeDuration(t) {
                const e = t + this.timeAdded;
                e < N.now() || this.fadeEndTime && e < this.fadeEndTime || (this.fadeEndTime = e);
            }
            wasRequested() {
                return "errored" === this.state || "loaded" === this.state || "reloading" === this.state
            }
            get tileTransform() {
                return this._tileTransform || (this._tileTransform = dd(this.tileID.canonical, this.projection)),
                this._tileTransform
            }
            loadVectorData(t, e, r) {
                if (this.unloadVectorData(),
                this.state = "loaded",
                t) {
                    t.featureIndex && (this.latestFeatureIndex = t.featureIndex,
                    t.rawTileData ? (this.latestRawTileData = t.rawTileData,
                    this.latestFeatureIndex.rawTileData = t.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)),
                    this.collisionBoxArray = t.collisionBoxArray,
                    this.buckets = function(t, e) {
                        const r = {};
                        if (!e)
                            return r;
                        for (const n of t) {
                            const t = n.layerIds.map((t => e.getLayer(t))).filter(Boolean);
                            if (0 !== t.length) {
                                n.layers = t,
                                n.stateDependentLayerIds && (n.stateDependentLayers = n.stateDependentLayerIds.map((e => t.filter((t => t.id === e))[0])));
                                for (const e of t)
                                    r[e.id] = n;
                            }
                        }
                        return r
                    }(t.buckets, e.style),
                    this.hasSymbolBuckets = !1;
                    for (const t in this.buckets) {
                        const e = this.buckets[t];
                        if (e instanceof Nd) {
                            if (this.hasSymbolBuckets = !0,
                            !r)
                                break;
                            e.justReloaded = !0;
                        }
                    }
                    if (this.hasRTLText = !1,
                    this.hasSymbolBuckets)
                        for (const t in this.buckets) {
                            const e = this.buckets[t];
                            if (e instanceof Nd && e.hasRTLText) {
                                this.hasRTLText = !0,
                                Is.isLoading() || Is.isLoaded() || "deferred" !== Ss() || Ms();
                                break
                            }
                        }
                    this.queryPadding = 0;
                    for (const t in this.buckets) {
                        const r = this.buckets[t];
                        this.queryPadding = Math.max(this.queryPadding, e.style.getLayer(t).queryRadius(r));
                    }
                    t.imageAtlas && (this.imageAtlas = t.imageAtlas),
                    t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage),
                    t.lineAtlas && (this.lineAtlas = t.lineAtlas);
                } else
                    this.collisionBoxArray = new ka;
            }
            unloadVectorData() {
                if (this.hasData()) {
                    for (const t in this.buckets)
                        this.buckets[t].destroy();
                    this.buckets = {},
                    this.imageAtlas && (this.imageAtlas = null),
                    this.lineAtlas && (this.lineAtlas = null),
                    this.imageAtlasTexture && this.imageAtlasTexture.destroy(),
                    this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(),
                    this.lineAtlasTexture && this.lineAtlasTexture.destroy(),
                    this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(),
                    this._tileBoundsIndexBuffer.destroy(),
                    this._tileBoundsSegments.destroy(),
                    this._tileBoundsBuffer = null),
                    this._tileDebugBuffer && (this._tileDebugBuffer.destroy(),
                    this._tileDebugSegments.destroy(),
                    this._tileDebugBuffer = null),
                    this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(),
                    this._tileDebugIndexBuffer = null),
                    this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(),
                    this._globeTileDebugBorderBuffer = null),
                    this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(),
                    this._tileDebugTextSegments.destroy(),
                    this._tileDebugTextIndexBuffer.destroy(),
                    this._tileDebugTextBuffer = null),
                    this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(),
                    this._globeTileDebugTextBuffer = null),
                    this.latestFeatureIndex = null,
                    this.state = "unloaded";
                }
            }
            getBucket(t) {
                return this.buckets[t.id]
            }
            upload(t) {
                for (const e in this.buckets) {
                    const r = this.buckets[e];
                    r.uploadPending() && r.upload(t);
                }
                const e = t.gl;
                this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new py(t,this.imageAtlas.image,e.RGBA),
                this.imageAtlas.uploaded = !0),
                this.glyphAtlasImage && (this.glyphAtlasTexture = new py(t,this.glyphAtlasImage,e.ALPHA),
                this.glyphAtlasImage = null),
                this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new py(t,this.lineAtlas.image,e.ALPHA),
                this.lineAtlas.uploaded = !0);
            }
            prepare(t) {
                this.imageAtlas && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture);
            }
            queryRenderedFeatures(t, e, r, n, i, s, a, o) {
                return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
                    tileResult: n,
                    pixelPosMatrix: a,
                    transform: s,
                    params: i,
                    tileTransform: this.tileTransform
                }, t, e, r, this.buckets) : {}
            }
            querySourceFeatures(t, e) {
                const r = this.latestFeatureIndex;
                if (!r || !r.rawTileData)
                    return;
                const n = r.loadVTLayers()
                  , i = e ? e.sourceLayer : ""
                  , s = n._geojsonTileLayer || n[i];
                if (!s)
                    return;
                const a = Hn(e && e.filter)
                  , {z: o, x: l, y: u} = this.tileID.canonical
                  , c = {
                    z: o,
                    x: l,
                    y: u
                };
                for (let e = 0; e < s.length; e++) {
                    const n = s.feature(e);
                    if (a.needGeometry) {
                        const t = Al(n, !0);
                        if (!a.filter(new Ts(this.tileID.overscaledZ), t, this.tileID.canonical))
                            continue
                    } else if (!a.filter(new Ts(this.tileID.overscaledZ), n))
                        continue;
                    const h = r.getId(n, i)
                      , p = new ky(n,o,l,u,h);
                    p.tile = c,
                    t.push(p);
                }
            }
            hasData() {
                return "loaded" === this.state || "reloading" === this.state || "expired" === this.state
            }
            patternsLoaded() {
                return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length
            }
            setExpiryData(t) {
                const e = this.expirationTime;
                if (t.cacheControl) {
                    const e = D(t.cacheControl);
                    e["max-age"] && (this.expirationTime = Date.now() + 1e3 * e["max-age"]);
                } else
                    t.expires && (this.expirationTime = new Date(t.expires).getTime());
                if (this.expirationTime) {
                    const t = Date.now();
                    let r = !1;
                    if (this.expirationTime > t)
                        r = !1;
                    else if (e)
                        if (this.expirationTime < e)
                            r = !0;
                        else {
                            const n = this.expirationTime - e;
                            n ? this.expirationTime = t + Math.max(n, 3e4) : r = !0;
                        }
                    else
                        r = !0;
                    r ? (this.expiredRequestCount++,
                    this.state = "expired") : this.expiredRequestCount = 0;
                }
            }
            getExpiryTimeout() {
                if (this.expirationTime)
                    return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (new Date).getTime(), Math.pow(2, 31) - 1)
            }
            setFeatureState(t, e) {
                if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(t).length || !e)
                    return;
                const r = this.latestFeatureIndex.loadVTLayers()
                  , n = e.style.listImages();
                for (const i in this.buckets) {
                    if (!e.style.hasLayer(i))
                        continue;
                    const s = this.buckets[i]
                      , a = s.layers[0].sourceLayer || "_geojsonTileLayer"
                      , o = r[a]
                      , l = t[a];
                    if (!o || !l || 0 === Object.keys(l).length)
                        continue;
                    if (s.update(l, o, n, this.imageAtlas && this.imageAtlas.patternPositions || {}),
                    s instanceof Fh || s instanceof $c) {
                        const t = e.style._getSourceCache(s.layers[0].source);
                        e._terrain && e._terrain.enabled && t && s.programConfigurations.needsUpload && e._terrain._clearRenderCacheForTile(t.id, this.tileID);
                    }
                    const u = e && e.style && e.style.getLayer(i);
                    u && (this.queryPadding = Math.max(this.queryPadding, u.queryRadius(s)));
                }
            }
            holdingForFade() {
                return void 0 !== this.symbolFadeHoldUntil
            }
            symbolFadeFinished() {
                return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < N.now()
            }
            clearFadeHold() {
                this.symbolFadeHoldUntil = void 0;
            }
            setHoldDuration(t) {
                this.symbolFadeHoldUntil = N.now() + t;
            }
            setTexture(t, e) {
                const r = e.context
                  , n = r.gl;
                this.texture = e.getTileTexture(t.width),
                this.texture ? this.texture.update(t, {
                    useMipmap: !0
                }) : (this.texture = new py(r,t,n.RGBA,{
                    useMipmap: !0
                }),
                this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE),
                r.extTextureFilterAnisotropic && n.texParameterf(n.TEXTURE_2D, r.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, r.extTextureFilterAnisotropicMax));
            }
            setDependencies(t, e) {
                const r = {};
                for (const t of e)
                    r[t] = !0;
                this.dependencies[t] = r;
            }
            hasDependency(t, e) {
                for (const r of t) {
                    const t = this.dependencies[r];
                    if (t)
                        for (const r of e)
                            if (t[r])
                                return !0
                }
                return !1
            }
            clearQueryDebugViz() {}
            _makeDebugTileBoundsBuffers(t, e) {
                if (!e || "mercator" === e.name || this._tileDebugBuffer)
                    return;
                const r = wl(Py, this.tileID.canonical, this.tileTransform)[0]
                  , n = new Ks
                  , i = new va;
                for (let t = 0; t < r.length; t++) {
                    const {x: e, y: s} = r[t];
                    n.emplaceBack(e, s),
                    i.emplaceBack(t);
                }
                i.emplaceBack(0),
                this._tileDebugIndexBuffer = t.createIndexBuffer(i),
                this._tileDebugBuffer = t.createVertexBuffer(n, Ff.members),
                this._tileDebugSegments = vo.simpleSegment(0, 0, n.length, i.length);
            }
            _makeTileBoundsBuffers(t, e) {
                if (this._tileBoundsBuffer || !e || "mercator" === e.name)
                    return;
                const r = wl(Py, this.tileID.canonical, this.tileTransform)[0];
                let n, i;
                if (this.isRaster) {
                    const t = function(t, e) {
                        const r = dd(t, e)
                          , n = Math.pow(2, t.z);
                        for (let i = 0; i < Sy; i++)
                            for (let s = 0; s < Sy; s++) {
                                const a = Wo((t.x + (s + Cy(s)) / zy) / n)
                                  , o = Qo((t.y + (i + Cy(i)) / zy) / n)
                                  , l = e.project(a, o)
                                  , u = i * Sy + s;
                                Iy[2 * u + 0] = Math.round((l.x * r.scale - r.x) * bo),
                                Iy[2 * u + 1] = Math.round((l.y * r.scale - r.y) * bo);
                            }
                        Ty.fill(0),
                        By.fill(0);
                        for (let t = 2045; t >= 0; t--) {
                            const e = 4 * t
                              , r = My[e + 0]
                              , n = My[e + 1]
                              , i = My[e + 2]
                              , s = My[e + 3]
                              , a = r + i >> 1
                              , o = n + s >> 1
                              , l = a + o - n
                              , u = o + r - a
                              , c = n * Sy + r
                              , h = s * Sy + i
                              , p = o * Sy + a
                              , f = Math.hypot((Iy[2 * c + 0] + Iy[2 * h + 0]) / 2 - Iy[2 * p + 0], (Iy[2 * c + 1] + Iy[2 * h + 1]) / 2 - Iy[2 * p + 1]) >= 16;
                            if (Ty[p] = Ty[p] || (f ? 1 : 0),
                            t < 1022) {
                                const t = (n + u >> 1) * Sy + (r + l >> 1)
                                  , e = (s + u >> 1) * Sy + (i + l >> 1);
                                Ty[p] = Ty[p] || Ty[t] || Ty[e];
                            }
                        }
                        const i = new Ws
                          , s = new pa;
                        let a = 0;
                        function o(t, e) {
                            const r = e * Sy + t;
                            return 0 === By[r] && (i.emplaceBack(Iy[2 * r + 0], Iy[2 * r + 1], t * bo / zy, e * bo / zy),
                            By[r] = ++a),
                            By[r] - 1
                        }
                        function l(t, e, r, n, i, a) {
                            const u = t + r >> 1
                              , c = e + n >> 1;
                            if (Math.abs(t - i) + Math.abs(e - a) > 1 && Ty[c * Sy + u])
                                l(i, a, t, e, u, c),
                                l(r, n, i, a, u, c);
                            else {
                                const l = o(t, e)
                                  , u = o(r, n)
                                  , c = o(i, a);
                                s.emplaceBack(l, u, c);
                            }
                        }
                        return l(0, 0, zy, zy, zy, 0),
                        l(zy, zy, 0, 0, 0, zy),
                        {
                            vertices: i,
                            indices: s
                        }
                    }(this.tileID.canonical, e);
                    n = t.vertices,
                    i = t.indices;
                } else {
                    n = new Ws,
                    i = new pa;
                    for (const {x: t, y: e} of r)
                        n.emplaceBack(t, e, 0, 0);
                    const t = sc(n.int16, void 0, 4);
                    for (let e = 0; e < t.length; e += 3)
                        i.emplaceBack(t[e], t[e + 1], t[e + 2]);
                }
                this._tileBoundsBuffer = t.createVertexBuffer(n, Vy.members),
                this._tileBoundsIndexBuffer = t.createIndexBuffer(i),
                this._tileBoundsSegments = vo.simpleSegment(0, 0, n.length, i.length);
            }
            _makeGlobeTileDebugBuffers(t, e) {
                const r = e.projection;
                if (!r || "globe" !== r.name || e.freezeTileCoverage)
                    return;
                const n = this.tileID.canonical
                  , i = sd(Hf(n, e))
                  , s = ld(e.zoom);
                let a;
                s > 0 && (a = Kl(new Float64Array(16), e.globeMatrix));
                const o = (n.x + .5) / (1 << n.z) - Ho(e.center.lng);
                let l = 0;
                o > .5 ? l = -1 : o < -.5 && (l = 1),
                this._makeGlobeTileDebugBorderBuffer(t, n, e, i, a, s, l),
                this._makeGlobeTileDebugTextBuffer(t, n, e, i, a, s, l);
            }
            _globePoint(t, e, r, n, i, s, a, o) {
                let l = rd(t, e, r);
                if (s) {
                    const i = 1 << r.z
                      , u = [((t / bo + r.x) / i + o) * n, gl(e, r) / i * n, 0];
                    vu(u, u, s),
                    l = Yf(l, u, a);
                }
                return vu(l, l, i)
            }
            _makeGlobeTileDebugBorderBuffer(t, e, r, n, i, s, a) {
                const o = new Ks
                  , l = new va
                  , u = new Js
                  , c = (t, c, h, p, f) => {
                    const d = (h - t) / (f - 1)
                      , y = (p - c) / (f - 1)
                      , m = o.length;
                    for (let h = 0; h < f; h++) {
                        const p = t + h * d
                          , f = c + h * y;
                        o.emplaceBack(p, f);
                        const g = this._globePoint(p, f, e, r.worldSize, n, i, s, a);
                        u.emplaceBack(g[0], g[1], g[2]),
                        l.emplaceBack(m + h);
                    }
                }
                  , h = bo;
                c(0, 0, h, 0, 16),
                c(h, 0, h, h, 16),
                c(h, h, 0, h, 16),
                c(0, h, 0, 0, 16),
                this._tileDebugIndexBuffer = t.createIndexBuffer(l),
                this._tileDebugBuffer = t.createVertexBuffer(o, Ff.members),
                this._globeTileDebugBorderBuffer = t.createVertexBuffer(u, Ef.members),
                this._tileDebugSegments = vo.simpleSegment(0, 0, o.length, l.length);
            }
            _makeGlobeTileDebugTextBuffer(t, e, r, n, i, s, a) {
                const o = new Ks
                  , l = new pa
                  , u = new Js
                  , c = 25;
                l.reserve(32),
                o.reserve(c),
                u.reserve(c);
                const h = (t, e) => c * t + e;
                for (let t = 0; t < c; t++) {
                    const l = 2048 * t;
                    for (let t = 0; t < c; t++) {
                        const c = 2048 * t;
                        o.emplaceBack(c, l);
                        const h = this._globePoint(c, l, e, r.worldSize, n, i, s, a);
                        u.emplaceBack(h[0], h[1], h[2]);
                    }
                }
                for (let t = 0; t < 4; t++)
                    for (let e = 0; e < 4; e++) {
                        const r = h(t, e)
                          , n = h(t, e + 1)
                          , i = h(t + 1, e)
                          , s = h(t + 1, e + 1);
                        l.emplaceBack(r, n, i),
                        l.emplaceBack(i, n, s);
                    }
                this._tileDebugTextIndexBuffer = t.createIndexBuffer(l),
                this._tileDebugTextBuffer = t.createVertexBuffer(o, Ff.members),
                this._globeTileDebugTextBuffer = t.createVertexBuffer(u, Ef.members),
                this._tileDebugTextSegments = vo.simpleSegment(0, 0, c, 32);
            }
        }
        class Ey {
            constructor() {
                this.state = {},
                this.stateChanges = {},
                this.deletedStates = {};
            }
            updateState(t, e, r) {
                const n = String(e);
                if (this.stateChanges[t] = this.stateChanges[t] || {},
                this.stateChanges[t][n] = this.stateChanges[t][n] || {},
                v(this.stateChanges[t][n], r),
                null === this.deletedStates[t]) {
                    this.deletedStates[t] = {};
                    for (const e in this.state[t])
                        e !== n && (this.deletedStates[t][e] = null);
                } else if (this.deletedStates[t] && null === this.deletedStates[t][n]) {
                    this.deletedStates[t][n] = {};
                    for (const e in this.state[t][n])
                        r[e] || (this.deletedStates[t][n][e] = null);
                } else
                    for (const e in r)
                        this.deletedStates[t] && this.deletedStates[t][n] && null === this.deletedStates[t][n][e] && delete this.deletedStates[t][n][e];
            }
            removeFeatureState(t, e, r) {
                if (null === this.deletedStates[t])
                    return;
                const n = String(e);
                if (this.deletedStates[t] = this.deletedStates[t] || {},
                r && void 0 !== e)
                    null !== this.deletedStates[t][n] && (this.deletedStates[t][n] = this.deletedStates[t][n] || {},
                    this.deletedStates[t][n][r] = null);
                else if (void 0 !== e)
                    if (this.stateChanges[t] && this.stateChanges[t][n])
                        for (r in this.deletedStates[t][n] = {},
                        this.stateChanges[t][n])
                            this.deletedStates[t][n][r] = null;
                    else
                        this.deletedStates[t][n] = null;
                else
                    this.deletedStates[t] = null;
            }
            getState(t, e) {
                const r = String(e)
                  , n = v({}, (this.state[t] || {})[r], (this.stateChanges[t] || {})[r]);
                if (null === this.deletedStates[t])
                    return {};
                if (this.deletedStates[t]) {
                    const r = this.deletedStates[t][e];
                    if (null === r)
                        return {};
                    for (const t in r)
                        delete n[t];
                }
                return n
            }
            initializeTileState(t, e) {
                t.setFeatureState(this.state, e);
            }
            coalesceChanges(t, e) {
                const r = {};
                for (const t in this.stateChanges) {
                    this.state[t] = this.state[t] || {};
                    const e = {};
                    for (const r in this.stateChanges[t])
                        this.state[t][r] || (this.state[t][r] = {}),
                        v(this.state[t][r], this.stateChanges[t][r]),
                        e[r] = this.state[t][r];
                    r[t] = e;
                }
                for (const t in this.deletedStates) {
                    this.state[t] = this.state[t] || {};
                    const e = {};
                    if (null === this.deletedStates[t])
                        for (const r in this.state[t])
                            e[r] = {},
                            this.state[t][r] = {};
                    else
                        for (const r in this.deletedStates[t]) {
                            if (null === this.deletedStates[t][r])
                                this.state[t][r] = {};
                            else
                                for (const e of Object.keys(this.deletedStates[t][r]))
                                    delete this.state[t][r][e];
                            e[r] = this.state[t][r];
                        }
                    r[t] = r[t] || {},
                    v(r[t], e);
                }
                if (this.stateChanges = {},
                this.deletedStates = {},
                0 !== Object.keys(r).length)
                    for (const n in t)
                        t[n].setFeatureState(r, e);
            }
        }
        class Fy {
            constructor(t) {
                this.size = t,
                this.minimums = [],
                this.maximums = [],
                this.leaves = [];
            }
            getElevation(t, e) {
                const r = this.toIdx(t, e);
                return {
                    min: this.minimums[r],
                    max: this.maximums[r]
                }
            }
            isLeaf(t, e) {
                return this.leaves[this.toIdx(t, e)]
            }
            toIdx(t, e) {
                return e * this.size + t
            }
        }
        function Ly(t, e, r, n) {
            let i = 0
              , s = Number.MAX_VALUE;
            for (let a = 0; a < 3; a++)
                if (Math.abs(n[a]) < 1e-15) {
                    if (r[a] < t[a] || r[a] > e[a])
                        return null
                } else {
                    const o = 1 / n[a];
                    let l = (t[a] - r[a]) * o
                      , u = (e[a] - r[a]) * o;
                    if (l > u) {
                        const t = l;
                        l = u,
                        u = t;
                    }
                    if (l > i && (i = l),
                    u < s && (s = u),
                    i > s)
                        return null
                }
            return i
        }
        function Ry(t, e, r, n, i, s, a, o, l, u, c) {
            const h = n - t
              , p = i - e
              , f = s - r
              , d = a - t
              , y = o - e
              , m = l - r
              , g = c[1] * m - c[2] * y
              , x = c[2] * d - c[0] * m
              , v = c[0] * y - c[1] * d
              , b = h * g + p * x + f * v;
            if (Math.abs(b) < 1e-15)
                return null;
            const _ = 1 / b
              , w = u[0] - t
              , A = u[1] - e
              , k = u[2] - r
              , z = (w * g + A * x + k * v) * _;
            if (z < 0 || z > 1)
                return null;
            const S = A * f - k * p
              , M = k * h - w * f
              , I = w * p - A * h
              , T = (c[0] * S + c[1] * M + c[2] * I) * _;
            return T < 0 || z + T > 1 ? null : (d * S + y * M + m * I) * _
        }
        function jy(t, e, r) {
            return (t - e) / (r - e)
        }
        function Uy(t, e, r, n, i, s, a, o, l) {
            const u = 1 << r
              , c = s - n
              , h = a - i
              , p = (t + 1) / u * c + n
              , f = (e + 0) / u * h + i
              , d = (e + 1) / u * h + i;
            o[0] = (t + 0) / u * c + n,
            o[1] = f,
            l[0] = p,
            l[1] = d;
        }
        class Oy {
            constructor(t) {
                if (this.maximums = [],
                this.minimums = [],
                this.leaves = [],
                this.childOffsets = [],
                this.nodeCount = 0,
                this.dem = t,
                this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]],
                !this.dem)
                    return;
                const e = function(t) {
                    const e = Math.ceil(Math.log2(t.dim / 8))
                      , r = [];
                    let n = Math.ceil(Math.pow(2, e));
                    const i = 1 / n
                      , s = (t, e, r, n, i) => {
                        const s = n ? 1 : 0
                          , a = (t + 1) * r - s
                          , o = e * r
                          , l = (e + 1) * r - s;
                        i[0] = t * r,
                        i[1] = o,
                        i[2] = a,
                        i[3] = l;
                    }
                    ;
                    let a = new Fy(n);
                    const o = [];
                    for (let e = 0; e < n * n; e++) {
                        s(e % n, Math.floor(e / n), i, !1, o);
                        const r = qy(o[0], o[1], t)
                          , l = qy(o[2], o[1], t)
                          , u = qy(o[2], o[3], t)
                          , c = qy(o[0], o[3], t);
                        a.minimums.push(Math.min(r, l, u, c)),
                        a.maximums.push(Math.max(r, l, u, c)),
                        a.leaves.push(1);
                    }
                    for (r.push(a),
                    n /= 2; n >= 1; n /= 2) {
                        const t = r[r.length - 1];
                        a = new Fy(n);
                        for (let e = 0; e < n * n; e++) {
                            s(e % n, Math.floor(e / n), 2, !0, o);
                            const r = t.getElevation(o[0], o[1])
                              , i = t.getElevation(o[2], o[1])
                              , l = t.getElevation(o[2], o[3])
                              , u = t.getElevation(o[0], o[3])
                              , c = t.isLeaf(o[0], o[1])
                              , h = t.isLeaf(o[2], o[1])
                              , p = t.isLeaf(o[2], o[3])
                              , f = t.isLeaf(o[0], o[3])
                              , d = Math.min(r.min, i.min, l.min, u.min)
                              , y = Math.max(r.max, i.max, l.max, u.max)
                              , m = c && h && p && f;
                            a.maximums.push(y),
                            a.minimums.push(d),
                            a.leaves.push(y - d <= 5 && m ? 1 : 0);
                        }
                        r.push(a);
                    }
                    return r
                }(this.dem)
                  , r = e.length - 1
                  , n = e[r];
                this._addNode(n.minimums[0], n.maximums[0], n.leaves[0]),
                this._construct(e, 0, 0, r, 0);
            }
            raycastRoot(t, e, r, n, i, s, a=1) {
                return Ly([t, e, -100], [r, n, this.maximums[0] * a], i, s)
            }
            raycast(t, e, r, n, i, s, a=1) {
                if (!this.nodeCount)
                    return null;
                const o = this.raycastRoot(t, e, r, n, i, s, a);
                if (null == o)
                    return null;
                const l = []
                  , u = []
                  , c = []
                  , h = []
                  , p = [{
                    idx: 0,
                    t: o,
                    nodex: 0,
                    nodey: 0,
                    depth: 0
                }];
                for (; p.length > 0; ) {
                    const {idx: o, t: f, nodex: d, nodey: y, depth: m} = p.pop();
                    if (this.leaves[o]) {
                        Uy(d, y, m, t, e, r, n, c, h);
                        const o = 1 << m
                          , l = (d + 0) / o
                          , u = (d + 1) / o
                          , p = (y + 0) / o
                          , g = (y + 1) / o
                          , x = qy(l, p, this.dem) * a
                          , v = qy(u, p, this.dem) * a
                          , b = qy(u, g, this.dem) * a
                          , _ = qy(l, g, this.dem) * a
                          , w = Ry(c[0], c[1], x, h[0], c[1], v, h[0], h[1], b, i, s)
                          , A = Ry(h[0], h[1], b, c[0], h[1], _, c[0], c[1], x, i, s)
                          , k = Math.min(null !== w ? w : Number.MAX_VALUE, null !== A ? A : Number.MAX_VALUE);
                        if (k !== Number.MAX_VALUE)
                            return k;
                        {
                            const t = yu([], i, s, f);
                            if ($y(x, v, _, b, jy(t[0], c[0], h[0]), jy(t[1], c[1], h[1])) >= t[2])
                                return f
                        }
                        continue
                    }
                    let g = 0;
                    for (let p = 0; p < this._siblingOffset.length; p++) {
                        Uy((d << 1) + this._siblingOffset[p][0], (y << 1) + this._siblingOffset[p][1], m + 1, t, e, r, n, c, h),
                        c[2] = -100,
                        h[2] = this.maximums[this.childOffsets[o] + p] * a;
                        const f = Ly(c, h, i, s);
                        if (null != f) {
                            const t = f;
                            l[p] = t;
                            let e = !1;
                            for (let r = 0; r < g && !e; r++)
                                t >= l[u[r]] && (u.splice(r, 0, p),
                                e = !0);
                            e || (u[g] = p),
                            g++;
                        }
                    }
                    for (let t = 0; t < g; t++) {
                        const e = u[t];
                        p.push({
                            idx: this.childOffsets[o] + e,
                            t: l[e],
                            nodex: (d << 1) + this._siblingOffset[e][0],
                            nodey: (y << 1) + this._siblingOffset[e][1],
                            depth: m + 1
                        });
                    }
                }
                return null
            }
            _addNode(t, e, r) {
                return this.minimums.push(t),
                this.maximums.push(e),
                this.leaves.push(r),
                this.childOffsets.push(0),
                this.nodeCount++
            }
            _construct(t, e, r, n, i) {
                if (1 === t[n].isLeaf(e, r))
                    return;
                this.childOffsets[i] || (this.childOffsets[i] = this.nodeCount);
                const s = n - 1
                  , a = t[s];
                let o = 0
                  , l = 0;
                for (let t = 0; t < this._siblingOffset.length; t++) {
                    const n = 2 * e + this._siblingOffset[t][0]
                      , i = 2 * r + this._siblingOffset[t][1]
                      , s = a.getElevation(n, i)
                      , u = a.isLeaf(n, i)
                      , c = this._addNode(s.min, s.max, u);
                    u && (o |= 1 << t),
                    l || (l = c);
                }
                for (let n = 0; n < this._siblingOffset.length; n++)
                    o & 1 << n || this._construct(t, 2 * e + this._siblingOffset[n][0], 2 * r + this._siblingOffset[n][1], s, l + n);
            }
        }
        function $y(t, e, r, n, i, s) {
            return mr(mr(t, r, s), mr(e, n, s), i)
        }
        function qy(t, e, r) {
            const n = r.dim
              , i = d(t * n - .5, 0, n - 1)
              , s = d(e * n - .5, 0, n - 1)
              , a = Math.floor(i)
              , o = Math.floor(s)
              , l = Math.min(a + 1, n - 1)
              , u = Math.min(o + 1, n - 1);
            return $y(r.get(a, o), r.get(l, o), r.get(a, u), r.get(l, u), i - a, s - o)
        }
        const Ny = {
            sgmap: [6553.6, 25.6, .1, 1e4],
            terrarium: [256, 1, 1 / 256, 32768],
            epgis: [9362.285714285717, 36.571428571428584, .1428571428571429, 9866]
        };
        class Zy {
            get tree() {
                return this._tree || this._buildQuadTree(),
                this._tree
            }
            constructor(t, e, r, n=!1, i=!1) {
                if (this.uid = t,
                e.height !== e.width)
                    throw new RangeError("DEM tiles must be square");
                if (r && "sgmap" !== r && "terrarium" !== r && "epgis" !== r)
                    return B(`"${r}" is not a valid encoding type. Valid types include "sgmap" and "terrarium"、"epgis".`);
                this.stride = e.height;
                const s = this.dim = e.height - 2
                  , a = new Uint32Array(e.data.buffer);
                if (this.pixels = new Uint8Array(e.data.buffer),
                this.encoding = r || "epgis",
                this.borderReady = n,
                !n) {
                    for (let t = 0; t < s; t++)
                        a[this._idx(-1, t)] = a[this._idx(0, t)],
                        a[this._idx(s, t)] = a[this._idx(s - 1, t)],
                        a[this._idx(t, -1)] = a[this._idx(t, 0)],
                        a[this._idx(t, s)] = a[this._idx(t, s - 1)];
                    a[this._idx(-1, -1)] = a[this._idx(0, 0)],
                    a[this._idx(s, -1)] = a[this._idx(s - 1, 0)],
                    a[this._idx(-1, s)] = a[this._idx(0, s - 1)],
                    a[this._idx(s, s)] = a[this._idx(s - 1, s - 1)],
                    i && this._buildQuadTree();
                }
            }
            _buildQuadTree() {
                this._tree = new Oy(this);
            }
            get(t, e, r=!1) {
                r && (t = d(t, -1, this.dim),
                e = d(e, -1, this.dim));
                const n = 4 * this._idx(t, e)
                  , i = Ny[this.encoding];
                return this.pixels[n] * i[0] + this.pixels[n + 1] * i[1] + this.pixels[n + 2] * i[2] - i[3]
            }
            static getUnpackVector(t) {
                return Ny[t]
            }
            get unpackVector() {
                return Ny[this.encoding]
            }
            _idx(t, e) {
                if (t < -1 || t >= this.dim + 1 || e < -1 || e >= this.dim + 1)
                    throw new RangeError("out of range source coordinates for DEM data");
                return (e + 1) * this.stride + (t + 1)
            }
            _unpacksgmap(t, e, r) {
                return (256 * t * 256 + 256 * e + r) / 10 - 1e4
            }
            _unpackTerrarium(t, e, r) {
                return 256 * t + e + r / 256 - 32768
            }
            static pack(t, e) {
                const r = [0, 0, 0, 0]
                  , n = Zy.getUnpackVector(e);
                let i = Math.floor((t + n[3]) / n[2]);
                return r[2] = i % 256,
                i = Math.floor(i / 256),
                r[1] = i % 256,
                i = Math.floor(i / 256),
                r[0] = i,
                r
            }
            getPixels() {
                return new Qu({
                    width: this.stride,
                    height: this.stride
                },this.pixels)
            }
            backfillBorder(t, e, r) {
                if (this.dim !== t.dim)
                    throw new Error("dem dimension mismatch");
                let n = e * this.dim
                  , i = e * this.dim + this.dim
                  , s = r * this.dim
                  , a = r * this.dim + this.dim;
                switch (e) {
                case -1:
                    n = i - 1;
                    break;
                case 1:
                    i = n + 1;
                }
                switch (r) {
                case -1:
                    s = a - 1;
                    break;
                case 1:
                    a = s + 1;
                }
                const o = -e * this.dim
                  , l = -r * this.dim;
                for (let e = s; e < a; e++)
                    for (let r = n; r < i; r++) {
                        const n = 4 * this._idx(r, e)
                          , i = 4 * this._idx(r + o, e + l);
                        this.pixels[n + 0] = t.pixels[i + 0],
                        this.pixels[n + 1] = t.pixels[i + 1],
                        this.pixels[n + 2] = t.pixels[i + 2],
                        this.pixels[n + 3] = t.pixels[i + 3];
                    }
            }
            onDeserialize() {
                this._tree && (this._tree.dem = this);
            }
        }
        Bi(Zy, "DEMData"),
        Bi(Oy, "DemMinMaxQuadTree", {
            omit: ["dem"]
        });
        class Gy {
            constructor(t, e) {
                this.max = t,
                this.onRemove = e,
                this.reset();
            }
            reset() {
                for (const t in this.data)
                    for (const e of this.data[t])
                        e.timeout && clearTimeout(e.timeout),
                        this.onRemove(e.value);
                return this.data = {},
                this.order = [],
                this
            }
            add(t, e, r) {
                const n = t.wrapped().key;
                void 0 === this.data[n] && (this.data[n] = []);
                const i = {
                    value: e,
                    timeout: void 0
                };
                if (void 0 !== r && (i.timeout = setTimeout(( () => {
                    this.remove(t, i);
                }
                ), r)),
                this.data[n].push(i),
                this.order.push(n),
                this.order.length > this.max) {
                    const t = this._getAndRemoveByKey(this.order[0]);
                    t && this.onRemove(t);
                }
                return this
            }
            has(t) {
                return t.wrapped().key in this.data
            }
            getAndRemove(t) {
                return this.has(t) ? this._getAndRemoveByKey(t.wrapped().key) : null
            }
            _getAndRemoveByKey(t) {
                const e = this.data[t].shift();
                return e.timeout && clearTimeout(e.timeout),
                0 === this.data[t].length && delete this.data[t],
                this.order.splice(this.order.indexOf(t), 1),
                e.value
            }
            getByKey(t) {
                const e = this.data[t];
                return e ? e[0].value : null
            }
            get(t) {
                return this.has(t) ? this.data[t.wrapped().key][0].value : null
            }
            remove(t, e) {
                if (!this.has(t))
                    return this;
                const r = t.wrapped().key
                  , n = void 0 === e ? 0 : this.data[r].indexOf(e)
                  , i = this.data[r][n];
                return this.data[r].splice(n, 1),
                i.timeout && clearTimeout(i.timeout),
                0 === this.data[r].length && delete this.data[r],
                this.onRemove(i.value),
                this.order.splice(this.order.indexOf(r), 1),
                this
            }
            setMaxSize(t) {
                for (this.max = t; this.order.length > this.max; ) {
                    const t = this._getAndRemoveByKey(this.order[0]);
                    t && this.onRemove(t);
                }
                return this
            }
            filter(t) {
                const e = [];
                for (const r in this.data)
                    for (const n of this.data[r])
                        t(n.value) || e.push(n);
                for (const t of e)
                    this.remove(t.value.tileID, t);
            }
        }
        class Xy {
            constructor(t, e, r) {
                this.func = t,
                this.mask = e,
                this.range = r;
            }
        }
        Xy.ReadOnly = !1,
        Xy.ReadWrite = !0,
        Xy.disabled = new Xy(519,Xy.ReadOnly,[0, 1]);
        const Yy = 7680;
        class Hy {
            constructor(t, e, r, n, i, s) {
                this.test = t,
                this.ref = e,
                this.mask = r,
                this.fail = n,
                this.depthFail = i,
                this.pass = s;
            }
        }
        Hy.disabled = new Hy({
            func: 519,
            mask: 0
        },0,0,Yy,Yy,Yy);
        class Ky {
            constructor(t, e, r) {
                this.blendFunction = t,
                this.blendColor = e,
                this.mask = r;
            }
        }
        Ky.Replace = [1, 0],
        Ky.disabled = new Ky(Ky.Replace,me.transparent,[!1, !1, !1, !1]),
        Ky.unblended = new Ky(Ky.Replace,me.transparent,[!0, !0, !0, !0]),
        Ky.alphaBlended = new Ky([1, 771],me.transparent,[!0, !0, !0, !0]);
        const Jy = 1029
          , Wy = 2305;
        class Qy {
            constructor(t, e, r) {
                this.enable = t,
                this.mode = e,
                this.frontFace = r;
            }
        }
        Qy.disabled = new Qy(!1,Jy,Wy),
        Qy.backCCW = new Qy(!0,Jy,Wy),
        Qy.backCW = new Qy(!0,Jy,2304),
        Qy.frontCW = new Qy(!0,1028,2304),
        Qy.frontCCW = new Qy(!0,1028,Wy);
        class tm extends $t {
            constructor(t, e, r) {
                super(),
                this.id = t,
                this._onlySymbols = r,
                e.on("data", (t => {
                    "source" === t.dataType && "metadata" === t.sourceDataType && (this._sourceLoaded = !0),
                    this._sourceLoaded && !this._paused && "source" === t.dataType && "content" === t.sourceDataType && (this.reload(),
                    this.transform && this.update(this.transform));
                }
                )),
                e.on("error", ( () => {
                    this._sourceErrored = !0;
                }
                )),
                this._source = e,
                this._tiles = {},
                this._cache = new Gy(0,this._unloadTile.bind(this)),
                this._timers = {},
                this._cacheTimers = {},
                this._minTileCacheSize = e.minTileCacheSize,
                this._maxTileCacheSize = e.maxTileCacheSize,
                this._loadedParentTiles = {},
                this._coveredTiles = {},
                this._state = new Ey,
                this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType;
            }
            onAdd(t) {
                this.map = t,
                this._minTileCacheSize = void 0 === this._minTileCacheSize && t ? t._minTileCacheSize : this._minTileCacheSize,
                this._maxTileCacheSize = void 0 === this._maxTileCacheSize && t ? t._maxTileCacheSize : this._maxTileCacheSize;
            }
            loaded() {
                if (this._sourceErrored)
                    return !0;
                if (!this._sourceLoaded)
                    return !1;
                if (!this._source.loaded())
                    return !1;
                for (const t in this._tiles) {
                    const e = this._tiles[t];
                    if ("loaded" !== e.state && "errored" !== e.state)
                        return !1
                }
                return !0
            }
            getSource() {
                return this._source
            }
            pause() {
                this._paused = !0;
            }
            resume() {
                if (!this._paused)
                    return;
                const t = this._shouldReloadOnResume;
                this._paused = !1,
                this._shouldReloadOnResume = !1,
                t && this.reload(),
                this.transform && this.update(this.transform);
            }
            _loadTile(t, e) {
                return t.isSymbolTile = this._onlySymbols,
                this._source.loadTile(t, e)
            }
            _unloadTile(t) {
                if (this._source.unloadTile)
                    return this._source.unloadTile(t, ( () => {}
                    ))
            }
            _abortTile(t) {
                if (this._source.abortTile)
                    return this._source.abortTile(t, ( () => {}
                    ))
            }
            serialize() {
                return this._source.serialize()
            }
            prepare(t) {
                if (this._source.prepare && this._source.prepare(),
                this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null),
                this._source.prepareTile)
                    for (const e in this._tiles) {
                        const r = this._tiles[e];
                        this._source.prepareTile(r) && this.map.painter.terrain && this.map.painter.terrain._clearRenderCacheForTile(this.id, r.tileID),
                        r.upload(t),
                        r.prepare(this.map.style.imageManager);
                    }
                else
                    for (const e in this._tiles) {
                        const r = this._tiles[e];
                        r.upload(t),
                        r.prepare(this.map.style.imageManager);
                    }
            }
            getIds() {
                return x(this._tiles).map((t => t.tileID)).sort(em).map((t => t.key))
            }
            getRenderableIds(t) {
                const e = [];
                for (const r in this._tiles)
                    this._isIdRenderable(r, t) && e.push(this._tiles[r]);
                return t ? e.sort(( (t, e) => {
                    const r = t.tileID
                      , n = e.tileID
                      , s = new i(r.canonical.x,r.canonical.y)._rotate(this.transform.angle)
                      , a = new i(n.canonical.x,n.canonical.y)._rotate(this.transform.angle);
                    return r.overscaledZ - n.overscaledZ || a.y - s.y || a.x - s.x
                }
                )).map((t => t.tileID.key)) : e.map((t => t.tileID)).sort(em).map((t => t.key))
            }
            hasRenderableParent(t) {
                const e = this.findLoadedParent(t, 0);
                return !!e && this._isIdRenderable(e.tileID.key)
            }
            _isIdRenderable(t, e) {
                return this._tiles[t] && this._tiles[t].hasData() && !this._coveredTiles[t] && (e || !this._tiles[t].holdingForFade())
            }
            reload() {
                if (this._paused)
                    this._shouldReloadOnResume = !0;
                else {
                    this._cache.reset();
                    for (const t in this._tiles)
                        "errored" !== this._tiles[t].state && this._reloadTile(t, "reloading");
                }
            }
            _reloadTile(t, e) {
                const r = this._tiles[t];
                r && ("loading" !== r.state && (r.state = e),
                this._loadTile(r, this._tileLoaded.bind(this, r, t, e)));
            }
            _tileLoaded(t, e, r, n) {
                if (n)
                    if (t.state = "errored",
                    404 !== n.status)
                        this._source.fire(new Ot(n,{
                            tile: t
                        }));
                    else if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
                        const t = this.map.painter.terrain;
                        this.update(this.transform, t.getScaledDemTileSize(), !0),
                        t.resetTileLookupCache(this.id);
                    } else
                        this.update(this.transform);
                else
                    t.timeAdded = N.now(),
                    "expired" === r && (t.refreshedUponExpiration = !0),
                    this._setTileReloadTimer(e, t),
                    "raster-dem" === this._source.type && t.dem && this._backfillDEM(t),
                    this._state.initializeTileState(t, this.map ? this.map.painter : null),
                    this._source.fire(new Ut("data",{
                        dataType: "source",
                        tile: t,
                        coord: t.tileID,
                        sourceCacheId: this.id
                    }));
            }
            _backfillDEM(t) {
                const e = this.getRenderableIds();
                for (let n = 0; n < e.length; n++) {
                    const i = e[n];
                    if (t.neighboringTiles && t.neighboringTiles[i]) {
                        const e = this.getTileByID(i);
                        r(t, e),
                        r(e, t);
                    }
                }
                function r(t, e) {
                    if (!t.dem || t.dem.borderReady)
                        return;
                    t.needsHillshadePrepare = !0,
                    t.needsDEMTextureUpload = !0;
                    let r = e.tileID.canonical.x - t.tileID.canonical.x;
                    const n = e.tileID.canonical.y - t.tileID.canonical.y
                      , i = Math.pow(2, t.tileID.canonical.z)
                      , s = e.tileID.key;
                    0 === r && 0 === n || Math.abs(n) > 1 || (Math.abs(r) > 1 && (1 === Math.abs(r + i) ? r += i : 1 === Math.abs(r - i) && (r -= i)),
                    e.dem && t.dem && (t.dem.backfillBorder(e.dem, r, n),
                    t.neighboringTiles && t.neighboringTiles[s] && (t.neighboringTiles[s].backfilled = !0)));
                }
            }
            getTile(t) {
                return this.getTileByID(t.key)
            }
            getTileByID(t) {
                return this._tiles[t]
            }
            _retainLoadedChildren(t, e, r, n) {
                for (const i in this._tiles) {
                    let s = this._tiles[i];
                    if (n[i] || !s.hasData() || s.tileID.overscaledZ <= e || s.tileID.overscaledZ > r)
                        continue;
                    let a = s.tileID;
                    for (; s && s.tileID.overscaledZ > e + 1; ) {
                        const t = s.tileID.scaledTo(s.tileID.overscaledZ, -1);
                        s = this._tiles[t.key],
                        s && s.hasData() && (a = t);
                    }
                    let o = a;
                    for (; o.overscaledZ > e; )
                        if (o = o.scaledTo(o.overscaledZ, -1),
                        t[o.key]) {
                            n[a.key] = a;
                            break
                        }
                }
            }
            findLoadedParent(t, e) {
                if (t.key in this._loadedParentTiles) {
                    const r = this._loadedParentTiles[t.key];
                    return r && r.tileID.overscaledZ >= e ? r : null
                }
                for (let r = t.overscaledZ - 1; r >= e; r--) {
                    const e = t.scaledTo(r)
                      , n = this._getLoadedTile(e);
                    if (n)
                        return n
                }
            }
            _getLoadedTile(t) {
                const e = this._tiles[t.key];
                return e && e.hasData() ? e : this._cache.getByKey(this._source.reparseOverscaled ? t.wrapped().key : t.canonical.key)
            }
            updateCacheSize(t, e) {
                e = e || this._source.tileSize;
                const r = Math.ceil(t.width / e) + 1
                  , n = Math.ceil(t.height / e) + 1
                  , i = Math.floor(r * n * 5)
                  , s = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, i) : i
                  , a = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, s) : s;
                this._cache.setMaxSize(a);
            }
            handleWrapJump(t) {
                const e = Math.round((t - (void 0 === this._prevLng ? t : this._prevLng)) / 360);
                if (this._prevLng = t,
                e) {
                    const t = {};
                    for (const r in this._tiles) {
                        const n = this._tiles[r];
                        n.tileID = n.tileID.unwrapTo(n.tileID.wrap + e),
                        t[n.tileID.key] = n;
                    }
                    this._tiles = t;
                    for (const t in this._timers)
                        clearTimeout(this._timers[t]),
                        delete this._timers[t];
                    for (const t in this._tiles)
                        this._setTileReloadTimer(t, this._tiles[t]);
                }
            }
            update(t, e, r, n) {
                if (this.transform = t,
                !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage)
                    return;
                if (this.usedForTerrain && !r)
                    return;
                let i;
                this.updateCacheSize(t, e),
                "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng),
                this._coveredTiles = {},
                this.used || this.usedForTerrain ? this._source.tileID ? i = t.getVisibleUnwrappedCoordinates(this._source.tileID).map((t => new kh(t.canonical.z,t.wrap,t.canonical.z,t.canonical.x,t.canonical.y,t))) : (i = t.coveringTiles({
                    tileSize: e || this._source.tileSize,
                    minzoom: this._source.minzoom,
                    maxzoom: this._source.maxzoom,
                    roundZoom: this._source.roundZoom && !r,
                    reparseOverscaled: this._source.reparseOverscaled,
                    isTerrainDEM: this.usedForTerrain,
                    reference: this._source.reference,
                    zoomRule: this._source.zoomRule,
                    sourceID: this._source.id
                }),
                this._source.hasTile && (i = i.filter((t => this._source.hasTile(t))))) : i = [];
                const s = t.coveringZoomLevel(this._source)
                  , a = this._updateRetainedTiles(i, s);
                if (rm(this._source.type) && 0 !== i.length) {
                    const t = {}
                      , e = {}
                      , r = Object.keys(a);
                    for (const n of r) {
                        const r = a[n]
                          , i = this._tiles[n];
                        if (!i || i.fadeEndTime && i.fadeEndTime <= N.now())
                            continue;
                        const s = this.findLoadedParent(r, Math.max(r.overscaledZ - tm.maxOverzooming, this._source.minzoom));
                        s && (this._addTile(s.tileID),
                        t[s.tileID.key] = s.tileID),
                        e[n] = r;
                    }
                    const n = i[i.length - 1].overscaledZ;
                    for (const t in this._tiles) {
                        const r = this._tiles[t];
                        if (a[t] || !r.hasData())
                            continue;
                        let i = r.tileID;
                        for (; i.overscaledZ > n; ) {
                            i = i.scaledTo(i.overscaledZ, -1);
                            const n = this._tiles[i.key];
                            if (n && n.hasData() && e[i.key]) {
                                a[t] = r.tileID;
                                break
                            }
                        }
                    }
                    for (const e in t)
                        a[e] || (this._coveredTiles[e] = !0,
                        a[e] = t[e]);
                }
                for (const t in a)
                    this._tiles[t].clearFadeHold();
                const o = function(t, e) {
                    const r = [];
                    for (const n in t)
                        n in e || r.push(n);
                    return r
                }(this._tiles, a);
                for (const t of o) {
                    const e = this._tiles[t];
                    e.hasSymbolBuckets && !e.holdingForFade() ? e.setHoldDuration(this.map._fadeDuration) : e.hasSymbolBuckets && !e.symbolFadeFinished() || this._removeTile(t);
                }
                this._updateLoadedParentTileCache(),
                this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
            }
            releaseSymbolFadeTiles() {
                for (const t in this._tiles)
                    this._tiles[t].holdingForFade() && this._removeTile(t);
            }
            _updateRetainedTiles(t, e) {
                const r = "Sg4326" == this._source.reference
                  , n = {};
                if (0 === t.length)
                    return n;
                const i = {}
                  , s = t.reduce(( (t, e) => Math.min(t, e.overscaledZ)), 1 / 0)
                  , a = t[0].overscaledZ
                  , o = Math.max(a - tm.maxOverzooming, this._source.minzoom)
                  , l = Math.max(a + tm.maxUnderzooming, this._source.minzoom)
                  , u = {};
                for (const i of t) {
                    const t = this._addTile(i);
                    n[i.key] = i,
                    r && this._tiles[i.key] && "reloading" != t.state && (t.tileZoom != e || t.tileID._mapZoom != e) && (t.tileZoom = e,
                    t.tileID._mapZoom = e,
                    this._reloadTile(i.key, "reloading")),
                    t.hasData() || s < this._source.maxzoom && (u[i.key] = i);
                }
                this._retainLoadedChildren(u, s, l, n);
                for (const e of t) {
                    let t = this._tiles[e.key];
                    if (t.hasData())
                        continue;
                    if (e.canonical.z >= this._source.maxzoom) {
                        const t = e.children(this._source.maxzoom)[0]
                          , r = this.getTile(t);
                        if (r && r.hasData()) {
                            n[t.key] = t;
                            continue
                        }
                    } else {
                        const t = e.children(this._source.maxzoom);
                        if (n[t[0].key] && n[t[1].key] && n[t[2].key] && n[t[3].key])
                            continue
                    }
                    let r = t.wasRequested();
                    for (let s = e.overscaledZ - 1; s >= o; --s) {
                        const a = e.scaledTo(s);
                        if (i[a.key])
                            break;
                        if (i[a.key] = !0,
                        t = this.getTile(a),
                        !t && r && (t = this._addTile(a)),
                        t && (n[a.key] = a,
                        r = t.wasRequested(),
                        t.hasData()))
                            break
                    }
                }
                return n
            }
            _updateLoadedParentTileCache() {
                this._loadedParentTiles = {};
                for (const t in this._tiles) {
                    const e = [];
                    let r, n = this._tiles[t].tileID;
                    for (; n.overscaledZ > 0; ) {
                        if (n.key in this._loadedParentTiles) {
                            r = this._loadedParentTiles[n.key];
                            break
                        }
                        e.push(n.key);
                        const t = n.scaledTo(n.overscaledZ, -1);
                        if (r = this._getLoadedTile(t),
                        r)
                            break;
                        n = t;
                    }
                    for (const t of e)
                        this._loadedParentTiles[t] = r;
                }
            }
            _addTile(t) {
                let e = this._tiles[t.key];
                if (e)
                    return this._source.prepareTile && this._source.prepareTile(e),
                    e;
                e = this._cache.getAndRemove(t),
                e && (this._setTileReloadTimer(t.key, e),
                e.tileID = t,
                this._state.initializeTileState(e, this.map ? this.map.painter : null),
                this._cacheTimers[t.key] && (clearTimeout(this._cacheTimers[t.key]),
                delete this._cacheTimers[t.key],
                this._setTileReloadTimer(t.key, e)));
                const r = Boolean(e);
                if (!r) {
                    const r = this.map ? this.map.painter : null;
                    e = new Dy(t,this._source.tileSize * t.overscaleFactor(),this.transform.tileZoom,r,this._isRaster),
                    this._source.prepareTile && this._source.prepareTile(e) || this._loadTile(e, this._tileLoaded.bind(this, e, t.key, e.state));
                }
                return e ? (e.uses++,
                this._tiles[t.key] = e,
                r || this._source.fire(new Ut("dataloading",{
                    tile: e,
                    coord: e.tileID,
                    dataType: "source"
                })),
                e) : null
            }
            _setTileReloadTimer(t, e) {
                t in this._timers && (clearTimeout(this._timers[t]),
                delete this._timers[t]);
                const r = e.getExpiryTimeout();
                r && (this._timers[t] = setTimeout(( () => {
                    this._reloadTile(t, "expired"),
                    delete this._timers[t];
                }
                ), r));
            }
            _removeTile(t) {
                const e = this._tiles[t];
                e && (e.uses--,
                delete this._tiles[t],
                this._timers[t] && (clearTimeout(this._timers[t]),
                delete this._timers[t]),
                e.uses > 0 || (e.hasData() && "reloading" !== e.state ? this._cache.add(e.tileID, e, e.getExpiryTimeout()) : (e.aborted = !0,
                this._abortTile(e),
                this._unloadTile(e))));
            }
            clearTiles() {
                this._shouldReloadOnResume = !1,
                this._paused = !1;
                for (const t in this._tiles)
                    this._removeTile(t);
                this._source._clear && this._source._clear(),
                this._cache.reset(),
                this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
            }
            tilesIn(t, e, r) {
                const n = []
                  , i = this.transform;
                if (!i)
                    return n;
                const s = "globe" === i.projection.name
                  , a = Ho(i.center.lng);
                for (const o in this._tiles) {
                    const l = this._tiles[o];
                    if (r && l.clearQueryDebugViz(),
                    l.holdingForFade())
                        continue;
                    let u;
                    if (s) {
                        const t = l.tileID.canonical;
                        if (0 === t.z) {
                            const e = [Math.abs(d(a, ...nm(t, -1)) - a), Math.abs(d(a, ...nm(t, 1)) - a)];
                            u = [0, 2 * e.indexOf(Math.min(...e)) - 1];
                        } else {
                            const e = [Math.abs(d(a, ...nm(t, -1)) - a), Math.abs(d(a, ...nm(t, 0)) - a), Math.abs(d(a, ...nm(t, 1)) - a)];
                            u = [e.indexOf(Math.min(...e)) - 1];
                        }
                    } else
                        u = [0];
                    for (const r of u) {
                        const s = t.containsTile(l, i, e, r);
                        s && n.push(s);
                    }
                }
                return n
            }
            getVisibleCoordinates(t) {
                const e = this.getRenderableIds(t).map((t => this._tiles[t].tileID));
                for (const t of e)
                    t.projMatrix = this.transform.calculateProjMatrix(t.toUnwrapped());
                return e
            }
            hasTransition() {
                if (this._source.hasTransition())
                    return !0;
                if (rm(this._source.type))
                    for (const t in this._tiles) {
                        const e = this._tiles[t];
                        if (void 0 !== e.fadeEndTime && e.fadeEndTime >= N.now())
                            return !0
                    }
                return !1
            }
            setFeatureState(t, e, r) {
                this._state.updateState(t = t || "_geojsonTileLayer", e, r);
            }
            removeFeatureState(t, e, r) {
                this._state.removeFeatureState(t = t || "_geojsonTileLayer", e, r);
            }
            getFeatureState(t, e) {
                return this._state.getState(t = t || "_geojsonTileLayer", e)
            }
            setDependencies(t, e, r) {
                const n = this._tiles[t];
                n && n.setDependencies(e, r);
            }
            reloadTilesForDependencies(t, e) {
                for (const r in this._tiles)
                    this._tiles[r].hasDependency(t, e) && this._reloadTile(r, "reloading");
                this._cache.filter((r => !r.hasDependency(t, e)));
            }
            _preloadTiles(t, e) {
                const r = new Map
                  , n = Array.isArray(t) ? t : [t]
                  , i = this.map.painter.terrain
                  , s = this.usedForTerrain && i ? i.getScaledDemTileSize() : this._source.tileSize;
                for (const t of n) {
                    const e = t.coveringTiles({
                        tileSize: s,
                        minzoom: this._source.minzoom,
                        maxzoom: this._source.maxzoom,
                        roundZoom: this._source.roundZoom && !this.usedForTerrain,
                        reparseOverscaled: this._source.reparseOverscaled,
                        isTerrainDEM: this.usedForTerrain,
                        reference: this._source.reference,
                        zoomRule: this._source.zoomRule,
                        sourceID: this._source.id
                    });
                    for (const t of e)
                        r.set(t.key, t);
                    this.usedForTerrain && t.updateElevation(!1);
                }
                g(Array.from(r.values()), ( (t, e) => {
                    const r = new Dy(t,this._source.tileSize * t.overscaleFactor(),this.transform.tileZoom,this.map.painter,this._isRaster);
                    this._loadTile(r, (t => {
                        "raster-dem" === this._source.type && r.dem && this._backfillDEM(r),
                        e(t, r);
                    }
                    ));
                }
                ), e);
            }
        }
        function em(t, e) {
            const r = Math.abs(2 * t.wrap) - +(t.wrap < 0)
              , n = Math.abs(2 * e.wrap) - +(e.wrap < 0);
            return t.overscaledZ - e.overscaledZ || n - r || e.canonical.y - t.canonical.y || e.canonical.x - t.canonical.x
        }
        function rm(t) {
            return "raster" === t || "image" === t || "video" === t
        }
        function nm(t, e) {
            const r = 1 << t.z;
            return [t.x / r + e, (t.x + 1) / r + e]
        }
        tm.maxOverzooming = 10,
        tm.maxUnderzooming = 3;
        class im {
            constructor(t, e, r) {
                this._demTile = t,
                this._dem = this._demTile.dem,
                this._scale = e,
                this._offset = r;
            }
            static create(t, e, r) {
                const n = r || t.findDEMTileFor(e);
                if (!n || !n.dem)
                    return;
                const i = n.dem
                  , s = n.tileID
                  , a = 1 << e.canonical.z - s.canonical.z;
                return new im(n,n.tileSize / bo / a,[(e.canonical.x / a - s.canonical.x) * i.dim, (e.canonical._tileY / a - s.canonical.y) * i.dim])
            }
            tileCoordToPixel(t, e) {
                const r = e * this._scale + this._offset[1]
                  , n = Math.floor(t * this._scale + this._offset[0])
                  , s = Math.floor(r);
                return new i(n,s)
            }
            getElevationAt(t, e, r, n) {
                const i = t * this._scale + this._offset[0]
                  , s = e * this._scale + this._offset[1]
                  , a = Math.floor(i)
                  , o = Math.floor(s)
                  , l = this._dem;
                return n = !!n,
                r ? mr(mr(l.get(a, o, n), l.get(a, o + 1, n), s - o), mr(l.get(a + 1, o, n), l.get(a + 1, o + 1, n), s - o), i - a) : l.get(a, o, n)
            }
            getElevationAtPixel(t, e, r) {
                return this._dem.get(t, e, !!r)
            }
            getMeterToDEM(t) {
                return (1 << this._demTile.tileID.canonical.z) * Jo(1, t) * this._dem.stride
            }
        }
        class sm {
            constructor(t, e) {
                this.tileID = t,
                this.x = t.canonical.x,
                this.y = t.canonical.y,
                this.z = t.canonical.z,
                this.grid = new Mi(bo,16,0),
                this.featureIndexArray = new Va,
                this.promoteId = e;
            }
            insert(t, e, r, n, i, s=0) {
                const a = this.featureIndexArray.length;
                this.featureIndexArray.emplaceBack(r, n, i, s);
                const o = this.grid;
                for (let t = 0; t < e.length; t++) {
                    const r = e[t]
                      , n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                    for (let t = 0; t < r.length; t++) {
                        const e = r[t];
                        n[0] = Math.min(n[0], e.x),
                        n[1] = Math.min(n[1], e.y),
                        n[2] = Math.max(n[2], e.x),
                        n[3] = Math.max(n[3], e.y);
                    }
                    n[0] < bo && n[1] < bo && n[2] >= 0 && n[3] >= 0 && o.insert(a, n[0], n[1], n[2], n[3]);
                }
            }
            loadVTLayers() {
                if (!this.vtLayers) {
                    let {canonical: t, reference: e, _tileY: r, _tileH: n} = this.tileID;
                    this.vtLayers = new _y.VectorTile(new op(this.rawTileData),null,{
                        reference: e,
                        _tileY: r,
                        _tileH: n,
                        x: t.x,
                        y: t.y,
                        z: t.z
                    }).layers,
                    this.sourceLayerCoder = new wy(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]),
                    this.vtFeatures = {};
                    for (const t in this.vtLayers)
                        this.vtFeatures[t] = [];
                }
                return this.vtLayers
            }
            query(t, e, r, n, i) {
                this.loadVTLayers();
                const s = t.params || {}
                  , a = Hn(s.filter)
                  , o = t.tileResult
                  , l = t.transform
                  , u = o.bufferedTilespaceBounds
                  , c = this.grid.query(u.min.x, u.min.y, u.max.x, u.max.y, ( (t, e, r, n) => Ll(o.bufferedTilespaceGeometry, t, e, r, n)));
                c.sort(om);
                let h = null;
                l.elevation && c.length > 0 && (h = im.create(l.elevation, this.tileID));
                const p = {};
                let f;
                for (let l = 0; l < c.length; l++) {
                    const u = c[l];
                    if (u === f)
                        continue;
                    f = u;
                    const d = this.featureIndexArray.get(u);
                    let y = null;
                    this.loadMatchingFeature(p, d, a, s.layers, s.availableImages, e, r, n, ( (e, r, n, s=0) => (y || (y = wl(e, this.tileID.canonical, t.tileTransform)),
                    r.queryIntersectsFeature(o, e, n, y, this.z, t.transform, t.pixelPosMatrix, h, s, i[r.id]))));
                }
                return p
            }
            loadMatchingFeature(t, e, r, n, i, s, a, o, l) {
                const {featureIndex: u, bucketIndex: c, sourceLayerIndex: h, layoutVertexArrayOffset: p} = e
                  , f = this.bucketLayerIDs[c];
                if (n && !function(t, e) {
                    for (let r = 0; r < t.length; r++)
                        if (e.indexOf(t[r]) >= 0)
                            return !0;
                    return !1
                }(n, f))
                    return;
                const d = this.sourceLayerCoder.decode(h)
                  , y = this.vtLayers[d].feature(u);
                if (r.needGeometry) {
                    const t = Al(y, !0);
                    if (!r.filter(new Ts(this.tileID.overscaledZ), t, this.tileID.canonical))
                        return
                } else if (!r.filter(new Ts(this.tileID.overscaledZ), y))
                    return;
                const m = this.getId(y, d);
                for (let e = 0; e < f.length; e++) {
                    const r = f[e];
                    if (n && n.indexOf(r) < 0)
                        continue;
                    const c = s[r];
                    if (!c)
                        continue;
                    let h = {};
                    void 0 !== m && o && (h = o.getState(c.sourceLayer || "_geojsonTileLayer", m));
                    const d = v({}, a[r]);
                    d.paint = am(d.paint, c.paint, y, h, i),
                    d.layout = am(d.layout, c.layout, y, h, i);
                    const g = !l || l(y, c, h, p);
                    if (!g)
                        continue;
                    const x = new ky(y,this.z,this.x,this.y,m);
                    x.layer = d;
                    let b = t[r];
                    void 0 === b && (b = t[r] = []),
                    b.push({
                        featureIndex: u,
                        feature: x,
                        intersectionZ: g
                    });
                }
            }
            lookupSymbolFeatures(t, e, r, n, i, s, a, o) {
                const l = {};
                this.loadVTLayers();
                const u = Hn(i);
                for (const i of t)
                    this.loadMatchingFeature(l, {
                        bucketIndex: r,
                        sourceLayerIndex: n,
                        featureIndex: i,
                        layoutVertexArrayOffset: 0
                    }, u, s, a, o, e);
                return l
            }
            loadFeature(t) {
                const {featureIndex: e, sourceLayerIndex: r} = t;
                this.loadVTLayers();
                const n = this.sourceLayerCoder.decode(r)
                  , i = this.vtFeatures[n];
                if (i[e])
                    return i[e];
                const s = this.vtLayers[n].feature(e);
                return i[e] = s,
                s
            }
            hasLayer(t) {
                for (const e of this.bucketLayerIDs)
                    for (const r of e)
                        if (t === r)
                            return !0;
                return !1
            }
            getId(t, e) {
                let r = t.id;
                return this.promoteId && (r = t.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e]],
                "boolean" == typeof r && (r = Number(r))),
                r
            }
        }
        function am(t, e, r, n, i) {
            return S(t, ( (t, s) => {
                const a = e instanceof Ls ? e.get(s) : null;
                return a && a.evaluate ? a.evaluate(r, n, i) : a
            }
            ))
        }
        function om(t, e) {
            return e - t
        }
        Bi(sm, "FeatureIndex", {
            omit: ["rawTileData", "sourceLayerCoder"]
        });
        class lm {
            constructor(t) {
                const e = {}
                  , r = [];
                for (const n in t) {
                    const i = t[n]
                      , s = e[n] = {};
                    for (const t in i.glyphs) {
                        const e = i.glyphs[+t];
                        if (!e || 0 === e.bitmap.width || 0 === e.bitmap.height)
                            continue;
                        const n = e.metrics.localGlyph ? 2 : 1
                          , a = {
                            x: 0,
                            y: 0,
                            w: e.bitmap.width + 2 * n,
                            h: e.bitmap.height + 2 * n
                        };
                        r.push(a),
                        s[t] = a;
                    }
                }
                const {w: n, h: i} = Bp(r)
                  , s = new Wu({
                    width: n || 1,
                    height: i || 1
                });
                for (const r in t) {
                    const n = t[r];
                    for (const t in n.glyphs) {
                        const i = n.glyphs[+t];
                        if (!i || 0 === i.bitmap.width || 0 === i.bitmap.height)
                            continue;
                        const a = e[r][t]
                          , o = i.metrics.localGlyph ? 2 : 1;
                        Wu.copy(i.bitmap, s, {
                            x: 0,
                            y: 0
                        }, {
                            x: a.x + o,
                            y: a.y + o
                        }, i.bitmap);
                    }
                }
                this.image = s,
                this.positions = e;
            }
        }
        Bi(lm, "GlyphAtlas");
        class um {
            constructor(t) {
                Xo(t.crs),
                this.tileID = new kh(t.tileID.overscaledZ,t.tileID.wrap,t.tileID.canonical.z,t.tileID.canonical.x,t.tileID.canonical.y,t.tileID),
                this.tileZoom = t.tileZoom,
                this.uid = t.uid,
                this.zoom = t.tileID._mapZoom || t.zoom,
                this.canonical = t.tileID.canonical,
                this.pixelRatio = t.pixelRatio,
                this.tileSize = t.tileSize,
                this.source = t.source,
                this.overscaling = this.tileID.overscaleFactor(),
                this.showCollisionBoxes = t.showCollisionBoxes,
                this.collectResourceTiming = !!t.collectResourceTiming,
                this.returnDependencies = !!t.returnDependencies,
                this.promoteId = t.promoteId,
                this.enableTerrain = !!t.enableTerrain,
                this.isSymbolTile = t.isSymbolTile,
                this.tileTransform = dd(t.tileID.canonical, t.projection),
                this.projection = t.projection;
            }
            parse(t, e, r, n, i) {
                let s = this.tileID
                  , a = s._mapZoom || this.zoom
                  , o = e._xml;
                const l = "Sg4326" == s.reference;
                let u = o && o["epgis-zoom-scale"];
                u && (a = a + u > 0 ? a + u : 1),
                this.status = "parsing",
                this.data = t,
                this.collisionBoxArray = new ka;
                const c = new wy(Object.keys(t.layers).sort())
                  , h = new sm(this.tileID,this.promoteId);
                h.bucketLayerIDs = [];
                const p = {}
                  , f = new fy(256,256)
                  , d = {
                    featureIndex: h,
                    iconDependencies: {},
                    patternDependencies: {},
                    glyphDependencies: {},
                    lineAtlas: f,
                    availableImages: r,
                    eleSymbolVertexs: {}
                }
                  , y = e.familiesBySource[this.source];
                for (const e in y) {
                    const n = t.layers[e];
                    if (!n)
                        continue;
                    let i = !1
                      , u = !1;
                    for (const t of y[e])
                        "symbol" === t[0].type ? i = !0 : u = !0;
                    if (!0 === this.isSymbolTile && !i)
                        continue;
                    if (!1 === this.isSymbolTile && !u)
                        continue;
                    const f = c.encode(e);
                    let x = []
                      , w = 0;
                    for (let t = 0; t < n.length; t++) {
                        let r = n.feature(t);
                        const i = h.getId(r, e);
                        if (l) {
                            var m = r.properties
                              , g = m.maxzoom
                              , v = m.minzoom
                              , b = 0
                              , _ = 25;
                            if (v >= 0 ? b = v <= 3 ? 0 : v - 1 : v = 0,
                            g >= 0 && (_ = g >= 19 ? 25 : g > b ? 3 == r.type ? g + 1 : g : b + 1),
                            a < b || a >= _)
                                continue;
                            if (null == (m = wt(m, o, a, l)))
                                continue
                        }
                        x.push({
                            feature: r,
                            id: i,
                            index: t,
                            sourceLayerIndex: f,
                            order: w
                        }),
                        w++;
                    }
                    if (x.length > 0) {
                        l && x.length > 1 && x[0].feature.properties.paintLevel && x.sort((function(t, e) {
                            return t.feature.properties.paintLevel - e.feature.properties.paintLevel
                        }
                        ));
                        for (let t = 0, n = y[e].length; t < n; t++) {
                            const n = y[e][t]
                              , i = n[0];
                            void 0 !== this.isSymbolTile && "symbol" === i.type !== this.isSymbolTile || i.minzoom && a < Math.floor(i.minzoom) || i.maxzoom && a >= i.maxzoom || "none" !== i.visibility && (cm(n, a, r),
                            (p[i.id] = i.createBucket({
                                index: h.bucketLayerIDs.length,
                                layers: n,
                                zoom: a,
                                canonical: this.canonical,
                                pixelRatio: this.pixelRatio,
                                overscaling: this.overscaling,
                                collisionBoxArray: this.collisionBoxArray,
                                sourceLayerIndex: f,
                                sourceID: this.source,
                                enableTerrain: this.enableTerrain,
                                projection: this.projection.spec,
                                availableImages: r
                            })).populate(x, d, s.canonical, this.tileTransform),
                            h.bucketLayerIDs.push(n.map((t => t.id))));
                        }
                    }
                }
                let w, A, k, z;
                f.trim();
                const M = {
                    type: "maybePrepare",
                    isSymbolTile: this.isSymbolTile,
                    zoom: this.zoom
                }
                  , I = S(d.glyphDependencies, (t => Object.keys(t).map(Number)));
                Object.keys(I).length ? n.send("getGlyphs", {
                    uid: this.uid,
                    stacks: I
                }, ( (t, e) => {
                    w || (w = t,
                    A = e,
                    P.call(this));
                }
                ), void 0, !1, M) : A = {};
                const T = Object.keys(d.iconDependencies);
                T.length ? n.send("getImages", {
                    icons: T,
                    source: this.source,
                    tileID: this.tileID,
                    type: "icons"
                }, ( (t, e) => {
                    w || (w = t,
                    k = e,
                    P.call(this));
                }
                ), void 0, !1, M) : k = {};
                const B = Object.keys(d.patternDependencies);
                let C;
                B.length ? n.send("getImages", {
                    icons: B,
                    source: this.source,
                    tileID: this.tileID,
                    type: "patterns"
                }, ( (t, e) => {
                    w || (w = t,
                    z = e,
                    P.call(this));
                }
                ), void 0, !1, M) : z = {};
                const V = Object.keys(d.eleSymbolVertexs);
                function P() {
                    if (w)
                        return i(w);
                    if (A && k && z && C) {
                        const t = new lm(A)
                          , e = new Vp(k,z);
                        for (const n in p) {
                            const i = p[n];
                            i instanceof Nd ? (cm(i.layers, this.zoom, r),
                            kf(i, A, t.positions, k, e.iconPositions, this.showCollisionBoxes, r, this.tileID.canonical, this.tileZoom, this.projection)) : i instanceof sy ? i.addFeatures(C, s.canonical, this.tileTransform) : i.hasPattern && (i instanceof Fh || i instanceof $c || i instanceof ch) && (cm(i.layers, a, r),
                            i.addFeatures(d, s.canonical, e.patternPositions, r, this.tileTransform));
                        }
                        this.status = "done",
                        i(null, {
                            buckets: x(p).filter((t => !t.isEmpty())),
                            featureIndex: h,
                            collisionBoxArray: this.collisionBoxArray,
                            glyphAtlasImage: t.image,
                            lineAtlas: f,
                            imageAtlas: e,
                            glyphMap: this.returnDependencies ? A : null,
                            iconMap: this.returnDependencies ? k : null,
                            glyphPositions: this.returnDependencies ? t.positions : null
                        });
                    }
                }
                V.length ? n.send("getEleSymbolVertexs", {
                    eleSymbolVertexs: V
                }, ( (t, e) => {
                    w || (w = t,
                    C = e,
                    P.call(this));
                }
                ), void 0, void 0, M) : C = {},
                P.call(this);
            }
        }
        function cm(t, e, r) {
            const n = new Ts(e);
            for (const e of t)
                e.recalculate(n, r);
        }
        class hm {
            constructor(t) {
                this.entries = {},
                this.scheduler = t;
            }
            request(t, e, r, n) {
                const i = this.entries[t] = this.entries[t] || {
                    callbacks: []
                };
                if (i.result) {
                    const [t,r] = i.result;
                    return this.scheduler ? this.scheduler.add(( () => {
                        n(t, r);
                    }
                    ), e) : n(t, r),
                    () => {}
                }
                return i.callbacks.push(n),
                i.cancel || (i.cancel = r(( (r, n) => {
                    i.result = [r, n];
                    for (const t of i.callbacks)
                        this.scheduler ? this.scheduler.add(( () => {
                            t(r, n);
                        }
                        ), e) : t(r, n);
                    setTimeout(( () => delete this.entries[t]), 3e3);
                }
                ))),
                () => {
                    i.result || (i.callbacks = i.callbacks.filter((t => t !== n)),
                    i.callbacks.length || (i.cancel(),
                    delete this.entries[t]));
                }
            }
        }
        function pm(t, e, r) {
            const n = JSON.stringify(t.request);
            return t.data && (this.deduped.entries[n] = {
                result: [null, t.data]
            }),
            this.deduped.request(n, {
                type: "parseTile",
                isSymbolTile: t.isSymbolTile,
                zoom: t.tileZoom
            }, (e => {
                const n = Vt(t.request, ( (n, i, s, a) => {
                    if (n)
                        e(n);
                    else if (i) {
                        let {canonical: n, reference: o, _tileY: l, _tileH: u} = t.tileID;
                        e(null, {
                            vectorTile: r ? void 0 : new _y.VectorTile(new op(i),null,{
                                reference: o,
                                _tileY: l,
                                _tileH: u,
                                x: n.x,
                                y: n.y,
                                z: n.z
                            }),
                            rawData: i,
                            cacheControl: s,
                            expires: a
                        });
                    }
                }
                ));
                return () => {
                    n.cancel(),
                    e();
                }
            }
            ), e)
        }
        var fm = ["background", "symbol", "line", "fill", "fill-extrusion", "circle", "heatmap", "raster", "hillshade", "esymbol"]
          , dm = []
          , ym = []
          , mm = ""
          , gm = []
          , xm = [];
        t.ARRAY_TYPE = Gl,
        t.Aabb = $u,
        t.Actor = class {
            constructor(t, r, n) {
                this.target = t,
                this.parent = r,
                this.mapId = n,
                this.callbacks = {},
                this.cancelCallbacks = {},
                k(["receive"], this),
                this.target.addEventListener("message", this.receive, !1),
                this.globalScope = P() ? t : e,
                this.scheduler = new yy;
            }
            send(t, e, r, n, i=!1, s) {
                const a = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
                r && (r.metadata = s,
                this.callbacks[a] = r);
                const o = F(this.globalScope) ? void 0 : [];
                var l;
                return (l = e) && "undefined" != typeof ArrayBuffer && (l instanceof ArrayBuffer || l.constructor && "ArrayBuffer" === l.constructor.name) && (e = e.slice(0)),
                this.target.postMessage({
                    id: a,
                    type: t,
                    hasCallback: !!r,
                    targetMapId: n,
                    mustQueue: i,
                    sourceMapId: this.mapId,
                    data: Pi(e, o)
                }, o),
                {
                    cancel: () => {
                        r && delete this.callbacks[a],
                        this.target.postMessage({
                            id: a,
                            type: "<cancel>",
                            targetMapId: n,
                            sourceMapId: this.mapId
                        });
                    }
                }
            }
            receive(t) {
                const e = t.data
                  , r = e.id;
                if (r && (!e.targetMapId || this.mapId === e.targetMapId))
                    if ("<cancel>" === e.type) {
                        const t = this.cancelCallbacks[r];
                        delete this.cancelCallbacks[r],
                        t && t.cancel();
                    } else if (e.mustQueue || P()) {
                        const t = this.callbacks[r];
                        this.cancelCallbacks[r] = this.scheduler.add(( () => this.processTask(r, e)), t && t.metadata || {
                            type: "message"
                        });
                    } else
                        this.processTask(r, e);
            }
            processTask(t, e) {
                if ("<response>" === e.type) {
                    const r = this.callbacks[t];
                    delete this.callbacks[t],
                    r && (e.error ? r(Di(e.error)) : r(null, Di(e.data)));
                } else {
                    const r = F(this.globalScope) ? void 0 : []
                      , n = e.hasCallback ? (e, n) => {
                        delete this.cancelCallbacks[t],
                        this.target.postMessage({
                            id: t,
                            type: "<response>",
                            sourceMapId: this.mapId,
                            error: e ? Pi(e) : null,
                            data: Pi(n, r)
                        }, r);
                    }
                    : t => {}
                      , i = Di(e.data);
                    if (this.parent[e.type])
                        this.parent[e.type](e.sourceMapId, i, n);
                    else if (this.parent.getWorkerSource) {
                        const t = e.type.split(".");
                        this.parent.getWorkerSource(e.sourceMapId, t[0], i.source)[t[1]](i, n);
                    } else
                        n(new Error(`Could not find function ${e.type}`));
                }
            }
            remove() {
                this.scheduler.remove(),
                this.target.removeEventListener("message", this.receive, !1);
            }
        }
        ,
        t.BufferTostyle = function(t) {
            function e(t, e, n) {
                e[xm[t]] = n.readMessage(r, {}),
                delete e[xm[t]].zoomRange;
            }
            function r(t, e, r) {
                0 === t ? e.zoomRange = r.readString().split(",").map((t => t.replace(/_/g, ","))) : e[e.zoomRange[t - 1]] = r.readMessage(n, {});
            }
            function n(t, e, r) {
                e[gm[t]] = JSON.parse(r.readString());
            }
            function i(t, e, r) {
                e[t] = r.readMessage(s, {});
            }
            function s(t, e, r) {
                1 === t && (e.id = r.readString()),
                2 === t && (e.type = fm[r.readVarint()]),
                3 === t && (e.source = mm[r.readVarint()]),
                4 === t && (e["source-layer"] = r.readString()),
                5 === t && (e.minzoom = r.readVarint()),
                6 === t && (e.maxzoom = r.readVarint()),
                7 === t && (e.layout = r.readMessage(a, {})),
                8 === t && (e.paint = r.readMessage(o, {})),
                9 === t && (e.filter = JSON.parse(r.readString()));
            }
            function a(t, e, r) {
                e[dm[t]] = JSON.parse(r.readString());
            }
            function o(t, e, r) {
                e[ym[t]] = JSON.parse(r.readString());
            }
            var l = t.readFields((function(t, r, n) {
                1 === t ? (r._layout = n.readString().split(","),
                dm = r._layout) : 2 === t ? (r._paint = n.readString().split(","),
                ym = r._paint) : 3 === t ? (r._source = n.readString(),
                mm = r._source.split(",")) : 4 === t ? r.layers = n.readMessage(i, []) : 5 === t ? r.created = n.readString() : 6 === t ? r.draft = n.readBoolean() : 7 === t ? r.glyphs = n.readString() : 8 === t ? r.id = n.readString() : 9 === t ? r.modified = n.readString() : 10 === t ? r.owner = n.readString() : 11 === t ? r.scheme = n.readString() : 12 === t ? r.sources = JSON.parse(n.readString()) : 13 === t ? r.sprite = n.readString() : 14 === t ? r.type = n.readString() : 15 === t ? r.url = n.readString() : 16 === t ? r.version = n.readVarint() : 17 === t ? r.minZoom = n.readVarint() : 18 === t ? r.maxZoom = n.readVarint() : 19 === t ? (r._xml_keys = n.readString().split(","),
                gm = r._xml_keys) : 20 === t ? (r._xml_ids = n.readString().split(","),
                xm = r._xml_ids) : 21 === t && (r.xml = n.readMessage(e, {}));
            }
            ), {});
            return delete l._paint,
            delete l._layout,
            delete l._source,
            delete l._xml_keys,
            delete l._xml_ids,
            l
        }
        ,
        t.CanonicalTileID = wh,
        t.Color = me,
        t.ColorMode = Ky,
        t.CullFaceMode = Qy,
        t.DEMData = Zy,
        t.DataConstantProperty = Rs,
        t.DedupedRequest = hm,
        t.DepthMode = Xy,
        t.EXTENT = bo,
        t.Elevation = class {
            isDataAvailableAtPoint(t) {
                const e = this._source();
                if (this.isUsingMockSource() || !e || t.y < 0 || t.y > 1)
                    return !1;
                const r = e.getSource().maxzoom
                  , n = 1 << r
                  , i = Math.floor(t.x)
                  , s = Math.floor((t.x - i) * n)
                  , a = Math.floor(t.y * n)
                  , o = this.findDEMTileFor(new kh(r,i,r,s,a));
                return !(!o || !o.dem)
            }
            getAtPointOrZero(t, e=0) {
                return this.getAtPoint(t, e) || 0
            }
            getAtPoint(t, e, r=!0) {
                if (this.isUsingMockSource())
                    return null;
                null == e && (e = null);
                const n = this._source();
                if (!n)
                    return e;
                if (t.y < 0 || t.y > 1)
                    return e;
                const i = n.getSource().maxzoom
                  , s = 1 << i
                  , a = Math.floor(t.x)
                  , o = t.x - a
                  , l = new kh(i,a,i,Math.floor(o * s),Math.floor(t.y * s))
                  , u = this.findDEMTileFor(l);
                if (!u || !u.dem)
                    return e;
                const c = u.dem
                  , h = 1 << u.tileID.canonical.z
                  , p = (o * h - u.tileID.canonical.x) * c.dim
                  , f = (t.y * h - u.tileID.canonical.y) * c.dim
                  , d = Math.floor(p)
                  , y = Math.floor(f);
                return (r ? this.exaggeration() : 1) * mr(mr(c.get(d, y), c.get(d, y + 1), f - y), mr(c.get(d + 1, y), c.get(d + 1, y + 1), f - y), p - d)
            }
            getAtTileOffset(t, e, r) {
                const n = 1 << t.canonical.z;
                return this.getAtPointOrZero(new nl(t.wrap + (t.canonical.x + e / bo) / n,gl(r, t.canonical) / n))
            }
            getAtTileOffsetFunc(t, e, r, n) {
                return i => {
                    const s = this.getAtTileOffset(t, i.x, i.y)
                      , a = n.upVector(t.canonical, i.x, i.y);
                    return du(a, a, s * n.upVectorScale(t.canonical, e, r).metersToTile),
                    a
                }
            }
            getForTilePoints(t, e, r, n) {
                if (this.isUsingMockSource())
                    return !1;
                const i = im.create(this, t, n);
                return !!i && (e.forEach((t => {
                    t[2] = this.exaggeration() * i.getElevationAt(t[0], t[1], r);
                }
                )),
                !0)
            }
            getMinMaxForTile(t) {
                if (this.isUsingMockSource())
                    return null;
                const e = this.findDEMTileFor(t);
                if (!e || !e.dem)
                    return null;
                const r = e.dem.tree
                  , n = e.tileID
                  , i = 1 << t.canonical.z - n.canonical.z;
                let s = t.canonical.x / i - n.canonical.x
                  , a = t.canonical._tileY / i - n.canonical.y
                  , o = 0;
                for (let e = 0; e < t.canonical.z - n.canonical.z && !r.leaves[o]; e++) {
                    s *= 2,
                    a *= 2;
                    const t = 2 * Math.floor(a) + Math.floor(s);
                    o = r.childOffsets[o] + t,
                    s %= 1,
                    a %= 1;
                }
                return {
                    min: this.exaggeration() * r.minimums[o],
                    max: this.exaggeration() * r.maximums[o]
                }
            }
            getMinElevationBelowMSL() {
                throw new Error("Pure virtual method called.")
            }
            raycast(t, e, r) {
                throw new Error("Pure virtual method called.")
            }
            pointCoordinate(t) {
                throw new Error("Pure virtual method called.")
            }
            _source() {
                throw new Error("Pure virtual method called.")
            }
            isUsingMockSource() {
                throw new Error("Pure virtual method called.")
            }
            exaggeration() {
                throw new Error("Pure virtual method called.")
            }
            findDEMTileFor(t) {
                throw new Error("Pure virtual method called.")
            }
            get visibleDemTiles() {
                throw new Error("Getter must be implemented in subclass.")
            }
        }
        ,
        t.ErrorEvent = Ot,
        t.EvaluationParameters = Ts,
        t.Event = Ut,
        t.Evented = $t,
        t.FillExtrusionBucket = ch,
        t.Frustum = Ou,
        t.FrustumCorners = Uu,
        t.GLOBE_METERS_TO_ECEF = Rf,
        t.GLOBE_RADIUS = Lf,
        t.GLOBE_SCALE_MATCH_LATITUDE = 45,
        t.GLOBE_ZOOM_THRESHOLD_MAX = 6,
        t.GLOBE_ZOOM_THRESHOLD_MIN = 5,
        t.GlobeSharedBuffers = class {
            constructor(t) {
                this._createGrid(t),
                this._createPoles(t);
            }
            destroy() {
                this._poleIndexBuffer.destroy(),
                this._gridBuffer.destroy(),
                this._gridIndexBuffer.destroy(),
                this._poleNorthVertexBuffer.destroy(),
                this._poleSouthVertexBuffer.destroy();
                for (const t of this._poleSegments)
                    t.destroy();
                for (const t of this._gridSegments)
                    t.destroy();
                if (this._wireframeIndexBuffer) {
                    this._wireframeIndexBuffer.destroy();
                    for (const t of this._wireframeSegments)
                        t.destroy();
                }
            }
            _createGrid(t) {
                const e = new Ks
                  , r = new pa
                  , n = 65;
                for (let t = 0; t < n; t++)
                    for (let r = 0; r < n; r++)
                        e.emplaceBack(r, t);
                this._gridSegments = [];
                for (let t = 0, e = 0; t < Uf.length; t++) {
                    const i = Uf[t];
                    for (let t = 0; t < i; t++)
                        for (let e = 0; e < 64; e++) {
                            const i = t * n + e;
                            r.emplaceBack(i + 1, i, i + n),
                            r.emplaceBack(i + n, i + n + 1, i + 1);
                        }
                    const s = 64 * i * 2;
                    this._gridSegments.push(vo.simpleSegment(0, e, (i + 1) * n, s)),
                    e += s;
                }
                this._gridBuffer = t.createVertexBuffer(e, Ff.members),
                this._gridIndexBuffer = t.createIndexBuffer(r, !0);
            }
            _createPoles(t) {
                const e = new pa;
                for (let t = 0; t <= jf; t++)
                    e.emplaceBack(0, t + 1, t + 2);
                this._poleIndexBuffer = t.createIndexBuffer(e, !0);
                const r = new ma
                  , n = new ma;
                this._poleSegments = [];
                for (let t = 0, e = 0; t < 5; t++) {
                    const i = 360 / (1 << t);
                    r.emplaceBack(0, -Lf, 0, .5, 0),
                    n.emplaceBack(0, -Lf, 0, .5, 1);
                    for (let t = 0; t <= jf; t++) {
                        const e = t / jf
                          , s = mr(0, i, e)
                          , [a,o,l] = td(hd, pd, s, Lf);
                        r.emplaceBack(a, o, l, e, 0),
                        n.emplaceBack(a, o, l, e, 1);
                    }
                    this._poleSegments.push(vo.simpleSegment(e, 0, 66, 64)),
                    e += 66;
                }
                this._poleNorthVertexBuffer = t.createVertexBuffer(r, Df, !1),
                this._poleSouthVertexBuffer = t.createVertexBuffer(n, Df, !1);
            }
            getGridBuffers(t) {
                return [this._gridBuffer, this._gridIndexBuffer, this._gridSegments[t]]
            }
            getPoleBuffers(t) {
                return [this._poleNorthVertexBuffer, this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[t]]
            }
            getWirefameBuffers(t, e) {
                if (!this._wireframeSegments) {
                    const e = new xa
                      , r = jf
                      , n = r + 1;
                    this._wireframeSegments = [];
                    for (let t = 0, i = 0; t < Uf.length; t++) {
                        const s = Uf[t];
                        for (let t = 0; t < s; t++)
                            for (let i = 0; i < r; i++) {
                                const r = t * n + i;
                                e.emplaceBack(r, r + 1),
                                e.emplaceBack(r, r + n),
                                e.emplaceBack(r, r + n + 1);
                            }
                        const a = s * r * 3;
                        this._wireframeSegments.push(vo.simpleSegment(0, i, (s + 1) * n, a)),
                        i += a;
                    }
                    this._wireframeIndexBuffer = t.createIndexBuffer(e);
                }
                return [this._gridBuffer, this._wireframeIndexBuffer, this._wireframeSegments[e]]
            }
        }
        ,
        t.GlyphManager = uf,
        t.ImagePosition = Cp,
        t.LineAtlas = fy,
        t.LngLat = Ao,
        t.LngLatBounds = _o,
        t.LocalGlyphMode = lf,
        t.MAX_MERCATOR_LATITUDE = el,
        t.MercatorCoordinate = nl,
        t.MercatorTileY = ml,
        t.ONE_EM = Hh,
        t.OverscaledTileID = kh,
        t.Properties = qs,
        t.RGBAImage = Qu,
        t.Ray = ju,
        t.RequestManager = class {
            constructor(t, e, r) {
                this._transformRequestFn = t,
                this._silenceAuthErrors = !!r,
                this._createSkuToken();
            }
            _createSkuToken() {
                const t = function() {
                    let t = "";
                    for (let e = 0; e < 10; e++)
                        t += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
                    return {
                        token: ["1", W, t].join(""),
                        tokenExpiresAt: Date.now() + 432e5
                    }
                }();
                this._skuToken = t.token,
                this._skuTokenExpiresAt = t.tokenExpiresAt;
            }
            _isSkuTokenExpired() {
                return Date.now() > this._skuTokenExpiresAt
            }
            transformRequest(t, e) {
                return this._transformRequestFn && this._transformRequestFn(t, e) || {
                    url: t
                }
            }
            normalizeStyleURL(t, e) {
                if (!Q(t))
                    return t;
                const r = it(t);
                return r.path = `/styles/v1${r.path}`,
                this._makeAPIURL(r, this._customAccessToken || e)
            }
            normalizeGlyphsURL(t, e) {
                if (!function(t) {
                    return 0 === t.indexOf("aegis:")
                }(t))
                    return t;
                const r = it(t);
                return r.path = `/fonts/v1${r.path}`,
                this._makeAPIURL(r, this._customAccessToken || e)
            }
            normalizeSourceURL(t, e, r, n) {
                if (!Q(t))
                    return t;
                const i = it(t);
                return i.path = `/v1/${i.authority}.json`,
                r && i.params.push(`language=${r}`),
                n && i.params.push(`worldview=${n}`),
                this._makeAPIURL(i, this._customAccessToken || e)
            }
            normalizeSpriteURL(t, e, r, n) {
                const i = it(t);
                return Q(t) ? (i.path = `/styles/v1${i.path}/sprite${e}${r}`,
                this._makeAPIURL(i, this._customAccessToken || n)) : (i.path += `${e}${r}`,
                st(i))
            }
            normalizeTileURL(t, e, r) {
                if (t && !Q(t) && !et(t))
                    return t;
                const n = it(t);
                n.path = n.path.replace(/(\.(png|jpg)\d*)(?=$)/, "$1"),
                n.path = `${n.path}`;
                const i = this._customAccessToken || rt(n.params) || Z.ACCESS_TOKEN;
                return rt(n.params) || n.params.push(`access_token=${i}`),
                st(n)
            }
            canonicalizeTileURL(t, e) {
                const r = it(t);
                if (!r.path.match(/(^\/v4\/)/) || !r.path.match(/\.[\w]+$/))
                    return t;
                let n = "sgmap://tiles/";
                n += r.path.replace("/v4/", "");
                let i = r.params;
                return e && (i = i.filter((t => !t.match(/^access_token=/)))),
                i.length && (n += `?${i.join("&")}`),
                n
            }
            canonicalizeTileset(t, e) {
                const r = !!e && Q(e)
                  , n = [];
                for (const e of t.tiles || [])
                    et(e) ? n.push("Sg4326" == t.reference ? this.normalizeTilesURL(e, r) : this.canonicalizeTileURL(e, r)) : n.push(e);
                return n
            }
            normalizeTilesURL(t, e) {
                if (0 !== t.indexOf("aegis:"))
                    return t;
                const r = it(t);
                r.path = `/v1${r.path}`;
                const n = it(Z.API_URL);
                return r.protocol = n.protocol,
                r.authority = n.authority,
                st(r)
            }
            _makeAPIURL(t, e) {
                const r = it(Z.API_URL);
                if (t.protocol = r.protocol,
                t.authority = r.authority,
                "/" !== r.path && (t.path = `${r.path}${t.path}`),
                !(e = e || Z.ACCESS_TOKEN))
                    throw new Error("请参考. See https://map.sgcc.com.cn/products/js-sdk/v3/# 进行登陆后获取资源");
                return t.params = t.params.filter((t => -1 === t.indexOf("access_token"))),
                t.params.push(`access_token=${e || ""}`),
                st(t)
            }
        }
        ,
        t.ResourceType = zt,
        t.SegmentVector = vo,
        t.SourceCache = tm,
        t.StencilMode = Hy,
        t.StructArrayLayout1ui2 = va,
        t.StructArrayLayout2f1f2i16 = ua,
        t.StructArrayLayout2i4 = Ks,
        t.StructArrayLayout2ui4 = xa,
        t.StructArrayLayout3f12 = ha,
        t.StructArrayLayout3ui6 = pa,
        t.StructArrayLayout4i8 = Ws,
        t.StructArrayLayout5f20 = ma,
        t.Texture = py,
        t.Tile = Dy,
        t.Transitionable = Vs,
        t.Uniform1f = Ha,
        t.Uniform1i = class extends Ya {
            constructor(t) {
                super(t),
                this.current = 0;
            }
            set(t, e, r) {
                this.fetchUniformLocation(t, e) && this.current !== r && (this.current = r,
                this.gl.uniform1i(this.location, r));
            }
        }
        ,
        t.Uniform2f = class extends Ya {
            constructor(t) {
                super(t),
                this.current = [0, 0];
            }
            set(t, e, r) {
                this.fetchUniformLocation(t, e) && (r[0] === this.current[0] && r[1] === this.current[1] || (this.current = r,
                this.gl.uniform2f(this.location, r[0], r[1])));
            }
        }
        ,
        t.Uniform3f = class extends Ya {
            constructor(t) {
                super(t),
                this.current = [0, 0, 0];
            }
            set(t, e, r) {
                this.fetchUniformLocation(t, e) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] || (this.current = r,
                this.gl.uniform3f(this.location, r[0], r[1], r[2])));
            }
        }
        ,
        t.Uniform4f = Ka,
        t.UniformColor = Ja,
        t.UniformMatrix2f = class extends Ya {
            constructor(t) {
                super(t),
                this.current = to;
            }
            set(t, e, r) {
                if (this.fetchUniformLocation(t, e))
                    for (let t = 0; t < 4; t++)
                        if (r[t] !== this.current[t]) {
                            this.current = r,
                            this.gl.uniformMatrix2fv(this.location, !1, r);
                            break
                        }
            }
        }
        ,
        t.UniformMatrix3f = class extends Ya {
            constructor(t) {
                super(t),
                this.current = Qa;
            }
            set(t, e, r) {
                if (this.fetchUniformLocation(t, e))
                    for (let t = 0; t < 9; t++)
                        if (r[t] !== this.current[t]) {
                            this.current = r,
                            this.gl.uniformMatrix3fv(this.location, !1, r);
                            break
                        }
            }
        }
        ,
        t.UniformMatrix4f = class extends Ya {
            constructor(t) {
                super(t),
                this.current = Wa;
            }
            set(t, e, r) {
                if (this.fetchUniformLocation(t, e)) {
                    if (r[12] !== this.current[12] || r[0] !== this.current[0])
                        return this.current = r,
                        void this.gl.uniformMatrix4fv(this.location, !1, r);
                    for (let t = 1; t < 16; t++)
                        if (r[t] !== this.current[t]) {
                            this.current = r,
                            this.gl.uniformMatrix4fv(this.location, !1, r);
                            break
                        }
                }
            }
        }
        ,
        t.UnwrappedTileID = Ah,
        t.ValidationError = Un,
        t.VectorTileWorkerSource = class extends $t {
            constructor(t, e, r, n, i) {
                super(),
                this.actor = t,
                this.layerIndex = e,
                this.availableImages = r,
                this.loadVectorData = i || pm,
                this.loading = {},
                this.loaded = {},
                this.deduped = new hm(t.scheduler),
                this.isSpriteLoaded = n,
                this.scheduler = t.scheduler;
            }
            loadTile(t, e) {
                const r = t.uid
                  , n = t && t.request
                  , i = n && n.collectResourceTiming
                  , s = this.loading[r] = new um(t);
                s.abort = this.loadVectorData(t, ( (a, o) => {
                    const l = !this.loading[r];
                    if (delete this.loading[r],
                    l || a || !o)
                        return s.status = "done",
                        l || (this.loaded[r] = s),
                        e(a);
                    const u = o.rawData
                      , c = {};
                    o.expires && (c.expires = o.expires),
                    o.cacheControl && (c.cacheControl = o.cacheControl);
                    let {canonical: h, reference: p, _tileY: f, _tileH: d} = t.tileID;
                    s.vectorTile = o.vectorTile || new _y.VectorTile(new op(u),null,{
                        reference: p,
                        _tileY: f,
                        _tileH: d,
                        x: h.x,
                        y: h.y,
                        z: h.z
                    });
                    const y = () => {
                        s.parse(s.vectorTile, this.layerIndex, this.availableImages, this.actor, ( (t, r) => {
                            if (t || !r)
                                return e(t);
                            const s = {};
                            if (i) {
                                const t = j(n);
                                t.length > 0 && (s.resourceTiming = JSON.parse(JSON.stringify(t)));
                            }
                            e(null, v({
                                rawTileData: u.slice(0)
                            }, r, c, s));
                        }
                        ));
                    }
                    ;
                    this.isSpriteLoaded ? y() : this.once("isSpriteLoaded", ( () => {
                        this.scheduler ? this.scheduler.add(y, {
                            type: "parseTile",
                            isSymbolTile: t.isSymbolTile,
                            zoom: t.tileZoom
                        }) : y();
                    }
                    )),
                    this.loaded = this.loaded || {},
                    this.loaded[r] = s;
                }
                ));
            }
            reloadTile(t, e) {
                const r = this.loaded
                  , n = t.uid
                  , i = this;
                if (r && r[n]) {
                    const s = r[n];
                    s.showCollisionBoxes = t.showCollisionBoxes,
                    s.enableTerrain = !!t.enableTerrain,
                    s.projection = t.projection,
                    s.tileTransform = dd(t.tileID.canonical, t.projection),
                    s.tileID = t.tileID;
                    const a = (t, r) => {
                        const n = s.reloadCallback;
                        n && (delete s.reloadCallback,
                        s.parse(s.vectorTile, i.layerIndex, this.availableImages, i.actor, n)),
                        e(t, r);
                    }
                    ;
                    "parsing" === s.status ? s.reloadCallback = a : "done" === s.status && (s.vectorTile ? s.parse(s.vectorTile, this.layerIndex, this.availableImages, this.actor, a) : a());
                }
            }
            abortTile(t, e) {
                const r = t.uid
                  , n = this.loading[r];
                n && (n.abort && n.abort(),
                delete this.loading[r]),
                e();
            }
            removeTile(t, e) {
                const r = this.loaded
                  , n = t.uid;
                r && r[n] && delete r[n],
                e();
            }
        }
        ,
        t.WritingMode = Pp,
        t.ZoomHistory = Ei,
        t._addCustomSource = function(t) {
            !kt(t) && At.push(t);
        }
        ,
        t._removeCustomSource = function(t) {
            kt(t) && At.splice(At.indexOf(t), 1);
        }
        ,
        t.add = uu,
        t.addDynamicAttributes = Ud,
        t.adjoint = function(t, e) {
            var r = e[0]
              , n = e[1]
              , i = e[2]
              , s = e[3]
              , a = e[4]
              , o = e[5]
              , l = e[6]
              , u = e[7]
              , c = e[8];
            return t[0] = a * c - o * u,
            t[1] = i * u - n * c,
            t[2] = n * o - i * a,
            t[3] = o * l - s * c,
            t[4] = r * c - i * l,
            t[5] = i * s - r * o,
            t[6] = s * u - a * l,
            t[7] = n * l - r * u,
            t[8] = r * a - n * s,
            t
        }
        ,
        t.asyncAll = g,
        t.bezier = p,
        t.bindAll = k,
        t.boundsAttributes = Vy,
        t.bufferConvexPolygon = function(t, e) {
            const r = [];
            for (let n = 0; n < t.length; n++) {
                const i = m(n - 1, -1, t.length - 1)
                  , s = m(n + 1, -1, t.length - 1)
                  , a = t[n]
                  , o = t[s]
                  , l = t[i].sub(a).unit()
                  , u = o.sub(a).unit()
                  , c = u.angleWithSep(l.x, l.y)
                  , h = l.add(u).unit().mult(-1 * e / Math.sin(c / 2));
                r.push(a.add(h));
            }
            return r
        }
        ,
        t.cacheEntryPossiblyAdded = function(t) {
            yt++,
            yt > lt && (t.getActor().send("enforceCacheSizeLimit", ot),
            yt = 0);
        }
        ,
        t.calculateGlobeLabelMatrix = function(t, e) {
            const {x: r, y: n} = t.point
              , i = od(r, n, t.worldSize / t._pixelsPerMercatorPixel, 0, 0);
            return Jl(i, i, ad(Xf(e)))
        }
        ,
        t.calculateGlobeMatrix = function(t) {
            const {x: e, y: r} = t.point
              , {lng: n, lat: i} = t._center;
            return od(e, r, t.worldSize, n, i)
        }
        ,
        t.calculateGlobeMercatorMatrix = function(t) {
            const e = t.pixelsPerMeter
              , r = e / Jo(1, t.center.lat)
              , n = Hl(new Float64Array(16));
            return Wl(n, n, [t.point.x, t.point.y, 0]),
            Ql(n, n, [r, r, e]),
            Float32Array.from(n)
        }
        ,
        t.changeCrs = Xo,
        t.checkCustomTileSource = function(t, e, r) {
            if ("raster" != e.type && "raster-dem" != e.type)
                return;
            let n = e.tiles;
            if (!n)
                return;
            if (kt(t))
                return void (e.tilesecurity = !1);
            let i = !0;
            for (let t = 0; t < n.length; t++)
                if (n[t] && !n[t].split("?")[0].match(/\.sg$/)) {
                    i = !1;
                    break
                }
            if (!i)
                throw delete r._userDatas.sources[t],
                new Error(`source:${t} 非标准数据源`);
            e.tilesecurity = !0;
        }
        ,
        t.circumferenceAtLatitude = function(t) {
            return Zo[Z.crs || Go].circumferenceAtLatitude(t)
        }
        ,
        t.clamp = d,
        t.clearTileCache = function(t) {
            const e = ht()
              , r = [];
            for (const t in ut)
                e && r.push(e.delete(t)),
                delete ut[t];
            t && Promise.all(r).catch(t).then(( () => t()));
        }
        ,
        t.clipLine = nf,
        t.clone = function(t) {
            var e = new Gl(16);
            return e[0] = t[0],
            e[1] = t[1],
            e[2] = t[2],
            e[3] = t[3],
            e[4] = t[4],
            e[5] = t[5],
            e[6] = t[6],
            e[7] = t[7],
            e[8] = t[8],
            e[9] = t[9],
            e[10] = t[10],
            e[11] = t[11],
            e[12] = t[12],
            e[13] = t[13],
            e[14] = t[14],
            e[15] = t[15],
            e
        }
        ,
        t.clone$1 = I,
        t.collisionCircleLayout = Yh,
        t.config = Z,
        t.conjugate = function(t, e) {
            return t[0] = -e[0],
            t[1] = -e[1],
            t[2] = -e[2],
            t[3] = e[3],
            t
        }
        ,
        t.create = function() {
            var t = new Gl(16);
            return Gl != Float32Array && (t[1] = 0,
            t[2] = 0,
            t[3] = 0,
            t[4] = 0,
            t[6] = 0,
            t[7] = 0,
            t[8] = 0,
            t[9] = 0,
            t[11] = 0,
            t[12] = 0,
            t[13] = 0,
            t[14] = 0),
            t[0] = 1,
            t[5] = 1,
            t[10] = 1,
            t[15] = 1,
            t
        }
        ,
        t.create$1 = Xl,
        t.createCommonjsModule = fe,
        t.createExpression = Dn,
        t.createLayout = Ys,
        t.createStyleLayer = function(t) {
            return "custom" === t.type ? new Jd(t) : new hy[t.type](t)
        }
        ,
        t.cross = xu,
        t.decodeFeatures = t => {
            t.features && t.features.length > 0 && (t => {
                const e = t => Array.isArray(t) ? e(t[0]) : "string" == typeof t && isNaN(t);
                return e(t.coordinates)
            }
            )(t.features[0].geometry) && t.features.forEach((t => {
                (t => {
                    const e = _t(t.geometry.coordinates);
                    t.geometry.coordinates = e;
                }
                )(t);
            }
            ));
        }
        ,
        t.degToRad = l,
        t.distance = function(t, e) {
            return Math.hypot(e[0] - t[0], e[1] - t[1], e[2] - t[2])
        }
        ,
        t.div = function(t, e, r) {
            return t[0] = e[0] / r[0],
            t[1] = e[1] / r[1],
            t[2] = e[2] / r[2],
            t
        }
        ,
        t.dot = gu,
        t.ease = f,
        t.easeCubicInOut = h,
        t.emitValidationErrors = Si,
        t.endsWith = z,
        t.enforceCacheSizeLimit = function(t) {
            for (const e in ut)
                pt(e),
                ut[e].then((e => {
                    e.keys().then((r => {
                        for (let n = 0; n < r.length - t; n++)
                            e.delete(r[n]);
                    }
                    ));
                }
                ));
        }
        ,
        t.evaluateSizeForFeature = Wh,
        t.evaluateSizeForZoom = Qh,
        t.evaluateVariableOffset = Af,
        t.evented = zs,
        t.exactEquals = function(t, e) {
            return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3]
        }
        ,
        t.exactEquals$1 = function(t, e) {
            return t[0] === e[0] && t[1] === e[1] && t[2] === e[2]
        }
        ,
        t.exported = N,
        t.exported$1 = G,
        t.extend = v,
        t.extend$1 = Nt,
        t.fillExtrusionHeightLift = gh,
        t.filterObject = M,
        t.formatAjax = t => "string" == typeof t ? {
            method: "GET",
            url: t
        } : (t.method || (t.method = "GET"),
        t.data && (t.body = t.body ? {
            ...t.data,
            ...t.body
        } : t.data,
        delete t.data),
        "GET" === t.method.toUpperCase() && (t.url = gt({
            url: t.url,
            params: t.body
        }),
        delete t.body),
        t),
        t.fromMat4 = function(t, e) {
            return t[0] = e[0],
            t[1] = e[1],
            t[2] = e[2],
            t[3] = e[4],
            t[4] = e[5],
            t[5] = e[6],
            t[6] = e[8],
            t[7] = e[9],
            t[8] = e[10],
            t
        }
        ,
        t.fromQuat = function(t, e) {
            var r = e[0]
              , n = e[1]
              , i = e[2]
              , s = e[3]
              , a = r + r
              , o = n + n
              , l = i + i
              , u = r * a
              , c = n * a
              , h = n * o
              , p = i * a
              , f = i * o
              , d = i * l
              , y = s * a
              , m = s * o
              , g = s * l;
            return t[0] = 1 - h - d,
            t[1] = c + g,
            t[2] = p - m,
            t[3] = 0,
            t[4] = c - g,
            t[5] = 1 - u - d,
            t[6] = f + y,
            t[7] = 0,
            t[8] = p + m,
            t[9] = f - y,
            t[10] = 1 - u - h,
            t[11] = 0,
            t[12] = 0,
            t[13] = 0,
            t[14] = 0,
            t[15] = 1,
            t
        }
        ,
        t.fromRotation = function(t, e) {
            var r = Math.sin(e)
              , n = Math.cos(e);
            return t[0] = n,
            t[1] = r,
            t[2] = 0,
            t[3] = -r,
            t[4] = n,
            t[5] = 0,
            t[6] = 0,
            t[7] = 0,
            t[8] = 1,
            t
        }
        ,
        t.fromScaling = ru,
        t.furthestTileCorner = function(t) {
            const e = Math.round((t + 45 + 360) % 360 / 90) % 4;
            return c[e]
        }
        ,
        t.getAABBPointSquareDist = function(t, e, r) {
            let n = 0;
            for (let i = 0; i < 2; ++i) {
                const s = r ? r[i] : 0;
                t[i] > s && (n += (t[i] - s) * (t[i] - s)),
                e[i] < s && (n += (s - e[i]) * (s - e[i]));
            }
            return n
        }
        ,
        t.getAnchorAlignment = Zp,
        t.getAnchorJustification = zf,
        t.getBounds = function(t) {
            let e = 1 / 0
              , r = 1 / 0
              , n = -1 / 0
              , s = -1 / 0;
            for (const i of t)
                e = Math.min(e, i.x),
                r = Math.min(r, i.y),
                n = Math.max(n, i.x),
                s = Math.max(s, i.y);
            return {
                min: new i(e,r),
                max: new i(n,s)
            }
        }
        ,
        t.getColumn = L,
        t.getGridMatrix = function(t, e, r, n) {
            const i = e.getNorth()
              , s = e.getSouth()
              , a = e.getWest()
              , o = e.getEast()
              , l = 1 << t.z
              , u = o - a
              , c = i - s
              , h = u / jf
              , p = -c / Uf[r]
              , f = [0, h, 0, p, 0, 0, i, a, 0];
            if (t.z > 0) {
                const t = 180 / n;
                Yl(f, f, [t / u + 1, 0, 0, 0, t / c + 1, 0, -.5 * t / h, .5 * t / p, 1]);
            }
            return f[2] = l,
            f[5] = t.x,
            f[8] = t._tileY,
            f
        }
        ,
        t.getImage = Lt,
        t.getJSON = function(t, e) {
            return Ct(v(t, {
                type: "json"
            }), e)
        }
        ,
        t.getLatitudinalLod = function(t) {
            const e = 80.051129;
            t = d(t, -80.051129, e) / e * 90;
            const r = Math.pow(Math.abs(Math.sin(l(t))), 3);
            return Math.round(r * (Uf.length - 1))
        }
        ,
        t.getMecYRange = xl,
        t.getPerformanceMeasurement = j,
        t.getProjection = Ed,
        t.getRTLTextPluginStatus = Ss,
        t.getReferrer = Mt,
        t.getTilePoint = function(t, {x: e, y: r}, n=0) {
            return new i(((e - n) * t.scale - t.x) * bo,(r * t.scale - (t._tileY || t.y)) / (t._tileH || 1) * bo)
        }
        ,
        t.getTileVec3 = function(t, e, r=0) {
            return lu(((e.x - r) * t.scale - t.x) * bo, (e.y * t.scale - (t._tileY || t.y)) / (t._tileH || 1) * bo, tl(e.z, e.y))
        }
        ,
        t.getVideo = function(t, r) {
            const n = e.document.createElement("video");
            n.muted = !0,
            n.onloadstart = function() {
                r(null, n);
            }
            ;
            for (let r = 0; r < t.length; r++) {
                const i = e.document.createElement("source");
                Pt(t[r]) || (n.crossOrigin = "Anonymous"),
                i.src = t[r],
                n.appendChild(i);
            }
            return {
                cancel: () => {}
            }
        }
        ,
        t.globeCenterToScreenPoint = function(t) {
            const e = [0, 0, 0]
              , r = Hl(new Float64Array(16));
            return Jl(r, t.pixelMatrix, t.globeMatrix),
            vu(e, e, r),
            new i(e[0],e[1])
        }
        ,
        t.globeDenormalizeECEF = ad,
        t.globeECEFOrigin = function(t, e) {
            const r = [0, 0, 0];
            return vu(r, r, sd(Xf(e.canonical))),
            vu(r, r, t),
            r
        }
        ,
        t.globeNormalizeECEF = sd,
        t.globePixelsToTileUnits = function(t, e) {
            return bo / (512 * Math.pow(2, t)) * nd(Xf(e))
        }
        ,
        t.globePoleMatrixForTile = function(t, e, r) {
            const n = Hl(new Float64Array(16))
              , i = (e / (1 << t) - .5) * Math.PI * 2;
            return eu(n, r.globeMatrix, i),
            Float32Array.from(n)
        }
        ,
        t.globeTileBounds = Xf,
        t.globeTiltAtLngLat = ud,
        t.globeToMercatorTransition = ld,
        t.globeUseCustomAntiAliasing = function(t, e, r) {
            const n = ld(r.zoom)
              , i = t.style.map._antialias
              , s = !!e.extStandardDerivatives
              , a = e.extStandardDerivativesForceOff || t.terrain && t.terrain.exaggeration() > 0;
            return 0 === n && !i && !a && s
        }
        ,
        t.identity = Hl,
        t.identity$1 = Iu,
        t.initApiURI = (t, e) => {
            const r = document.getElementsByTagName("script")
              , n = [];
            let i = -1;
            for (; ++i < r.length; ) {
                const e = r[i];
                e.src && /http[s]?\:\/\/[\w\d\.\:-]+\/(maps\?v=[\d\.]+|api\/gl\/epgis-[\d\.]+\.min\.js)/.test(e.src) && -1 !== e.src.indexOf(t) && n.push(/http[s]?\:\/\/[\w\d\.\:-]+/.exec(e.src)[0]);
            }
            vt("识别SDK JS加载的路径"),
            vt(n),
            0 === n.length ? console.warn("版本没有匹配") : (e.API_URL = n[0],
            ( ({API_URL: t}, e) => {
                const r = document.createElement("link");
                r.setAttribute("rel", "stylesheet"),
                r.setAttribute("href", `${t}/api/gl/epgis-${e}.min.css`),
                (document.head || document.getElementsByTagName("head")[0]).appendChild(r);
            }
            )(e, t));
        }
        ,
        t.invert = Kl,
        t.isFullscreen = function() {
            return !!e.document.fullscreenElement || !!e.document.webkitFullscreenElement
        }
        ,
        t.isLngLatBehindGlobe = function(t, e) {
            return ud(t, e) > Math.PI / 2 * 1.01
        }
        ,
        t.issgmapURL = Q,
        t.isSafariWithAntialiasingBug = function(t) {
            const e = t.navigator ? t.navigator.userAgent : null;
            return !!F(t) && e && (e.match("Version/15.4") || e.match("Version/15.5") || e.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/))
        }
        ,
        t.latFromMercatorY = Qo,
        t.len = ku,
        t.length = ou,
        t.length$1 = function(t) {
            return Math.hypot(t[0], t[1], t[2], t[3])
        }
        ,
        t.loadVectorTile = pm,
        t.makeRequest = Ct,
        t.makeRequest2 = function(t, r) {
            const n = xt(t.url)
              , {access_token: i} = n.params;
            if (void 0 === t.cache && (t.cache = !0),
            i && (delete n.params.access_token,
            t.headers || (t.headers = {}),
            t.headers.Authorization = i),
            t.url = gt(n),
            t.url = encodeURI(t.url),
            !It(t.url)) {
                if (e.fetch && e.Request && e.AbortController && e.Request.prototype.hasOwnProperty("signal"))
                    return Tt(t, r);
                if (P() && self.worker && self.worker.actor)
                    return self.worker.actor.send("getResource", t, r, void 0, !0)
            }
            return Bt(t, r)
        }
        ,
        t.mapValue = function(t, e, r, n, i) {
            return d((t - e) / (r - e) * (i - n) + n, n, i)
        }
        ,
        t.mercatorScale = rl,
        t.mercatorXfromLng = Ho,
        t.mercatorYfromLat = Ko,
        t.mercatorZfromAltitude = Jo,
        t.mul = iu,
        t.mul$1 = Au,
        t.multiply = Jl,
        t.multiply$1 = Yl,
        t.multiply$2 = hu,
        t.mvt = _y,
        t.nextPowerOfTwo = A,
        t.normalize = mu,
        t.normalize$1 = function(t, e) {
            var r = e[0]
              , n = e[1]
              , i = e[2]
              , s = e[3]
              , a = r * r + n * n + i * i + s * s;
            return a > 0 && (a = 1 / Math.sqrt(a)),
            t[0] = r * a,
            t[1] = n * a,
            t[2] = i * a,
            t[3] = s * a,
            t
        }
        ,
        t.number = mr,
        t.ortho = function(t, e, r, n, i, s, a) {
            var o = 1 / (e - r)
              , l = 1 / (n - i)
              , u = 1 / (s - a);
            return t[0] = -2 * o,
            t[1] = 0,
            t[2] = 0,
            t[3] = 0,
            t[4] = 0,
            t[5] = -2 * l,
            t[6] = 0,
            t[7] = 0,
            t[8] = 0,
            t[9] = 0,
            t[10] = 2 * u,
            t[11] = 0,
            t[12] = (e + r) * o,
            t[13] = (i + n) * l,
            t[14] = (a + s) * u,
            t[15] = 1,
            t
        }
        ,
        t.pbf = op,
        t.perspective = function(t, e, r, n, i) {
            var s, a = 1 / Math.tan(e / 2);
            return t[0] = a / r,
            t[1] = 0,
            t[2] = 0,
            t[3] = 0,
            t[4] = 0,
            t[5] = a,
            t[6] = 0,
            t[7] = 0,
            t[8] = 0,
            t[9] = 0,
            t[11] = -1,
            t[12] = 0,
            t[13] = 0,
            t[15] = 0,
            null != i && i !== 1 / 0 ? (t[10] = (i + n) * (s = 1 / (n - i)),
            t[14] = 2 * i * n * s) : (t[10] = -1,
            t[14] = -2 * n),
            t
        }
        ,
        t.pick = function(t, e) {
            const r = {};
            for (let n = 0; n < e.length; n++) {
                const i = e[n];
                i in t && (r[i] = t[i]);
            }
            return r
        }
        ,
        t.plugin = Is,
        t.pointGeometry = i,
        t.polygonContainsPoint = Fl,
        t.polygonIntersectsBox = Ll,
        t.polygonIntersectsPolygon = Ml,
        t.polygonizeBounds = function(t, e, r=0, n=!0) {
            const s = new i(r,r)
              , a = t.sub(s)
              , o = e.add(s)
              , l = [a, new i(o.x,a.y), o, new i(a.x,o.y)];
            return n && l.push(a.clone()),
            l
        }
        ,
        t.posAttributes = Ff,
        t.potpack = Bp,
        t.prevPowerOfTwo = function(t) {
            return t <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
        }
        ,
        t.radToDeg = u,
        t.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"],
        t.registerForPluginStateChange = function(t) {
            return t({
                pluginStatus: _s,
                pluginURL: ws
            }),
            zs.on("pluginStateChange", t),
            t
        }
        ,
        t.renderColorRamp = ec,
        t.resample = sl,
        t.rotateX = tu,
        t.rotateX$1 = Tu,
        t.rotateY = eu,
        t.rotateY$1 = Bu,
        t.rotateZ = function(t, e, r) {
            var n = Math.sin(r)
              , i = Math.cos(r)
              , s = e[0]
              , a = e[1]
              , o = e[2]
              , l = e[3]
              , u = e[4]
              , c = e[5]
              , h = e[6]
              , p = e[7];
            return e !== t && (t[8] = e[8],
            t[9] = e[9],
            t[10] = e[10],
            t[11] = e[11],
            t[12] = e[12],
            t[13] = e[13],
            t[14] = e[14],
            t[15] = e[15]),
            t[0] = s * i + u * n,
            t[1] = a * i + c * n,
            t[2] = o * i + h * n,
            t[3] = l * i + p * n,
            t[4] = u * i - s * n,
            t[5] = c * i - a * n,
            t[6] = h * i - o * n,
            t[7] = p * i - l * n,
            t
        }
        ,
        t.rotateZ$1 = function(t, e, r) {
            r *= .5;
            var n = e[0]
              , i = e[1]
              , s = e[2]
              , a = e[3]
              , o = Math.sin(r)
              , l = Math.cos(r);
            return t[0] = n * l + i * o,
            t[1] = i * l - n * o,
            t[2] = s * l + a * o,
            t[3] = a * l - s * o,
            t
        }
        ,
        t.scale = Ql,
        t.scale$1 = zu,
        t.scale$2 = du,
        t.scaleAndAdd = yu,
        t.securityTile = mt,
        t.setCacheLimits = function(t, e) {
            ot = t,
            lt = e;
        }
        ,
        t.setColumn = function(t, e, r) {
            t[4 * e + 0] = r[0],
            t[4 * e + 1] = r[1],
            t[4 * e + 2] = r[2],
            t[4 * e + 3] = r[3];
        }
        ,
        t.setRTLTextPlugin = function(t, e, r=!1) {
            if (_s === gs || _s === xs || _s === vs)
                throw new Error("setRTLTextPlugin cannot be called multiple times.");
            ws = N.resolveURL(t),
            _s = gs,
            bs = e,
            ks(),
            r || Ms();
        }
        ,
        t.setWaterMarkLayer = (t, e=!1, r) => {
            const n = JSON.parse(window.atob(Z.ACCESS_TOKEN.split(".")[1]));
            let i = n && "N" === n.Issuance
              , s = {
                text: r || "",
                color: "rgba(17, 102, 184,0.1)",
                rotate: 0
            };
            i || e ? (!i && e ? (s.text = r,
            s.size = 18) : i && !e ? (s.text = "思极地图-测试",
            s.color = "rgba(0, 0,0, 0.1)",
            s.size = 30) : (s.text = "思极地图-测试\n" + r,
            s.rotate = 30,
            s.size = 18),
            s.show = !0) : s.show = !1,
            t.painter._waterSetting = s,
            t._update(!0);
        }
        ,
        t.smoothstep = y,
        t.spec = qt,
        t.sub = wu,
        t.subtract = cu,
        t.symbolSize = tp,
        t.tileAABB = function(t, e, r, n, i, s, a, o, l, u, c, h, p) {
            if ("globe" === l.name)
                return Jf(t, e, new wh(r,n,i,{
                    reference: u,
                    sourceID: c,
                    _tileY: h,
                    _tileH: p
                }));
            const f = dd({
                z: r,
                x: n,
                y: i,
                reference: u,
                sourceID: c,
                _tileY: h,
                _tileH: p
            }, l);
            return new $u([(s + f.x / f.scale) * e, e * (f.y / f.scale), a],[(s + f.x2 / f.scale) * e, e * (f.y2 / f.scale), o])
        }
        ,
        t.tileCornersToBounds = Wf,
        t.tileTransform = dd,
        t.transformMat3 = function(t, e, r) {
            var n = e[0]
              , i = e[1]
              , s = e[2];
            return t[0] = n * r[0] + i * r[3] + s * r[6],
            t[1] = n * r[1] + i * r[4] + s * r[7],
            t[2] = n * r[2] + i * r[5] + s * r[8],
            t
        }
        ,
        t.transformMat4 = vu,
        t.transformMat4$1 = Su,
        t.transformQuat = bu,
        t.transitionTileAABBinECEF = Hf,
        t.translate = Wl,
        t.transpose = function(t, e) {
            if (t === e) {
                var r = e[1]
                  , n = e[2]
                  , i = e[5];
                t[1] = e[3],
                t[2] = e[6],
                t[3] = r,
                t[5] = e[7],
                t[6] = n,
                t[7] = i;
            } else
                t[0] = e[0],
                t[1] = e[3],
                t[2] = e[6],
                t[3] = e[1],
                t[4] = e[4],
                t[5] = e[7],
                t[6] = e[2],
                t[7] = e[5],
                t[8] = e[8];
            return t
        }
        ,
        t.triggerPluginCompletionEvent = As,
        t.uniqueId = w,
        t.updateGlobeVertexNormal = function(t, e, r, n, i) {
            const s = 5 * e + 2;
            t.float32[s + 0] = r,
            t.float32[s + 1] = n,
            t.float32[s + 2] = i;
        }
        ,
        t.validateCustomStyleLayer = function(t) {
            const e = []
              , r = t.id;
            return void 0 === r && e.push({
                message: `layers.${r}: missing required property "id"`
            }),
            void 0 === t.render && e.push({
                message: `layers.${r}: missing required method "render"`
            }),
            t.renderingMode && "2d" !== t.renderingMode && "3d" !== t.renderingMode && e.push({
                message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"`
            }),
            e
        }
        ,
        t.validateFilter = t => zi(oi(t)),
        t.validateFog = t => zi(xi(t)),
        t.validateLayer = t => zi(pi(t)),
        t.validateLight = t => zi(mi(t)),
        t.validateSource = t => zi(yi(t)),
        t.validateStyle = wi,
        t.validateTerrain = t => zi(gi(t)),
        t.values = x,
        t.vectorTile = nh,
        t.warnOnce = B,
        t.window = e,
        t.wrap = m;
    }
    ));

    define(["./shared"], (function(e) {
        "use strict";
        function t(e) {
            if ("number" == typeof e || "boolean" == typeof e || "string" == typeof e || null == e)
                return JSON.stringify(e);
            if (Array.isArray(e)) {
                let r = "[";
                for (const o of e)
                    r += `${t(o)},`;
                return `${r}]`
            }
            let r = "{";
            for (const o of Object.keys(e).sort())
                r += `${o}:${t(e[o])},`;
            return `${r}}`
        }
        function r(r) {
            let o = "";
            for (const n of e.refProperties)
                o += `/${t(r[n])}`;
            return o
        }
        class o {
            constructor(e) {
                this.keyCache = {},
                e && this.replace(e);
            }
            replace(e) {
                this._layerConfigs = {},
                this._layers = {},
                this.update(e, []);
            }
            update(t, o) {
                for (const r of t)
                    this._layerConfigs[r.id] = r,
                    (this._layers[r.id] = e.createStyleLayer(r)).compileFilter(),
                    this.keyCache[r.id] && delete this.keyCache[r.id];
                for (const e of o)
                    delete this.keyCache[e],
                    delete this._layerConfigs[e],
                    delete this._layers[e];
                this.familiesBySource = {};
                const n = function(e, t) {
                    const o = {};
                    for (let n = 0; n < e.length; n++) {
                        const i = t && t[e[n].id] || r(e[n]);
                        t && (t[e[n].id] = i);
                        let s = o[i];
                        s || (s = o[i] = []),
                        s.push(e[n]);
                    }
                    const n = [];
                    for (const e in o)
                        n.push(o[e]);
                    return n
                }(e.values(this._layerConfigs), this.keyCache);
                for (const e of n) {
                    const t = e.map((e => this._layers[e.id]))
                      , r = t[0];
                    if ("none" === r.visibility)
                        continue;
                    const o = r.source || "";
                    let n = this.familiesBySource[o];
                    n || (n = this.familiesBySource[o] = {});
                    const i = r.sourceLayer || "_geojsonTileLayer";
                    let s = n[i];
                    s || (s = n[i] = []),
                    s.push(t);
                }
            }
        }
        class n {
            loadTile(t, r) {
                const {uid: o, encoding: n, rawImageData: i, padding: s, buildQuadTree: a} = t
                  , l = e.window.ImageBitmap && i instanceof e.window.ImageBitmap ? this.getImageData(i, s) : i;
                r(null, new e.DEMData(o,l,n,s < 1,a));
            }
            getImageData(e, t) {
                this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e.width,e.height),
                this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", {
                    willReadFrequently: !0
                })),
                this.offscreenCanvas.width = e.width,
                this.offscreenCanvas.height = e.height,
                this.offscreenCanvasContext.drawImage(e, 0, 0, e.width, e.height);
                const r = this.offscreenCanvasContext.getImageData(-t, -t, e.width + 2 * t, e.height + 2 * t);
                return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height),
                r
            }
        }
        var i = function e(t, r) {
            var o, n = t && t.type;
            if ("FeatureCollection" === n)
                for (o = 0; o < t.features.length; o++)
                    e(t.features[o], r);
            else if ("GeometryCollection" === n)
                for (o = 0; o < t.geometries.length; o++)
                    e(t.geometries[o], r);
            else if ("Feature" === n)
                e(t.geometry, r);
            else if ("Polygon" === n)
                s(t.coordinates, r);
            else if ("MultiPolygon" === n)
                for (o = 0; o < t.coordinates.length; o++)
                    s(t.coordinates[o], r);
            return t
        };
        function s(e, t) {
            if (0 !== e.length) {
                a(e[0], t);
                for (var r = 1; r < e.length; r++)
                    a(e[r], !t);
            }
        }
        function a(e, t) {
            for (var r = 0, o = 0, n = 0, i = e.length, s = i - 1; n < i; s = n++) {
                var a = (e[n][0] - e[s][0]) * (e[s][1] + e[n][1])
                  , l = r + a;
                o += Math.abs(r) >= Math.abs(a) ? r - l + a : a - l + r,
                r = l;
            }
            r + o >= 0 != !!t && e.reverse();
        }
        const l = e.mvt.VectorTileFeature.prototype.toGeoJSON;
        class u {
            constructor(t) {
                this._feature = t,
                this.extent = e.EXTENT,
                this.type = t.type,
                this.properties = t.tags,
                "id"in t && !isNaN(t.id) && (this.id = parseInt(t.id, 10));
            }
            loadGeometry() {
                if (1 === this._feature.type) {
                    const t = [];
                    for (const r of this._feature.geometry)
                        t.push([new e.pointGeometry(r[0],r[1])]);
                    return t
                }
                {
                    const t = [];
                    for (const r of this._feature.geometry) {
                        const o = [];
                        for (const t of r)
                            o.push(new e.pointGeometry(t[0],t[1]));
                        t.push(o);
                    }
                    return t
                }
            }
            toGeoJSON(e, t, r) {
                return l.call(this, e, t, r)
            }
        }
        class h {
            constructor(t) {
                this.layers = {
                    _geojsonTileLayer: this
                },
                this.name = "_geojsonTileLayer",
                this.extent = e.EXTENT,
                this.length = t.length,
                this._features = t;
            }
            feature(e) {
                return new u(this._features[e])
            }
        }
        var c = e.vectorTile.VectorTileFeature
          , f = p;
        function p(e, t) {
            this.options = t || {},
            this.features = e,
            this.length = e.length;
        }
        function g(e, t) {
            this.id = "number" == typeof e.id ? e.id : void 0,
            this.type = e.type,
            this.rawGeometry = 1 === e.type ? [e.geometry] : e.geometry,
            this.properties = e.tags,
            this.extent = t || 4096;
        }
        p.prototype.feature = function(e) {
            return new g(this.features[e],this.options.extent)
        }
        ,
        g.prototype.loadGeometry = function() {
            var t = this.rawGeometry;
            this.geometry = [];
            for (var r = 0; r < t.length; r++) {
                for (var o = t[r], n = [], i = 0; i < o.length; i++)
                    n.push(new e.pointGeometry(o[i][0],o[i][1]));
                this.geometry.push(n);
            }
            return this.geometry
        }
        ,
        g.prototype.bbox = function() {
            this.geometry || this.loadGeometry();
            for (var e = this.geometry, t = 1 / 0, r = -1 / 0, o = 1 / 0, n = -1 / 0, i = 0; i < e.length; i++)
                for (var s = e[i], a = 0; a < s.length; a++) {
                    var l = s[a];
                    t = Math.min(t, l.x),
                    r = Math.max(r, l.x),
                    o = Math.min(o, l.y),
                    n = Math.max(n, l.y);
                }
            return [t, o, r, n]
        }
        ,
        g.prototype.toGeoJSON = c.prototype.toGeoJSON;
        var d = y
          , m = f;
        function y(t) {
            var r = new e.pbf;
            return function(e, t) {
                for (var r in e.layers)
                    t.writeMessage(3, v, e.layers[r]);
            }(t, r),
            r.finish()
        }
        function v(e, t) {
            var r;
            t.writeVarintField(15, e.version || 1),
            t.writeStringField(1, e.name || ""),
            t.writeVarintField(5, e.extent || 4096);
            var o = {
                keys: [],
                values: [],
                keycache: {},
                valuecache: {}
            };
            for (r = 0; r < e.length; r++)
                o.feature = e.feature(r),
                t.writeMessage(2, x, o);
            var n = o.keys;
            for (r = 0; r < n.length; r++)
                t.writeStringField(3, n[r]);
            var i = o.values;
            for (r = 0; r < i.length; r++)
                t.writeMessage(4, b, i[r]);
        }
        function x(e, t) {
            var r = e.feature;
            void 0 !== r.id && t.writeVarintField(1, r.id),
            t.writeMessage(2, w, e),
            t.writeVarintField(3, r.type),
            t.writeMessage(4, P, r);
        }
        function w(e, t) {
            var r = e.feature
              , o = e.keys
              , n = e.values
              , i = e.keycache
              , s = e.valuecache;
            for (var a in r.properties) {
                var l = r.properties[a]
                  , u = i[a];
                if (null !== l) {
                    void 0 === u && (o.push(a),
                    i[a] = u = o.length - 1),
                    t.writeVarint(u);
                    var h = typeof l;
                    "string" !== h && "boolean" !== h && "number" !== h && (l = JSON.stringify(l));
                    var c = h + ":" + l
                      , f = s[c];
                    void 0 === f && (n.push(l),
                    s[c] = f = n.length - 1),
                    t.writeVarint(f);
                }
            }
        }
        function S(e, t) {
            return (t << 3) + (7 & e)
        }
        function M(e) {
            return e << 1 ^ e >> 31
        }
        function P(e, t) {
            for (var r = e.loadGeometry(), o = e.type, n = 0, i = 0, s = r.length, a = 0; a < s; a++) {
                var l = r[a]
                  , u = 1;
                1 === o && (u = l.length),
                t.writeVarint(S(1, u));
                for (var h = 3 === o ? l.length - 1 : l.length, c = 0; c < h; c++) {
                    1 === c && 1 !== o && t.writeVarint(S(2, h - 1));
                    var f = l[c].x - n
                      , p = l[c].y - i;
                    t.writeVarint(M(f)),
                    t.writeVarint(M(p)),
                    n += f,
                    i += p;
                }
                3 === o && t.writeVarint(S(7, 1));
            }
        }
        function b(e, t) {
            var r = typeof e;
            "string" === r ? t.writeStringField(1, e) : "boolean" === r ? t.writeBooleanField(7, e) : "number" === r && (e % 1 != 0 ? t.writeDoubleField(3, e) : e < 0 ? t.writeSVarintField(6, e) : t.writeVarintField(5, e));
        }
        function T(e, t, r, o, n, i) {
            if (n - o <= r)
                return;
            const s = o + n >> 1;
            k(e, t, s, o, n, i % 2),
            T(e, t, r, o, s - 1, i + 1),
            T(e, t, r, s + 1, n, i + 1);
        }
        function k(e, t, r, o, n, i) {
            for (; n > o; ) {
                if (n - o > 600) {
                    const s = n - o + 1
                      , a = r - o + 1
                      , l = Math.log(s)
                      , u = .5 * Math.exp(2 * l / 3)
                      , h = .5 * Math.sqrt(l * u * (s - u) / s) * (a - s / 2 < 0 ? -1 : 1);
                    k(e, t, r, Math.max(o, Math.floor(r - a * u / s + h)), Math.min(n, Math.floor(r + (s - a) * u / s + h)), i);
                }
                const s = t[2 * r + i];
                let a = o
                  , l = n;
                for (I(e, t, o, r),
                t[2 * n + i] > s && I(e, t, o, n); a < l; ) {
                    for (I(e, t, a, l),
                    a++,
                    l--; t[2 * a + i] < s; )
                        a++;
                    for (; t[2 * l + i] > s; )
                        l--;
                }
                t[2 * o + i] === s ? I(e, t, o, l) : (l++,
                I(e, t, l, n)),
                l <= r && (o = l + 1),
                r <= l && (n = l - 1);
            }
        }
        function I(e, t, r, o) {
            _(e, r, o),
            _(t, 2 * r, 2 * o),
            _(t, 2 * r + 1, 2 * o + 1);
        }
        function _(e, t, r) {
            const o = e[t];
            e[t] = e[r],
            e[r] = o;
        }
        function L(e, t, r, o) {
            const n = e - r
              , i = t - o;
            return n * n + i * i
        }
        d.fromVectorTileJs = y,
        d.fromGeojsonVt = function(e, t) {
            t = t || {};
            var r = {};
            for (var o in e)
                r[o] = new f(e[o].features,t),
                r[o].name = o,
                r[o].version = t.version,
                r[o].extent = t.extent;
            return y({
                layers: r
            })
        }
        ,
        d.GeoJSONWrapper = m;
        const C = e => e[0]
          , O = e => e[1];
        class z {
            constructor(e, t=C, r=O, o=64, n=Float64Array) {
                this.nodeSize = o,
                this.points = e;
                const i = e.length < 65536 ? Uint16Array : Uint32Array
                  , s = this.ids = new i(e.length)
                  , a = this.coords = new n(2 * e.length);
                for (let o = 0; o < e.length; o++)
                    s[o] = o,
                    a[2 * o] = t(e[o]),
                    a[2 * o + 1] = r(e[o]);
                T(s, a, o, 0, s.length - 1, 0);
            }
            range(e, t, r, o) {
                return function(e, t, r, o, n, i, s) {
                    const a = [0, e.length - 1, 0]
                      , l = [];
                    let u, h;
                    for (; a.length; ) {
                        const c = a.pop()
                          , f = a.pop()
                          , p = a.pop();
                        if (f - p <= s) {
                            for (let s = p; s <= f; s++)
                                u = t[2 * s],
                                h = t[2 * s + 1],
                                u >= r && u <= n && h >= o && h <= i && l.push(e[s]);
                            continue
                        }
                        const g = Math.floor((p + f) / 2);
                        u = t[2 * g],
                        h = t[2 * g + 1],
                        u >= r && u <= n && h >= o && h <= i && l.push(e[g]);
                        const d = (c + 1) % 2;
                        (0 === c ? r <= u : o <= h) && (a.push(p),
                        a.push(g - 1),
                        a.push(d)),
                        (0 === c ? n >= u : i >= h) && (a.push(g + 1),
                        a.push(f),
                        a.push(d));
                    }
                    return l
                }(this.ids, this.coords, e, t, r, o, this.nodeSize)
            }
            within(e, t, r) {
                return function(e, t, r, o, n, i) {
                    const s = [0, e.length - 1, 0]
                      , a = []
                      , l = n * n;
                    for (; s.length; ) {
                        const u = s.pop()
                          , h = s.pop()
                          , c = s.pop();
                        if (h - c <= i) {
                            for (let n = c; n <= h; n++)
                                L(t[2 * n], t[2 * n + 1], r, o) <= l && a.push(e[n]);
                            continue
                        }
                        const f = Math.floor((c + h) / 2)
                          , p = t[2 * f]
                          , g = t[2 * f + 1];
                        L(p, g, r, o) <= l && a.push(e[f]);
                        const d = (u + 1) % 2;
                        (0 === u ? r - n <= p : o - n <= g) && (s.push(c),
                        s.push(f - 1),
                        s.push(d)),
                        (0 === u ? r + n >= p : o + n >= g) && (s.push(f + 1),
                        s.push(h),
                        s.push(d));
                    }
                    return a
                }(this.ids, this.coords, e, t, r, this.nodeSize)
            }
        }
        const E = {
            minZoom: 0,
            maxZoom: 16,
            minPoints: 2,
            radius: 40,
            extent: 512,
            nodeSize: 64,
            log: !1,
            generateId: !1,
            reduce: null,
            map: e => e
        }
          , F = Math.fround || (N = new Float32Array(1),
        e => (N[0] = +e,
        N[0]));
        var N;
        class j {
            constructor(e) {
                this.options = A(Object.create(E), e),
                this.trees = new Array(this.options.maxZoom + 1);
            }
            load(e) {
                const {log: t, minZoom: r, maxZoom: o, nodeSize: n} = this.options;
                t && console.time("total time");
                const i = `prepare ${e.length} points`;
                t && console.time(i),
                this.points = e;
                let s = [];
                for (let t = 0; t < e.length; t++)
                    e[t].geometry && s.push(G(e[t], t));
                this.trees[o + 1] = new z(s,D,$,n,Float32Array),
                t && console.timeEnd(i);
                for (let e = o; e >= r; e--) {
                    const r = +Date.now();
                    s = this._cluster(s, e),
                    this.trees[e] = new z(s,D,$,n,Float32Array),
                    t && console.log("z%d: %d clusters in %dms", e, s.length, +Date.now() - r);
                }
                return t && console.timeEnd("total time"),
                this
            }
            getClusters(e, t) {
                let r = ((e[0] + 180) % 360 + 360) % 360 - 180;
                const o = Math.max(-90, Math.min(90, e[1]));
                let n = 180 === e[2] ? 180 : ((e[2] + 180) % 360 + 360) % 360 - 180;
                const i = Math.max(-90, Math.min(90, e[3]));
                if (e[2] - e[0] >= 360)
                    r = -180,
                    n = 180;
                else if (r > n) {
                    const e = this.getClusters([r, o, 180, i], t)
                      , s = this.getClusters([-180, o, n, i], t);
                    return e.concat(s)
                }
                const s = this.trees[this._limitZoom(t)]
                  , a = s.range(W(r), X(i), W(n), X(o))
                  , l = [];
                for (const e of a) {
                    const t = s.points[e];
                    l.push(t.numPoints ? J(t) : this.points[t.index]);
                }
                return l
            }
            getChildren(e) {
                const t = this._getOriginId(e)
                  , r = this._getOriginZoom(e)
                  , o = "No cluster with the specified id."
                  , n = this.trees[r];
                if (!n)
                    throw new Error(o);
                const i = n.points[t];
                if (!i)
                    throw new Error(o);
                const s = this.options.radius / (this.options.extent * Math.pow(2, r - 1))
                  , a = n.within(i.x, i.y, s)
                  , l = [];
                for (const t of a) {
                    const r = n.points[t];
                    r.parentId === e && l.push(r.numPoints ? J(r) : this.points[r.index]);
                }
                if (0 === l.length)
                    throw new Error(o);
                return l
            }
            getLeaves(e, t, r) {
                const o = [];
                return this._appendLeaves(o, e, t = t || 10, r = r || 0, 0),
                o
            }
            getTile(e, t, r) {
                const o = this.trees[this._limitZoom(e)]
                  , n = Math.pow(2, e)
                  , {extent: i, radius: s} = this.options
                  , a = s / i
                  , l = (r - a) / n
                  , u = (r + 1 + a) / n
                  , h = {
                    features: []
                };
                return this._addTileFeatures(o.range((t - a) / n, l, (t + 1 + a) / n, u), o.points, t, r, n, h),
                0 === t && this._addTileFeatures(o.range(1 - a / n, l, 1, u), o.points, n, r, n, h),
                t === n - 1 && this._addTileFeatures(o.range(0, l, a / n, u), o.points, -1, r, n, h),
                h.features.length ? h : null
            }
            getClusterExpansionZoom(e) {
                let t = this._getOriginZoom(e) - 1;
                for (; t <= this.options.maxZoom; ) {
                    const r = this.getChildren(e);
                    if (t++,
                    1 !== r.length)
                        break;
                    e = r[0].properties.cluster_id;
                }
                return t
            }
            _appendLeaves(e, t, r, o, n) {
                const i = this.getChildren(t);
                for (const t of i) {
                    const i = t.properties;
                    if (i && i.cluster ? n + i.point_count <= o ? n += i.point_count : n = this._appendLeaves(e, i.cluster_id, r, o, n) : n < o ? n++ : e.push(t),
                    e.length === r)
                        break
                }
                return n
            }
            _addTileFeatures(e, t, r, o, n, i) {
                for (const s of e) {
                    const e = t[s]
                      , a = e.numPoints;
                    let l, u, h;
                    if (a)
                        l = Y(e),
                        u = e.x,
                        h = e.y;
                    else {
                        const t = this.points[e.index];
                        l = t.properties,
                        u = W(t.geometry.coordinates[0]),
                        h = X(t.geometry.coordinates[1]);
                    }
                    const c = {
                        type: 1,
                        geometry: [[Math.round(this.options.extent * (u * n - r)), Math.round(this.options.extent * (h * n - o))]],
                        tags: l
                    };
                    let f;
                    a ? f = e.id : this.options.generateId ? f = e.index : this.points[e.index].id && (f = this.points[e.index].id),
                    void 0 !== f && (c.id = f),
                    i.features.push(c);
                }
            }
            _limitZoom(e) {
                return Math.max(this.options.minZoom, Math.min(+e, this.options.maxZoom + 1))
            }
            _cluster(e, t) {
                const r = []
                  , {radius: o, extent: n, reduce: i, minPoints: s} = this.options
                  , a = o / (n * Math.pow(2, t));
                for (let o = 0; o < e.length; o++) {
                    const n = e[o];
                    if (n.zoom <= t)
                        continue;
                    n.zoom = t;
                    const l = this.trees[t + 1]
                      , u = l.within(n.x, n.y, a)
                      , h = n.numPoints || 1;
                    let c = h;
                    for (const e of u) {
                        const r = l.points[e];
                        r.zoom > t && (c += r.numPoints || 1);
                    }
                    if (c > h && c >= s) {
                        let e = n.x * h
                          , s = n.y * h
                          , a = i && h > 1 ? this._map(n, !0) : null;
                        const f = (o << 5) + (t + 1) + this.points.length;
                        for (const r of u) {
                            const o = l.points[r];
                            if (o.zoom <= t)
                                continue;
                            o.zoom = t;
                            const u = o.numPoints || 1;
                            e += o.x * u,
                            s += o.y * u,
                            o.parentId = f,
                            i && (a || (a = this._map(n, !0)),
                            i(a, this._map(o)));
                        }
                        n.parentId = f,
                        r.push(Z(e / c, s / c, f, c, a));
                    } else if (r.push(n),
                    c > 1)
                        for (const e of u) {
                            const o = l.points[e];
                            o.zoom <= t || (o.zoom = t,
                            r.push(o));
                        }
                }
                return r
            }
            _getOriginId(e) {
                return e - this.points.length >> 5
            }
            _getOriginZoom(e) {
                return (e - this.points.length) % 32
            }
            _map(e, t) {
                if (e.numPoints)
                    return t ? A({}, e.properties) : e.properties;
                const r = this.points[e.index].properties
                  , o = this.options.map(r);
                return t && o === r ? A({}, o) : o
            }
        }
        function Z(e, t, r, o, n) {
            return {
                x: F(e),
                y: F(t),
                zoom: 1 / 0,
                id: r,
                parentId: -1,
                numPoints: o,
                properties: n
            }
        }
        function G(e, t) {
            const [r,o] = e.geometry.coordinates;
            return {
                x: F(W(r)),
                y: F(X(o)),
                zoom: 1 / 0,
                index: t,
                parentId: -1
            }
        }
        function J(e) {
            return {
                type: "Feature",
                id: e.id,
                properties: Y(e),
                geometry: {
                    type: "Point",
                    coordinates: [(t = e.x,
                    360 * (t - .5)), V(e.y)]
                }
            };
            var t;
        }
        function Y(e) {
            const t = e.numPoints
              , r = t >= 1e4 ? `${Math.round(t / 1e3)}k` : t >= 1e3 ? Math.round(t / 100) / 10 + "k" : t;
            return A(A({}, e.properties), {
                cluster: !0,
                cluster_id: e.id,
                point_count: t,
                point_count_abbreviated: r
            })
        }
        function W(e) {
            return e / 360 + .5
        }
        function X(e) {
            const t = Math.sin(e * Math.PI / 180)
              , r = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;
            return r < 0 ? 0 : r > 1 ? 1 : r
        }
        function V(e) {
            const t = (180 - 360 * e) * Math.PI / 180;
            return 360 * Math.atan(Math.exp(t)) / Math.PI - 90
        }
        function A(e, t) {
            for (const r in t)
                e[r] = t[r];
            return e
        }
        function D(e) {
            return e.x
        }
        function $(e) {
            return e.y
        }
        function B(e, t, r, o) {
            for (var n, i = o, s = r - t >> 1, a = r - t, l = e[t], u = e[t + 1], h = e[r], c = e[r + 1], f = t + 3; f < r; f += 3) {
                var p = R(e[f], e[f + 1], l, u, h, c);
                if (p > i)
                    n = f,
                    i = p;
                else if (p === i) {
                    var g = Math.abs(f - s);
                    g < a && (n = f,
                    a = g);
                }
            }
            i > o && (n - t > 3 && B(e, t, n, o),
            e[n + 2] = i,
            r - n > 3 && B(e, n, r, o));
        }
        function R(e, t, r, o, n, i) {
            var s = n - r
              , a = i - o;
            if (0 !== s || 0 !== a) {
                var l = ((e - r) * s + (t - o) * a) / (s * s + a * a);
                l > 1 ? (r = n,
                o = i) : l > 0 && (r += s * l,
                o += a * l);
            }
            return (s = e - r) * s + (a = t - o) * a
        }
        function q(e, t, r, o) {
            var n = {
                id: void 0 === e ? null : e,
                type: t,
                geometry: r,
                tags: o,
                minX: 1 / 0,
                minY: 1 / 0,
                maxX: -1 / 0,
                maxY: -1 / 0
            };
            return function(e) {
                var t = e.geometry
                  , r = e.type;
                if ("Point" === r || "MultiPoint" === r || "LineString" === r)
                    U(e, t);
                else if ("Polygon" === r || "MultiLineString" === r)
                    for (var o = 0; o < t.length; o++)
                        U(e, t[o]);
                else if ("MultiPolygon" === r)
                    for (o = 0; o < t.length; o++)
                        for (var n = 0; n < t[o].length; n++)
                            U(e, t[o][n]);
            }(n),
            n
        }
        function U(e, t) {
            for (var r = 0; r < t.length; r += 3)
                e.minX = Math.min(e.minX, t[r]),
                e.minY = Math.min(e.minY, t[r + 1]),
                e.maxX = Math.max(e.maxX, t[r]),
                e.maxY = Math.max(e.maxY, t[r + 1]);
        }
        function Q(e, t, r, o) {
            if (t.geometry) {
                var n = t.geometry.coordinates
                  , i = t.geometry.type
                  , s = Math.pow(r.tolerance / ((1 << r.maxZoom) * r.extent), 2)
                  , a = []
                  , l = t.id;
                if (r.promoteId ? l = t.properties[r.promoteId] : r.generateId && (l = o || 0),
                "Point" === i)
                    H(n, a);
                else if ("MultiPoint" === i)
                    for (var u = 0; u < n.length; u++)
                        H(n[u], a);
                else if ("LineString" === i)
                    K(n, a, s, !1);
                else if ("MultiLineString" === i) {
                    if (r.lineMetrics) {
                        for (u = 0; u < n.length; u++)
                            K(n[u], a = [], s, !1),
                            e.push(q(l, "LineString", a, t.properties));
                        return
                    }
                    ee(n, a, s, !1);
                } else if ("Polygon" === i)
                    ee(n, a, s, !0);
                else {
                    if ("MultiPolygon" !== i) {
                        if ("GeometryCollection" === i) {
                            for (u = 0; u < t.geometry.geometries.length; u++)
                                Q(e, {
                                    id: l,
                                    geometry: t.geometry.geometries[u],
                                    properties: t.properties
                                }, r, o);
                            return
                        }
                        throw new Error("Input data is not a valid GeoJSON object.")
                    }
                    for (u = 0; u < n.length; u++) {
                        var h = [];
                        ee(n[u], h, s, !0),
                        a.push(h);
                    }
                }
                e.push(q(l, i, a, t.properties));
            }
        }
        function H(e, t) {
            t.push(te(e[0])),
            t.push(re(e[1])),
            t.push(0);
        }
        function K(e, t, r, o) {
            for (var n, i, s = 0, a = 0; a < e.length; a++) {
                var l = te(e[a][0])
                  , u = re(e[a][1]);
                t.push(l),
                t.push(u),
                t.push(0),
                a > 0 && (s += o ? (n * u - l * i) / 2 : Math.sqrt(Math.pow(l - n, 2) + Math.pow(u - i, 2))),
                n = l,
                i = u;
            }
            var h = t.length - 3;
            t[2] = 1,
            B(t, 0, h, r),
            t[h + 2] = 1,
            t.size = Math.abs(s),
            t.start = 0,
            t.end = t.size;
        }
        function ee(e, t, r, o) {
            for (var n = 0; n < e.length; n++) {
                var i = [];
                K(e[n], i, r, o),
                t.push(i);
            }
        }
        function te(t) {
            return e.mercatorXfromLng(t)
        }
        function re(t) {
            return e.mercatorYfromLat(t)
        }
        function oe(e, t, r, o, n, i, s, a) {
            if (o /= t,
            i >= (r /= t) && s < o)
                return e;
            if (s < r || i >= o)
                return null;
            for (var l = [], u = 0; u < e.length; u++) {
                var h = e[u]
                  , c = h.geometry
                  , f = h.type
                  , p = 0 === n ? h.minX : h.minY
                  , g = 0 === n ? h.maxX : h.maxY;
                if (p >= r && g < o)
                    l.push(h);
                else if (!(g < r || p >= o)) {
                    var d = [];
                    if ("Point" === f || "MultiPoint" === f)
                        ne(c, d, r, o, n);
                    else if ("LineString" === f)
                        ie(c, d, r, o, n, !1, a.lineMetrics);
                    else if ("MultiLineString" === f)
                        ae(c, d, r, o, n, !1);
                    else if ("Polygon" === f)
                        ae(c, d, r, o, n, !0);
                    else if ("MultiPolygon" === f)
                        for (var m = 0; m < c.length; m++) {
                            var y = [];
                            ae(c[m], y, r, o, n, !0),
                            y.length && d.push(y);
                        }
                    if (d.length) {
                        if (a.lineMetrics && "LineString" === f) {
                            for (m = 0; m < d.length; m++)
                                l.push(q(h.id, f, d[m], h.tags));
                            continue
                        }
                        "LineString" !== f && "MultiLineString" !== f || (1 === d.length ? (f = "LineString",
                        d = d[0]) : f = "MultiLineString"),
                        "Point" !== f && "MultiPoint" !== f || (f = 3 === d.length ? "Point" : "MultiPoint"),
                        l.push(q(h.id, f, d, h.tags));
                    }
                }
            }
            return l.length ? l : null
        }
        function ne(e, t, r, o, n) {
            for (var i = 0; i < e.length; i += 3) {
                var s = e[i + n];
                s >= r && s <= o && (t.push(e[i]),
                t.push(e[i + 1]),
                t.push(e[i + 2]));
            }
        }
        function ie(e, t, r, o, n, i, s) {
            for (var a, l, u = se(e), h = 0 === n ? ue : he, c = e.start, f = 0; f < e.length - 3; f += 3) {
                var p = e[f]
                  , g = e[f + 1]
                  , d = e[f + 2]
                  , m = e[f + 3]
                  , y = e[f + 4]
                  , v = 0 === n ? p : g
                  , x = 0 === n ? m : y
                  , w = !1;
                s && (a = Math.sqrt(Math.pow(p - m, 2) + Math.pow(g - y, 2))),
                v < r ? x > r && (l = h(u, p, g, m, y, r),
                s && (u.start = c + a * l)) : v > o ? x < o && (l = h(u, p, g, m, y, o),
                s && (u.start = c + a * l)) : le(u, p, g, d),
                x < r && v >= r && (l = h(u, p, g, m, y, r),
                w = !0),
                x > o && v <= o && (l = h(u, p, g, m, y, o),
                w = !0),
                !i && w && (s && (u.end = c + a * l),
                t.push(u),
                u = se(e)),
                s && (c += a);
            }
            var S = e.length - 3;
            p = e[S],
            g = e[S + 1],
            d = e[S + 2],
            (v = 0 === n ? p : g) >= r && v <= o && le(u, p, g, d),
            S = u.length - 3,
            i && S >= 3 && (u[S] !== u[0] || u[S + 1] !== u[1]) && le(u, u[0], u[1], u[2]),
            u.length && t.push(u);
        }
        function se(e) {
            var t = [];
            return t.size = e.size,
            t.start = e.start,
            t.end = e.end,
            t
        }
        function ae(e, t, r, o, n, i) {
            for (var s = 0; s < e.length; s++)
                ie(e[s], t, r, o, n, i, !1);
        }
        function le(e, t, r, o) {
            e.push(t),
            e.push(r),
            e.push(o);
        }
        function ue(e, t, r, o, n, i) {
            var s = (i - t) / (o - t);
            return e.push(i),
            e.push(r + (n - r) * s),
            e.push(1),
            s
        }
        function he(e, t, r, o, n, i) {
            var s = (i - r) / (n - r);
            return e.push(t + (o - t) * s),
            e.push(i),
            e.push(1),
            s
        }
        function ce(e, t) {
            for (var r = [], o = 0; o < e.length; o++) {
                var n, i = e[o], s = i.type;
                if ("Point" === s || "MultiPoint" === s || "LineString" === s)
                    n = fe(i.geometry, t);
                else if ("MultiLineString" === s || "Polygon" === s) {
                    n = [];
                    for (var a = 0; a < i.geometry.length; a++)
                        n.push(fe(i.geometry[a], t));
                } else if ("MultiPolygon" === s)
                    for (n = [],
                    a = 0; a < i.geometry.length; a++) {
                        for (var l = [], u = 0; u < i.geometry[a].length; u++)
                            l.push(fe(i.geometry[a][u], t));
                        n.push(l);
                    }
                r.push(q(i.id, s, n, i.tags));
            }
            return r
        }
        function fe(e, t) {
            var r = [];
            r.size = e.size,
            void 0 !== e.start && (r.start = e.start,
            r.end = e.end);
            for (var o = 0; o < e.length; o += 3)
                r.push(e[o] + t, e[o + 1], e[o + 2]);
            return r
        }
        function pe(e, t) {
            if (e.transformed)
                return e;
            var r, o, n, i = 1 << e.z, s = e.x, a = e.y;
            for (r = 0; r < e.features.length; r++) {
                var l = e.features[r]
                  , u = l.geometry
                  , h = l.type;
                if (l.geometry = [],
                1 === h)
                    for (o = 0; o < u.length; o += 2)
                        l.geometry.push(ge(u[o], u[o + 1], t, i, s, a));
                else
                    for (o = 0; o < u.length; o++) {
                        var c = [];
                        for (n = 0; n < u[o].length; n += 2)
                            c.push(ge(u[o][n], u[o][n + 1], t, i, s, a));
                        l.geometry.push(c);
                    }
            }
            return e.transformed = !0,
            e
        }
        function ge(e, t, r, o, n, i) {
            return [Math.round(r * (e * o - n)), Math.round(r * (t * o - i))]
        }
        function de(e, t, r, o, n) {
            for (var i = t === n.maxZoom ? 0 : n.tolerance / ((1 << t) * n.extent), s = {
                features: [],
                numPoints: 0,
                numSimplified: 0,
                numFeatures: 0,
                source: null,
                x: r,
                y: o,
                z: t,
                transformed: !1,
                minX: 2,
                minY: 1,
                maxX: -1,
                maxY: 0
            }, a = 0; a < e.length; a++) {
                s.numFeatures++,
                me(s, e[a], i, n);
                var l = e[a].minX
                  , u = e[a].minY
                  , h = e[a].maxX
                  , c = e[a].maxY;
                l < s.minX && (s.minX = l),
                u < s.minY && (s.minY = u),
                h > s.maxX && (s.maxX = h),
                c > s.maxY && (s.maxY = c);
            }
            return s
        }
        function me(e, t, r, o) {
            var n = t.geometry
              , i = t.type
              , s = [];
            if ("Point" === i || "MultiPoint" === i)
                for (var a = 0; a < n.length; a += 3)
                    s.push(n[a]),
                    s.push(n[a + 1]),
                    e.numPoints++,
                    e.numSimplified++;
            else if ("LineString" === i)
                ye(s, n, e, r, !1, !1);
            else if ("MultiLineString" === i || "Polygon" === i)
                for (a = 0; a < n.length; a++)
                    ye(s, n[a], e, r, "Polygon" === i, 0 === a);
            else if ("MultiPolygon" === i)
                for (var l = 0; l < n.length; l++) {
                    var u = n[l];
                    for (a = 0; a < u.length; a++)
                        ye(s, u[a], e, r, !0, 0 === a);
                }
            if (s.length) {
                var h = t.tags || null;
                if ("LineString" === i && o.lineMetrics) {
                    for (var c in h = {},
                    t.tags)
                        h[c] = t.tags[c];
                    h.sgmap_clip_start = n.start / n.size,
                    h.sgmap_clip_end = n.end / n.size;
                }
                var f = {
                    geometry: s,
                    type: "Polygon" === i || "MultiPolygon" === i ? 3 : "LineString" === i || "MultiLineString" === i ? 2 : 1,
                    tags: h
                };
                null !== t.id && (f.id = t.id),
                e.features.push(f);
            }
        }
        function ye(e, t, r, o, n, i) {
            var s = o * o;
            if (o > 0 && t.size < (n ? s : o))
                r.numPoints += t.length / 3;
            else {
                for (var a = [], l = 0; l < t.length; l += 3)
                    (0 === o || t[l + 2] > s) && (r.numSimplified++,
                    a.push(t[l]),
                    a.push(t[l + 1])),
                    r.numPoints++;
                n && function(e, t) {
                    for (var r = 0, o = 0, n = e.length, i = n - 2; o < n; i = o,
                    o += 2)
                        r += (e[o] - e[i]) * (e[o + 1] + e[i + 1]);
                    if (r > 0 === t)
                        for (o = 0,
                        n = e.length; o < n / 2; o += 2) {
                            var s = e[o]
                              , a = e[o + 1];
                            e[o] = e[n - 2 - o],
                            e[o + 1] = e[n - 1 - o],
                            e[n - 2 - o] = s,
                            e[n - 1 - o] = a;
                        }
                }(a, i),
                e.push(a);
            }
        }
        function ve(t, r) {
            var o = (r = this.options = function(e, t) {
                for (var r in t)
                    e[r] = t[r];
                return e
            }(Object.create(this.options), r)).debug;
            if (o && console.time("preprocess data"),
            r.maxZoom < 0 || r.maxZoom > 24)
                throw new Error("maxZoom should be in the 0-24 range");
            if (r.promoteId && r.generateId)
                throw new Error("promoteId and generateId cannot be used together.");
            var n = function(t, r) {
                var o = [];
                if (e.changeCrs(r.crs),
                "FeatureCollection" === t.type)
                    for (var n = 0; n < t.features.length; n++)
                        Q(o, t.features[n], r, n);
                else
                    Q(o, "Feature" === t.type ? t : {
                        geometry: t
                    }, r);
                return o
            }(t, r);
            this.tiles = {},
            this.tileCoords = [],
            o && (console.timeEnd("preprocess data"),
            console.log("index: maxZoom: %d, maxPoints: %d", r.indexMaxZoom, r.indexMaxPoints),
            console.time("generate tiles"),
            this.stats = {},
            this.total = 0),
            (n = function(e, t) {
                var r = t.buffer / t.extent
                  , o = e
                  , n = oe(e, 1, -1 - r, r, 0, -1, 2, t)
                  , i = oe(e, 1, 1 - r, 2 + r, 0, -1, 2, t);
                return (n || i) && (o = oe(e, 1, -r, 1 + r, 0, -1, 2, t) || [],
                n && (o = ce(n, 1).concat(o)),
                i && (o = o.concat(ce(i, -1)))),
                o
            }(n, r)).length && this.splitTile(n, 0, 0, 0),
            o && (n.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints),
            console.timeEnd("generate tiles"),
            console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        function xe(e, t, r) {
            return 32 * ((1 << e) * r + t) + e
        }
        function we(e, t) {
            const r = e.tileID.canonical;
            if (!this._geoJSONIndex)
                return t(null, null);
            const o = this._geoJSONIndex.getTile(r.z, r.x, r.y);
            if (!o)
                return t(null, null);
            const n = new h(o.features);
            let i = d(n);
            0 === i.byteOffset && i.byteLength === i.buffer.byteLength || (i = new Uint8Array(i)),
            t(null, {
                vectorTile: n,
                rawData: i.buffer
            });
        }
        ve.prototype.options = {
            maxZoom: 14,
            indexMaxZoom: 5,
            indexMaxPoints: 1e5,
            tolerance: 3,
            extent: 4096,
            buffer: 64,
            lineMetrics: !1,
            promoteId: null,
            generateId: !1,
            debug: 0
        },
        ve.prototype.splitTile = function(e, t, r, o, n, i, s) {
            for (var a = [e, t, r, o], l = this.options, u = l.debug; a.length; ) {
                o = a.pop(),
                r = a.pop(),
                t = a.pop(),
                e = a.pop();
                var h = 1 << t
                  , c = xe(t, r, o)
                  , f = this.tiles[c];
                if (!f && (u > 1 && console.time("creation"),
                f = this.tiles[c] = de(e, t, r, o, l),
                this.tileCoords.push({
                    z: t,
                    x: r,
                    y: o
                }),
                u)) {
                    u > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t, r, o, f.numFeatures, f.numPoints, f.numSimplified),
                    console.timeEnd("creation"));
                    var p = "z" + t;
                    this.stats[p] = (this.stats[p] || 0) + 1,
                    this.total++;
                }
                if (f.source = e,
                n) {
                    if (t === l.maxZoom || t === n)
                        continue;
                    var g = 1 << n - t;
                    if (r !== Math.floor(i / g) || o !== Math.floor(s / g))
                        continue
                } else if (t === l.indexMaxZoom || f.numPoints <= l.indexMaxPoints)
                    continue;
                if (f.source = null,
                0 !== e.length) {
                    u > 1 && console.time("clipping");
                    var d, m, y, v, x, w, S = .5 * l.buffer / l.extent, M = .5 - S, P = .5 + S, b = 1 + S;
                    d = m = y = v = null,
                    x = oe(e, h, r - S, r + P, 0, f.minX, f.maxX, l),
                    w = oe(e, h, r + M, r + b, 0, f.minX, f.maxX, l),
                    e = null,
                    x && (d = oe(x, h, o - S, o + P, 1, f.minY, f.maxY, l),
                    m = oe(x, h, o + M, o + b, 1, f.minY, f.maxY, l),
                    x = null),
                    w && (y = oe(w, h, o - S, o + P, 1, f.minY, f.maxY, l),
                    v = oe(w, h, o + M, o + b, 1, f.minY, f.maxY, l),
                    w = null),
                    u > 1 && console.timeEnd("clipping"),
                    a.push(d || [], t + 1, 2 * r, 2 * o),
                    a.push(m || [], t + 1, 2 * r, 2 * o + 1),
                    a.push(y || [], t + 1, 2 * r + 1, 2 * o),
                    a.push(v || [], t + 1, 2 * r + 1, 2 * o + 1);
                }
            }
        }
        ,
        ve.prototype.getTile = function(e, t, r) {
            var o = this.options
              , n = o.extent
              , i = o.debug;
            if (e < 0 || e > 24)
                return null;
            var s = 1 << e
              , a = xe(e, t = (t % s + s) % s, r);
            if (this.tiles[a])
                return pe(this.tiles[a], n);
            i > 1 && console.log("drilling down to z%d-%d-%d", e, t, r);
            for (var l, u = e, h = t, c = r; !l && u > 0; )
                u--,
                h = Math.floor(h / 2),
                c = Math.floor(c / 2),
                l = this.tiles[xe(u, h, c)];
            return l && l.source ? (i > 1 && console.log("found parent tile z%d-%d-%d", u, h, c),
            i > 1 && console.time("drilling down"),
            this.splitTile(l.source, u, h, c, e, t, r),
            i > 1 && console.timeEnd("drilling down"),
            this.tiles[a] ? pe(this.tiles[a], n) : null) : null
        }
        ;
        class Se extends e.VectorTileWorkerSource {
            constructor(e, t, r, o, n) {
                super(e, t, r, o, we),
                n && (this.loadGeoJSON = n);
            }
            loadData(t, r) {
                const o = t && t.request
                  , n = o && o.collectResourceTiming;
                this.loadGeoJSON(t, ( (s, a) => {
                    if (s || !a)
                        return r(s);
                    if ("object" != typeof a)
                        return r(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));
                    {
                        e.decodeFeatures(a),
                        i(a, !0);
                        try {
                            if (t.filter) {
                                const r = e.createExpression(t.filter, {
                                    type: "boolean",
                                    "property-type": "data-driven",
                                    overridable: !1,
                                    transition: !1
                                });
                                if ("error" === r.result)
                                    throw new Error(r.value.map((e => `${e.key}: ${e.message}`)).join(", "));
                                const o = a.features.filter((e => r.value.evaluate({
                                    zoom: 0
                                }, e)));
                                a = {
                                    type: "FeatureCollection",
                                    features: o
                                };
                            }
                            this._geoJSONIndex = t.cluster ? new j(function({superclusterOptions: t, clusterProperties: r}) {
                                if (!r || !t)
                                    return t;
                                const o = {}
                                  , n = {}
                                  , i = {
                                    accumulated: null,
                                    zoom: 0
                                }
                                  , s = {
                                    properties: null
                                }
                                  , a = Object.keys(r);
                                for (const t of a) {
                                    const [i,s] = r[t]
                                      , a = e.createExpression(s)
                                      , l = e.createExpression("string" == typeof i ? [i, ["accumulated"], ["get", t]] : i);
                                    o[t] = a.value,
                                    n[t] = l.value;
                                }
                                return t.map = e => {
                                    s.properties = e;
                                    const t = {};
                                    for (const e of a)
                                        t[e] = o[e].evaluate(i, s);
                                    return t
                                }
                                ,
                                t.reduce = (e, t) => {
                                    s.properties = t;
                                    for (const t of a)
                                        i.accumulated = e[t],
                                        e[t] = n[t].evaluate(i, s);
                                }
                                ,
                                t
                            }(t)).load(a.features) : function(e, t) {
                                return new ve(e,t)
                            }(a, t.geojsonVtOptions);
                        } catch (s) {
                            return r(s)
                        }
                        this.loaded = {};
                        const l = {};
                        if (n) {
                            const r = e.getPerformanceMeasurement(o);
                            r && (l.resourceTiming = {},
                            l.resourceTiming[t.source] = JSON.parse(JSON.stringify(r)));
                        }
                        r(null, l);
                    }
                }
                ));
            }
            reloadTile(e, t) {
                const r = this.loaded;
                return r && r[e.uid] ? super.reloadTile(e, t) : this.loadTile(e, t)
            }
            loadGeoJSON(t, r) {
                if (t.request)
                    e.getJSON(t.request, r);
                else {
                    if ("string" != typeof t.data)
                        return r(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));
                    try {
                        return r(null, JSON.parse(t.data))
                    } catch (e) {
                        return r(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`))
                    }
                }
            }
            getClusterExpansionZoom(e, t) {
                try {
                    t(null, this._geoJSONIndex.getClusterExpansionZoom(e.clusterId));
                } catch (e) {
                    t(e);
                }
            }
            getClusterChildren(e, t) {
                try {
                    t(null, this._geoJSONIndex.getChildren(e.clusterId));
                } catch (e) {
                    t(e);
                }
            }
            getClusterLeaves(e, t) {
                try {
                    t(null, this._geoJSONIndex.getLeaves(e.clusterId, e.limit, e.offset));
                } catch (e) {
                    t(e);
                }
            }
        }
        class Me {
            constructor(t) {
                this.self = t,
                this.actor = new e.Actor(t,this),
                this.layerIndexes = {},
                this.availableImages = {},
                this.isSpriteLoaded = {},
                this.projections = {},
                this.defaultProjection = e.getProjection({
                    name: "mercator"
                }),
                this.workerSourceTypes = {
                    vector: e.VectorTileWorkerSource,
                    geojson: Se,
                    geobuf: Se,
                    flatgeobuf: Se
                },
                this.workerSources = {},
                this.demWorkerSources = {},
                this.self.registerWorkerSource = (e, t) => {
                    if (this.workerSourceTypes[e])
                        throw new Error(`Worker source with name "${e}" already registered.`);
                    this.workerSourceTypes[e] = t;
                }
                ,
                this.self.registerRTLTextPlugin = t => {
                    if (e.plugin.isParsed())
                        throw new Error("RTL text plugin already registered.");
                    e.plugin.applyArabicShaping = t.applyArabicShaping,
                    e.plugin.processBidirectionalText = t.processBidirectionalText,
                    e.plugin.processStyledBidirectionalText = t.processStyledBidirectionalText;
                }
                ;
            }
            clearCaches(e, t, r) {
                delete this.layerIndexes[e],
                delete this.availableImages[e],
                delete this.workerSources[e],
                delete this.demWorkerSources[e],
                r();
            }
            checkIfReady(e, t, r) {
                r();
            }
            setReferrer(e, t) {
                this.referrer = t;
            }
            spriteLoaded(t, r) {
                this.isSpriteLoaded[t] = r;
                for (const o in this.workerSources[t]) {
                    const n = this.workerSources[t][o];
                    for (const t in n)
                        n[t]instanceof e.VectorTileWorkerSource && (n[t].isSpriteLoaded = r,
                        n[t].fire(new e.Event("isSpriteLoaded")));
                }
            }
            setImages(e, t, r) {
                this.availableImages[e] = t;
                for (const r in this.workerSources[e]) {
                    const o = this.workerSources[e][r];
                    for (const e in o)
                        o[e].availableImages = t;
                }
                r();
            }
            enableTerrain(e, t, r) {
                this.terrain = t,
                r();
            }
            setProjection(t, r) {
                this.projections[t] = e.getProjection(r);
            }
            setLayers(e, t, r) {
                this.getLayerIndex(e).replace(t),
                r();
            }
            setXml(e, t, r) {
                this.getLayerIndex(e)._xml = t,
                r();
            }
            setLayersbuffer(t, r, o) {
                var n = e.BufferTostyle(new e.pbf(r))
                  , i = this.getLayerIndex(t);
                i.replace(n.layers),
                i._xml = n.xml,
                o();
            }
            updateLayers(e, t, r) {
                this.getLayerIndex(e).update(t.layers, t.removedIds),
                r();
            }
            loadTile(t, r, o) {
                const n = this.enableTerrain ? e.extend({
                    enableTerrain: this.terrain
                }, r) : r;
                n.projection = this.projections[t] || this.defaultProjection,
                this.getWorkerSource(t, r.type, r.source).loadTile(n, o);
            }
            loadDEMTile(t, r, o) {
                const n = this.enableTerrain ? e.extend({
                    buildQuadTree: this.terrain
                }, r) : r;
                this.getDEMWorkerSource(t, r.source).loadTile(n, o);
            }
            reloadTile(t, r, o) {
                const n = this.enableTerrain ? e.extend({
                    enableTerrain: this.terrain
                }, r) : r;
                n.projection = this.projections[t] || this.defaultProjection,
                this.getWorkerSource(t, r.type, r.source).reloadTile(n, o);
            }
            abortTile(e, t, r) {
                this.getWorkerSource(e, t.type, t.source).abortTile(t, r);
            }
            removeTile(e, t, r) {
                this.getWorkerSource(e, t.type, t.source).removeTile(t, r);
            }
            removeSource(e, t, r) {
                if (!this.workerSources[e] || !this.workerSources[e][t.type] || !this.workerSources[e][t.type][t.source])
                    return;
                const o = this.workerSources[e][t.type][t.source];
                delete this.workerSources[e][t.type][t.source],
                void 0 !== o.removeSource ? o.removeSource(t, r) : r();
            }
            loadWorkerSource(e, t, r) {
                try {
                    this.self.importScripts(t.url),
                    r();
                } catch (e) {
                    r(e.toString());
                }
            }
            syncRTLPluginState(t, r, o) {
                try {
                    e.plugin.setState(r);
                    const t = e.plugin.getPluginURL();
                    if (e.plugin.isLoaded() && !e.plugin.isParsed() && null != t) {
                        this.self.importScripts(t);
                        const r = e.plugin.isParsed();
                        o(r ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t}`), r);
                    }
                } catch (e) {
                    o(e.toString());
                }
            }
            getAvailableImages(e) {
                let t = this.availableImages[e];
                return t || (t = []),
                t
            }
            getLayerIndex(e) {
                let t = this.layerIndexes[e];
                return t || (t = this.layerIndexes[e] = new o),
                t
            }
            getWorkerSource(e, t, r) {
                return this.workerSources[e] || (this.workerSources[e] = {}),
                this.workerSources[e][t] || (this.workerSources[e][t] = {}),
                this.workerSources[e][t][r] || (this.workerSources[e][t][r] = new this.workerSourceTypes[t]({
                    send: (t, r, o, n, i, s) => {
                        this.actor.send(t, r, o, e, i, s);
                    }
                    ,
                    scheduler: this.actor.scheduler
                },this.getLayerIndex(e),this.getAvailableImages(e),this.isSpriteLoaded[e])),
                this.workerSources[e][t][r]
            }
            getDEMWorkerSource(e, t) {
                return this.demWorkerSources[e] || (this.demWorkerSources[e] = {}),
                this.demWorkerSources[e][t] || (this.demWorkerSources[e][t] = new n),
                this.demWorkerSources[e][t]
            }
            enforceCacheSizeLimit(t, r) {
                e.enforceCacheSizeLimit(r);
            }
            getWorkerPerformanceMetrics(e, t, r) {
                r(void 0, void 0);
            }
        }
        return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new Me(self)),
        Me
    }
    ));

    define(["./shared", "ol/Feature.js", "ol/geom/Point.js", "ol/geom/MultiPoint.js", "ol/geom/LineString.js", "ol/geom/MultiLineString.js", "ol/geom/Polygon.js", "ol/geom/MultiPolygon.js"], (function(t, e, r, o, n, s, a, l) {
        "use strict";
        function c(t, e) {
            if (Array.isArray(t)) {
                if (!Array.isArray(e) || t.length !== e.length)
                    return !1;
                for (let i = 0; i < t.length; i++)
                    if (!c(t[i], e[i]))
                        return !1;
                return !0
            }
            if ("object" == typeof t && null !== t && null !== e) {
                if ("object" != typeof e)
                    return !1;
                if (Object.keys(t).length !== Object.keys(e).length)
                    return !1;
                for (const i in t)
                    if (!c(t[i], e[i]))
                        return !1;
                return !0
            }
            return t === e
        }
        var h = u;
        function u(t) {
            return !function(t) {
                return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON"in window && "parse"in JSON && "stringify"in JSON ? function() {
                    if (!("Worker"in window && "Blob"in window && "URL"in window))
                        return !1;
                    var t, e, i = new Blob([""],{
                        type: "text/javascript"
                    }), r = URL.createObjectURL(i);
                    try {
                        e = new Worker(r),
                        t = !0;
                    } catch (e) {
                        t = !1;
                    }
                    return e && e.terminate(),
                    URL.revokeObjectURL(r),
                    t
                }() ? "Uint8ClampedArray"in window ? ArrayBuffer.isView ? function() {
                    var t = document.createElement("canvas");
                    t.width = t.height = 1;
                    var e = t.getContext("2d");
                    if (!e)
                        return !1;
                    var i = e.getImageData(0, 0, 1, 1);
                    return i && i.width === t.width
                }() ? (void 0 === d[e = t && t.failIfMajorPerformanceCaveat] && (d[e] = function(t) {
                    var e, i = function(t) {
                        var e = document.createElement("canvas")
                          , i = Object.create(u.webGLContextAttributes);
                        return i.failIfMajorPerformanceCaveat = t,
                        e.getContext("webgl", i) || e.getContext("experimental-webgl", i)
                    }(t);
                    if (!i)
                        return !1;
                    try {
                        e = i.createShader(i.VERTEX_SHADER);
                    } catch (t) {
                        return !1
                    }
                    return !(!e || i.isContextLost()) && (i.shaderSource(e, "void main() {}"),
                    i.compileShader(e),
                    !0 === i.getShaderParameter(e, i.COMPILE_STATUS))
                }(e)),
                d[e] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
                var e;
            }(t)
        }
        var d = {};
        u.webGLContextAttributes = {
            antialias: !1,
            alpha: !0,
            stencil: !0,
            depth: !0
        };
        var f = "3.1.2.4";
        function _(e, i, r) {
            const o = t.window.document.createElement(e);
            return void 0 !== i && (o.className = i),
            r && r.appendChild(o),
            o
        }
        function p(e, i, r) {
            const o = t.window.document.createElementNS("http://www.w3.org/2000/svg", e);
            for (const t of Object.keys(i))
                o.setAttributeNS(null, t, i[t]);
            return r && r.appendChild(o),
            o
        }
        const m = t.window.document && t.window.document.documentElement.style
          , g = m && void 0 !== m.userSelect ? "userSelect" : "WebkitUserSelect";
        let v;
        function y() {
            m && g && (v = m[g],
            m[g] = "none");
        }
        function b() {
            m && g && (m[g] = v);
        }
        function x(e) {
            e.preventDefault(),
            e.stopPropagation(),
            t.window.removeEventListener("click", x, !0);
        }
        function w() {
            t.window.addEventListener("click", x, !0),
            t.window.setTimeout(( () => {
                t.window.removeEventListener("click", x, !0);
            }
            ), 0);
        }
        function T(t, e) {
            const i = t.getBoundingClientRect();
            return C(t, i, e)
        }
        function E(t, e) {
            const i = t.getBoundingClientRect()
              , r = [];
            for (let o = 0; o < e.length; o++)
                r.push(C(t, i, e[o]));
            return r
        }
        function S(e) {
            return void 0 !== t.window.InstallTrigger && 2 === e.button && e.ctrlKey && t.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : e.button
        }
        function C(e, i, r) {
            const o = e.offsetWidth === i.width ? 1 : e.offsetWidth / i.width;
            return new t.pointGeometry((r.clientX - i.left) * o,(r.clientY - i.top) * o)
        }
        function A(t, e) {
            var i = e[0]
              , r = e[1]
              , o = e[2]
              , n = e[3]
              , s = i * n - o * r;
            return s ? (t[0] = n * (s = 1 / s),
            t[1] = -r * s,
            t[2] = -o * s,
            t[3] = i * s,
            t) : null
        }
        function M(e, i, r) {
            let o, n, s;
            const a = t.exported.devicePixelRatio > 1 ? "@2x" : "";
            let l = t.getJSON(i.transformRequest(i.normalizeSpriteURL(e, a, ".json"), t.ResourceType.SpriteJSON), ( (t, e) => {
                l = null,
                s || (s = t,
                o = e,
                h());
            }
            ))
              , c = t.getImage(i.transformRequest(i.normalizeSpriteURL(e, a, ".png"), t.ResourceType.SpriteImage), ( (t, e) => {
                c = null,
                s || (s = t,
                n = e,
                h());
            }
            ));
            function h() {
                if (s)
                    r(s);
                else if (o && n) {
                    const e = t.exported.getImageData(n)
                      , i = {};
                    for (const r in o) {
                        const {width: n, height: s, x: a, y: l, sdf: c, pixelRatio: h, stretchX: u, stretchY: d, content: f} = o[r]
                          , _ = new t.RGBAImage({
                            width: n,
                            height: s
                        });
                        t.RGBAImage.copy(e, _, {
                            x: a,
                            y: l
                        }, {
                            x: 0,
                            y: 0
                        }, {
                            width: n,
                            height: s
                        }),
                        i[r] = {
                            data: _,
                            pixelRatio: h,
                            sdf: c,
                            stretchX: u,
                            stretchY: d,
                            content: f
                        };
                    }
                    r(null, i);
                }
            }
            return {
                cancel() {
                    l && (l.cancel(),
                    l = null),
                    c && (c.cancel(),
                    c = null);
                }
            }
        }
        function I(t) {
            const {userImage: e} = t;
            return !!(e && e.render && e.render()) && (t.data.replace(new Uint8Array(e.data.buffer)),
            !0)
        }
        class z extends t.Evented {
            constructor() {
                super(),
                this.images = {},
                this.updatedImages = {},
                this.callbackDispatchedThisFrame = {},
                this.loaded = !1,
                this.requestors = [],
                this.patterns = {},
                this.atlasImage = new t.RGBAImage({
                    width: 1,
                    height: 1
                }),
                this.dirty = !0;
            }
            isLoaded() {
                return this.loaded
            }
            setLoaded(t) {
                if (this.loaded !== t && (this.loaded = t,
                t)) {
                    for (const {ids: t, callback: e} of this.requestors)
                        this._notify(t, e);
                    this.requestors = [];
                }
            }
            hasImage(t) {
                return !!this.getImage(t)
            }
            getImage(t) {
                return this.images[t]
            }
            addImage(t, e) {
                this._validate(t, e) && (this.images[t] = e);
            }
            _validate(e, i) {
                let r = !0;
                return this._validateStretch(i.stretchX, i.data && i.data.width) || (this.fire(new t.ErrorEvent(new Error(`Image "${e}" has invalid "stretchX" value`))),
                r = !1),
                this._validateStretch(i.stretchY, i.data && i.data.height) || (this.fire(new t.ErrorEvent(new Error(`Image "${e}" has invalid "stretchY" value`))),
                r = !1),
                this._validateContent(i.content, i) || (this.fire(new t.ErrorEvent(new Error(`Image "${e}" has invalid "content" value`))),
                r = !1),
                r
            }
            _validateStretch(t, e) {
                if (!t)
                    return !0;
                let i = 0;
                for (const r of t) {
                    if (r[0] < i || r[1] < r[0] || e < r[1])
                        return !1;
                    i = r[1];
                }
                return !0
            }
            _validateContent(t, e) {
                return !(t && (4 !== t.length || t[0] < 0 || e.data.width < t[0] || t[1] < 0 || e.data.height < t[1] || t[2] < 0 || e.data.width < t[2] || t[3] < 0 || e.data.height < t[3] || t[2] < t[0] || t[3] < t[1]))
            }
            updateImage(t, e) {
                e.version = this.images[t].version + 1,
                this.images[t] = e,
                this.updatedImages[t] = !0;
            }
            removeImage(t) {
                const e = this.images[t];
                delete this.images[t],
                delete this.patterns[t],
                e.userImage && e.userImage.onRemove && e.userImage.onRemove();
            }
            listImages() {
                return Object.keys(this.images)
            }
            getImages(t, e) {
                let i = !0;
                if (!this.isLoaded())
                    for (const e of t)
                        this.images[e] || (i = !1);
                this.isLoaded() || i ? this._notify(t, e) : this.requestors.push({
                    ids: t,
                    callback: e
                });
            }
            _notify(e, i) {
                const r = {};
                for (const i of e) {
                    this.images[i] || this.fire(new t.Event("styleimagemissing",{
                        id: i
                    }));
                    const e = this.images[i];
                    e ? r[i] = {
                        data: e.data.clone(),
                        pixelRatio: e.pixelRatio,
                        sdf: e.sdf,
                        version: e.version,
                        stretchX: e.stretchX,
                        stretchY: e.stretchY,
                        content: e.content,
                        hasRenderCallback: Boolean(e.userImage && e.userImage.render)
                    } : t.warnOnce(`Image "${i}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
                }
                i(null, r);
            }
            getPixelSize() {
                const {width: t, height: e} = this.atlasImage;
                return {
                    width: t,
                    height: e
                }
            }
            getPattern(e) {
                const i = this.patterns[e]
                  , r = this.getImage(e);
                if (!r)
                    return null;
                if (i && i.position.version === r.version)
                    return i.position;
                if (i)
                    i.position.version = r.version;
                else {
                    const i = {
                        w: r.data.width + 2,
                        h: r.data.height + 2,
                        x: 0,
                        y: 0
                    }
                      , o = new t.ImagePosition(i,r);
                    this.patterns[e] = {
                        bin: i,
                        position: o
                    };
                }
                return this._updatePatternAtlas(),
                this.patterns[e].position
            }
            bind(e) {
                const i = e.gl;
                this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage),
                this.dirty = !1) : this.atlasTexture = new t.Texture(e,this.atlasImage,i.RGBA),
                this.atlasTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE);
            }
            _updatePatternAtlas() {
                const e = [];
                for (const t in this.patterns)
                    e.push(this.patterns[t].bin);
                const {w: i, h: r} = t.potpack(e)
                  , o = this.atlasImage;
                o.resize({
                    width: i || 1,
                    height: r || 1
                });
                for (const e in this.patterns) {
                    const {bin: i} = this.patterns[e]
                      , r = i.x + 1
                      , n = i.y + 1
                      , s = this.images[e].data
                      , a = s.width
                      , l = s.height;
                    t.RGBAImage.copy(s, o, {
                        x: 0,
                        y: 0
                    }, {
                        x: r,
                        y: n
                    }, {
                        width: a,
                        height: l
                    }),
                    t.RGBAImage.copy(s, o, {
                        x: 0,
                        y: l - 1
                    }, {
                        x: r,
                        y: n - 1
                    }, {
                        width: a,
                        height: 1
                    }),
                    t.RGBAImage.copy(s, o, {
                        x: 0,
                        y: 0
                    }, {
                        x: r,
                        y: n + l
                    }, {
                        width: a,
                        height: 1
                    }),
                    t.RGBAImage.copy(s, o, {
                        x: a - 1,
                        y: 0
                    }, {
                        x: r - 1,
                        y: n
                    }, {
                        width: 1,
                        height: l
                    }),
                    t.RGBAImage.copy(s, o, {
                        x: 0,
                        y: 0
                    }, {
                        x: r + a,
                        y: n
                    }, {
                        width: 1,
                        height: l
                    });
                }
                this.dirty = !0;
            }
            beginFrame() {
                this.callbackDispatchedThisFrame = {};
            }
            dispatchRenderCallbacks(t) {
                for (const e of t) {
                    if (this.callbackDispatchedThisFrame[e])
                        continue;
                    this.callbackDispatchedThisFrame[e] = !0;
                    const t = this.images[e];
                    I(t) && this.updateImage(e, t);
                }
            }
        }
        const P = new t.Properties({
            anchor: new t.DataConstantProperty(t.spec.light.anchor),
            position: new class {
                constructor() {
                    this.specification = t.spec.light.position;
                }
                possiblyEvaluate(e, i) {
                    return function([e,i,r]) {
                        const o = t.degToRad(i + 90)
                          , n = t.degToRad(r);
                        return {
                            x: e * Math.cos(o) * Math.sin(n),
                            y: e * Math.sin(o) * Math.sin(n),
                            z: e * Math.cos(n),
                            azimuthal: i,
                            polar: r
                        }
                    }(e.expression.evaluate(i))
                }
                interpolate(e, i, r) {
                    return {
                        x: t.number(e.x, i.x, r),
                        y: t.number(e.y, i.y, r),
                        z: t.number(e.z, i.z, r),
                        azimuthal: t.number(e.azimuthal, i.azimuthal, r),
                        polar: t.number(e.polar, i.polar, r)
                    }
                }
            }
            ,
            color: new t.DataConstantProperty(t.spec.light.color),
            intensity: new t.DataConstantProperty(t.spec.light.intensity)
        })
          , D = "-transition";
        class B extends t.Evented {
            constructor(e) {
                super(),
                this._transitionable = new t.Transitionable(P),
                this.setLight(e),
                this._transitioning = this._transitionable.untransitioned();
            }
            getLight() {
                return this._transitionable.serialize()
            }
            setLight(e, i={}) {
                if (!this._validate(t.validateLight, e, i))
                    for (const i in e) {
                        const r = e[i];
                        t.endsWith(i, D) ? this._transitionable.setTransition(i.slice(0, -D.length), r) : this._transitionable.setValue(i, r);
                    }
            }
            updateTransitions(t) {
                this._transitioning = this._transitionable.transitioned(t, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition()
            }
            recalculate(t) {
                this.properties = this._transitioning.possiblyEvaluate(t);
            }
            _validate(e, i, r) {
                return (!r || !1 !== r.validate) && t.emitValidationErrors(this, e.call(t.validateStyle, t.extend({
                    value: i,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    },
                    styleSpec: t.spec
                })))
            }
        }
        const L = new t.Properties({
            source: new t.DataConstantProperty(t.spec.terrain.source),
            exaggeration: new t.DataConstantProperty(t.spec.terrain.exaggeration)
        })
          , R = "-transition";
        class k extends t.Evented {
            constructor(e, i) {
                super(),
                this._transitionable = new t.Transitionable(L),
                this.set(e),
                this._transitioning = this._transitionable.untransitioned(),
                this.drapeRenderMode = i;
            }
            get() {
                return this._transitionable.serialize()
            }
            set(e) {
                for (const i in e) {
                    const r = e[i];
                    t.endsWith(i, R) ? this._transitionable.setTransition(i.slice(0, -R.length), r) : this._transitionable.setValue(i, r);
                }
            }
            updateTransitions(t) {
                this._transitioning = this._transitionable.transitioned(t, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition()
            }
            recalculate(t) {
                this.properties = this._transitioning.possiblyEvaluate(t);
            }
        }
        function O(e, i, r, o) {
            const n = t.smoothstep(45, 65, r)
              , [s,a] = F(e, o)
              , l = t.length(i);
            let c = 1 - Math.min(1, Math.exp((l - s) / (a - s) * -6));
            return c *= c * c,
            c = Math.min(1, 1.00747 * c),
            c * n * e.alpha
        }
        function F(t, e) {
            const i = .5 / Math.tan(.5 * e);
            return [t.range[0] + i, t.range[1] + i]
        }
        const U = new t.Properties({
            range: new t.DataConstantProperty(t.spec.fog.range),
            color: new t.DataConstantProperty(t.spec.fog.color),
            "high-color": new t.DataConstantProperty(t.spec.fog["high-color"]),
            "space-color": new t.DataConstantProperty(t.spec.fog["space-color"]),
            "horizon-blend": new t.DataConstantProperty(t.spec.fog["horizon-blend"]),
            "star-intensity": new t.DataConstantProperty(t.spec.fog["star-intensity"])
        })
          , N = "-transition";
        class j extends t.Evented {
            constructor(e, i) {
                super(),
                this._transitionable = new t.Transitionable(U),
                this.set(e),
                this._transitioning = this._transitionable.untransitioned(),
                this._transform = i;
            }
            get state() {
                const e = this._transform
                  , i = "globe" === e.projection.name
                  , r = t.globeToMercatorTransition(e.zoom)
                  , o = this.properties.get("range")
                  , n = [.5, 3];
                return {
                    range: i ? [t.number(n[0], o[0], r), t.number(n[1], o[1], r)] : o,
                    horizonBlend: this.properties.get("horizon-blend"),
                    alpha: this.properties.get("color").a
                }
            }
            get() {
                return this._transitionable.serialize()
            }
            set(e, i={}) {
                if (!this._validate(t.validateFog, e, i)) {
                    for (const i of Object.keys(t.spec.fog))
                        e && void 0 === e[i] && (e[i] = t.spec.fog[i].default);
                    for (const i in e) {
                        const r = e[i];
                        t.endsWith(i, N) ? this._transitionable.setTransition(i.slice(0, -N.length), r) : this._transitionable.setValue(i, r);
                    }
                }
            }
            getOpacity(e) {
                if (!this._transform.projection.supportsFog)
                    return 0;
                const i = this.properties && this.properties.get("color") || 1;
                return ("globe" === this._transform.projection.name ? 1 : t.smoothstep(45, 65, e)) * i.a
            }
            getOpacityAtLatLng(e, i) {
                return this._transform.projection.supportsFog ? function(e, i, r) {
                    const o = t.MercatorCoordinate.fromLngLat(i)
                      , n = r.elevation ? r.elevation.getAtPointOrZero(o) : 0
                      , s = [o.x, o.y, n];
                    return t.transformMat4(s, s, r.mercatorFogMatrix),
                    O(e, s, r.pitch, r._fov)
                }(this.state, e, i) : 0
            }
            getFovAdjustedRange(t) {
                return this._transform.projection.supportsFog ? F(this.state, t) : [0, 1]
            }
            updateTransitions(t) {
                this._transitioning = this._transitionable.transitioned(t, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition()
            }
            recalculate(t) {
                this.properties = this._transitioning.possiblyEvaluate(t);
            }
            _validate(e, i, r) {
                return (!r || !1 !== r.validate) && t.emitValidationErrors(this, e.call(t.validateStyle, t.extend({
                    value: i,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    },
                    styleSpec: t.spec
                })))
            }
        }
        class G {
            constructor(e, i) {
                this.workerPool = e,
                this.actors = [],
                this.currentActor = 0,
                this.id = t.uniqueId();
                const r = this.workerPool.acquire(this.id);
                for (let t = 0; t < r.length; t++) {
                    const e = new G.Actor(r[t],i,this.id);
                    e.name = `Worker ${t}`,
                    this.actors.push(e);
                }
                this.ready = !1,
                this.broadcast("checkIfReady", null, ( () => {
                    this.ready = !0;
                }
                ));
            }
            broadcast(e, i, r) {
                t.asyncAll(this.actors, ( (t, r) => {
                    t.send(e, i, r);
                }
                ), r = r || function() {}
                );
            }
            getActor() {
                return this.currentActor = (this.currentActor + 1) % this.actors.length,
                this.actors[this.currentActor]
            }
            remove() {
                this.actors.forEach((t => {
                    t.remove();
                }
                )),
                this.actors = [],
                this.workerPool.release(this.id);
            }
        }
        function V(e, i, r, o) {
            var n = i * (t.EXTENT / (e.tileSize * Math.pow(2, r - e.tileID.overscaledZ)));
            return "xy" == o ? "Sg4326" == e.tileID.reference ? [n, n / e.tileID._tileH] : [n, n] : n
        }
        G.Actor = t.Actor;
        class Z {
            constructor(t, e, i, r) {
                this.screenBounds = t,
                this.cameraPoint = e,
                this._screenRaycastCache = {},
                this._cameraRaycastCache = {},
                this.isAboveHorizon = i,
                this.screenGeometry = this.bufferedScreenGeometry(0),
                this.screenGeometryMercator = this._bufferedScreenMercator(0, r);
            }
            static createFromScreenPoints(e, i) {
                let r, o;
                if (e instanceof t.pointGeometry || "number" == typeof e[0]) {
                    const n = t.pointGeometry.convert(e);
                    r = [t.pointGeometry.convert(e)],
                    o = i.isPointAboveHorizon(n);
                } else {
                    const n = t.pointGeometry.convert(e[0])
                      , s = t.pointGeometry.convert(e[1]);
                    r = [n, s],
                    o = t.polygonizeBounds(n, s).every((t => i.isPointAboveHorizon(t)));
                }
                return new Z(r,i.getCameraPoint(),o,i)
            }
            isPointQuery() {
                return 1 === this.screenBounds.length
            }
            bufferedScreenGeometry(e) {
                return t.polygonizeBounds(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], e)
            }
            bufferedCameraGeometry(e) {
                const i = this.screenBounds[0]
                  , r = 1 === this.screenBounds.length ? this.screenBounds[0].add(new t.pointGeometry(1,1)) : this.screenBounds[1]
                  , o = t.polygonizeBounds(i, r, 0, !1);
                return this.cameraPoint.y > r.y && (this.cameraPoint.x > i.x && this.cameraPoint.x < r.x ? o.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= r.x ? o[2] = this.cameraPoint : this.cameraPoint.x <= i.x && (o[3] = this.cameraPoint)),
                t.bufferConvexPolygon(o, e)
            }
            bufferedCameraGeometryGlobe(e) {
                const i = this.screenBounds[0]
                  , r = 1 === this.screenBounds.length ? this.screenBounds[0].add(new t.pointGeometry(1,1)) : this.screenBounds[1]
                  , o = t.polygonizeBounds(i, r, e)
                  , n = this.cameraPoint.clone();
                switch (3 * ((n.y > i.y) + (n.y > r.y)) + ((n.x > i.x) + (n.x > r.x))) {
                case 0:
                    o[0] = n,
                    o[4] = n.clone();
                    break;
                case 1:
                    o.splice(1, 0, n);
                    break;
                case 2:
                    o[1] = n;
                    break;
                case 3:
                    o.splice(4, 0, n);
                    break;
                case 5:
                    o.splice(2, 0, n);
                    break;
                case 6:
                    o[3] = n;
                    break;
                case 7:
                    o.splice(3, 0, n);
                    break;
                case 8:
                    o[2] = n;
                }
                return o
            }
            containsTile(e, i, r, o=0) {
                const n = e.queryPadding / i._pixelsPerMercatorPixel + 1
                  , s = r ? this._bufferedCameraMercator(n, i) : this._bufferedScreenMercator(n, i);
                let a = e.tileID.wrap + (s.unwrapped ? o : 0);
                const l = s.polygon.map((i => t.getTilePoint(e.tileTransform, i, a)));
                if (!t.polygonIntersectsBox(l, 0, 0, t.EXTENT, t.EXTENT))
                    return;
                a = e.tileID.wrap + (this.screenGeometryMercator.unwrapped ? o : 0);
                const c = this.screenGeometryMercator.polygon.map((i => t.getTileVec3(e.tileTransform, i, a)))
                  , h = c.map((e => new t.pointGeometry(e[0],e[1])))
                  , u = i.getFreeCameraOptions().position || new t.MercatorCoordinate(0,0,0)
                  , d = t.getTileVec3(e.tileTransform, u, a)
                  , f = c.map((e => {
                    const i = t.sub(e, e, d);
                    return t.normalize(i, i),
                    new t.Ray(d,i)
                }
                ))
                  , _ = V(e, 1, i.zoom) * i._pixelsPerMercatorPixel;
                return {
                    queryGeometry: this,
                    tilespaceGeometry: h,
                    tilespaceRays: f,
                    bufferedTilespaceGeometry: l,
                    bufferedTilespaceBounds: (p = t.getBounds(l),
                    p.min.x = t.clamp(p.min.x, 0, t.EXTENT),
                    p.min.y = t.clamp(p.min.y, 0, t.EXTENT),
                    p.max.x = t.clamp(p.max.x, 0, t.EXTENT),
                    p.max.y = t.clamp(p.max.y, 0, t.EXTENT),
                    p),
                    tile: e,
                    tileID: e.tileID,
                    pixelToTileUnitsFactor: _
                };
                var p;
            }
            _bufferedScreenMercator(t, e) {
                const i = H(t);
                if (this._screenRaycastCache[i])
                    return this._screenRaycastCache[i];
                {
                    let r;
                    return r = "globe" === e.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(t), e) : {
                        polygon: this.bufferedScreenGeometry(t).map((t => e.pointCoordinate3D(t))),
                        unwrapped: !0
                    },
                    this._screenRaycastCache[i] = r,
                    r
                }
            }
            _bufferedCameraMercator(t, e) {
                const i = H(t);
                if (this._cameraRaycastCache[i])
                    return this._cameraRaycastCache[i];
                {
                    let r;
                    return r = "globe" === e.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(t), e) : {
                        polygon: this.bufferedCameraGeometry(t).map((t => e.pointCoordinate3D(t))),
                        unwrapped: !0
                    },
                    this._cameraRaycastCache[i] = r,
                    r
                }
            }
            _projectAndResample(e, i) {
                const r = function(e, i) {
                    const r = t.multiply([], i.pixelMatrix, i.globeMatrix)
                      , o = [0, -t.GLOBE_RADIUS, 0, 1]
                      , n = [0, t.GLOBE_RADIUS, 0, 1]
                      , s = [0, 0, 0, 1];
                    t.transformMat4$1(o, o, r),
                    t.transformMat4$1(n, n, r),
                    t.transformMat4$1(s, s, r);
                    const a = new t.pointGeometry(o[0] / o[3],o[1] / o[3])
                      , l = new t.pointGeometry(n[0] / n[3],n[1] / n[3])
                      , c = t.polygonContainsPoint(e, a) && o[3] < s[3]
                      , h = t.polygonContainsPoint(e, l) && n[3] < s[3];
                    if (!c && !h)
                        return null;
                    const u = function(t, e, i) {
                        for (let r = 1; r < t.length; r++) {
                            const o = q(e.pointCoordinate3D(t[r - 1]).x)
                              , n = q(e.pointCoordinate3D(t[r]).x);
                            if (i < 0) {
                                if (o < n)
                                    return {
                                        idx: r,
                                        t: -o / (n - 1 - o)
                                    }
                            } else if (n < o)
                                return {
                                    idx: r,
                                    t: (1 - o) / (n + 1 - o)
                                }
                        }
                        return null
                    }(e, i, c ? -1 : 1);
                    if (!u)
                        return null;
                    const {idx: d, t: f} = u;
                    let _ = d > 1 ? W(e.slice(0, d), i) : []
                      , p = d < e.length ? W(e.slice(d), i) : [];
                    _ = _.map((e => new t.pointGeometry(q(e.x),e.y))),
                    p = p.map((e => new t.pointGeometry(q(e.x),e.y)));
                    const m = [..._];
                    0 === m.length && m.push(p[p.length - 1]);
                    const g = t.number(m[m.length - 1].y, (0 === p.length ? _[0] : p[0]).y, f);
                    let v;
                    return v = c ? [new t.pointGeometry(0,g), new t.pointGeometry(0,0), new t.pointGeometry(1,0), new t.pointGeometry(1,g)] : [new t.pointGeometry(1,g), new t.pointGeometry(1,1), new t.pointGeometry(0,1), new t.pointGeometry(0,g)],
                    m.push(...v),
                    0 === p.length ? m.push(_[0]) : m.push(...p),
                    {
                        polygon: m.map((e => new t.MercatorCoordinate(e.x,e.y))),
                        unwrapped: !1
                    }
                }(e, i);
                if (r)
                    return r;
                const o = function(e, i) {
                    let r = !1
                      , o = -1 / 0
                      , n = 0;
                    for (let t = 0; t < e.length - 1; t++)
                        e[t].x > o && (o = e[t].x,
                        n = t);
                    for (let t = 0; t < e.length - 1; t++) {
                        const i = (n + t) % (e.length - 1)
                          , o = e[i]
                          , s = e[i + 1];
                        Math.abs(o.x - s.x) > .5 && (o.x < s.x ? (o.x += 1,
                        0 === i && (e[e.length - 1].x += 1)) : (s.x += 1,
                        i + 1 === e.length - 1 && (e[0].x += 1)),
                        r = !0);
                    }
                    const s = t.mercatorXfromLng(i.center.lng);
                    return r && s < Math.abs(s - 1) && e.forEach((t => {
                        t.x -= 1;
                    }
                    )),
                    {
                        polygon: e,
                        unwrapped: r
                    }
                }(W(e, i).map((e => new t.pointGeometry(q(e.x),e.y))), i);
                return {
                    polygon: o.polygon.map((e => new t.MercatorCoordinate(e.x,e.y))),
                    unwrapped: o.unwrapped
                }
            }
        }
        function W(e, i) {
            return t.resample(e, (t => {
                const e = i.pointCoordinate3D(t);
                t.x = e.x,
                t.y = e.y;
            }
            ), 1 / 256)
        }
        function q(t) {
            return t < 0 ? 1 + t % 1 : t % 1
        }
        function H(t) {
            return 100 * t | 0
        }
        function X(e, i, r, o, n) {
            const s = function(r, o) {
                if (r)
                    return n(r);
                if (o) {
                    const r = t.pick(t.extend(o, e), ["tiles", "minzoom", "maxzoom", "attribution", "sgmap_logo", "bounds", "scheme", "tileSize", "encoding", "tilesecurity", "traffic", "zoomRule", "reference"]);
                    2 == o.reference && (r.reference = "Sg4326"),
                    o.vector_layers && (r.vectorLayers = o.vector_layers,
                    r.vectorLayerIds = r.vectorLayers.map((t => t.id))),
                    o.language_options && (r.languageOptions = o.language_options),
                    o.language && o.language[o.id] && (r.language = o.language[o.id]),
                    o.worldview_options && (r.worldviewOptions = o.worldview_options),
                    o.worldview ? r.worldview = o.worldview[o.id] : o.worldview_default && (r.worldview = o.worldview_default),
                    r.tiles = i.canonicalizeTileset(r, e.url),
                    n(null, r);
                }
            };
            return e.url ? t.getJSON(i.transformRequest(i.normalizeSourceURL(e.url, null, r, o), t.ResourceType.Source), s) : t.exported.frame(( () => s(null, e)))
        }
        class Y {
            constructor(e, i, r) {
                this.bounds = t.LngLatBounds.convert(this.validateBounds(e)),
                this.minzoom = i || 0,
                this.maxzoom = r || 24;
            }
            validateBounds(t) {
                return Array.isArray(t) && 4 === t.length ? [Math.max(-180, t[0]), Math.max(-90, t[1]), Math.min(180, t[2]), Math.min(90, t[3])] : [-180, -90, 180, 90]
            }
            contains(e) {
                const i = Math.pow(2, e.z)
                  , r = Math.floor(t.mercatorXfromLng(this.bounds.getWest()) * i)
                  , o = t.mercatorYfromLat(this.bounds.getNorth()) * i
                  , n = Math.ceil(t.mercatorXfromLng(this.bounds.getEast()) * i)
                  , s = t.mercatorYfromLat(this.bounds.getSouth()) * i;
                return e.x >= r && e.x < n && (t.getMecYRange(e).top >= o && t.getMecYRange(e).top < s || t.getMecYRange(e).bottom >= o && t.getMecYRange(e).bottom < s || t.getMecYRange(e).top <= o && t.getMecYRange(e).bottom > s)
            }
        }
        class K {
            constructor(t, e, i) {
                this.context = t;
                const r = t.gl;
                this.buffer = r.createBuffer(),
                this.dynamicDraw = Boolean(i),
                this.context.unbindVAO(),
                t.bindElementBuffer.set(this.buffer),
                r.bufferData(r.ELEMENT_ARRAY_BUFFER, e.arrayBuffer, this.dynamicDraw ? r.DYNAMIC_DRAW : r.STATIC_DRAW),
                this.dynamicDraw || e.destroy();
            }
            bind() {
                this.context.bindElementBuffer.set(this.buffer);
            }
            updateData(t) {
                const e = this.context.gl;
                this.context.unbindVAO(),
                this.bind(),
                e.bufferSubData(e.ELEMENT_ARRAY_BUFFER, 0, t.arrayBuffer);
            }
            destroy() {
                this.buffer && (this.context.gl.deleteBuffer(this.buffer),
                delete this.buffer);
            }
        }
        const J = {
            Int8: "BYTE",
            Uint8: "UNSIGNED_BYTE",
            Int16: "SHORT",
            Uint16: "UNSIGNED_SHORT",
            Int32: "INT",
            Uint32: "UNSIGNED_INT",
            Float32: "FLOAT"
        };
        class $ {
            constructor(t, e, i, r) {
                this.length = e.length,
                this.attributes = i,
                this.itemSize = e.bytesPerElement,
                this.dynamicDraw = r,
                this.context = t;
                const o = t.gl;
                this.buffer = o.createBuffer(),
                t.bindVertexBuffer.set(this.buffer),
                o.bufferData(o.ARRAY_BUFFER, e.arrayBuffer, this.dynamicDraw ? o.DYNAMIC_DRAW : o.STATIC_DRAW),
                this.dynamicDraw || e.destroy();
            }
            bind() {
                this.context.bindVertexBuffer.set(this.buffer);
            }
            updateData(t) {
                const e = this.context.gl;
                this.bind(),
                e.bufferSubData(e.ARRAY_BUFFER, 0, t.arrayBuffer);
            }
            enableAttributes(t, e) {
                for (let i = 0; i < this.attributes.length; i++) {
                    const r = e.attributes[this.attributes[i].name];
                    void 0 !== r && t.enableVertexAttribArray(r);
                }
            }
            setVertexAttribPointers(t, e, i) {
                for (let r = 0; r < this.attributes.length; r++) {
                    const o = this.attributes[r]
                      , n = e.attributes[o.name];
                    void 0 !== n && t.vertexAttribPointer(n, o.components, t[J[o.type]], !1, this.itemSize, o.offset + this.itemSize * (i || 0));
                }
            }
            destroy() {
                this.buffer && (this.context.gl.deleteBuffer(this.buffer),
                delete this.buffer);
            }
        }
        class Q {
            constructor(t) {
                this.gl = t.gl,
                this.default = this.getDefault(),
                this.current = this.default,
                this.dirty = !1;
            }
            get() {
                return this.current
            }
            set(t) {}
            getDefault() {
                return this.default
            }
            setDefault() {
                this.set(this.default);
            }
        }
        class tt extends Q {
            getDefault() {
                return t.Color.transparent
            }
            set(t) {
                const e = this.current;
                (t.r !== e.r || t.g !== e.g || t.b !== e.b || t.a !== e.a || this.dirty) && (this.gl.clearColor(t.r, t.g, t.b, t.a),
                this.current = t,
                this.dirty = !1);
            }
        }
        class et extends Q {
            getDefault() {
                return 1
            }
            set(t) {
                (t !== this.current || this.dirty) && (this.gl.clearDepth(t),
                this.current = t,
                this.dirty = !1);
            }
        }
        class it extends Q {
            getDefault() {
                return 0
            }
            set(t) {
                (t !== this.current || this.dirty) && (this.gl.clearStencil(t),
                this.current = t,
                this.dirty = !1);
            }
        }
        class rt extends Q {
            getDefault() {
                return [!0, !0, !0, !0]
            }
            set(t) {
                const e = this.current;
                (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || t[3] !== e[3] || this.dirty) && (this.gl.colorMask(t[0], t[1], t[2], t[3]),
                this.current = t,
                this.dirty = !1);
            }
        }
        class ot extends Q {
            getDefault() {
                return !0
            }
            set(t) {
                (t !== this.current || this.dirty) && (this.gl.depthMask(t),
                this.current = t,
                this.dirty = !1);
            }
        }
        class nt extends Q {
            getDefault() {
                return 255
            }
            set(t) {
                (t !== this.current || this.dirty) && (this.gl.stencilMask(t),
                this.current = t,
                this.dirty = !1);
            }
        }
        class st extends Q {
            getDefault() {
                return {
                    func: this.gl.ALWAYS,
                    ref: 0,
                    mask: 255
                }
            }
            set(t) {
                const e = this.current;
                (t.func !== e.func || t.ref !== e.ref || t.mask !== e.mask || this.dirty) && (this.gl.stencilFunc(t.func, t.ref, t.mask),
                this.current = t,
                this.dirty = !1);
            }
        }
        class at extends Q {
            getDefault() {
                const t = this.gl;
                return [t.KEEP, t.KEEP, t.KEEP]
            }
            set(t) {
                const e = this.current;
                (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || this.dirty) && (this.gl.stencilOp(t[0], t[1], t[2]),
                this.current = t,
                this.dirty = !1);
            }
        }
        class lt extends Q {
            getDefault() {
                return !1
            }
            set(t) {
                if (t === this.current && !this.dirty)
                    return;
                const e = this.gl;
                t ? e.enable(e.STENCIL_TEST) : e.disable(e.STENCIL_TEST),
                this.current = t,
                this.dirty = !1;
            }
        }
        class ct extends Q {
            getDefault() {
                return [0, 1]
            }
            set(t) {
                const e = this.current;
                (t[0] !== e[0] || t[1] !== e[1] || this.dirty) && (this.gl.depthRange(t[0], t[1]),
                this.current = t,
                this.dirty = !1);
            }
        }
        class ht extends Q {
            getDefault() {
                return !1
            }
            set(t) {
                if (t === this.current && !this.dirty)
                    return;
                const e = this.gl;
                t ? e.enable(e.DEPTH_TEST) : e.disable(e.DEPTH_TEST),
                this.current = t,
                this.dirty = !1;
            }
        }
        class ut extends Q {
            getDefault() {
                return this.gl.LESS
            }
            set(t) {
                (t !== this.current || this.dirty) && (this.gl.depthFunc(t),
                this.current = t,
                this.dirty = !1);
            }
        }
        class dt extends Q {
            getDefault() {
                return !1
            }
            set(t) {
                if (t === this.current && !this.dirty)
                    return;
                const e = this.gl;
                t ? e.enable(e.BLEND) : e.disable(e.BLEND),
                this.current = t,
                this.dirty = !1;
            }
        }
        class ft extends Q {
            getDefault() {
                const t = this.gl;
                return [t.ONE, t.ZERO]
            }
            set(t) {
                const e = this.current;
                (t[0] !== e[0] || t[1] !== e[1] || this.dirty) && (this.gl.blendFunc(t[0], t[1]),
                this.current = t,
                this.dirty = !1);
            }
        }
        class _t extends Q {
            getDefault() {
                return t.Color.transparent
            }
            set(t) {
                const e = this.current;
                (t.r !== e.r || t.g !== e.g || t.b !== e.b || t.a !== e.a || this.dirty) && (this.gl.blendColor(t.r, t.g, t.b, t.a),
                this.current = t,
                this.dirty = !1);
            }
        }
        class pt extends Q {
            getDefault() {
                return this.gl.FUNC_ADD
            }
            set(t) {
                (t !== this.current || this.dirty) && (this.gl.blendEquation(t),
                this.current = t,
                this.dirty = !1);
            }
        }
        class mt extends Q {
            getDefault() {
                return !1
            }
            set(t) {
                if (t === this.current && !this.dirty)
                    return;
                const e = this.gl;
                t ? e.enable(e.CULL_FACE) : e.disable(e.CULL_FACE),
                this.current = t,
                this.dirty = !1;
            }
        }
        class gt extends Q {
            getDefault() {
                return this.gl.BACK
            }
            set(t) {
                (t !== this.current || this.dirty) && (this.gl.cullFace(t),
                this.current = t,
                this.dirty = !1);
            }
        }
        class vt extends Q {
            getDefault() {
                return this.gl.CCW
            }
            set(t) {
                (t !== this.current || this.dirty) && (this.gl.frontFace(t),
                this.current = t,
                this.dirty = !1);
            }
        }
        class yt extends Q {
            getDefault() {
                return null
            }
            set(t) {
                (t !== this.current || this.dirty) && (this.gl.useProgram(t),
                this.current = t,
                this.dirty = !1);
            }
        }
        class bt extends Q {
            getDefault() {
                return this.gl.TEXTURE0
            }
            set(t) {
                (t !== this.current || this.dirty) && (this.gl.activeTexture(t),
                this.current = t,
                this.dirty = !1);
            }
        }
        class xt extends Q {
            getDefault() {
                const t = this.gl;
                return [0, 0, t.drawingBufferWidth, t.drawingBufferHeight]
            }
            set(t) {
                const e = this.current;
                (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || t[3] !== e[3] || this.dirty) && (this.gl.viewport(t[0], t[1], t[2], t[3]),
                this.current = t,
                this.dirty = !1);
            }
        }
        class wt extends Q {
            getDefault() {
                return null
            }
            set(t) {
                if (t === this.current && !this.dirty)
                    return;
                const e = this.gl;
                e.bindFramebuffer(e.FRAMEBUFFER, t),
                this.current = t,
                this.dirty = !1;
            }
        }
        class Tt extends Q {
            getDefault() {
                return null
            }
            set(t) {
                if (t === this.current && !this.dirty)
                    return;
                const e = this.gl;
                e.bindRenderbuffer(e.RENDERBUFFER, t),
                this.current = t,
                this.dirty = !1;
            }
        }
        class Et extends Q {
            getDefault() {
                return null
            }
            set(t) {
                if (t === this.current && !this.dirty)
                    return;
                const e = this.gl;
                e.bindTexture(e.TEXTURE_2D, t),
                this.current = t,
                this.dirty = !1;
            }
        }
        class St extends Q {
            getDefault() {
                return null
            }
            set(t) {
                if (t === this.current && !this.dirty)
                    return;
                const e = this.gl;
                e.bindBuffer(e.ARRAY_BUFFER, t),
                this.current = t,
                this.dirty = !1;
            }
        }
        class Ct extends Q {
            getDefault() {
                return null
            }
            set(t) {
                const e = this.gl;
                e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t),
                this.current = t,
                this.dirty = !1;
            }
        }
        class At extends Q {
            constructor(t) {
                super(t),
                this.vao = t.extVertexArrayObject;
            }
            getDefault() {
                return null
            }
            set(t) {
                this.vao && (t !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(t),
                this.current = t,
                this.dirty = !1);
            }
        }
        class Mt extends Q {
            getDefault() {
                return 4
            }
            set(t) {
                if (t === this.current && !this.dirty)
                    return;
                const e = this.gl;
                e.pixelStorei(e.UNPACK_ALIGNMENT, t),
                this.current = t,
                this.dirty = !1;
            }
        }
        class It extends Q {
            getDefault() {
                return !1
            }
            set(t) {
                if (t === this.current && !this.dirty)
                    return;
                const e = this.gl;
                e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t),
                this.current = t,
                this.dirty = !1;
            }
        }
        class zt extends Q {
            getDefault() {
                return !1
            }
            set(t) {
                if (t === this.current && !this.dirty)
                    return;
                const e = this.gl;
                e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, t),
                this.current = t,
                this.dirty = !1;
            }
        }
        class Pt extends Q {
            constructor(t, e) {
                super(t),
                this.context = t,
                this.parent = e;
            }
            getDefault() {
                return null
            }
        }
        class Dt extends Pt {
            setDirty() {
                this.dirty = !0;
            }
            set(t) {
                if (t === this.current && !this.dirty)
                    return;
                this.context.bindFramebuffer.set(this.parent);
                const e = this.gl;
                e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0),
                this.current = t,
                this.dirty = !1;
            }
        }
        class Bt extends Pt {
            attachment() {
                return this.gl.DEPTH_ATTACHMENT
            }
            set(t) {
                if (t === this.current && !this.dirty)
                    return;
                this.context.bindFramebuffer.set(this.parent);
                const e = this.gl;
                e.framebufferRenderbuffer(e.FRAMEBUFFER, this.attachment(), e.RENDERBUFFER, t),
                this.current = t,
                this.dirty = !1;
            }
        }
        class Lt extends Bt {
            attachment() {
                return this.gl.DEPTH_STENCIL_ATTACHMENT
            }
        }
        class Rt {
            constructor(t, e, i, r) {
                this.context = t,
                this.width = e,
                this.height = i;
                const o = this.framebuffer = t.gl.createFramebuffer();
                this.colorAttachment = new Dt(t,o),
                r && (this.depthAttachment = new Bt(t,o));
            }
            destroy() {
                const t = this.context.gl
                  , e = this.colorAttachment.get();
                if (e && t.deleteTexture(e),
                this.depthAttachment) {
                    const e = this.depthAttachment.get();
                    e && t.deleteRenderbuffer(e);
                }
                t.deleteFramebuffer(this.framebuffer);
            }
        }
        class kt {
            constructor(t) {
                this.gl = t,
                this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"),
                this.clearColor = new tt(this),
                this.clearDepth = new et(this),
                this.clearStencil = new it(this),
                this.colorMask = new rt(this),
                this.depthMask = new ot(this),
                this.stencilMask = new nt(this),
                this.stencilFunc = new st(this),
                this.stencilOp = new at(this),
                this.stencilTest = new lt(this),
                this.depthRange = new ct(this),
                this.depthTest = new ht(this),
                this.depthFunc = new ut(this),
                this.blend = new dt(this),
                this.blendFunc = new ft(this),
                this.blendColor = new _t(this),
                this.blendEquation = new pt(this),
                this.cullFace = new mt(this),
                this.cullFaceSide = new gt(this),
                this.frontFace = new vt(this),
                this.program = new yt(this),
                this.activeTexture = new bt(this),
                this.viewport = new xt(this),
                this.bindFramebuffer = new wt(this),
                this.bindRenderbuffer = new Tt(this),
                this.bindTexture = new Et(this),
                this.bindVertexBuffer = new St(this),
                this.bindElementBuffer = new Ct(this),
                this.bindVertexArrayOES = this.extVertexArrayObject && new At(this),
                this.pixelStoreUnpack = new Mt(this),
                this.pixelStoreUnpackPremultiplyAlpha = new It(this),
                this.pixelStoreUnpackFlipY = new zt(this),
                this.extTextureFilterAnisotropic = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),
                this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)),
                this.extTextureFilterAnisotropicForceOff = !1,
                this.extStandardDerivativesForceOff = !1,
                this.extTextureHalfFloat = t.getExtension("OES_texture_half_float"),
                this.extTextureHalfFloat && (t.getExtension("OES_texture_half_float_linear"),
                this.extRenderToTextureHalfFloat = t.getExtension("EXT_color_buffer_half_float")),
                this.extStandardDerivatives = t.getExtension("OES_standard_derivatives"),
                this.extTimerQuery = t.getExtension("EXT_disjoint_timer_query"),
                this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE);
            }
            setDefault() {
                this.unbindVAO(),
                this.clearColor.setDefault(),
                this.clearDepth.setDefault(),
                this.clearStencil.setDefault(),
                this.colorMask.setDefault(),
                this.depthMask.setDefault(),
                this.stencilMask.setDefault(),
                this.stencilFunc.setDefault(),
                this.stencilOp.setDefault(),
                this.stencilTest.setDefault(),
                this.depthRange.setDefault(),
                this.depthTest.setDefault(),
                this.depthFunc.setDefault(),
                this.blend.setDefault(),
                this.blendFunc.setDefault(),
                this.blendColor.setDefault(),
                this.blendEquation.setDefault(),
                this.cullFace.setDefault(),
                this.cullFaceSide.setDefault(),
                this.frontFace.setDefault(),
                this.program.setDefault(),
                this.activeTexture.setDefault(),
                this.bindFramebuffer.setDefault(),
                this.pixelStoreUnpack.setDefault(),
                this.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                this.pixelStoreUnpackFlipY.setDefault();
            }
            setDirty() {
                this.clearColor.dirty = !0,
                this.clearDepth.dirty = !0,
                this.clearStencil.dirty = !0,
                this.colorMask.dirty = !0,
                this.depthMask.dirty = !0,
                this.stencilMask.dirty = !0,
                this.stencilFunc.dirty = !0,
                this.stencilOp.dirty = !0,
                this.stencilTest.dirty = !0,
                this.depthRange.dirty = !0,
                this.depthTest.dirty = !0,
                this.depthFunc.dirty = !0,
                this.blend.dirty = !0,
                this.blendFunc.dirty = !0,
                this.blendColor.dirty = !0,
                this.blendEquation.dirty = !0,
                this.cullFace.dirty = !0,
                this.cullFaceSide.dirty = !0,
                this.frontFace.dirty = !0,
                this.program.dirty = !0,
                this.activeTexture.dirty = !0,
                this.viewport.dirty = !0,
                this.bindFramebuffer.dirty = !0,
                this.bindRenderbuffer.dirty = !0,
                this.bindTexture.dirty = !0,
                this.bindVertexBuffer.dirty = !0,
                this.bindElementBuffer.dirty = !0,
                this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0),
                this.pixelStoreUnpack.dirty = !0,
                this.pixelStoreUnpackPremultiplyAlpha.dirty = !0,
                this.pixelStoreUnpackFlipY.dirty = !0;
            }
            createIndexBuffer(t, e) {
                return new K(this,t,e)
            }
            createVertexBuffer(t, e, i) {
                return new $(this,t,e,i)
            }
            createRenderbuffer(t, e, i) {
                const r = this.gl
                  , o = r.createRenderbuffer();
                return this.bindRenderbuffer.set(o),
                r.renderbufferStorage(r.RENDERBUFFER, t, e, i),
                this.bindRenderbuffer.set(null),
                o
            }
            createFramebuffer(t, e, i) {
                return new Rt(this,t,e,i)
            }
            clear({color: t, depth: e, stencil: i}) {
                const r = this.gl;
                let o = 0;
                t && (o |= r.COLOR_BUFFER_BIT,
                this.clearColor.set(t),
                this.colorMask.set([!0, !0, !0, !0])),
                void 0 !== e && (o |= r.DEPTH_BUFFER_BIT,
                this.depthRange.set([0, 1]),
                this.clearDepth.set(e),
                this.depthMask.set(!0)),
                void 0 !== i && (o |= r.STENCIL_BUFFER_BIT,
                this.clearStencil.set(i),
                this.stencilMask.set(255)),
                r.clear(o);
            }
            setCullFace(t) {
                !1 === t.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0),
                this.cullFaceSide.set(t.mode),
                this.frontFace.set(t.frontFace));
            }
            setDepthMode(t) {
                t.func !== this.gl.ALWAYS || t.mask ? (this.depthTest.set(!0),
                this.depthFunc.set(t.func),
                this.depthMask.set(t.mask),
                this.depthRange.set(t.range)) : this.depthTest.set(!1);
            }
            setStencilMode(t) {
                t.test.func !== this.gl.ALWAYS || t.mask ? (this.stencilTest.set(!0),
                this.stencilMask.set(t.mask),
                this.stencilOp.set([t.fail, t.depthFail, t.pass]),
                this.stencilFunc.set({
                    func: t.test.func,
                    ref: t.ref,
                    mask: t.test.mask
                })) : this.stencilTest.set(!1);
            }
            setColorMode(e) {
                c(e.blendFunction, t.ColorMode.Replace) ? this.blend.set(!1) : (this.blend.set(!0),
                this.blendFunc.set(e.blendFunction),
                this.blendColor.set(e.blendColor)),
                this.colorMask.set(e.mask);
            }
            unbindVAO() {
                this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
            }
        }
        class Ot extends t.Evented {
            constructor(e, i, r, o) {
                super(),
                this.id = e,
                this.dispatcher = r,
                this.setEventedParent(o),
                this.type = "raster",
                this.minzoom = 0,
                this.maxzoom = 22,
                this.roundZoom = !0,
                this.scheme = "xyz",
                this.tileSize = 512,
                this._loaded = !1,
                this._options = t.extend({
                    type: "raster"
                }, i),
                t.extend(this, t.pick(i, ["url", "scheme", "tileSize"]));
            }
            load() {
                this._loaded = !1,
                this.fire(new t.Event("dataloading",{
                    dataType: "source"
                })),
                this._tileJSONRequest = X(this._options, this.map._requestManager, null, null, ( (e, i) => {
                    this._tileJSONRequest = null,
                    this._loaded = !0,
                    e ? this.fire(new t.ErrorEvent(e)) : i && (t.extend(this, i),
                    i.bounds && (this.tileBounds = new Y(i.bounds,this.minzoom,this.maxzoom)),
                    this.fire(new t.Event("data",{
                        dataType: "source",
                        sourceDataType: "metadata"
                    })),
                    this.fire(new t.Event("data",{
                        dataType: "source",
                        sourceDataType: "content"
                    })));
                }
                ));
            }
            loaded() {
                return this._loaded
            }
            onAdd(t) {
                this.map = t,
                this.load();
            }
            onRemove() {
                this._tileJSONRequest && (this._tileJSONRequest.cancel(),
                this._tileJSONRequest = null);
            }
            serialize() {
                return t.extend({}, this._options)
            }
            hasTile(t) {
                return !this.tileBounds || this.tileBounds.contains(t.canonical)
            }
            loadTile(e, i) {
                const r = t.exported.devicePixelRatio >= 2
                  , o = this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles, this.scheme), r, this.tileSize);
                e.request = t.getImage(t.extend(this.map._requestManager.transformRequest(o, t.ResourceType.Tile), {
                    tilesecurity: this.tilesecurity,
                    zxy: e.tileID.canonical,
                    traffic: this.traffic,
                    reference: this.reference
                }), ( (r, o, n, s) => (delete e.request,
                e.aborted ? (e.state = "unloaded",
                i(null)) : r ? (e.state = "errored",
                i(r)) : o ? (this.map._refreshExpiredTiles && e.setExpiryData({
                    cacheControl: n,
                    expires: s
                }),
                e.setTexture(o, this.map.painter),
                e.state = "loaded",
                t.cacheEntryPossiblyAdded(this.dispatcher),
                void i(null)) : i(null))));
            }
            static loadTileData(t, e, i) {
                t.setTexture(e, i);
            }
            static unloadTileData(t, e) {
                t.texture && e.saveTileTexture(t.texture);
            }
            abortTile(t, e) {
                t.request && (t.request.cancel(),
                delete t.request),
                e();
            }
            unloadTile(t, e) {
                t.texture && this.map.painter.saveTileTexture(t.texture),
                e();
            }
            hasTransition() {
                return !1
            }
        }
        let Ft;
        class Ut extends t.Evented {
            constructor(e, i, r, o) {
                super(),
                this.id = e,
                this.type = "geojson",
                this.minzoom = 0,
                this.maxzoom = 18,
                this.tileSize = 512,
                this.isTileClipped = !0,
                this.reparseOverscaled = !0,
                this._loaded = !1,
                this.actor = r.getActor(),
                this.setEventedParent(o),
                this._data = i.data,
                this._options = t.extend({}, i),
                this._collectResourceTiming = i.collectResourceTiming,
                void 0 !== i.maxzoom && (this.maxzoom = i.maxzoom),
                i.type && (this.type = i.type),
                i.attribution && (this.attribution = i.attribution),
                this.promoteId = i.promoteId;
                const n = t.EXTENT / this.tileSize;
                this.workerOptions = t.extend({
                    source: this.id,
                    cluster: i.cluster || !1,
                    geojsonVtOptions: {
                        buffer: (void 0 !== i.buffer ? i.buffer : 128) * n,
                        tolerance: (void 0 !== i.tolerance ? i.tolerance : .375) * n,
                        extent: t.EXTENT,
                        maxZoom: this.maxzoom,
                        lineMetrics: i.lineMetrics || !1,
                        generateId: i.generateId || !1,
                        crs: t.config.crs
                    },
                    superclusterOptions: {
                        maxZoom: void 0 !== i.clusterMaxZoom ? Math.min(i.clusterMaxZoom, this.maxzoom - 1) : this.maxzoom - 1,
                        minPoints: Math.max(2, i.clusterMinPoints || 2),
                        extent: t.EXTENT,
                        radius: (void 0 !== i.clusterRadius ? i.clusterRadius : 50) * n,
                        log: !1,
                        generateId: i.generateId || !1
                    },
                    clusterProperties: i.clusterProperties,
                    filter: i.filter
                }, i.workerOptions);
            }
            onAdd(t) {
                this.map = t,
                this.setData(this._data);
            }
            setData(t) {
                return this._data = t,
                this._updateWorkerData(),
                this
            }
            getClusterExpansionZoom(t, e) {
                return this.actor.send("geojson.getClusterExpansionZoom", {
                    clusterId: t,
                    source: this.id
                }, e),
                this
            }
            getClusterChildren(t, e) {
                return this.actor.send("geojson.getClusterChildren", {
                    clusterId: t,
                    source: this.id
                }, e),
                this
            }
            getClusterLeaves(t, e, i, r) {
                return this.actor.send("geojson.getClusterLeaves", {
                    source: this.id,
                    clusterId: t,
                    limit: e,
                    offset: i
                }, r),
                this
            }
            _updateWorkerData() {
                if (this._pendingLoad)
                    return void (this._coalesce = !0);
                this.fire(new t.Event("dataloading",{
                    dataType: "source"
                })),
                this._loaded = !1;
                const e = t.extend({}, this.workerOptions)
                  , i = this._data;
                "string" == typeof i ? (e.request = this.map._requestManager.transformRequest(t.exported.resolveURL(i), t.ResourceType.Source),
                e.request.collectResourceTiming = this._collectResourceTiming) : e.data = JSON.stringify(i),
                this._pendingLoad = this.actor.send(`${this.type}.loadData`, e, ( (e, i) => {
                    if (this._loaded = !0,
                    this._pendingLoad = null,
                    e)
                        this.fire(new t.ErrorEvent(e));
                    else {
                        const e = {
                            dataType: "source",
                            sourceDataType: this._metadataFired ? "content" : "metadata"
                        };
                        this._collectResourceTiming && i && i.resourceTiming && i.resourceTiming[this.id] && (e.resourceTiming = i.resourceTiming[this.id]),
                        this.fire(new t.Event("data",e)),
                        this._metadataFired = !0;
                    }
                    this._coalesce && (this._updateWorkerData(),
                    this._coalesce = !1);
                }
                ));
            }
            loaded() {
                return this._loaded
            }
            loadTile(e, i) {
                const r = e.actor ? "reloadTile" : "loadTile";
                e.actor = this.actor,
                e.request = this.actor.send(r, {
                    type: this.type,
                    uid: e.uid,
                    tileID: e.tileID,
                    tileZoom: e.tileZoom,
                    zoom: e.tileID.overscaledZ,
                    maxZoom: this.maxzoom,
                    tileSize: this.tileSize,
                    source: this.id,
                    pixelRatio: t.exported.devicePixelRatio,
                    showCollisionBoxes: this.map.showCollisionBoxes,
                    promoteId: this.promoteId
                }, ( (t, o) => (delete e.request,
                e.unloadVectorData(),
                e.aborted ? i(null) : t ? i(t) : (e.loadVectorData(o, this.map.painter, "reloadTile" === r),
                i(null)))), void 0, "loadTile" === r);
            }
            abortTile(t) {
                t.request && (t.request.cancel(),
                delete t.request),
                t.aborted = !0;
            }
            unloadTile(t) {
                t.unloadVectorData(),
                this.actor.send("removeTile", {
                    uid: t.uid,
                    type: this.type,
                    source: this.id
                });
            }
            onRemove() {
                this._pendingLoad && this._pendingLoad.cancel();
            }
            serialize() {
                return t.extend({}, this._options, {
                    type: this.type,
                    data: this._data
                })
            }
            hasTransition() {
                return !1
            }
        }
        function Nt(e, i, r, o, n, s, a, l) {
            const c = [e, r, n, i, o, s, 1, 1, 1]
              , h = [a, l, 1]
              , u = t.adjoint([], c)
              , [d,f,_] = t.transformMat3(h, h, t.transpose(u, u));
            return t.multiply$1(c, [d, 0, 0, 0, f, 0, 0, 0, _], c)
        }
        class jt extends t.Evented {
            constructor(t, e, i, r) {
                super(),
                this.id = t,
                this.dispatcher = i,
                this.coordinates = e.coordinates,
                this.type = "image",
                this.minzoom = 0,
                this.maxzoom = 22,
                this.tileSize = 512,
                this.tiles = {},
                this._loaded = !1,
                this.setEventedParent(r),
                this.options = e,
                this._dirty = !1;
            }
            load(e, i) {
                this._loaded = i || !1,
                this.fire(new t.Event("dataloading",{
                    dataType: "source"
                })),
                this.url = this.options.url,
                this._imageRequest = t.getImage(this.map._requestManager.transformRequest(this.url, t.ResourceType.Image), ( (i, r) => {
                    if (this._imageRequest = null,
                    this._loaded = !0,
                    i)
                        this.fire(new t.ErrorEvent(i));
                    else if (r) {
                        const {HTMLImageElement: i} = t.window;
                        this.image = r instanceof i ? t.exported.getImageData(r) : r,
                        this._dirty = !0,
                        this.width = this.image.width,
                        this.height = this.image.height,
                        e && (this.coordinates = e),
                        this._finishLoading();
                    }
                }
                ));
            }
            loaded() {
                return this._loaded
            }
            updateImage(t) {
                return this.image && t.url ? (this._imageRequest && t.url !== this.options.url && (this._imageRequest.cancel(),
                this._imageRequest = null),
                this.options.url = t.url,
                this.load(t.coordinates, this._loaded),
                this) : this
            }
            _finishLoading() {
                this.map && (this.setCoordinates(this.coordinates),
                this.fire(new t.Event("data",{
                    dataType: "source",
                    sourceDataType: "metadata"
                })));
            }
            onAdd(t) {
                this.map = t,
                this.load();
            }
            onRemove() {
                this._imageRequest && (this._imageRequest.cancel(),
                this._imageRequest = null),
                this.texture && this.texture.destroy();
            }
            setCoordinates(e) {
                this.coordinates = e,
                this._boundsArray = void 0;
                const i = e.map(t.MercatorCoordinate.fromLngLat);
                return this.tileID = function(e) {
                    let i = 1 / 0
                      , r = 1 / 0
                      , o = -1 / 0
                      , n = -1 / 0;
                    for (const t of e)
                        i = Math.min(i, t.x),
                        r = Math.min(r, t.y),
                        o = Math.max(o, t.x),
                        n = Math.max(n, t.y);
                    const s = Math.max(o - i, n - r)
                      , a = Math.max(0, Math.floor(-Math.log(s) / Math.LN2))
                      , l = Math.pow(2, a);
                    return new t.CanonicalTileID(a,Math.floor((i + o) / 2 * l),Math.floor((r + n) / 2 * l))
                }(i),
                this.minzoom = this.maxzoom = this.tileID.z,
                this.fire(new t.Event("data",{
                    dataType: "source",
                    sourceDataType: "content"
                })),
                this
            }
            _clear() {
                this._boundsArray = void 0;
            }
            _prepareData(e) {
                for (const t in this.tiles) {
                    const e = this.tiles[t];
                    "loaded" !== e.state && (e.state = "loaded",
                    e.texture = this.texture);
                }
                if (this._boundsArray)
                    return;
                const i = t.tileTransform(this.tileID, this.map.transform.projection)
                  , [r,o,n,s] = this.coordinates.map((e => {
                    const r = i.projection.project(e[0], e[1]);
                    return t.getTilePoint(i, r)._round()
                }
                ));
                this.perspectiveTransform = function(e, i, r, o, n, s, a, l, c, h) {
                    const u = Nt(0, 0, e, 0, 0, i, e, i)
                      , d = Nt(r, o, n, s, a, l, c, h);
                    return t.multiply$1(d, t.adjoint(u, u), d),
                    [d[6] / d[8] * e / t.EXTENT, d[7] / d[8] * i / t.EXTENT]
                }(this.width, this.height, r.x, r.y, o.x, o.y, s.x, s.y, n.x, n.y);
                const a = this._boundsArray = new t.StructArrayLayout4i8;
                a.emplaceBack(r.x, r.y, 0, 0),
                a.emplaceBack(o.x, o.y, t.EXTENT, 0),
                a.emplaceBack(s.x, s.y, 0, t.EXTENT),
                a.emplaceBack(n.x, n.y, t.EXTENT, t.EXTENT),
                this.boundsBuffer && this.boundsBuffer.destroy(),
                this.boundsBuffer = e.createVertexBuffer(a, t.boundsAttributes.members),
                this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
            }
            prepare() {
                if (0 === Object.keys(this.tiles).length || !this.image)
                    return;
                const e = this.map.painter.context
                  , i = e.gl;
                this._dirty && (this.texture ? this.texture.update(this.image) : (this.texture = new t.Texture(e,this.image,i.RGBA),
                this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE)),
                this._dirty = !1),
                this._prepareData(e);
            }
            loadTile(t, e) {
                this.tileID && this.tileID.equals(t.tileID.canonical) ? (this.tiles[String(t.tileID.wrap)] = t,
                t.buckets = {},
                e(null)) : (t.state = "errored",
                e(null));
            }
            serialize() {
                return {
                    type: "image",
                    url: this.options.url,
                    coordinates: this.coordinates
                }
            }
            hasTransition() {
                return !1
            }
        }
        var Gt, Vt, Zt, Wt, qt, Ht = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon", "GeometryCollection"];
        function Xt(t, e, i) {
            1 === t ? Gt.push(i.readString()) : 2 === t ? Wt = i.readVarint() : 3 === t ? qt = Math.pow(10, i.readVarint()) : 4 === t ? function(t, e) {
                e.type = "FeatureCollection",
                e.features = [],
                t.readMessage(Jt, e);
            }(i, e) : 5 === t ? Yt(i, e) : 6 === t && Kt(i, e);
        }
        function Yt(t, e) {
            e.type = "Feature";
            var i = t.readMessage($t, e);
            return "geometry"in i || (i.geometry = null),
            i
        }
        function Kt(t, e) {
            return e.type = "Point",
            t.readMessage(Qt, e)
        }
        function Jt(t, e, i) {
            1 === t ? e.features.push(Yt(i, {})) : 13 === t ? Vt.push(te(i)) : 15 === t && ee(i, e);
        }
        function $t(t, e, i) {
            1 === t ? e.geometry = Kt(i, {}) : 11 === t ? e.id = i.readString() : 12 === t ? e.id = i.readSVarint() : 13 === t ? Vt.push(te(i)) : 14 === t ? e.properties = ee(i, {}) : 15 === t && ee(i, e);
        }
        function Qt(t, e, i) {
            1 === t ? e.type = Ht[i.readVarint()] : 2 === t ? Zt = i.readPackedVarint() : 3 === t ? function(t, e, i) {
                "Point" === i ? t.coordinates = function(t) {
                    for (var e = t.readVarint() + t.pos, i = []; t.pos < e; )
                        i.push(t.readSVarint() / qt);
                    return i
                }(e) : "MultiPoint" === i || "LineString" === i ? t.coordinates = function(t) {
                    return ie(t, t.readVarint() + t.pos)
                }(e) : "MultiLineString" === i ? t.coordinates = re(e) : "Polygon" === i ? t.coordinates = re(e, !0) : "MultiPolygon" === i && (t.coordinates = function(t) {
                    var e = t.readVarint() + t.pos;
                    if (!Zt)
                        return [[ie(t, e, null, !0)]];
                    for (var i = [], r = 1, o = 0; o < Zt[0]; o++) {
                        for (var n = [], s = 0; s < Zt[r]; s++)
                            n.push(ie(t, e, Zt[r + 1 + s], !0));
                        r += Zt[r] + 1,
                        i.push(n);
                    }
                    return Zt = null,
                    i
                }(e));
            }(e, i, e.type) : 4 === t ? (e.geometries = e.geometries || [],
            e.geometries.push(Kt(i, {}))) : 13 === t ? Vt.push(te(i)) : 15 === t && ee(i, e);
        }
        function te(t) {
            for (var e = t.readVarint() + t.pos, i = null; t.pos < e; ) {
                var r = t.readVarint() >> 3;
                1 === r ? i = t.readString() : 2 === r ? i = t.readDouble() : 3 === r ? i = t.readVarint() : 4 === r ? i = -t.readVarint() : 5 === r ? i = t.readBoolean() : 6 === r && (i = JSON.parse(t.readString()));
            }
            return i
        }
        function ee(t, e) {
            for (var i = t.readVarint() + t.pos; t.pos < i; )
                e[Gt[t.readVarint()]] = Vt[t.readVarint()];
            return Vt = [],
            e
        }
        function ie(t, e, i, r) {
            var o, n, s = 0, a = [], l = [];
            for (n = 0; n < Wt; n++)
                l[n] = 0;
            for (; i ? s < i : t.pos < e; ) {
                for (o = [],
                n = 0; n < Wt; n++)
                    l[n] += t.readSVarint(),
                    o[n] = l[n] / qt;
                a.push(o),
                s++;
            }
            return r && a.push(a[0]),
            a
        }
        function re(t, e) {
            var i = t.readVarint() + t.pos;
            if (!Zt)
                return [ie(t, i, null, e)];
            for (var r = [], o = 0; o < Zt.length; o++)
                r.push(ie(t, i, Zt[o], e));
            return Zt = null,
            r
        }
        const oe = new Int32Array(2)
          , ne = new Float32Array(oe.buffer)
          , se = new Float64Array(oe.buffer)
          , ae = 1 === new Uint16Array(new Uint8Array([1, 0]).buffer)[0];
        var le;
        !function(t) {
            t[t.UTF8_BYTES = 1] = "UTF8_BYTES",
            t[t.UTF16_STRING = 2] = "UTF16_STRING";
        }(le || (le = {}));
        class ce {
            constructor(t) {
                this.bytes_ = t,
                this.position_ = 0,
                this.text_decoder_ = new TextDecoder;
            }
            static allocate(t) {
                return new ce(new Uint8Array(t))
            }
            clear() {
                this.position_ = 0;
            }
            bytes() {
                return this.bytes_
            }
            position() {
                return this.position_
            }
            setPosition(t) {
                this.position_ = t;
            }
            capacity() {
                return this.bytes_.length
            }
            readInt8(t) {
                return this.readUint8(t) << 24 >> 24
            }
            readUint8(t) {
                return this.bytes_[t]
            }
            readInt16(t) {
                return this.readUint16(t) << 16 >> 16
            }
            readUint16(t) {
                return this.bytes_[t] | this.bytes_[t + 1] << 8
            }
            readInt32(t) {
                return this.bytes_[t] | this.bytes_[t + 1] << 8 | this.bytes_[t + 2] << 16 | this.bytes_[t + 3] << 24
            }
            readUint32(t) {
                return this.readInt32(t) >>> 0
            }
            readInt64(t) {
                return BigInt.asIntN(64, BigInt(this.readUint32(t)) + (BigInt(this.readUint32(t + 4)) << BigInt(32)))
            }
            readUint64(t) {
                return BigInt.asUintN(64, BigInt(this.readUint32(t)) + (BigInt(this.readUint32(t + 4)) << BigInt(32)))
            }
            readFloat32(t) {
                return oe[0] = this.readInt32(t),
                ne[0]
            }
            readFloat64(t) {
                return oe[ae ? 0 : 1] = this.readInt32(t),
                oe[ae ? 1 : 0] = this.readInt32(t + 4),
                se[0]
            }
            writeInt8(t, e) {
                this.bytes_[t] = e;
            }
            writeUint8(t, e) {
                this.bytes_[t] = e;
            }
            writeInt16(t, e) {
                this.bytes_[t] = e,
                this.bytes_[t + 1] = e >> 8;
            }
            writeUint16(t, e) {
                this.bytes_[t] = e,
                this.bytes_[t + 1] = e >> 8;
            }
            writeInt32(t, e) {
                this.bytes_[t] = e,
                this.bytes_[t + 1] = e >> 8,
                this.bytes_[t + 2] = e >> 16,
                this.bytes_[t + 3] = e >> 24;
            }
            writeUint32(t, e) {
                this.bytes_[t] = e,
                this.bytes_[t + 1] = e >> 8,
                this.bytes_[t + 2] = e >> 16,
                this.bytes_[t + 3] = e >> 24;
            }
            writeInt64(t, e) {
                this.writeInt32(t, Number(BigInt.asIntN(32, e))),
                this.writeInt32(t + 4, Number(BigInt.asIntN(32, e >> BigInt(32))));
            }
            writeUint64(t, e) {
                this.writeUint32(t, Number(BigInt.asUintN(32, e))),
                this.writeUint32(t + 4, Number(BigInt.asUintN(32, e >> BigInt(32))));
            }
            writeFloat32(t, e) {
                ne[0] = e,
                this.writeInt32(t, oe[0]);
            }
            writeFloat64(t, e) {
                se[0] = e,
                this.writeInt32(t, oe[ae ? 0 : 1]),
                this.writeInt32(t + 4, oe[ae ? 1 : 0]);
            }
            getBufferIdentifier() {
                if (this.bytes_.length < this.position_ + 4 + 4)
                    throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
                let t = "";
                for (let e = 0; e < 4; e++)
                    t += String.fromCharCode(this.readInt8(this.position_ + 4 + e));
                return t
            }
            __offset(t, e) {
                const i = t - this.readInt32(t);
                return e < this.readInt16(i) ? this.readInt16(i + e) : 0
            }
            __union(t, e) {
                return t.bb_pos = e + this.readInt32(e),
                t.bb = this,
                t
            }
            __string(t, e) {
                t += this.readInt32(t);
                const i = this.readInt32(t)
                  , r = this.bytes_.subarray(t += 4, t + i);
                return e === le.UTF8_BYTES ? r : this.text_decoder_.decode(r)
            }
            __union_with_string(t, e) {
                return "string" == typeof t ? this.__string(e) : this.__union(t, e)
            }
            __indirect(t) {
                return t + this.readInt32(t)
            }
            __vector(t) {
                return t + this.readInt32(t) + 4
            }
            __vector_len(t) {
                return this.readInt32(t + this.readInt32(t))
            }
            __has_identifier(t) {
                if (4 != t.length)
                    throw new Error("FlatBuffers: file identifier must be length 4");
                for (let e = 0; e < 4; e++)
                    if (t.charCodeAt(e) != this.readInt8(this.position() + 4 + e))
                        return !1;
                return !0
            }
            createScalarList(t, e) {
                const i = [];
                for (let r = 0; r < e; ++r) {
                    const e = t(r);
                    null !== e && i.push(e);
                }
                return i
            }
            createObjList(t, e) {
                const i = [];
                for (let r = 0; r < e; ++r) {
                    const e = t(r);
                    null !== e && i.push(e.unpack());
                }
                return i
            }
        }
        var he, ue, de = new Uint8Array(0);
        function fe(t, e) {
            if (!t.length)
                return e;
            if (!e.length)
                return t;
            var i = new Uint8Array(t.length + e.length);
            return i.set(t),
            i.set(e, t.length),
            i
        }
        function _e(t) {
            this._source = t,
            this._array = de,
            this._index = 0;
        }
        _e.prototype.read = function() {
            var t = this
              , e = t._array.subarray(t._index);
            return t._source.read().then((function(i) {
                return t._array = de,
                t._index = 0,
                i.done ? e.length > 0 ? {
                    done: !1,
                    value: e
                } : {
                    done: !0,
                    value: void 0
                } : {
                    done: !1,
                    value: fe(e, i.value)
                }
            }
            ))
        }
        ,
        _e.prototype.slice = function(t) {
            if ((t |= 0) < 0)
                throw new Error("invalid length");
            var e = this
              , i = this._array.length - this._index;
            if (this._index + t <= this._array.length)
                return Promise.resolve(this._array.subarray(this._index, this._index += t));
            var r = new Uint8Array(t);
            return r.set(this._array.subarray(this._index)),
            function o() {
                return e._source.read().then((function(n) {
                    return n.done ? (e._array = de,
                    e._index = 0,
                    i > 0 ? r.subarray(0, i) : null) : i + n.value.length >= t ? (e._array = n.value,
                    e._index = t - i,
                    r.set(n.value.subarray(0, t - i), i),
                    r) : (r.set(n.value, i),
                    i += n.value.length,
                    o())
                }
                ))
            }()
        }
        ,
        _e.prototype.cancel = function() {
            return this._source.cancel()
        }
        ,
        function(t) {
            t[t.Byte = 0] = "Byte",
            t[t.UByte = 1] = "UByte",
            t[t.Bool = 2] = "Bool",
            t[t.Short = 3] = "Short",
            t[t.UShort = 4] = "UShort",
            t[t.Int = 5] = "Int",
            t[t.UInt = 6] = "UInt",
            t[t.Long = 7] = "Long",
            t[t.ULong = 8] = "ULong",
            t[t.Float = 9] = "Float",
            t[t.Double = 10] = "Double",
            t[t.String = 11] = "String",
            t[t.Json = 12] = "Json",
            t[t.DateTime = 13] = "DateTime",
            t[t.Binary = 14] = "Binary";
        }(he || (he = {}));
        class pe {
            constructor() {
                this.bb = null,
                this.bb_pos = 0;
            }
            __init(t, e) {
                return this.bb_pos = t,
                this.bb = e,
                this
            }
            static getRootAsColumn(t, e) {
                return (e || new pe).__init(t.readInt32(t.position()) + t.position(), t)
            }
            static getSizePrefixedRootAsColumn(t, e) {
                return t.setPosition(t.position() + 4),
                (e || new pe).__init(t.readInt32(t.position()) + t.position(), t)
            }
            name(t) {
                const e = this.bb.__offset(this.bb_pos, 4);
                return e ? this.bb.__string(this.bb_pos + e, t) : null
            }
            type() {
                const t = this.bb.__offset(this.bb_pos, 6);
                return t ? this.bb.readUint8(this.bb_pos + t) : he.Byte
            }
            title(t) {
                const e = this.bb.__offset(this.bb_pos, 8);
                return e ? this.bb.__string(this.bb_pos + e, t) : null
            }
            description(t) {
                const e = this.bb.__offset(this.bb_pos, 10);
                return e ? this.bb.__string(this.bb_pos + e, t) : null
            }
            width() {
                const t = this.bb.__offset(this.bb_pos, 12);
                return t ? this.bb.readInt32(this.bb_pos + t) : -1
            }
            precision() {
                const t = this.bb.__offset(this.bb_pos, 14);
                return t ? this.bb.readInt32(this.bb_pos + t) : -1
            }
            scale() {
                const t = this.bb.__offset(this.bb_pos, 16);
                return t ? this.bb.readInt32(this.bb_pos + t) : -1
            }
            nullable() {
                const t = this.bb.__offset(this.bb_pos, 18);
                return !t || !!this.bb.readInt8(this.bb_pos + t)
            }
            unique() {
                const t = this.bb.__offset(this.bb_pos, 20);
                return !!t && !!this.bb.readInt8(this.bb_pos + t)
            }
            primaryKey() {
                const t = this.bb.__offset(this.bb_pos, 22);
                return !!t && !!this.bb.readInt8(this.bb_pos + t)
            }
            metadata(t) {
                const e = this.bb.__offset(this.bb_pos, 24);
                return e ? this.bb.__string(this.bb_pos + e, t) : null
            }
            static startColumn(t) {
                t.startObject(11);
            }
            static addName(t, e) {
                t.addFieldOffset(0, e, 0);
            }
            static addType(t, e) {
                t.addFieldInt8(1, e, he.Byte);
            }
            static addTitle(t, e) {
                t.addFieldOffset(2, e, 0);
            }
            static addDescription(t, e) {
                t.addFieldOffset(3, e, 0);
            }
            static addWidth(t, e) {
                t.addFieldInt32(4, e, -1);
            }
            static addPrecision(t, e) {
                t.addFieldInt32(5, e, -1);
            }
            static addScale(t, e) {
                t.addFieldInt32(6, e, -1);
            }
            static addNullable(t, e) {
                t.addFieldInt8(7, +e, 1);
            }
            static addUnique(t, e) {
                t.addFieldInt8(8, +e, 0);
            }
            static addPrimaryKey(t, e) {
                t.addFieldInt8(9, +e, 0);
            }
            static addMetadata(t, e) {
                t.addFieldOffset(10, e, 0);
            }
            static endColumn(t) {
                const e = t.endObject();
                return t.requiredField(e, 4),
                e
            }
            static createColumn(t, e, i, r, o, n, s, a, l, c, h, u) {
                return pe.startColumn(t),
                pe.addName(t, e),
                pe.addType(t, i),
                pe.addTitle(t, r),
                pe.addDescription(t, o),
                pe.addWidth(t, n),
                pe.addPrecision(t, s),
                pe.addScale(t, a),
                pe.addNullable(t, l),
                pe.addUnique(t, c),
                pe.addPrimaryKey(t, h),
                pe.addMetadata(t, u),
                pe.endColumn(t)
            }
        }
        class me {
            constructor() {
                this.bb = null,
                this.bb_pos = 0;
            }
            __init(t, e) {
                return this.bb_pos = t,
                this.bb = e,
                this
            }
            static getRootAsCrs(t, e) {
                return (e || new me).__init(t.readInt32(t.position()) + t.position(), t)
            }
            static getSizePrefixedRootAsCrs(t, e) {
                return t.setPosition(t.position() + 4),
                (e || new me).__init(t.readInt32(t.position()) + t.position(), t)
            }
            org(t) {
                const e = this.bb.__offset(this.bb_pos, 4);
                return e ? this.bb.__string(this.bb_pos + e, t) : null
            }
            code() {
                const t = this.bb.__offset(this.bb_pos, 6);
                return t ? this.bb.readInt32(this.bb_pos + t) : 0
            }
            name(t) {
                const e = this.bb.__offset(this.bb_pos, 8);
                return e ? this.bb.__string(this.bb_pos + e, t) : null
            }
            description(t) {
                const e = this.bb.__offset(this.bb_pos, 10);
                return e ? this.bb.__string(this.bb_pos + e, t) : null
            }
            wkt(t) {
                const e = this.bb.__offset(this.bb_pos, 12);
                return e ? this.bb.__string(this.bb_pos + e, t) : null
            }
            codeString(t) {
                const e = this.bb.__offset(this.bb_pos, 14);
                return e ? this.bb.__string(this.bb_pos + e, t) : null
            }
            static startCrs(t) {
                t.startObject(6);
            }
            static addOrg(t, e) {
                t.addFieldOffset(0, e, 0);
            }
            static addCode(t, e) {
                t.addFieldInt32(1, e, 0);
            }
            static addName(t, e) {
                t.addFieldOffset(2, e, 0);
            }
            static addDescription(t, e) {
                t.addFieldOffset(3, e, 0);
            }
            static addWkt(t, e) {
                t.addFieldOffset(4, e, 0);
            }
            static addCodeString(t, e) {
                t.addFieldOffset(5, e, 0);
            }
            static endCrs(t) {
                return t.endObject()
            }
            static createCrs(t, e, i, r, o, n, s) {
                return me.startCrs(t),
                me.addOrg(t, e),
                me.addCode(t, i),
                me.addName(t, r),
                me.addDescription(t, o),
                me.addWkt(t, n),
                me.addCodeString(t, s),
                me.endCrs(t)
            }
        }
        !function(t) {
            t[t.Unknown = 0] = "Unknown",
            t[t.Point = 1] = "Point",
            t[t.LineString = 2] = "LineString",
            t[t.Polygon = 3] = "Polygon",
            t[t.MultiPoint = 4] = "MultiPoint",
            t[t.MultiLineString = 5] = "MultiLineString",
            t[t.MultiPolygon = 6] = "MultiPolygon",
            t[t.GeometryCollection = 7] = "GeometryCollection",
            t[t.CircularString = 8] = "CircularString",
            t[t.CompoundCurve = 9] = "CompoundCurve",
            t[t.CurvePolygon = 10] = "CurvePolygon",
            t[t.MultiCurve = 11] = "MultiCurve",
            t[t.MultiSurface = 12] = "MultiSurface",
            t[t.Curve = 13] = "Curve",
            t[t.Surface = 14] = "Surface",
            t[t.PolyhedralSurface = 15] = "PolyhedralSurface",
            t[t.TIN = 16] = "TIN",
            t[t.Triangle = 17] = "Triangle";
        }(ue || (ue = {}));
        class ge {
            constructor() {
                this.bb = null,
                this.bb_pos = 0;
            }
            __init(t, e) {
                return this.bb_pos = t,
                this.bb = e,
                this
            }
            static getRootAsHeader(t, e) {
                return (e || new ge).__init(t.readInt32(t.position()) + t.position(), t)
            }
            static getSizePrefixedRootAsHeader(t, e) {
                return t.setPosition(t.position() + 4),
                (e || new ge).__init(t.readInt32(t.position()) + t.position(), t)
            }
            name(t) {
                const e = this.bb.__offset(this.bb_pos, 4);
                return e ? this.bb.__string(this.bb_pos + e, t) : null
            }
            envelope(t) {
                const e = this.bb.__offset(this.bb_pos, 6);
                return e ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + e) + 8 * t) : 0
            }
            envelopeLength() {
                const t = this.bb.__offset(this.bb_pos, 6);
                return t ? this.bb.__vector_len(this.bb_pos + t) : 0
            }
            envelopeArray() {
                const t = this.bb.__offset(this.bb_pos, 6);
                return t ? new Float64Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),this.bb.__vector_len(this.bb_pos + t)) : null
            }
            geometryType() {
                const t = this.bb.__offset(this.bb_pos, 8);
                return t ? this.bb.readUint8(this.bb_pos + t) : ue.Unknown
            }
            hasZ() {
                const t = this.bb.__offset(this.bb_pos, 10);
                return !!t && !!this.bb.readInt8(this.bb_pos + t)
            }
            hasM() {
                const t = this.bb.__offset(this.bb_pos, 12);
                return !!t && !!this.bb.readInt8(this.bb_pos + t)
            }
            hasT() {
                const t = this.bb.__offset(this.bb_pos, 14);
                return !!t && !!this.bb.readInt8(this.bb_pos + t)
            }
            hasTm() {
                const t = this.bb.__offset(this.bb_pos, 16);
                return !!t && !!this.bb.readInt8(this.bb_pos + t)
            }
            columns(t, e) {
                const i = this.bb.__offset(this.bb_pos, 18);
                return i ? (e || new pe).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + 4 * t), this.bb) : null
            }
            columnsLength() {
                const t = this.bb.__offset(this.bb_pos, 18);
                return t ? this.bb.__vector_len(this.bb_pos + t) : 0
            }
            featuresCount() {
                const t = this.bb.__offset(this.bb_pos, 20);
                return t ? this.bb.readUint64(this.bb_pos + t) : BigInt("0")
            }
            indexNodeSize() {
                const t = this.bb.__offset(this.bb_pos, 22);
                return t ? this.bb.readUint16(this.bb_pos + t) : 16
            }
            crs(t) {
                const e = this.bb.__offset(this.bb_pos, 24);
                return e ? (t || new me).__init(this.bb.__indirect(this.bb_pos + e), this.bb) : null
            }
            title(t) {
                const e = this.bb.__offset(this.bb_pos, 26);
                return e ? this.bb.__string(this.bb_pos + e, t) : null
            }
            description(t) {
                const e = this.bb.__offset(this.bb_pos, 28);
                return e ? this.bb.__string(this.bb_pos + e, t) : null
            }
            metadata(t) {
                const e = this.bb.__offset(this.bb_pos, 30);
                return e ? this.bb.__string(this.bb_pos + e, t) : null
            }
            static startHeader(t) {
                t.startObject(14);
            }
            static addName(t, e) {
                t.addFieldOffset(0, e, 0);
            }
            static addEnvelope(t, e) {
                t.addFieldOffset(1, e, 0);
            }
            static createEnvelopeVector(t, e) {
                t.startVector(8, e.length, 8);
                for (let i = e.length - 1; i >= 0; i--)
                    t.addFloat64(e[i]);
                return t.endVector()
            }
            static startEnvelopeVector(t, e) {
                t.startVector(8, e, 8);
            }
            static addGeometryType(t, e) {
                t.addFieldInt8(2, e, ue.Unknown);
            }
            static addHasZ(t, e) {
                t.addFieldInt8(3, +e, 0);
            }
            static addHasM(t, e) {
                t.addFieldInt8(4, +e, 0);
            }
            static addHasT(t, e) {
                t.addFieldInt8(5, +e, 0);
            }
            static addHasTm(t, e) {
                t.addFieldInt8(6, +e, 0);
            }
            static addColumns(t, e) {
                t.addFieldOffset(7, e, 0);
            }
            static createColumnsVector(t, e) {
                t.startVector(4, e.length, 4);
                for (let i = e.length - 1; i >= 0; i--)
                    t.addOffset(e[i]);
                return t.endVector()
            }
            static startColumnsVector(t, e) {
                t.startVector(4, e, 4);
            }
            static addFeaturesCount(t, e) {
                t.addFieldInt64(8, e, BigInt("0"));
            }
            static addIndexNodeSize(t, e) {
                t.addFieldInt16(9, e, 16);
            }
            static addCrs(t, e) {
                t.addFieldOffset(10, e, 0);
            }
            static addTitle(t, e) {
                t.addFieldOffset(11, e, 0);
            }
            static addDescription(t, e) {
                t.addFieldOffset(12, e, 0);
            }
            static addMetadata(t, e) {
                t.addFieldOffset(13, e, 0);
            }
            static endHeader(t) {
                return t.endObject()
            }
            static finishHeaderBuffer(t, e) {
                t.finish(e);
            }
            static finishSizePrefixedHeaderBuffer(t, e) {
                t.finish(e, void 0, !0);
            }
        }
        class ve {
            constructor() {
                this.bb = null,
                this.bb_pos = 0;
            }
            __init(t, e) {
                return this.bb_pos = t,
                this.bb = e,
                this
            }
            static getRootAsGeometry(t, e) {
                return (e || new ve).__init(t.readInt32(t.position()) + t.position(), t)
            }
            static getSizePrefixedRootAsGeometry(t, e) {
                return t.setPosition(t.position() + 4),
                (e || new ve).__init(t.readInt32(t.position()) + t.position(), t)
            }
            ends(t) {
                const e = this.bb.__offset(this.bb_pos, 4);
                return e ? this.bb.readUint32(this.bb.__vector(this.bb_pos + e) + 4 * t) : 0
            }
            endsLength() {
                const t = this.bb.__offset(this.bb_pos, 4);
                return t ? this.bb.__vector_len(this.bb_pos + t) : 0
            }
            endsArray() {
                const t = this.bb.__offset(this.bb_pos, 4);
                return t ? new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),this.bb.__vector_len(this.bb_pos + t)) : null
            }
            xy(t) {
                const e = this.bb.__offset(this.bb_pos, 6);
                return e ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + e) + 8 * t) : 0
            }
            xyLength() {
                const t = this.bb.__offset(this.bb_pos, 6);
                return t ? this.bb.__vector_len(this.bb_pos + t) : 0
            }
            xyArray() {
                const t = this.bb.__offset(this.bb_pos, 6);
                return t ? new Float64Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),this.bb.__vector_len(this.bb_pos + t)) : null
            }
            z(t) {
                const e = this.bb.__offset(this.bb_pos, 8);
                return e ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + e) + 8 * t) : 0
            }
            zLength() {
                const t = this.bb.__offset(this.bb_pos, 8);
                return t ? this.bb.__vector_len(this.bb_pos + t) : 0
            }
            zArray() {
                const t = this.bb.__offset(this.bb_pos, 8);
                return t ? new Float64Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),this.bb.__vector_len(this.bb_pos + t)) : null
            }
            m(t) {
                const e = this.bb.__offset(this.bb_pos, 10);
                return e ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + e) + 8 * t) : 0
            }
            mLength() {
                const t = this.bb.__offset(this.bb_pos, 10);
                return t ? this.bb.__vector_len(this.bb_pos + t) : 0
            }
            mArray() {
                const t = this.bb.__offset(this.bb_pos, 10);
                return t ? new Float64Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),this.bb.__vector_len(this.bb_pos + t)) : null
            }
            t(t) {
                const e = this.bb.__offset(this.bb_pos, 12);
                return e ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + e) + 8 * t) : 0
            }
            tLength() {
                const t = this.bb.__offset(this.bb_pos, 12);
                return t ? this.bb.__vector_len(this.bb_pos + t) : 0
            }
            tArray() {
                const t = this.bb.__offset(this.bb_pos, 12);
                return t ? new Float64Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),this.bb.__vector_len(this.bb_pos + t)) : null
            }
            tm(t) {
                const e = this.bb.__offset(this.bb_pos, 14);
                return e ? this.bb.readUint64(this.bb.__vector(this.bb_pos + e) + 8 * t) : BigInt(0)
            }
            tmLength() {
                const t = this.bb.__offset(this.bb_pos, 14);
                return t ? this.bb.__vector_len(this.bb_pos + t) : 0
            }
            type() {
                const t = this.bb.__offset(this.bb_pos, 16);
                return t ? this.bb.readUint8(this.bb_pos + t) : ue.Unknown
            }
            parts(t, e) {
                const i = this.bb.__offset(this.bb_pos, 18);
                return i ? (e || new ve).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + 4 * t), this.bb) : null
            }
            partsLength() {
                const t = this.bb.__offset(this.bb_pos, 18);
                return t ? this.bb.__vector_len(this.bb_pos + t) : 0
            }
            static startGeometry(t) {
                t.startObject(8);
            }
            static addEnds(t, e) {
                t.addFieldOffset(0, e, 0);
            }
            static createEndsVector(t, e) {
                t.startVector(4, e.length, 4);
                for (let i = e.length - 1; i >= 0; i--)
                    t.addInt32(e[i]);
                return t.endVector()
            }
            static startEndsVector(t, e) {
                t.startVector(4, e, 4);
            }
            static addXy(t, e) {
                t.addFieldOffset(1, e, 0);
            }
            static createXyVector(t, e) {
                t.startVector(8, e.length, 8);
                for (let i = e.length - 1; i >= 0; i--)
                    t.addFloat64(e[i]);
                return t.endVector()
            }
            static startXyVector(t, e) {
                t.startVector(8, e, 8);
            }
            static addZ(t, e) {
                t.addFieldOffset(2, e, 0);
            }
            static createZVector(t, e) {
                t.startVector(8, e.length, 8);
                for (let i = e.length - 1; i >= 0; i--)
                    t.addFloat64(e[i]);
                return t.endVector()
            }
            static startZVector(t, e) {
                t.startVector(8, e, 8);
            }
            static addM(t, e) {
                t.addFieldOffset(3, e, 0);
            }
            static createMVector(t, e) {
                t.startVector(8, e.length, 8);
                for (let i = e.length - 1; i >= 0; i--)
                    t.addFloat64(e[i]);
                return t.endVector()
            }
            static startMVector(t, e) {
                t.startVector(8, e, 8);
            }
            static addT(t, e) {
                t.addFieldOffset(4, e, 0);
            }
            static createTVector(t, e) {
                t.startVector(8, e.length, 8);
                for (let i = e.length - 1; i >= 0; i--)
                    t.addFloat64(e[i]);
                return t.endVector()
            }
            static startTVector(t, e) {
                t.startVector(8, e, 8);
            }
            static addTm(t, e) {
                t.addFieldOffset(5, e, 0);
            }
            static createTmVector(t, e) {
                t.startVector(8, e.length, 8);
                for (let i = e.length - 1; i >= 0; i--)
                    t.addInt64(e[i]);
                return t.endVector()
            }
            static startTmVector(t, e) {
                t.startVector(8, e, 8);
            }
            static addType(t, e) {
                t.addFieldInt8(6, e, ue.Unknown);
            }
            static addParts(t, e) {
                t.addFieldOffset(7, e, 0);
            }
            static createPartsVector(t, e) {
                t.startVector(4, e.length, 4);
                for (let i = e.length - 1; i >= 0; i--)
                    t.addOffset(e[i]);
                return t.endVector()
            }
            static startPartsVector(t, e) {
                t.startVector(4, e, 4);
            }
            static endGeometry(t) {
                return t.endObject()
            }
            static createGeometry(t, e, i, r, o, n, s, a, l) {
                return ve.startGeometry(t),
                ve.addEnds(t, e),
                ve.addXy(t, i),
                ve.addZ(t, r),
                ve.addM(t, o),
                ve.addT(t, n),
                ve.addTm(t, s),
                ve.addType(t, a),
                ve.addParts(t, l),
                ve.endGeometry(t)
            }
        }
        class ye {
            constructor() {
                this.bb = null,
                this.bb_pos = 0;
            }
            __init(t, e) {
                return this.bb_pos = t,
                this.bb = e,
                this
            }
            static getRootAsFeature(t, e) {
                return (e || new ye).__init(t.readInt32(t.position()) + t.position(), t)
            }
            static getSizePrefixedRootAsFeature(t, e) {
                return t.setPosition(t.position() + 4),
                (e || new ye).__init(t.readInt32(t.position()) + t.position(), t)
            }
            geometry(t) {
                const e = this.bb.__offset(this.bb_pos, 4);
                return e ? (t || new ve).__init(this.bb.__indirect(this.bb_pos + e), this.bb) : null
            }
            properties(t) {
                const e = this.bb.__offset(this.bb_pos, 6);
                return e ? this.bb.readUint8(this.bb.__vector(this.bb_pos + e) + t) : 0
            }
            propertiesLength() {
                const t = this.bb.__offset(this.bb_pos, 6);
                return t ? this.bb.__vector_len(this.bb_pos + t) : 0
            }
            propertiesArray() {
                const t = this.bb.__offset(this.bb_pos, 6);
                return t ? new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),this.bb.__vector_len(this.bb_pos + t)) : null
            }
            columns(t, e) {
                const i = this.bb.__offset(this.bb_pos, 8);
                return i ? (e || new pe).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + 4 * t), this.bb) : null
            }
            columnsLength() {
                const t = this.bb.__offset(this.bb_pos, 8);
                return t ? this.bb.__vector_len(this.bb_pos + t) : 0
            }
            static startFeature(t) {
                t.startObject(3);
            }
            static addGeometry(t, e) {
                t.addFieldOffset(0, e, 0);
            }
            static addProperties(t, e) {
                t.addFieldOffset(1, e, 0);
            }
            static createPropertiesVector(t, e) {
                t.startVector(1, e.length, 1);
                for (let i = e.length - 1; i >= 0; i--)
                    t.addInt8(e[i]);
                return t.endVector()
            }
            static startPropertiesVector(t, e) {
                t.startVector(1, e, 1);
            }
            static addColumns(t, e) {
                t.addFieldOffset(2, e, 0);
            }
            static createColumnsVector(t, e) {
                t.startVector(4, e.length, 4);
                for (let i = e.length - 1; i >= 0; i--)
                    t.addOffset(e[i]);
                return t.endVector()
            }
            static startColumnsVector(t, e) {
                t.startVector(4, e, 4);
            }
            static endFeature(t) {
                return t.endObject()
            }
            static finishFeatureBuffer(t, e) {
                t.finish(e);
            }
            static finishSizePrefixedFeatureBuffer(t, e) {
                t.finish(e, void 0, !0);
            }
            static createFeature(t, e, i, r) {
                return ye.startFeature(t),
                ye.addGeometry(t, e),
                ye.addProperties(t, i),
                ye.addColumns(t, r),
                ye.endFeature(t)
            }
        }
        function be(t) {
            const e = ge.getRootAsHeader(t)
              , i = e.featuresCount()
              , r = e.indexNodeSize()
              , o = [];
            for (let t = 0; t < e.columnsLength(); t++) {
                const i = e.columns(t);
                if (!i)
                    throw new Error("Column unexpectedly missing");
                if (!i.name())
                    throw new Error("Column name unexpectedly missing");
                o.push({
                    name: i.name(),
                    type: i.type(),
                    title: i.title(),
                    description: i.description(),
                    width: i.width(),
                    precision: i.precision(),
                    scale: i.scale(),
                    nullable: i.nullable(),
                    unique: i.unique(),
                    primary_key: i.primaryKey()
                });
            }
            const n = e.crs()
              , s = n ? {
                org: n.org(),
                code: n.code(),
                name: n.name(),
                description: n.description(),
                wkt: n.wkt(),
                code_string: n.codeString()
            } : null;
            return {
                geometryType: e.geometryType(),
                columns: o,
                envelope: null,
                featuresCount: Number(i),
                indexNodeSize: r,
                crs: s,
                title: e.title(),
                description: e.description(),
                metadata: e.metadata()
            }
        }
        function xe(t, e) {
            const i = [];
            for (let r = 0; r < t.length; r += 2) {
                const o = [t[r], t[r + 1]];
                e && o.push(e[r >> 1]),
                i.push(o);
            }
            return i
        }
        new TextEncoder;
        const we = new TextDecoder;
        function Te(t, e) {
            const i = {};
            if (!e || 0 === e.length)
                return i;
            const r = t.propertiesArray();
            if (!r)
                return i;
            const o = new DataView(r.buffer,r.byteOffset)
              , n = t.propertiesLength();
            let s = 0;
            for (; s < n; ) {
                const t = o.getUint16(s, !0);
                s += 2;
                const n = e[t]
                  , a = n.name;
                switch (n.type) {
                case he.Bool:
                    i[a] = !!o.getUint8(s),
                    s += 1;
                    break;
                case he.Byte:
                    i[a] = o.getInt8(s),
                    s += 1;
                    break;
                case he.UByte:
                    i[a] = o.getUint8(s),
                    s += 1;
                    break;
                case he.Short:
                    i[a] = o.getInt16(s, !0),
                    s += 2;
                    break;
                case he.UShort:
                    i[a] = o.getUint16(s, !0),
                    s += 2;
                    break;
                case he.Int:
                    i[a] = o.getInt32(s, !0),
                    s += 4;
                    break;
                case he.UInt:
                    i[a] = o.getUint32(s, !0),
                    s += 4;
                    break;
                case he.Long:
                    i[a] = Number(o.getBigInt64(s, !0)),
                    s += 8;
                    break;
                case he.ULong:
                    i[a] = Number(o.getBigUint64(s, !0)),
                    s += 8;
                    break;
                case he.Float:
                    i[a] = o.getFloat32(s, !0),
                    s += 4;
                    break;
                case he.Double:
                    i[a] = o.getFloat64(s, !0),
                    s += 8;
                    break;
                case he.DateTime:
                case he.String:
                    {
                        const t = o.getUint32(s, !0);
                        s += 4,
                        i[a] = we.decode(r.subarray(s, s + t)),
                        s += t;
                        break
                    }
                case he.Json:
                    {
                        const t = o.getUint32(s, !0);
                        s += 4;
                        const e = we.decode(r.subarray(s, s + t));
                        i[a] = JSON.parse(e),
                        s += t;
                        break
                    }
                default:
                    throw new Error("Unknown type " + n.type)
                }
            }
            return i
        }
        /*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
        var Ee = function(t, e) {
            return (Ee = Object.setPrototypeOf || {
                __proto__: []
            }instanceof Array && function(t, e) {
                t.__proto__ = e;
            }
            || function(t, e) {
                for (var i in e)
                    e.hasOwnProperty(i) && (t[i] = e[i]);
            }
            )(t, e)
        };
        function Se(t, e, i, r) {
            return new (i || (i = Promise))((function(o, n) {
                function s(t) {
                    try {
                        l(r.next(t));
                    } catch (t) {
                        n(t);
                    }
                }
                function a(t) {
                    try {
                        l(r.throw(t));
                    } catch (t) {
                        n(t);
                    }
                }
                function l(t) {
                    var e;
                    t.done ? o(t.value) : (e = t.value,
                    e instanceof i ? e : new i((function(t) {
                        t(e);
                    }
                    ))).then(s, a);
                }
                l((r = r.apply(t, e || [])).next());
            }
            ))
        }
        function Ce(t, e) {
            var i, r, o, n, s = {
                label: 0,
                sent: function() {
                    if (1 & o[0])
                        throw o[1];
                    return o[1]
                },
                trys: [],
                ops: []
            };
            return n = {
                next: a(0),
                throw: a(1),
                return: a(2)
            },
            "function" == typeof Symbol && (n[Symbol.iterator] = function() {
                return this
            }
            ),
            n;
            function a(n) {
                return function(a) {
                    return function(n) {
                        if (i)
                            throw new TypeError("Generator is already executing.");
                        for (; s; )
                            try {
                                if (i = 1,
                                r && (o = 2 & n[0] ? r.return : n[0] ? r.throw || ((o = r.return) && o.call(r),
                                0) : r.next) && !(o = o.call(r, n[1])).done)
                                    return o;
                                switch (r = 0,
                                o && (n = [2 & n[0], o.value]),
                                n[0]) {
                                case 0:
                                case 1:
                                    o = n;
                                    break;
                                case 4:
                                    return s.label++,
                                    {
                                        value: n[1],
                                        done: !1
                                    };
                                case 5:
                                    s.label++,
                                    r = n[1],
                                    n = [0];
                                    continue;
                                case 7:
                                    n = s.ops.pop(),
                                    s.trys.pop();
                                    continue;
                                default:
                                    if (!((o = (o = s.trys).length > 0 && o[o.length - 1]) || 6 !== n[0] && 2 !== n[0])) {
                                        s = 0;
                                        continue
                                    }
                                    if (3 === n[0] && (!o || n[1] > o[0] && n[1] < o[3])) {
                                        s.label = n[1];
                                        break
                                    }
                                    if (6 === n[0] && s.label < o[1]) {
                                        s.label = o[1],
                                        o = n;
                                        break
                                    }
                                    if (o && s.label < o[2]) {
                                        s.label = o[2],
                                        s.ops.push(n);
                                        break
                                    }
                                    o[2] && s.ops.pop(),
                                    s.trys.pop();
                                    continue
                                }
                                n = e.call(t, s);
                            } catch (t) {
                                n = [6, t],
                                r = 0;
                            } finally {
                                i = o = 0;
                            }
                        if (5 & n[0])
                            throw n[1];
                        return {
                            value: n[0] ? n[1] : void 0,
                            done: !0
                        }
                    }([n, a])
                }
            }
        }
        function Ae(t) {
            var e = "function" == typeof Symbol && Symbol.iterator
              , i = e && t[e]
              , r = 0;
            if (i)
                return i.call(t);
            if (t && "number" == typeof t.length)
                return {
                    next: function() {
                        return t && r >= t.length && (t = void 0),
                        {
                            value: t && t[r++],
                            done: !t
                        }
                    }
                };
            throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
        }
        function Me(t) {
            return this instanceof Me ? (this.v = t,
            this) : new Me(t)
        }
        function Ie(t, e, i) {
            if (!Symbol.asyncIterator)
                throw new TypeError("Symbol.asyncIterator is not defined.");
            var r, o = i.apply(t, e || []), n = [];
            return r = {},
            s("next"),
            s("throw"),
            s("return"),
            r[Symbol.asyncIterator] = function() {
                return this
            }
            ,
            r;
            function s(t) {
                o[t] && (r[t] = function(e) {
                    return new Promise((function(i, r) {
                        n.push([t, e, i, r]) > 1 || a(t, e);
                    }
                    ))
                }
                );
            }
            function a(t, e) {
                try {
                    (i = o[t](e)).value instanceof Me ? Promise.resolve(i.value.v).then(l, c) : h(n[0][2], i);
                } catch (t) {
                    h(n[0][3], t);
                }
                var i;
            }
            function l(t) {
                a("next", t);
            }
            function c(t) {
                a("throw", t);
            }
            function h(t, e) {
                t(e),
                n.shift(),
                n.length && a(n[0][0], n[0][1]);
            }
        }
        var ze = function(t) {
            function e(e) {
                var i = t.call(this, e) || this;
                return Object.defineProperty(i, "name", {
                    value: "RepeaterOverflowError",
                    enumerable: !1
                }),
                "function" == typeof Object.setPrototypeOf ? Object.setPrototypeOf(i, i.constructor.prototype) : i.__proto__ = i.constructor.prototype,
                "function" == typeof Error.captureStackTrace && Error.captureStackTrace(i, i.constructor),
                i
            }
            return function(t, e) {
                function i() {
                    this.constructor = t;
                }
                Ee(t, e),
                t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype,
                new i);
            }(e, t),
            e
        }(Error);
        function Pe(t) {
            null != t && "function" == typeof t.then && t.then(De, De);
        }
        !function() {
            function t(t) {
                if (t < 0)
                    throw new RangeError("Capacity may not be less than 0");
                this._c = t,
                this._q = [];
            }
            Object.defineProperty(t.prototype, "empty", {
                get: function() {
                    return 0 === this._q.length
                },
                enumerable: !1,
                configurable: !0
            }),
            Object.defineProperty(t.prototype, "full", {
                get: function() {
                    return this._q.length >= this._c
                },
                enumerable: !1,
                configurable: !0
            }),
            t.prototype.add = function(t) {
                if (this.full)
                    throw new Error("Buffer full");
                this._q.push(t);
            }
            ,
            t.prototype.remove = function() {
                if (this.empty)
                    throw new Error("Buffer empty");
                return this._q.shift()
            }
            ;
        }(),
        function() {
            function t(t) {
                if (t < 1)
                    throw new RangeError("Capacity may not be less than 1");
                this._c = t,
                this._q = [];
            }
            Object.defineProperty(t.prototype, "empty", {
                get: function() {
                    return 0 === this._q.length
                },
                enumerable: !1,
                configurable: !0
            }),
            Object.defineProperty(t.prototype, "full", {
                get: function() {
                    return !1
                },
                enumerable: !1,
                configurable: !0
            }),
            t.prototype.add = function(t) {
                for (; this._q.length >= this._c; )
                    this._q.shift();
                this._q.push(t);
            }
            ,
            t.prototype.remove = function() {
                if (this.empty)
                    throw new Error("Buffer empty");
                return this._q.shift()
            }
            ;
        }(),
        function() {
            function t(t) {
                if (t < 1)
                    throw new RangeError("Capacity may not be less than 1");
                this._c = t,
                this._q = [];
            }
            Object.defineProperty(t.prototype, "empty", {
                get: function() {
                    return 0 === this._q.length
                },
                enumerable: !1,
                configurable: !0
            }),
            Object.defineProperty(t.prototype, "full", {
                get: function() {
                    return !1
                },
                enumerable: !1,
                configurable: !0
            }),
            t.prototype.add = function(t) {
                this._q.length < this._c && this._q.push(t);
            }
            ,
            t.prototype.remove = function() {
                if (this.empty)
                    throw new Error("Buffer empty");
                return this._q.shift()
            }
            ;
        }();
        var De = function() {};
        function Be(t) {
            var e = t.err
              , i = Promise.resolve(t.execution).then((function(t) {
                if (null != e)
                    throw e;
                return t
            }
            ));
            return t.err = void 0,
            t.execution = i.then((function() {}
            ), (function() {}
            )),
            void 0 === t.pending ? i : t.pending.then((function() {
                return i
            }
            ))
        }
        function Le(t, e) {
            var i = t.state >= 3;
            return Promise.resolve(e).then((function(e) {
                return !i && t.state >= 4 ? Be(t).then((function(t) {
                    return {
                        value: t,
                        done: !0
                    }
                }
                )) : {
                    value: e,
                    done: i
                }
            }
            ))
        }
        function Re(t, e) {
            var i, r;
            if (!(t.state >= 2))
                if (t.state = 2,
                t.onnext(),
                t.onstop(),
                null == t.err && (t.err = e),
                0 !== t.pushes.length || void 0 !== t.buffer && !t.buffer.empty)
                    try {
                        for (var o = Ae(t.pushes), n = o.next(); !n.done; n = o.next())
                            n.value.resolve();
                    } catch (t) {
                        i = {
                            error: t
                        };
                    } finally {
                        try {
                            n && !n.done && (r = o.return) && r.call(o);
                        } finally {
                            if (i)
                                throw i.error
                        }
                    }
                else
                    ke(t);
        }
        function ke(t) {
            var e, i;
            if (!(t.state >= 3)) {
                t.state < 2 && Re(t),
                t.state = 3,
                t.buffer = void 0;
                try {
                    for (var r = Ae(t.nexts), o = r.next(); !o.done; o = r.next()) {
                        var n = o.value
                          , s = void 0 === t.pending ? Be(t) : t.pending.then((function() {
                            return Be(t)
                        }
                        ));
                        n.resolve(Le(t, s));
                    }
                } catch (t) {
                    e = {
                        error: t
                    };
                } finally {
                    try {
                        o && !o.done && (i = r.return) && i.call(r);
                    } finally {
                        if (e)
                            throw e.error
                    }
                }
                t.pushes = [],
                t.nexts = [];
            }
        }
        function Oe(t) {
            t.state >= 4 || (t.state < 3 && ke(t),
            t.state = 4);
        }
        function Fe(t, e) {
            if (Pe(e),
            t.pushes.length >= 1024)
                throw new ze("No more than 1024 pending calls to push are allowed on a single repeater.");
            if (t.state >= 2)
                return Promise.resolve(void 0);
            var i, r = void 0 === t.pending ? Promise.resolve(e) : t.pending.then((function() {
                return e
            }
            ));
            r = r.catch((function(e) {
                t.state < 2 && (t.err = e),
                Oe(t);
            }
            )),
            t.nexts.length ? (t.nexts.shift().resolve(Le(t, r)),
            i = t.nexts.length ? Promise.resolve(t.nexts[0].value) : new Promise((function(e) {
                return t.onnext = e
            }
            ))) : void 0 === t.buffer || t.buffer.full ? i = new Promise((function(e) {
                return t.pushes.push({
                    resolve: e,
                    value: r
                })
            }
            )) : (t.buffer.add(r),
            i = Promise.resolve(void 0));
            var o = !0
              , n = {}
              , s = i.catch((function(t) {
                if (o)
                    throw t
            }
            ));
            return n.then = function(t, e) {
                return o = !1,
                Promise.prototype.then.call(i, t, e)
            }
            ,
            n.catch = function(t) {
                return o = !1,
                Promise.prototype.catch.call(i, t)
            }
            ,
            n.finally = i.finally.bind(i),
            t.pending = r.then((function() {
                return s
            }
            )).catch((function(e) {
                t.err = e,
                Oe(t);
            }
            )),
            n
        }
        function Ue(t) {
            if (!(t.state >= 1)) {
                t.state = 1;
                var e = Fe.bind(null, t)
                  , i = function(t) {
                    var e = Re.bind(null, t)
                      , i = new Promise((function(e) {
                        return t.onstop = e
                    }
                    ));
                    return e.then = i.then.bind(i),
                    e.catch = i.catch.bind(i),
                    e.finally = i.finally.bind(i),
                    e
                }(t);
                t.execution = new Promise((function(r) {
                    return r(t.executor(e, i))
                }
                )),
                t.execution.catch((function() {
                    return Re(t)
                }
                ));
            }
        }
        var Ne, je = new WeakMap, Ge = function() {
            function t(t, e) {
                je.set(this, {
                    executor: t,
                    buffer: e,
                    err: void 0,
                    state: 0,
                    pushes: [],
                    nexts: [],
                    pending: void 0,
                    execution: void 0,
                    onnext: De,
                    onstop: De
                });
            }
            return t.prototype.next = function(t) {
                Pe(t);
                var e = je.get(this);
                if (void 0 === e)
                    throw new Error("WeakMap error");
                if (e.nexts.length >= 1024)
                    throw new ze("No more than 1024 pending calls to next are allowed on a single repeater.");
                if (e.state <= 0 && Ue(e),
                e.onnext(t),
                void 0 !== e.buffer && !e.buffer.empty) {
                    var i = Le(e, e.buffer.remove());
                    if (e.pushes.length) {
                        var r = e.pushes.shift();
                        e.buffer.add(r.value),
                        e.onnext = r.resolve;
                    }
                    return i
                }
                if (e.pushes.length) {
                    var o = e.pushes.shift();
                    return e.onnext = o.resolve,
                    Le(e, o.value)
                }
                return e.state >= 2 ? (ke(e),
                Le(e, Be(e))) : new Promise((function(i) {
                    return e.nexts.push({
                        resolve: i,
                        value: t
                    })
                }
                ))
            }
            ,
            t.prototype.return = function(t) {
                Pe(t);
                var e = je.get(this);
                if (void 0 === e)
                    throw new Error("WeakMap error");
                return ke(e),
                e.execution = Promise.resolve(e.execution).then((function() {
                    return t
                }
                )),
                Le(e, Be(e))
            }
            ,
            t.prototype.throw = function(t) {
                var e = je.get(this);
                if (void 0 === e)
                    throw new Error("WeakMap error");
                return e.state <= 0 || e.state >= 2 || void 0 !== e.buffer && !e.buffer.empty ? (ke(e),
                null == e.err && (e.err = t),
                Le(e, Be(e))) : this.next(Promise.reject(t))
            }
            ,
            t.prototype[Symbol.asyncIterator] = function() {
                return this
            }
            ,
            t.race = Ze,
            t.merge = We,
            t.zip = qe,
            t.latest = He,
            t
        }();
        function Ve(t, e) {
            var i, r, o = [], n = function(t) {
                null != t && "function" == typeof t[Symbol.asyncIterator] ? o.push(t[Symbol.asyncIterator]()) : null != t && "function" == typeof t[Symbol.iterator] ? o.push(t[Symbol.iterator]()) : o.push(function() {
                    return Ie(this, arguments, (function() {
                        return Ce(this, (function(i) {
                            switch (i.label) {
                            case 0:
                                return e.yieldValues ? [4, Me(t)] : [3, 3];
                            case 1:
                                return [4, i.sent()];
                            case 2:
                                i.sent(),
                                i.label = 3;
                            case 3:
                                return e.returnValues ? [4, Me(t)] : [3, 5];
                            case 4:
                                return [2, i.sent()];
                            case 5:
                                return [2]
                            }
                        }
                        ))
                    }
                    ))
                }());
            };
            try {
                for (var s = Ae(t), a = s.next(); !a.done; a = s.next())
                    n(a.value);
            } catch (t) {
                i = {
                    error: t
                };
            } finally {
                try {
                    a && !a.done && (r = s.return) && r.call(s);
                } finally {
                    if (i)
                        throw i.error
                }
            }
            return o
        }
        function Ze(t) {
            var e = this
              , i = Ve(t, {
                returnValues: !0
            });
            return new Ge((function(t, r) {
                return Se(e, void 0, void 0, (function() {
                    var e, o, n, s, a, l;
                    return Ce(this, (function(c) {
                        switch (c.label) {
                        case 0:
                            if (!i.length)
                                return r(),
                                [2];
                            o = !1,
                            r.then((function() {
                                e(),
                                o = !0;
                            }
                            )),
                            c.label = 1;
                        case 1:
                            c.trys.push([1, , 5, 7]),
                            s = void 0,
                            a = 0,
                            l = function() {
                                var o, l, c, h, u;
                                return Ce(this, (function(d) {
                                    switch (d.label) {
                                    case 0:
                                        o = a;
                                        try {
                                            for (h = void 0,
                                            l = Ae(i),
                                            c = l.next(); !c.done; c = l.next())
                                                Promise.resolve(c.value.next()).then((function(t) {
                                                    t.done ? (r(),
                                                    void 0 === n && (n = t)) : a === o && (a++,
                                                    e(t));
                                                }
                                                ), (function(t) {
                                                    return r(t)
                                                }
                                                ));
                                        } catch (t) {
                                            h = {
                                                error: t
                                            };
                                        } finally {
                                            try {
                                                c && !c.done && (u = l.return) && u.call(l);
                                            } finally {
                                                if (h)
                                                    throw h.error
                                            }
                                        }
                                        return [4, new Promise((function(t) {
                                            return e = t
                                        }
                                        ))];
                                    case 1:
                                        return void 0 === (s = d.sent()) ? [3, 3] : [4, t(s.value)];
                                    case 2:
                                        d.sent(),
                                        d.label = 3;
                                    case 3:
                                        return [2]
                                    }
                                }
                                ))
                            }
                            ,
                            c.label = 2;
                        case 2:
                            return o ? [3, 4] : [5, l()];
                        case 3:
                            return c.sent(),
                            [3, 2];
                        case 4:
                            return [2, n && n.value];
                        case 5:
                            return r(),
                            [4, Promise.race(i.map((function(t) {
                                return t.return && t.return()
                            }
                            )))];
                        case 6:
                            return c.sent(),
                            [7];
                        case 7:
                            return [2]
                        }
                    }
                    ))
                }
                ))
            }
            ))
        }
        function We(t) {
            var e = this
              , i = Ve(t, {
                yieldValues: !0
            });
            return new Ge((function(t, r) {
                return Se(e, void 0, void 0, (function() {
                    var e, o, n, s = this;
                    return Ce(this, (function(a) {
                        switch (a.label) {
                        case 0:
                            if (!i.length)
                                return r(),
                                [2];
                            e = [],
                            o = !1,
                            r.then((function() {
                                var t, i;
                                o = !0;
                                try {
                                    for (var r = Ae(e), n = r.next(); !n.done; n = r.next())
                                        (0,
                                        n.value)();
                                } catch (e) {
                                    t = {
                                        error: e
                                    };
                                } finally {
                                    try {
                                        n && !n.done && (i = r.return) && i.call(r);
                                    } finally {
                                        if (t)
                                            throw t.error
                                    }
                                }
                            }
                            )),
                            a.label = 1;
                        case 1:
                            return a.trys.push([1, , 3, 4]),
                            [4, Promise.all(i.map((function(i, a) {
                                return Se(s, void 0, void 0, (function() {
                                    var s;
                                    return Ce(this, (function(l) {
                                        switch (l.label) {
                                        case 0:
                                            l.trys.push([0, , 6, 9]),
                                            l.label = 1;
                                        case 1:
                                            return o ? [3, 5] : (Promise.resolve(i.next()).then((function(t) {
                                                return e[a](t)
                                            }
                                            ), (function(t) {
                                                return r(t)
                                            }
                                            )),
                                            [4, new Promise((function(t) {
                                                e[a] = t;
                                            }
                                            ))]);
                                        case 2:
                                            return void 0 === (s = l.sent()) ? [3, 4] : s.done ? (n = s,
                                            [2]) : [4, t(s.value)];
                                        case 3:
                                            l.sent(),
                                            l.label = 4;
                                        case 4:
                                            return [3, 1];
                                        case 5:
                                            return [3, 9];
                                        case 6:
                                            return i.return ? [4, i.return()] : [3, 8];
                                        case 7:
                                            l.sent(),
                                            l.label = 8;
                                        case 8:
                                            return [7];
                                        case 9:
                                            return [2]
                                        }
                                    }
                                    ))
                                }
                                ))
                            }
                            )))];
                        case 2:
                            return a.sent(),
                            [2, n && n.value];
                        case 3:
                            return r(),
                            [7];
                        case 4:
                            return [2]
                        }
                    }
                    ))
                }
                ))
            }
            ))
        }
        function qe(t) {
            var e = this
              , i = Ve(t, {
                returnValues: !0
            });
            return new Ge((function(t, r) {
                return Se(e, void 0, void 0, (function() {
                    var e, o, n, s;
                    return Ce(this, (function(a) {
                        switch (a.label) {
                        case 0:
                            if (!i.length)
                                return r(),
                                [2, []];
                            o = !1,
                            r.then((function() {
                                e(),
                                o = !0;
                            }
                            )),
                            a.label = 1;
                        case 1:
                            a.trys.push([1, , 6, 8]),
                            a.label = 2;
                        case 2:
                            return o ? [3, 5] : (Promise.all(i.map((function(t) {
                                return t.next()
                            }
                            ))).then((function(t) {
                                return e(t)
                            }
                            ), (function(t) {
                                return r(t)
                            }
                            )),
                            [4, new Promise((function(t) {
                                return e = t
                            }
                            ))]);
                        case 3:
                            return void 0 === (n = a.sent()) ? [2] : (s = n.map((function(t) {
                                return t.value
                            }
                            )),
                            n.some((function(t) {
                                return t.done
                            }
                            )) ? [2, s] : [4, t(s)]);
                        case 4:
                            return a.sent(),
                            [3, 2];
                        case 5:
                            return [3, 8];
                        case 6:
                            return r(),
                            [4, Promise.all(i.map((function(t) {
                                return t.return && t.return()
                            }
                            )))];
                        case 7:
                            return a.sent(),
                            [7];
                        case 8:
                            return [2]
                        }
                    }
                    ))
                }
                ))
            }
            ))
        }
        function He(t) {
            var e = this
              , i = Ve(t, {
                yieldValues: !0,
                returnValues: !0
            });
            return new Ge((function(t, r) {
                return Se(e, void 0, void 0, (function() {
                    var e, o, n, s, a, l = this;
                    return Ce(this, (function(c) {
                        switch (c.label) {
                        case 0:
                            if (!i.length)
                                return r(),
                                [2, []];
                            o = [],
                            n = !1,
                            r.then((function() {
                                var t, i;
                                e();
                                try {
                                    for (var r = Ae(o), s = r.next(); !s.done; s = r.next())
                                        (0,
                                        s.value)();
                                } catch (e) {
                                    t = {
                                        error: e
                                    };
                                } finally {
                                    try {
                                        s && !s.done && (i = r.return) && i.call(r);
                                    } finally {
                                        if (t)
                                            throw t.error
                                    }
                                }
                                n = !0;
                            }
                            )),
                            c.label = 1;
                        case 1:
                            return c.trys.push([1, , 5, 7]),
                            Promise.all(i.map((function(t) {
                                return t.next()
                            }
                            ))).then((function(t) {
                                return e(t)
                            }
                            ), (function(t) {
                                return r(t)
                            }
                            )),
                            [4, new Promise((function(t) {
                                return e = t
                            }
                            ))];
                        case 2:
                            return void 0 === (s = c.sent()) ? [2] : (a = s.map((function(t) {
                                return t.value
                            }
                            )),
                            s.every((function(t) {
                                return t.done
                            }
                            )) ? [2, a] : [4, t(a.slice())]);
                        case 3:
                            return c.sent(),
                            [4, Promise.all(i.map((function(e, i) {
                                return Se(l, void 0, void 0, (function() {
                                    var l;
                                    return Ce(this, (function(c) {
                                        switch (c.label) {
                                        case 0:
                                            if (s[i].done)
                                                return [2, s[i].value];
                                            c.label = 1;
                                        case 1:
                                            return n ? [3, 4] : (Promise.resolve(e.next()).then((function(t) {
                                                return o[i](t)
                                            }
                                            ), (function(t) {
                                                return r(t)
                                            }
                                            )),
                                            [4, new Promise((function(t) {
                                                return o[i] = t
                                            }
                                            ))]);
                                        case 2:
                                            return void 0 === (l = c.sent()) ? [2, s[i].value] : l.done ? [2, l.value] : (a[i] = l.value,
                                            [4, t(a.slice())]);
                                        case 3:
                                            return c.sent(),
                                            [3, 1];
                                        case 4:
                                            return [2]
                                        }
                                    }
                                    ))
                                }
                                ))
                            }
                            )))];
                        case 4:
                            return [2, c.sent()];
                        case 5:
                            return r(),
                            [4, Promise.all(i.map((function(t) {
                                return t.return && t.return()
                            }
                            )))];
                        case 6:
                            return c.sent(),
                            [7];
                        case 7:
                            return [2]
                        }
                    }
                    ))
                }
                ))
            }
            ))
        }
        class Xe {
            constructor() {
                this._extraRequestThreshold = 262144;
            }
            extraRequestThreshold() {
                return this._extraRequestThreshold
            }
            setExtraRequestThreshold(t) {
                if (t < 0)
                    throw new Error("extraRequestThreshold cannot be negative");
                this._extraRequestThreshold = t;
            }
        }
        Xe.global = new Xe,
        function(t) {
            t[t.Debug = 0] = "Debug",
            t[t.Info = 1] = "Info",
            t[t.Warn = 2] = "Warn",
            t[t.Error = 3] = "Error";
        }(Ne || (Ne = {}));
        class Ye {
            static debug(...t) {
                this.log(Ne.Debug, ...t);
            }
            static info(...t) {
                this.log(Ne.Info, ...t);
            }
            static warn(...t) {
                this.log(Ne.Warn, ...t);
            }
            static error(...t) {
                this.log(Ne.Error, ...t);
            }
            static log(t, ...e) {
                if (!(this.logLevel > t))
                    switch (t) {
                    case Ne.Debug:
                        console.debug(...e);
                        break;
                    case Ne.Info:
                        console.info(...e);
                        break;
                    case Ne.Warn:
                        console.warn(...e);
                        break;
                    case Ne.Error:
                        console.error(...e);
                    }
            }
        }
        Ye.logLevel = Ne.Warn;
        const Ke = 40;
        function Je(t, e) {
            e = Math.min(Math.max(+e, 2), 65535);
            let i = t
              , r = i;
            do {
                i = Math.ceil(i / e),
                r += i;
            } while (1 !== i);
            return r * Ke
        }
        const $e = new Uint8Array([102, 103, 98, 3, 102, 103, 98, 0]);
        class Qe {
            constructor(t, e, i, r, o) {
                this.headerClient = t,
                this.header = e,
                this.headerLength = i,
                this.indexLength = r,
                this.nocache = o;
            }
            static async open(t, e) {
                const i = new ti(t,e)
                  , r = ( () => {
                    let t, e = 0;
                    for (t = 0; t < 3; t++)
                        e += 16 ** t * Ke;
                    return e
                }
                )()
                  , o = 2024 + r;
                Ye.debug(`fetching header. minReqLength: ${o} (assumedHeaderLength: 2024, assumedIndexLength: ${r})`);
                {
                    const t = new Uint8Array(await i.getRange(0, 8, o, "header"));
                    if (!t.subarray(0, 3).every(( (t, e) => $e[e] === t)))
                        throw Ye.error(`bytes: ${t} != ${$e}`),
                        new Error("Not a FlatGeobuf file");
                    Ye.debug("magic bytes look good");
                }
                let n;
                {
                    const t = await i.getRange(8, 4, o, "header");
                    if (n = new DataView(t).getUint32(0, !0),
                    n > 10485760 || n < 8)
                        throw new Error("Invalid header size");
                    Ye.debug(`headerLength: ${n}`);
                }
                const s = await i.getRange(12, n, o, "header")
                  , a = be(new ce(new Uint8Array(s)))
                  , l = Je(a.featuresCount, a.indexNodeSize);
                return Ye.debug("completed: opening http reader"),
                new Qe(i,a,n,l,e)
            }
            async*selectBbox(t) {
                const e = this.lengthBeforeTree()
                  , i = this.headerClient
                  , r = async function(t, r) {
                    return i.getRange(e + t, r, 0, "index")
                }
                  , o = [];
                let n = [];
                for await(const e of async function*(t, e, i, r) {
                    class o {
                        constructor(t, e) {
                            this._level = e,
                            this.nodes = t;
                        }
                        level() {
                            return this._level
                        }
                        startNodeIdx() {
                            return this.nodes[0]
                        }
                        endNodeIdx() {
                            return this.nodes[1]
                        }
                        extendEndNodeIdx(t) {
                            console.assert(t > this.nodes[1]),
                            this.nodes[1] = t;
                        }
                        toString() {
                            return `[NodeRange level: ${this._level}, nodes: ${this.nodes[0]}-${this.nodes[1]}]`
                        }
                    }
                    const {minX: n, minY: s, maxX: a, maxY: l} = i;
                    Ye.info(`tree items: ${t}, nodeSize: ${e}`);
                    const c = function(t, e) {
                        if (e < 2)
                            throw new Error("Node size must be at least 2");
                        if (0 === t)
                            throw new Error("Number of items must be greater than 0");
                        let i = t
                          , r = i;
                        const o = [i];
                        do {
                            i = Math.ceil(i / e),
                            r += i,
                            o.push(i);
                        } while (1 !== i);
                        const n = [];
                        i = r;
                        for (const t of o)
                            n.push(i - t),
                            i -= t;
                        const s = [];
                        for (let t = 0; t < o.length; t++)
                            s.push([n[t], n[t] + o[t]]);
                        return s
                    }(t, e)
                      , h = c[0][0]
                      , u = [new o([0, 1],c.length - 1)];
                    for (Ye.debug(`starting stream search with queue: ${u}, numItems: ${t}, nodeSize: ${e}, levelBounds: ${c}`); 0 != u.length; ) {
                        const i = u.shift();
                        Ye.debug(`popped node: ${i}, queueLength: ${u.length}`);
                        const d = i.startNodeIdx()
                          , f = d >= h
                          , _ = ( () => {
                            const [,t] = c[i.level()]
                              , r = Math.min(i.endNodeIdx() + e, t);
                            return f && r < t ? r + 1 : r
                        }
                        )()
                          , p = _ - d
                          , m = await r(d * Ke, p * Ke)
                          , g = new DataView(m);
                        for (let e = d; e < _; e++) {
                            const r = e - d
                              , c = r * Ke;
                            if (a < g.getFloat64(c + 0, !0))
                                continue;
                            if (l < g.getFloat64(c + 8, !0))
                                continue;
                            if (n > g.getFloat64(c + 16, !0))
                                continue;
                            if (s > g.getFloat64(c + 24, !0))
                                continue;
                            const _ = g.getBigUint64(c + 32, !0);
                            if (f) {
                                const i = _
                                  , o = e < t - 1 ? g.getBigUint64((r + 1) * Ke + 32, !0) - i : null
                                  , n = e - h;
                                yield[Number(i), n, Number(o)];
                                continue
                            }
                            const p = _
                              , m = Xe.global.extraRequestThreshold() / Ke
                              , v = u[u.length - 1];
                            if (void 0 !== v && v.level() == i.level() - 1 && p < v.endNodeIdx() + m) {
                                Ye.debug(`Merging "nodeRange" request into existing range: ${v}, newEndNodeIdx: ${v.endNodeIdx()} -> ${p}`),
                                v.extendEndNodeIdx(Number(p));
                                continue
                            }
                            const y = ( () => {
                                const t = i.level() - 1
                                  , e = [Number(p), Number(p) + 1];
                                return new o(e,t)
                            }
                            )();
                            void 0 !== v && v.level() == y.level() ? Ye.info(`Same level, but too far away. Pushing new request for nodeIdx: ${p} rather than merging with distant ${v}`) : Ye.info(`Pushing new level for ${y} onto queue with nearestNodeRange: ${v} since there's not already a range for this level.`),
                            u.push(y);
                        }
                    }
                }(this.header.featuresCount, this.header.indexNodeSize, t, r)) {
                    const [t,,] = e;
                    let[,,i] = e;
                    if (i || (Ye.info("final feature"),
                    i = 4),
                    0 == n.length) {
                        n.push([t, i]);
                        continue
                    }
                    const r = n[n.length - 1]
                      , s = t - (r[0] + r[1]);
                    s > Xe.global.extraRequestThreshold() && (Ye.info(`Pushing new feature batch, since gap ${s} was too large`),
                    o.push(n),
                    n = []),
                    n.push([t, i]);
                }
                this.headerClient.logUsage("header+index"),
                n.length > 0 && o.push(n);
                const s = o.flatMap((t => this.readFeatureBatch(t, this.nocache)));
                yield*Ge.merge(s);
            }
            lengthBeforeTree() {
                return $e.length + 4 + this.headerLength
            }
            lengthBeforeFeatures() {
                return this.lengthBeforeTree() + this.indexLength
            }
            buildFeatureClient(t) {
                return new ti(this.headerClient.httpClient,t)
            }
            async*readFeatureBatch(t, e) {
                const [i] = t[0]
                  , [r,o] = t[t.length - 1]
                  , n = r + o - i
                  , s = this.buildFeatureClient(e);
                let a = n;
                for (const [e] of t)
                    yield await this.readFeature(s, e, a),
                    a = 0;
                s.logUsage("feature");
            }
            async readFeature(t, e, i) {
                const r = e + this.lengthBeforeFeatures();
                let o;
                {
                    const e = await t.getRange(r, 4, i, "feature length");
                    o = new DataView(e).getUint32(0, !0);
                }
                const n = await t.getRange(r + 4, o, i, "feature data")
                  , s = new Uint8Array(n)
                  , a = new Uint8Array(o + 4);
                a.set(s, 4);
                const l = new ce(a);
                return l.setPosition(4),
                ye.getRootAsFeature(l)
            }
        }
        class ti {
            constructor(t, e) {
                if (this.bytesEverUsed = 0,
                this.bytesEverFetched = 0,
                this.buffer = new ArrayBuffer(0),
                this.head = 0,
                "string" == typeof t)
                    this.httpClient = new ei(t,e);
                else {
                    if (!(t instanceof ei))
                        throw new Error("Unknown source ");
                    this.httpClient = t;
                }
            }
            async getRange(t, e, i, r) {
                this.bytesEverUsed += e;
                const o = t - this.head
                  , n = o + e;
                if (o >= 0 && n <= this.buffer.byteLength)
                    return this.buffer.slice(o, n);
                const s = Math.max(e, i);
                return this.bytesEverFetched += s,
                Ye.debug(`requesting for new Range: ${t}-${t + s - 1}`),
                this.buffer = await this.httpClient.getRange(t, s, r),
                this.head = t,
                this.buffer.slice(0, e)
            }
            logUsage(t) {
                const e = t.split(" ")[0]
                  , i = this.bytesEverUsed
                  , r = this.bytesEverFetched
                  , o = (100 * i / r).toFixed(2);
                Ye.info(`${e} bytes used/requested: ${i} / ${r} = ${o}%`);
            }
        }
        class ei {
            constructor(t, e) {
                this.requestsEverMade = 0,
                this.bytesEverRequested = 0,
                this.url = t,
                this.nocache = e;
            }
            async getRange(t, e, i) {
                this.requestsEverMade += 1,
                this.bytesEverRequested += e;
                const r = `bytes=${t}-${t + e - 1}`;
                Ye.info(`request: #${this.requestsEverMade}, purpose: ${i}), bytes: (this_request: ${e}, ever: ${this.bytesEverRequested}), Range: ${r}`);
                const o = {
                    Range: r
                };
                return this.nocache && (o["Cache-Control"] = "no-cache, no-store"),
                (await fetch(this.url, {
                    headers: o
                })).arrayBuffer()
            }
        }
        async function ii(t, e, i) {
            let r = new Uint8Array(await t(4, "feature length"));
            if (0 === r.byteLength)
                return;
            let o = new ce(r);
            const n = o.readUint32(0);
            r = new Uint8Array(await t(n, "feature data"));
            const s = new Uint8Array(n + 4);
            return s.set(r, 4),
            o = new ce(s),
            o.setPosition(4),
            i(ye.getRootAsFeature(o), e)
        }
        function ri(t, e) {
            let i = e;
            if (i === ue.Unknown && (i = t.type()),
            i === ue.GeometryCollection) {
                const e = [];
                for (let i = 0; i < t.partsLength(); i++) {
                    const r = t.parts(i)
                      , o = r.type();
                    e.push(ri(r, o));
                }
                return {
                    type: ue[i],
                    geometries: e
                }
            }
            if (i === ue.MultiPolygon) {
                const e = [];
                for (let i = 0; i < t.partsLength(); i++)
                    e.push(ri(t.parts(i), ue.Polygon));
                return {
                    type: ue[i],
                    coordinates: e.map((t => t.coordinates))
                }
            }
            const r = function(t, e) {
                const i = t.xyArray()
                  , r = t.zArray();
                switch (e) {
                case ue.Point:
                    {
                        const t = Array.from(i);
                        return r && t.push(r[0]),
                        t
                    }
                case ue.MultiPoint:
                case ue.LineString:
                    return xe(i, r);
                case ue.MultiLineString:
                case ue.Polygon:
                    return function(t, e, i) {
                        if (!i || 0 === i.length)
                            return [xe(t, e)];
                        let r = 0;
                        const o = Array.from(i).map((e => t.slice(r, r = e << 1)));
                        let n;
                        return e && (r = 0,
                        n = Array.from(i).map((t => e.slice(r, r = t)))),
                        o.map(( (t, e) => xe(t, n ? n[e] : void 0)))
                    }(i, r, t.endsArray())
                }
            }(t, i);
            return {
                type: ue[i],
                coordinates: r
            }
        }
        function oi(t, e) {
            const i = e.columns;
            return {
                type: "Feature",
                geometry: ri(t.geometry(), e.geometryType),
                properties: Te(t, i)
            }
        }
        class ni extends Ut {
            constructor(t, e, i, r) {
                super(t, e, i, r),
                this.id = t,
                this.url = e.url,
                this.type = e.type || "geobuf";
            }
            onAdd(t) {
                this.map = t,
                this.load();
            }
            load(e) {
                this.url || this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${this.id}`,null,'missing required property "url"'))),
                this._loaded = !1,
                this._bufferRequest = t.makeRequest({
                    method: "GET",
                    type: "arrayBuffer",
                    headers: {
                        Authorization: t.config.ACCESS_TOKEN
                    },
                    url: this.url
                }, ( (i, r, o, n) => {
                    if (this._bufferRequest = null,
                    this._loaded = !0,
                    i)
                        this.fire(new t.ErrorEvent(i));
                    else if (r) {
                        let t = this._arrayBufferToGeojson(r);
                        super.setData(t);
                    }
                    e && e(i);
                }
                ));
            }
            loaded() {
                return this._loaded
            }
            setUrl(t) {
                return this.setSourceProperty(( () => {
                    this.url = t,
                    this._options.url = t;
                }
                )),
                this
            }
            setSourceProperty(t) {
                this._bufferRequest && this._bufferRequest.cancel(),
                t();
                const e = this.map.style._getSourceCaches(this.id);
                for (const t of e)
                    t.clearTiles();
                this.load();
            }
            _arrayBufferToGeojson(e) {
                let i, r = new DataView(e);
                if (115 == r.getUint8(0) && 103 == r.getUint8(1) && 103 == r.getUint8(14) && 115 == r.getUint8(15)) {
                    if (r.getInt32(10) != r.byteLength - 20)
                        throw new Error("长度校验失败");
                    r.getUint8(2, !1);
                    let i = r.getUint8(3, !1);
                    if ("geobuf" == this.type && 2 != i || "flatgeobuf" == this.type && 3 != i)
                        throw new Error("数据格式错误");
                    let o = r.getUint8(4, !1) * Math.pow(2, 40);
                    o += r.getUint8(5, !1) * Math.pow(2, 32),
                    o += r.getUint8(6, !1) * Math.pow(2, 24),
                    o += r.getUint8(7, !1) * Math.pow(2, 16),
                    o += r.getUint8(8, !1) * Math.pow(2, 8),
                    o += r.getUint8(9, !1),
                    o = new Date(o);
                    let n = o.getHours()
                      , s = o.getMinutes()
                      , a = o.getMilliseconds()
                      , l = n
                      , c = 60 * n + s + a
                      , h = 60 * s + o.getSeconds() + a;
                    e = t.securityTile({
                        z: l,
                        x: c,
                        y: h
                    }, r.buffer.slice(16, r.byteLength - 4));
                }
                try {
                    i = "geobuf" == this.type ? function(t) {
                        Wt = 2,
                        qt = Math.pow(10, 6),
                        Zt = null,
                        Gt = [],
                        Vt = [];
                        var e = t.readFields(Xt, {});
                        return Gt = null,
                        e
                    }(new t.pbf(e)) : function(t, e, i, r=!1) {
                        return t instanceof Uint8Array ? function(t, e) {
                            return {
                                type: "FeatureCollection",
                                features: function(t, e, i) {
                                    if (!t.subarray(0, 3).every(( (t, e) => $e[e] === t)))
                                        throw new Error("Not a FlatGeobuf file");
                                    const r = new ce(t)
                                      , o = r.readUint32($e.length);
                                    r.setPosition($e.length + 4);
                                    const n = be(r);
                                    i && i(n);
                                    let s = $e.length + 4 + o;
                                    const {indexNodeSize: a, featuresCount: l} = n;
                                    a > 0 && (s += Je(l, a));
                                    const c = [];
                                    for (; s < r.capacity(); ) {
                                        const t = r.readUint32(s);
                                        r.setPosition(s + 4);
                                        const i = ye.getRootAsFeature(r);
                                        c.push(e(i, n)),
                                        s += 4 + t;
                                    }
                                    return c
                                }(t, oi, e)
                            }
                        }(t, i) : t instanceof ReadableStream ? function(t, e) {
                            return async function*(t, e, i) {
                                const r = "function" == typeof (o = t).slice ? o : new _e("function" == typeof o.read ? o : o.getReader());
                                var o;
                                const n = async t => await r.slice(t);
                                let s = new Uint8Array(await n(8));
                                if (!s.subarray(0, 3).every(( (t, e) => $e[e] === t)))
                                    throw new Error("Not a FlatGeobuf file");
                                s = new Uint8Array(await n(4));
                                let a = new ce(s);
                                const l = a.readUint32(0);
                                s = new Uint8Array(await n(l)),
                                a = new ce(s);
                                const c = be(a);
                                i && i(c);
                                const {indexNodeSize: h, featuresCount: u} = c;
                                if (h > 0) {
                                    const t = Je(u, h);
                                    await n(t);
                                }
                                let d;
                                for (; d = await ii(n, c, e); )
                                    yield d;
                            }(t, oi, e)
                        }(t, i) : function(t, e, i, r=!1) {
                            return async function*(t, e, i, r, o=!1) {
                                const n = await Qe.open(t, o);
                                Ye.debug("opened reader"),
                                r && r(n.header);
                                for await(const t of n.selectBbox(e))
                                    yield i(t, n.header);
                            }(t, e, oi, i, r)
                        }(t, e, i, r)
                    }(new Uint8Array(e));
                } catch (t) {
                    throw new Error(this.id + "数据内容错误，无法解析",t)
                }
                return i
            }
            onRemove() {
                this._bufferRequest && (this._bufferRequest.cancel(),
                this._bufferRequest = null),
                super.onRemove();
            }
            serialize() {
                return t.extend({}, this._options, {
                    type: this.type,
                    url: this.url
                })
            }
            hasTransition() {
                return !1
            }
        }
        const si = {
            vector: class extends t.Evented {
                constructor(e, i, r, o) {
                    if (super(),
                    this.id = e,
                    this.dispatcher = r,
                    this.type = "vector",
                    this.minzoom = 0,
                    this.maxzoom = 22,
                    this.scheme = "xyz",
                    this.tileSize = 512,
                    this.reparseOverscaled = !0,
                    this.isTileClipped = !0,
                    this._loaded = !1,
                    t.extend(this, t.pick(i, ["url", "scheme", "tileSize", "promoteId"])),
                    this._options = t.extend({
                        type: "vector"
                    }, i),
                    this._collectResourceTiming = i.collectResourceTiming,
                    512 !== this.tileSize)
                        throw new Error("vector tile sources must have a tileSize of 512");
                    this.setEventedParent(o),
                    this._tileWorkers = {},
                    this._deduped = new t.DedupedRequest;
                }
                load(e) {
                    this._loaded = !1,
                    this.fire(new t.Event("dataloading",{
                        dataType: "source"
                    }));
                    const i = this.language || this.map._language
                      , r = this.worldview || this.map._worldview;
                    this._tileJSONRequest = X(this._options, this.map._requestManager, i, r, ( (o, n) => {
                        this._tileJSONRequest = null,
                        this._loaded = !0,
                        o ? (i && console.warn(`Ensure that your requested language string is a valid BCP-47 code. Found: ${i}`),
                        r && 2 !== r.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${r}`),
                        this.fire(new t.ErrorEvent(o))) : n && (t.extend(this, n),
                        n.bounds && (this.tileBounds = new Y(n.bounds,this.minzoom,this.maxzoom)),
                        this.fire(new t.Event("data",{
                            dataType: "source",
                            sourceDataType: "metadata"
                        })),
                        this.fire(new t.Event("data",{
                            dataType: "source",
                            sourceDataType: "content"
                        }))),
                        e && e(o);
                    }
                    ));
                }
                loaded() {
                    return this._loaded
                }
                hasTile(t) {
                    return !this.tileBounds || this.tileBounds.contains(t.canonical)
                }
                onAdd(t) {
                    this.map = t,
                    this.load();
                }
                setSourceProperty(t) {
                    this._tileJSONRequest && this._tileJSONRequest.cancel(),
                    t(),
                    this.load(( () => {
                        const t = this.map.style._getSourceCaches(this.id);
                        for (const e of t)
                            e.clearTiles();
                    }
                    ));
                }
                setTiles(t) {
                    return this.setSourceProperty(( () => {
                        this._options.tiles = t;
                    }
                    )),
                    this
                }
                setUrl(t) {
                    return this.setSourceProperty(( () => {
                        this.url = t,
                        this._options.url = t;
                    }
                    )),
                    this
                }
                _setLanguage(t) {
                    return t === this.language || this.setSourceProperty(( () => {
                        this.language = t;
                    }
                    )),
                    this
                }
                _setWorldview(t) {
                    return t === this.worldview ? this : this.worldviewOptions && t && !this.worldviewOptions[t] ? (console.warn(`Vector tile source "${this.id}" does not support worldview "${t}".`),
                    this) : (this.setSourceProperty(( () => {
                        this.worldview = t;
                    }
                    )),
                    this)
                }
                onRemove() {
                    this._tileJSONRequest && (this._tileJSONRequest.cancel(),
                    this._tileJSONRequest = null);
                }
                serialize() {
                    return t.extend({}, this._options)
                }
                loadTile(e, i) {
                    const r = this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles, this.scheme))
                      , o = {
                        request: t.extend(this.map._requestManager.transformRequest(r, t.ResourceType.Tile), {
                            tilesecurity: this.tilesecurity,
                            zxy: e.tileID.canonical,
                            traffic: this.traffic,
                            reference: this.reference,
                            crs: t.config.crs
                        }),
                        data: void 0,
                        uid: e.uid,
                        tileID: e.tileID,
                        tileZoom: e.tileZoom,
                        zoom: e.tileID.overscaledZ,
                        tileSize: this.tileSize * e.tileID.overscaleFactor(),
                        type: this.type,
                        source: this.id,
                        pixelRatio: t.exported.devicePixelRatio,
                        showCollisionBoxes: this.map.showCollisionBoxes,
                        promoteId: this.promoteId,
                        isSymbolTile: e.isSymbolTile
                    };
                    if (o.request.collectResourceTiming = this._collectResourceTiming,
                    e.actor && "expired" !== e.state)
                        "loading" === e.state ? e.reloadCallback = i : e.request = e.actor.send("reloadTile", o, n.bind(this));
                    else if (e.actor = this._tileWorkers[r] = this._tileWorkers[r] || this.dispatcher.getActor(),
                    this.dispatcher.ready)
                        e.request = e.actor.send("loadTile", o, n.bind(this), void 0, !0);
                    else {
                        const i = t.loadVectorTile.call({
                            deduped: this._deduped
                        }, o, ( (t, i) => {
                            t || !i ? n.call(this, t) : (o.data = {
                                cacheControl: i.cacheControl,
                                expires: i.expires,
                                rawData: i.rawData.slice(0)
                            },
                            e.actor && e.actor.send("loadTile", o, n.bind(this), void 0, !0));
                        }
                        ), !0);
                        e.request = {
                            cancel: i
                        };
                    }
                    function n(r, o) {
                        return delete e.request,
                        e.aborted ? i(null) : r && 404 !== r.status ? i(r) : (o && o.resourceTiming && (e.resourceTiming = o.resourceTiming),
                        this.map._refreshExpiredTiles && o && e.setExpiryData(o),
                        e.loadVectorData(o, this.map.painter),
                        t.cacheEntryPossiblyAdded(this.dispatcher),
                        i(null),
                        void (e.reloadCallback && (this.loadTile(e, e.reloadCallback),
                        e.reloadCallback = null)))
                    }
                }
                abortTile(t) {
                    t.request && (t.request.cancel(),
                    delete t.request),
                    t.actor && t.actor.send("abortTile", {
                        uid: t.uid,
                        type: this.type,
                        source: this.id
                    });
                }
                unloadTile(t) {
                    t.unloadVectorData(),
                    t.actor && t.actor.send("removeTile", {
                        uid: t.uid,
                        type: this.type,
                        source: this.id
                    });
                }
                hasTransition() {
                    return !1
                }
                afterUpdate() {
                    this._tileWorkers = {};
                }
            }
            ,
            raster: Ot,
            "raster-dem": class extends Ot {
                constructor(e, i, r, o) {
                    super(e, i, r, o),
                    this.type = "raster-dem",
                    this.maxzoom = 22,
                    this._options = t.extend({
                        type: "raster-dem"
                    }, i),
                    this.encoding = i.encoding || "epgis";
                }
                loadTile(e, i) {
                    const r = this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);
                    function o(t, r) {
                        t && (e.state = "errored",
                        i(t)),
                        r && (e.dem = r,
                        e.dem.onDeserialize(),
                        e.needsHillshadePrepare = !0,
                        e.needsDEMTextureUpload = !0,
                        e.state = "loaded",
                        i(null));
                    }
                    e.request = t.getImage(t.extend(this.map._requestManager.transformRequest(r, t.ResourceType.Tile), {
                        tilesecurity: this.tilesecurity,
                        zxy: e.tileID.canonical,
                        traffic: this.traffic,
                        reference: this.reference
                    }), function(r, n, s, a) {
                        if (delete e.request,
                        e.aborted)
                            e.state = "unloaded",
                            i(null);
                        else if (r)
                            e.state = "errored",
                            i(r);
                        else if (n) {
                            this.map._refreshExpiredTiles && e.setExpiryData({
                                cacheControl: s,
                                expires: a
                            });
                            const i = t.window.ImageBitmap && n instanceof t.window.ImageBitmap && (null == Ft && (Ft = t.window.OffscreenCanvas && new t.window.OffscreenCanvas(1,1).getContext("2d") && "function" == typeof t.window.createImageBitmap),
                            Ft)
                              , r = 1 - (n.width - t.prevPowerOfTwo(n.width)) / 2;
                            r < 1 || e.neighboringTiles || (e.neighboringTiles = this._getNeighboringTiles(e.tileID));
                            const l = i ? n : t.exported.getImageData(n, r)
                              , c = {
                                uid: e.uid,
                                coord: e.tileID,
                                source: this.id,
                                rawImageData: l,
                                encoding: this.encoding,
                                padding: r
                            };
                            e.actor && "expired" !== e.state || (e.actor = this.dispatcher.getActor(),
                            e.actor.send("loadDEMTile", c, o.bind(this), void 0, !0));
                        }
                    }
                    .bind(this));
                }
                _getNeighboringTiles(e) {
                    const i = e.canonical
                      , r = Math.pow(2, i.z)
                      , o = (i.x - 1 + r) % r
                      , n = 0 === i.x ? e.wrap - 1 : e.wrap
                      , s = (i.x + 1 + r) % r
                      , a = i.x + 1 === r ? e.wrap + 1 : e.wrap
                      , l = {};
                    return l[new t.OverscaledTileID(e.overscaledZ,n,i.z,o,i.y).key] = {
                        backfilled: !1
                    },
                    l[new t.OverscaledTileID(e.overscaledZ,a,i.z,s,i.y).key] = {
                        backfilled: !1
                    },
                    i.y > 0 && (l[new t.OverscaledTileID(e.overscaledZ,n,i.z,o,i.y - 1).key] = {
                        backfilled: !1
                    },
                    l[new t.OverscaledTileID(e.overscaledZ,e.wrap,i.z,i.x,i.y - 1).key] = {
                        backfilled: !1
                    },
                    l[new t.OverscaledTileID(e.overscaledZ,a,i.z,s,i.y - 1).key] = {
                        backfilled: !1
                    }),
                    i.y + 1 < r && (l[new t.OverscaledTileID(e.overscaledZ,n,i.z,o,i.y + 1).key] = {
                        backfilled: !1
                    },
                    l[new t.OverscaledTileID(e.overscaledZ,e.wrap,i.z,i.x,i.y + 1).key] = {
                        backfilled: !1
                    },
                    l[new t.OverscaledTileID(e.overscaledZ,a,i.z,s,i.y + 1).key] = {
                        backfilled: !1
                    }),
                    l
                }
                unloadTile(t) {
                    t.demTexture && this.map.painter.saveTileTexture(t.demTexture),
                    t.fbo && (t.fbo.destroy(),
                    delete t.fbo),
                    t.dem && delete t.dem,
                    delete t.neighboringTiles,
                    t.state = "unloaded";
                }
            }
            ,
            geojson: Ut,
            video: class extends jt {
                constructor(t, e, i, r) {
                    super(t, e, i, r),
                    this.roundZoom = !0,
                    this.type = "video",
                    this.options = e;
                }
                load() {
                    this._loaded = !1;
                    const e = this.options;
                    this.urls = [];
                    for (const i of e.urls)
                        this.urls.push(this.map._requestManager.transformRequest(i, t.ResourceType.Source).url);
                    t.getVideo(this.urls, ( (e, i) => {
                        this._loaded = !0,
                        e ? this.fire(new t.ErrorEvent(e)) : i && (this.video = i,
                        this.video.loop = !0,
                        this.video.setAttribute("playsinline", ""),
                        this.video.addEventListener("playing", ( () => {
                            this.map.triggerRepaint();
                        }
                        )),
                        this.map && this.video.play(),
                        this._finishLoading());
                    }
                    ));
                }
                pause() {
                    this.video && this.video.pause();
                }
                play() {
                    this.video && this.video.play();
                }
                seek(e) {
                    if (this.video) {
                        const i = this.video.seekable;
                        e < i.start(0) || e > i.end(0) ? this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${this.id}`,null,`Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))) : this.video.currentTime = e;
                    }
                }
                getVideo() {
                    return this.video
                }
                onAdd(t) {
                    this.map || (this.map = t,
                    this.load(),
                    this.video && (this.video.play(),
                    this.setCoordinates(this.coordinates)));
                }
                prepare() {
                    if (0 === Object.keys(this.tiles).length || this.video.readyState < 2)
                        return;
                    const e = this.map.painter.context
                      , i = e.gl;
                    this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE),
                    i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new t.Texture(e,this.video,i.RGBA),
                    this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE),
                    this.width = this.video.videoWidth,
                    this.height = this.video.videoHeight),
                    this._prepareData(e);
                }
                serialize() {
                    return {
                        type: "video",
                        urls: this.urls,
                        coordinates: this.coordinates
                    }
                }
                hasTransition() {
                    return this.video && !this.video.paused
                }
            }
            ,
            image: jt,
            canvas: class extends jt {
                constructor(e, i, r, o) {
                    super(e, i, r, o),
                    i.coordinates ? Array.isArray(i.coordinates) && 4 === i.coordinates.length && !i.coordinates.some((t => !Array.isArray(t) || 2 !== t.length || t.some((t => "number" != typeof t)))) || this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e}`,null,'"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e}`,null,'missing required property "coordinates"'))),
                    i.animate && "boolean" != typeof i.animate && this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e}`,null,'optional "animate" property must be a boolean value'))),
                    i.canvas ? "string" == typeof i.canvas || i.canvas instanceof t.window.HTMLCanvasElement || this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e}`,null,'"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e}`,null,'missing required property "canvas"'))),
                    this.options = i,
                    this.animate = void 0 === i.animate || i.animate;
                }
                load() {
                    this._loaded = !0,
                    this.canvas || (this.canvas = this.options.canvas instanceof t.window.HTMLCanvasElement ? this.options.canvas : t.window.document.getElementById(this.options.canvas)),
                    this.width = this.canvas.width,
                    this.height = this.canvas.height,
                    this._hasInvalidDimensions() ? this.fire(new t.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                        this._playing = !0,
                        this.map.triggerRepaint();
                    }
                    ,
                    this.pause = function() {
                        this._playing && (this.prepare(),
                        this._playing = !1);
                    }
                    ,
                    this._finishLoading());
                }
                getCanvas() {
                    return this.canvas
                }
                onAdd(t) {
                    this.map = t,
                    this.load(),
                    this.canvas && this.animate && this.play();
                }
                onRemove() {
                    this.pause();
                }
                prepare() {
                    let e = !1;
                    if (this.canvas.width !== this.width && (this.width = this.canvas.width,
                    e = !0),
                    this.canvas.height !== this.height && (this.height = this.canvas.height,
                    e = !0),
                    this._hasInvalidDimensions())
                        return;
                    if (0 === Object.keys(this.tiles).length)
                        return;
                    const i = this.map.painter.context;
                    this.texture ? (e || this._playing) && this.texture.update(this.canvas, {
                        premultiply: !0
                    }) : this.texture = new t.Texture(i,this.canvas,i.gl.RGBA,{
                        premultiply: !0
                    }),
                    this._prepareData(i);
                }
                serialize() {
                    return {
                        type: "canvas",
                        coordinates: this.coordinates
                    }
                }
                hasTransition() {
                    return this._playing
                }
                _hasInvalidDimensions() {
                    for (const t of [this.canvas.width, this.canvas.height])
                        if (isNaN(t) || t <= 0)
                            return !0;
                    return !1
                }
            }
            ,
            custom: class extends t.Evented {
                constructor(e, i, r, o) {
                    super(),
                    this.id = e,
                    this.type = "custom",
                    this._dataType = "raster",
                    this._dispatcher = r,
                    this._implementation = i,
                    this.setEventedParent(o),
                    this.scheme = "xyz",
                    this.minzoom = 0,
                    this.maxzoom = 22,
                    this.tileSize = 512,
                    this._loaded = !1,
                    this.roundZoom = !0,
                    this._implementation || this.fire(new t.ErrorEvent(new Error(`Missing implementation for ${this.id} custom source`))),
                    this._implementation.loadTile || this.fire(new t.ErrorEvent(new Error(`Missing loadTile implementation for ${this.id} custom source`))),
                    this._implementation.bounds && (this.tileBounds = new Y(this._implementation.bounds,this.minzoom,this.maxzoom)),
                    i.update = this._update.bind(this),
                    i.coveringTiles = this._coveringTiles.bind(this),
                    t.extend(this, t.pick(i, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]));
                }
                serialize() {
                    return t.pick(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"])
                }
                load() {
                    this._loaded = !0,
                    this.fire(new t.Event("data",{
                        dataType: "source",
                        sourceDataType: "metadata"
                    })),
                    this.fire(new t.Event("data",{
                        dataType: "source",
                        sourceDataType: "content"
                    }));
                }
                loaded() {
                    return this._loaded
                }
                onAdd(e) {
                    this._map = e,
                    this._loaded = !1,
                    this.fire(new t.Event("dataloading",{
                        dataType: "source"
                    })),
                    this._implementation.onAdd && this._implementation.onAdd(e),
                    this.load();
                }
                onRemove(t) {
                    this._implementation.onRemove && this._implementation.onRemove(t);
                }
                hasTile(t) {
                    if (this._implementation.hasTile) {
                        const {x: e, y: i, z: r} = t.canonical;
                        return this._implementation.hasTile({
                            x: e,
                            y: i,
                            z: r
                        })
                    }
                    return !this.tileBounds || this.tileBounds.contains(t.canonical)
                }
                loadTile(e, i) {
                    const {x: r, y: o, z: n} = e.tileID.canonical
                      , s = new t.window.AbortController
                      , a = this._implementation.loadTile({
                        x: r,
                        y: o,
                        z: n
                    }, {
                        signal: s.signal
                    });
                    if (!a)
                        return this.loadTileData(e, {
                            width: this.tileSize,
                            height: this.tileSize,
                            data: null
                        }),
                        e.state = "loaded",
                        i(null);
                    a.cancel = () => s.abort(),
                    e.request = a.then(function(r) {
                        return delete e.request,
                        e.aborted ? (e.state = "unloaded",
                        i(null)) : r ? function(e) {
                            return e instanceof t.window.ImageData || e instanceof t.window.ImageBitmap || e instanceof t.window.HTMLCanvasElement
                        }(r) ? (this.loadTileData(e, r),
                        e.state = "loaded",
                        void i(null)) : (e.state = "errored",
                        i(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`))) : (this.loadTileData(e, {
                            width: this.tileSize,
                            height: this.tileSize,
                            data: null
                        }),
                        e.state = "loaded",
                        i(null))
                    }
                    .bind(this)).catch((t => {
                        20 !== t.code && (e.state = "errored",
                        i(t));
                    }
                    ));
                }
                loadTileData(t, e) {
                    Ot.loadTileData(t, e, this._map.painter);
                }
                unloadTileData(t) {
                    Ot.unloadTileData(t, this._map.painter);
                }
                prepareTile(t) {
                    if (!this._implementation.prepareTile)
                        return null;
                    const {x: e, y: i, z: r} = t.tileID.canonical
                      , o = this._implementation.prepareTile({
                        x: e,
                        y: i,
                        z: r
                    });
                    return o ? (this.loadTileData(t, o),
                    t.state = "loaded",
                    o) : null
                }
                unloadTile(t, e) {
                    if (this.unloadTileData(t),
                    this._implementation.unloadTile) {
                        const {x: e, y: i, z: r} = t.tileID.canonical;
                        this._implementation.unloadTile({
                            x: e,
                            y: i,
                            z: r
                        });
                    }
                    e();
                }
                abortTile(t, e) {
                    t.request && t.request.cancel && (t.request.cancel(),
                    delete t.request),
                    e();
                }
                hasTransition() {
                    return !1
                }
                _coveringTiles() {
                    return this._map.transform.coveringTiles({
                        tileSize: this.tileSize,
                        minzoom: this.minzoom,
                        maxzoom: this.maxzoom,
                        roundZoom: this.roundZoom
                    }).map((t => ({
                        x: t.canonical.x,
                        y: t.canonical.y,
                        z: t.canonical.z
                    })))
                }
                _update() {
                    this.fire(new t.Event("data",{
                        dataType: "source",
                        sourceDataType: "content"
                    }));
                }
            }
            ,
            geobuf: ni,
            flatgeobuf: ni
        }
          , ai = function(e, i, r, o) {
            const n = new si[i.type](e,i,r,o);
            if (n.id !== e)
                throw new Error(`Expected Source id to be ${e} instead of ${n.id}`);
            return t.bindAll(["load", "abort", "unload", "serialize", "prepare"], n),
            n
        };
        function li(e, i) {
            const r = t.identity([]);
            return t.scale(r, r, [.5 * e.width, .5 * -e.height, 1]),
            t.translate(r, r, [1, -1, 0]),
            t.multiply(r, r, e.calculateProjMatrix(i.toUnwrapped())),
            Float32Array.from(r)
        }
        function ci(t, e, i, r, o, n, s, a=!1) {
            const l = t.tilesIn(r, s, a);
            l.sort(ui);
            const c = [];
            for (const r of l)
                c.push({
                    wrappedTileID: r.tile.tileID.wrapped().key,
                    queryResults: r.tile.queryRenderedFeatures(e, i, t._state, r, o, n, li(t.transform, r.tile.tileID), a)
                });
            const h = function(t) {
                const e = {}
                  , i = {};
                for (const r of t) {
                    const t = r.queryResults
                      , o = r.wrappedTileID
                      , n = i[o] = i[o] || {};
                    for (const i in t) {
                        const r = t[i]
                          , o = n[i] = n[i] || {}
                          , s = e[i] = e[i] || [];
                        for (const t of r)
                            o[t.featureIndex] || (o[t.featureIndex] = !0,
                            s.push(t));
                    }
                }
                return e
            }(c);
            for (const e in h)
                h[e].forEach((e => {
                    const i = e.feature
                      , r = i.layer;
                    r && "background" !== r.type && "sky" !== r.type && (i.source = r.source,
                    r["source-layer"] && (i.sourceLayer = r["source-layer"]),
                    i.state = void 0 !== i.id ? t.getFeatureState(r["source-layer"], i.id) : {});
                }
                ));
            return h
        }
        function hi(t, e) {
            const i = t.getRenderableIds().map((e => t.getTileByID(e)))
              , r = []
              , o = {};
            for (let t = 0; t < i.length; t++) {
                const n = i[t]
                  , s = n.tileID.canonical.key;
                o[s] || (o[s] = !0,
                n.querySourceFeatures(r, e));
            }
            return r
        }
        function ui(t, e) {
            const i = t.tileID
              , r = e.tileID;
            return i.overscaledZ - r.overscaledZ || i.canonical.y - r.canonical.y || i.wrap - r.wrap || i.canonical.x - r.canonical.x
        }
        function di() {
            return null != Rp.workerClass ? new Rp.workerClass : new t.window.Worker(Rp.workerUrl)
        }
        const fi = "sgmap_preloaded_worker_pool";
        class _i {
            constructor() {
                this.active = {};
            }
            acquire(t) {
                if (!this.workers)
                    for (this.workers = []; this.workers.length < _i.workerCount; )
                        this.workers.push(new di);
                return this.active[t] = !0,
                this.workers.slice()
            }
            release(t) {
                delete this.active[t],
                0 === this.numActive() && (this.workers.forEach((t => {
                    t.terminate();
                }
                )),
                this.workers = null);
            }
            isPreloaded() {
                return !!this.active[fi]
            }
            numActive() {
                return Object.keys(this.active).length
            }
        }
        let pi;
        function mi() {
            return pi || (pi = new _i),
            pi
        }
        function gi(e, i) {
            const r = {};
            for (const t in e)
                "ref" !== t && (r[t] = e[t]);
            return t.refProperties.forEach((t => {
                t in i && (r[t] = i[t]);
            }
            )),
            r
        }
        function vi(t) {
            t = t.slice();
            const e = Object.create(null);
            for (let i = 0; i < t.length; i++)
                e[t[i].id] = t[i];
            for (let i = 0; i < t.length; i++)
                "ref"in t[i] && (t[i] = gi(t[i], e[t[i].ref]));
            return t
        }
        _i.workerCount = 2;
        const yi = {
            setStyle: "setStyle",
            addLayer: "addLayer",
            removeLayer: "removeLayer",
            setPaintProperty: "setPaintProperty",
            setLayoutProperty: "setLayoutProperty",
            setFilter: "setFilter",
            addSource: "addSource",
            removeSource: "removeSource",
            setGeoJSONSourceData: "setGeoJSONSourceData",
            setLayerZoomRange: "setLayerZoomRange",
            setLayerProperty: "setLayerProperty",
            setCenter: "setCenter",
            setZoom: "setZoom",
            setBearing: "setBearing",
            setPitch: "setPitch",
            setSprite: "setSprite",
            setGlyphs: "setGlyphs",
            setTransition: "setTransition",
            setLight: "setLight",
            setTerrain: "setTerrain",
            setFog: "setFog",
            setProjection: "setProjection"
        };
        function bi(t, e, i) {
            i.push({
                command: yi.addSource,
                args: [t, e[t]]
            });
        }
        function xi(t, e, i) {
            e.push({
                command: yi.removeSource,
                args: [t]
            }),
            i[t] = !0;
        }
        function wi(t, e, i, r) {
            xi(t, i, r),
            bi(t, e, i);
        }
        function Ti(t, e, i) {
            let r;
            for (r in t[i])
                if (t[i].hasOwnProperty(r) && "data" !== r && !c(t[i][r], e[i][r]))
                    return !1;
            for (r in e[i])
                if (e[i].hasOwnProperty(r) && "data" !== r && !c(t[i][r], e[i][r]))
                    return !1;
            return !0
        }
        function Ei(t, e, i, r, o, n) {
            let s;
            for (s in e = e || {},
            t = t || {})
                t.hasOwnProperty(s) && (c(t[s], e[s]) || i.push({
                    command: n,
                    args: [r, s, e[s], o]
                }));
            for (s in e)
                e.hasOwnProperty(s) && !t.hasOwnProperty(s) && (c(t[s], e[s]) || i.push({
                    command: n,
                    args: [r, s, e[s], o]
                }));
        }
        function Si(t) {
            return t.id
        }
        function Ci(t, e) {
            return t[e.id] = e,
            t
        }
        class Ai {
            constructor(t, e) {
                this.reset(t, e);
            }
            reset(t, e) {
                this.points = t || [],
                this._distances = [0];
                for (let t = 1; t < this.points.length; t++)
                    this._distances[t] = this._distances[t - 1] + this.points[t].dist(this.points[t - 1]);
                this.length = this._distances[this._distances.length - 1],
                this.padding = Math.min(e || 0, .5 * this.length),
                this.paddedLength = this.length - 2 * this.padding;
            }
            lerp(e) {
                if (1 === this.points.length)
                    return this.points[0];
                e = t.clamp(e, 0, 1);
                let i = 1
                  , r = this._distances[i];
                const o = e * this.paddedLength + this.padding;
                for (; r < o && i < this._distances.length; )
                    r = this._distances[++i];
                const n = i - 1
                  , s = this._distances[n]
                  , a = r - s
                  , l = a > 0 ? (o - s) / a : 0;
                return this.points[n].mult(1 - l).add(this.points[i].mult(l))
            }
        }
        class Mi {
            constructor(t, e, i) {
                const r = this.boxCells = []
                  , o = this.circleCells = [];
                this.xCellCount = Math.ceil(t / i),
                this.yCellCount = Math.ceil(e / i);
                for (let t = 0; t < this.xCellCount * this.yCellCount; t++)
                    r.push([]),
                    o.push([]);
                this.circleKeys = [],
                this.boxKeys = [],
                this.bboxes = [],
                this.circles = [],
                this.width = t,
                this.height = e,
                this.xScale = this.xCellCount / t,
                this.yScale = this.yCellCount / e,
                this.boxUid = 0,
                this.circleUid = 0;
            }
            keysLength() {
                return this.boxKeys.length + this.circleKeys.length
            }
            insert(t, e, i, r, o) {
                this._forEachCell(e, i, r, o, this._insertBoxCell, this.boxUid++),
                this.boxKeys.push(t),
                this.bboxes.push(e),
                this.bboxes.push(i),
                this.bboxes.push(r),
                this.bboxes.push(o);
            }
            insertCircle(t, e, i, r) {
                this._forEachCell(e - r, i - r, e + r, i + r, this._insertCircleCell, this.circleUid++),
                this.circleKeys.push(t),
                this.circles.push(e),
                this.circles.push(i),
                this.circles.push(r);
            }
            _insertBoxCell(t, e, i, r, o, n) {
                this.boxCells[o].push(n);
            }
            _insertCircleCell(t, e, i, r, o, n) {
                this.circleCells[o].push(n);
            }
            _query(t, e, i, r, o, n) {
                if (i < 0 || t > this.width || r < 0 || e > this.height)
                    return !o && [];
                const s = [];
                if (t <= 0 && e <= 0 && this.width <= i && this.height <= r) {
                    if (o)
                        return !0;
                    for (let t = 0; t < this.boxKeys.length; t++)
                        s.push({
                            key: this.boxKeys[t],
                            x1: this.bboxes[4 * t],
                            y1: this.bboxes[4 * t + 1],
                            x2: this.bboxes[4 * t + 2],
                            y2: this.bboxes[4 * t + 3]
                        });
                    for (let t = 0; t < this.circleKeys.length; t++) {
                        const e = this.circles[3 * t]
                          , i = this.circles[3 * t + 1]
                          , r = this.circles[3 * t + 2];
                        s.push({
                            key: this.circleKeys[t],
                            x1: e - r,
                            y1: i - r,
                            x2: e + r,
                            y2: i + r
                        });
                    }
                    return n ? s.filter(n) : s
                }
                return this._forEachCell(t, e, i, r, this._queryCell, s, {
                    hitTest: o,
                    seenUids: {
                        box: {},
                        circle: {}
                    }
                }, n),
                o ? s.length > 0 : s
            }
            _queryCircle(t, e, i, r, o) {
                const n = t - i
                  , s = t + i
                  , a = e - i
                  , l = e + i;
                if (s < 0 || n > this.width || l < 0 || a > this.height)
                    return !r && [];
                const c = [];
                return this._forEachCell(n, a, s, l, this._queryCellCircle, c, {
                    hitTest: r,
                    circle: {
                        x: t,
                        y: e,
                        radius: i
                    },
                    seenUids: {
                        box: {},
                        circle: {}
                    }
                }, o),
                r ? c.length > 0 : c
            }
            query(t, e, i, r, o) {
                return this._query(t, e, i, r, !1, o)
            }
            hitTest(t, e, i, r, o) {
                return this._query(t, e, i, r, !0, o)
            }
            hitTestCircle(t, e, i, r) {
                return this._queryCircle(t, e, i, !0, r)
            }
            _queryCell(t, e, i, r, o, n, s, a) {
                const l = s.seenUids
                  , c = this.boxCells[o];
                if (null !== c) {
                    const o = this.bboxes;
                    for (const h of c)
                        if (!l.box[h]) {
                            l.box[h] = !0;
                            const c = 4 * h;
                            if (t <= o[c + 2] && e <= o[c + 3] && i >= o[c + 0] && r >= o[c + 1] && (!a || a(this.boxKeys[h]))) {
                                if (s.hitTest)
                                    return n.push(!0),
                                    !0;
                                n.push({
                                    key: this.boxKeys[h],
                                    x1: o[c],
                                    y1: o[c + 1],
                                    x2: o[c + 2],
                                    y2: o[c + 3]
                                });
                            }
                        }
                }
                const h = this.circleCells[o];
                if (null !== h) {
                    const o = this.circles;
                    for (const c of h)
                        if (!l.circle[c]) {
                            l.circle[c] = !0;
                            const h = 3 * c;
                            if (this._circleAndRectCollide(o[h], o[h + 1], o[h + 2], t, e, i, r) && (!a || a(this.circleKeys[c]))) {
                                if (s.hitTest)
                                    return n.push(!0),
                                    !0;
                                {
                                    const t = o[h]
                                      , e = o[h + 1]
                                      , i = o[h + 2];
                                    n.push({
                                        key: this.circleKeys[c],
                                        x1: t - i,
                                        y1: e - i,
                                        x2: t + i,
                                        y2: e + i
                                    });
                                }
                            }
                        }
                }
            }
            _queryCellCircle(t, e, i, r, o, n, s, a) {
                const l = s.circle
                  , c = s.seenUids
                  , h = this.boxCells[o];
                if (null !== h) {
                    const t = this.bboxes;
                    for (const e of h)
                        if (!c.box[e]) {
                            c.box[e] = !0;
                            const i = 4 * e;
                            if (this._circleAndRectCollide(l.x, l.y, l.radius, t[i + 0], t[i + 1], t[i + 2], t[i + 3]) && (!a || a(this.boxKeys[e])))
                                return n.push(!0),
                                !0
                        }
                }
                const u = this.circleCells[o];
                if (null !== u) {
                    const t = this.circles;
                    for (const e of u)
                        if (!c.circle[e]) {
                            c.circle[e] = !0;
                            const i = 3 * e;
                            if (this._circlesCollide(t[i], t[i + 1], t[i + 2], l.x, l.y, l.radius) && (!a || a(this.circleKeys[e])))
                                return n.push(!0),
                                !0
                        }
                }
            }
            _forEachCell(t, e, i, r, o, n, s, a) {
                const l = this._convertToXCellCoord(t)
                  , c = this._convertToYCellCoord(e)
                  , h = this._convertToXCellCoord(i)
                  , u = this._convertToYCellCoord(r);
                for (let d = l; d <= h; d++)
                    for (let l = c; l <= u; l++)
                        if (o.call(this, t, e, i, r, this.xCellCount * l + d, n, s, a))
                            return
            }
            _convertToXCellCoord(t) {
                return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t * this.xScale)))
            }
            _convertToYCellCoord(t) {
                return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t * this.yScale)))
            }
            _circlesCollide(t, e, i, r, o, n) {
                const s = r - t
                  , a = o - e
                  , l = i + n;
                return l * l > s * s + a * a
            }
            _circleAndRectCollide(t, e, i, r, o, n, s) {
                const a = (n - r) / 2
                  , l = Math.abs(t - (r + a));
                if (l > a + i)
                    return !1;
                const c = (s - o) / 2
                  , h = Math.abs(e - (o + c));
                if (h > c + i)
                    return !1;
                if (l <= a || h <= c)
                    return !0;
                const u = l - a
                  , d = h - c;
                return u * u + d * d <= i * i
            }
        }
        const Ii = Math.tan(85 * Math.PI / 180);
        function zi(e, i, r, o, n, s, a) {
            const l = t.create();
            if (r)
                if ("globe" === s.name) {
                    const e = t.calculateGlobeLabelMatrix(n, i);
                    t.multiply(l, l, e);
                } else {
                    const e = A([], a);
                    l[0] = e[0],
                    l[1] = e[1],
                    l[4] = e[2],
                    l[5] = e[3],
                    o || t.rotateZ(l, l, n.angle);
                }
            else
                t.multiply(l, n.labelPlaneMatrix, e);
            return l
        }
        function Pi(t, e, i, r, o, n, s) {
            const a = zi(t, e, i, r, o, n, s);
            return "globe" === n.name && i || (a[2] = a[6] = a[10] = a[14] = 0),
            a
        }
        function Di(e, i, r, o, n, s, a) {
            if (r) {
                if ("globe" === s.name) {
                    const l = zi(e, i, r, o, n, s, a);
                    return t.invert(l, l),
                    t.multiply(l, e, l),
                    l
                }
                {
                    const i = t.clone(e)
                      , r = t.identity([]);
                    return r[0] = a[0],
                    r[1] = a[1],
                    r[4] = a[2],
                    r[5] = a[3],
                    t.multiply(i, i, r),
                    o || t.rotateZ(i, i, -n.angle),
                    i
                }
            }
            return n.glCoordMatrix
        }
        function Bi(e, i, r=0) {
            const o = [e.x, e.y, r, 1];
            r ? t.transformMat4$1(o, o, i) : qi(o, o, i);
            const n = o[3];
            return {
                point: [o[0] / n, o[1] / n, o[2] / n],
                signedDistanceFromCamera: n
            }
        }
        function Li(e, i) {
            const r = [e[0], e[1], e[2], 1];
            t.transformMat4$1(r, r, i);
            const o = r[3];
            return {
                point: [r[0] / o, r[1] / o, r[2] / o],
                signedDistanceFromCamera: o
            }
        }
        function Ri(t, e) {
            return Math.min(.5 + t / e * .5, 1.5)
        }
        function ki(t, e) {
            const i = t[0] / t[3]
              , r = t[1] / t[3];
            return i >= -e[0] && i <= e[0] && r >= -e[1] && r <= e[1]
        }
        function Oi(e, i, r, o, n, s, a, l, c, h) {
            const u = r.transform
              , d = o ? e.textSizeData : e.iconSizeData
              , f = t.evaluateSizeForZoom(d, r.transform.zoom)
              , _ = "globe" === u.projection.name
              , p = [256 / r.width * 2 + 1, 256 / r.height * 2 + 1]
              , m = o ? e.text.dynamicLayoutVertexArray : e.icon.dynamicLayoutVertexArray;
            m.clear();
            let g = null;
            _ && (g = o ? e.text.globeExtVertexArray : e.icon.globeExtVertexArray);
            const v = e.lineVertexArray
              , y = o ? e.text.placedSymbolArray : e.icon.placedSymbolArray
              , b = r.transform.width / r.transform.height;
            let x = !1;
            for (let o = 0; o < y.length; o++) {
                const _ = y.get(o);
                if (_.writingMode !== t.WritingMode.vertical || x || 0 !== o && y.get(o - 1).writingMode === t.WritingMode.horizontal || (x = !0),
                (_.hidden || _.writingMode === t.WritingMode.vertical) && !x) {
                    Wi(_.numGlyphs, m);
                    continue
                }
                x = !1;
                const w = new t.pointGeometry(_.tileAnchorX,_.tileAnchorY)
                  , T = c ? c(w) : [0, 0, 0]
                  , E = u.projection.projectTilePoint(w.x, w.y, h.canonical)
                  , S = [E.x + T[0], E.y + T[1], E.z + T[2]]
                  , C = [...S, 1];
                if (t.transformMat4$1(C, C, i),
                !ki(C, p)) {
                    Wi(_.numGlyphs, m);
                    continue
                }
                const A = Ri(r.transform.cameraToCenterDistance, C[3])
                  , M = t.evaluateSizeForFeature(d, f, _)
                  , I = a ? M / A : M * A
                  , z = Bi(new t.pointGeometry(S[0],S[1]), n, S[2]);
                if (z.signedDistanceFromCamera <= 0) {
                    Wi(_.numGlyphs, m);
                    continue
                }
                let P = {};
                const D = a ? null : c
                  , B = Ni(_, I, !1, l, i, n, s, e.glyphOffsetArray, v, m, g, z.point, w, P, b, D, u.projection, h, a);
                x = B.useVertical,
                D && B.needsFlipping && (P = {}),
                (B.notEnoughRoom || x || B.needsFlipping && Ni(_, I, !0, l, i, n, s, e.glyphOffsetArray, v, m, g, z.point, w, P, b, D, u.projection, h, a).notEnoughRoom) && Wi(_.numGlyphs, m);
            }
            o ? (e.text.dynamicLayoutVertexBuffer.updateData(m),
            g && e.text.globeExtVertexBuffer.updateData(g)) : (e.icon.dynamicLayoutVertexBuffer.updateData(m),
            g && e.icon.globeExtVertexBuffer.updateData(g));
        }
        function Fi(t, e, i, r, o, n, s, a, l, c, h, u, d, f, _, p) {
            const m = a.glyphStartIndex + a.numGlyphs
              , g = a.lineStartIndex
              , v = a.lineStartIndex + a.lineLength
              , y = e.getoffsetX(a.glyphStartIndex)
              , b = e.getoffsetX(m - 1)
              , x = Vi(t * y, i, r, o, n, s, a.segment, g, v, l, c, h, u, d, !0, f, _, p);
            if (!x)
                return null;
            const w = Vi(t * b, i, r, o, n, s, a.segment, g, v, l, c, h, u, d, !0, f, _, p);
            return w ? {
                first: x,
                last: w
            } : null
        }
        function Ui(e, i, r, o) {
            return e.writingMode === t.WritingMode.horizontal && Math.abs(r.y - i.y) > Math.abs(r.x - i.x) * o ? {
                useVertical: !0
            } : e.writingMode === t.WritingMode.vertical ? i.y < r.y ? {
                needsFlipping: !0
            } : null : 0 !== e.flipState && function(t, e, i) {
                const r = (e.x - t.x) * i;
                return 0 === r || Math.abs((e.y - t.y) / r) > Ii
            }(i, r, o) ? 1 === e.flipState ? {
                needsFlipping: !0
            } : null : i.x > r.x ? {
                needsFlipping: !0
            } : null
        }
        function Ni(e, i, r, o, n, s, a, l, c, h, u, d, f, _, p, m, g, v, y) {
            const b = i / 24
              , x = e.lineOffsetX * b
              , w = e.lineOffsetY * b;
            let T;
            if (e.numGlyphs > 1) {
                const i = e.glyphStartIndex + e.numGlyphs
                  , n = e.lineStartIndex
                  , h = e.lineStartIndex + e.lineLength
                  , u = Fi(b, l, x, w, r, d, f, e, c, s, _, m, !1, g, v, y);
                if (!u)
                    return {
                        notEnoughRoom: !0
                    };
                const E = Li(u.first.point, a).point
                  , S = Li(u.last.point, a).point
                  , C = new t.pointGeometry(E[0],E[1])
                  , A = new t.pointGeometry(S[0],S[1]);
                if (o && !r) {
                    const t = Ui(e, C, A, p);
                    if (e.flipState = t && t.needsFlipping ? 1 : 2,
                    t)
                        return t
                }
                T = [u.first];
                for (let t = e.glyphStartIndex + 1; t < i - 1; t++)
                    T.push(Vi(b * l.getoffsetX(t), x, w, r, d, f, e.segment, n, h, c, s, _, m, !1, !1, g, v, y));
                T.push(u.last);
            } else {
                if (o && !r) {
                    const i = Bi(f, n).point
                      , r = e.lineStartIndex + e.segment + 1
                      , o = new t.pointGeometry(c.getx(r),c.gety(r))
                      , s = Bi(o, n)
                      , a = s.signedDistanceFromCamera > 0 ? s.point : Gi(f, o, i, 1, n, void 0, g, v.canonical)
                      , l = Ui(e, new t.pointGeometry(i[0],i[1]), new t.pointGeometry(a[0],a[1]), p);
                    if (e.flipState = l && l.needsFlipping ? 1 : 2,
                    l)
                        return l
                }
                const i = Vi(b * l.getoffsetX(e.glyphStartIndex), x, w, r, d, f, e.segment, e.lineStartIndex, e.lineStartIndex + e.lineLength, c, s, _, m, !1, !1, g, v, y);
                if (!i)
                    return {
                        notEnoughRoom: !0
                    };
                T = [i];
            }
            if (u)
                for (const e of T)
                    t.updateGlobeVertexNormal(u, h.length + 0, e.up[0], e.up[1], e.up[2]),
                    t.updateGlobeVertexNormal(u, h.length + 1, e.up[0], e.up[1], e.up[2]),
                    t.updateGlobeVertexNormal(u, h.length + 2, e.up[0], e.up[1], e.up[2]),
                    t.updateGlobeVertexNormal(u, h.length + 3, e.up[0], e.up[1], e.up[2]),
                    t.addDynamicAttributes(h, e.point[0], e.point[1], e.point[2], e.angle);
            else
                for (const e of T)
                    t.addDynamicAttributes(h, e.point[0], e.point[1], e.point[2], e.angle);
            return {}
        }
        function ji(e, i, r, o, n) {
            const s = o.projectTilePoint(e.x, e.y, i);
            if (!n)
                return Bi(s, r, s.z);
            const a = n(e);
            return Bi(new t.pointGeometry(s.x + a[0],s.y + a[1]), r, s.z + a[2])
        }
        function Gi(e, i, r, o, n, s, a, l) {
            const c = ji(e.add(e.sub(i)._unit()), l, n, a, s).point
              , h = t.sub([], r, c);
            return t.scaleAndAdd([], r, h, o / t.length(h))
        }
        function Vi(e, i, r, o, n, s, a, l, c, h, u, d, f, _, p, m, g, v) {
            const y = o ? e - i : e + i;
            let b = y > 0 ? 1 : -1
              , x = 0;
            o && (b *= -1,
            x = Math.PI),
            b < 0 && (x += Math.PI);
            let w = b > 0 ? l + a : l + a + 1
              , T = n
              , E = n
              , S = 0
              , C = 0;
            const A = Math.abs(y)
              , M = []
              , I = [];
            let z = s;
            const P = () => {
                const e = w - b;
                return 0 === S ? s : new t.pointGeometry(h.getx(e),h.gety(e))
            }
              , D = () => Gi(P(), z, E, A - S + 1, u, f, m, g.canonical);
            for (; S + C <= A; ) {
                if (w += b,
                w < l || w >= c)
                    return null;
                if (E = T,
                M.push(T),
                _ && I.push(z || P()),
                T = d[w],
                void 0 === T) {
                    z = new t.pointGeometry(h.getx(w),h.gety(w));
                    const e = ji(z, g.canonical, u, m, f);
                    T = e.signedDistanceFromCamera > 0 ? d[w] = e.point : D();
                } else
                    z = null;
                S += C,
                C = t.distance(E, T);
            }
            z = z || new t.pointGeometry(h.getx(w),h.gety(w));
            const B = P();
            p && f && (d[w] = T = void 0 === d[w] ? T : D(),
            C = t.distance(E, T));
            const L = (A - S) / C
              , R = z.sub(B).mult(L)._add(B)
              , k = t.sub([], T, E)
              , O = t.scaleAndAdd([], E, k, L);
            let F = [0, 0, 1]
              , U = k[0]
              , N = k[1];
            if (v && (F = m.upVector(g.canonical, R.x, R.y),
            0 !== F[0] || 0 !== F[1] || 1 !== F[2])) {
                const e = [1, 0, 0]
                  , i = [0, 1, 0];
                e[0] = F[2],
                e[1] = 0,
                e[2] = -F[0],
                t.cross(i, F, e),
                t.normalize(e, e),
                t.normalize(i, i),
                U = t.dot(k, e),
                N = t.dot(k, i);
            }
            if (r) {
                const e = t.cross([], F, k);
                t.normalize(e, e),
                t.scaleAndAdd(O, O, e, r * b);
            }
            const j = x + Math.atan2(N, U);
            return M.push(O),
            _ && I.push(R),
            {
                point: O,
                angle: j,
                path: M,
                tilePath: I,
                up: F
            }
        }
        const Zi = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function Wi(t, e) {
            for (let i = 0; i < t; i++) {
                const t = e.length;
                e.resize(t + 4),
                e.float32.set(Zi, 4 * t);
            }
        }
        function qi(t, e, i) {
            const r = e[0]
              , o = e[1];
            return t[0] = i[0] * r + i[4] * o + i[12],
            t[1] = i[1] * r + i[5] * o + i[13],
            t[3] = i[3] * r + i[7] * o + i[15],
            t
        }
        const Hi = 100;
        class Xi {
            constructor(t, e, i=new Mi(t.width + 200,t.height + 200,25), r=new Mi(t.width + 200,t.height + 200,25)) {
                this.transform = t,
                this.grid = i,
                this.ignoredGrid = r,
                this.pitchfactor = Math.cos(t._pitch) * t.cameraToCenterDistance,
                this.screenRightBoundary = t.width + Hi,
                this.screenBottomBoundary = t.height + Hi,
                this.gridRightBoundary = t.width + 200,
                this.gridBottomBoundary = t.height + 200,
                this.fogState = e;
            }
            placeCollisionBox(t, e, i, r, o, n, s, a) {
                let l = i.projectedAnchorX
                  , c = i.projectedAnchorY
                  , h = i.projectedAnchorZ;
                const u = i.elevation
                  , d = i.tileID;
                if (u && d) {
                    const e = t.getProjection().upVector(d.canonical, i.tileAnchorX, i.tileAnchorY)
                      , r = t.getProjection().upVectorScale(d.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
                    l += e[0] * u * r,
                    c += e[1] * u * r,
                    h += e[2] * u * r;
                }
                const f = this.projectAndGetPerspectiveRatio(s, [l, c, h], i.tileID, "globe" === t.projection.name || !!u || this.transform.pitch > 0, t.getProjection())
                  , _ = n * f.perspectiveRatio
                  , p = (i.x1 * e + r.x - i.padding) * _ + f.point.x
                  , m = (i.y1 * e + r.y - i.padding) * _ + f.point.y
                  , g = (i.x2 * e + r.x + i.padding) * _ + f.point.x
                  , v = (i.y2 * e + r.y + i.padding) * _ + f.point.y
                  , y = f.perspectiveRatio <= .55 || f.occluded;
                return !this.isInsideGrid(p, m, g, v) || !o && this.grid.hitTest(p, m, g, v, a) || y ? {
                    box: [],
                    offscreen: !1,
                    occluded: f.occluded
                } : {
                    box: [p, m, g, v],
                    offscreen: this.isOffscreen(p, m, g, v),
                    occluded: !1
                }
            }
            placeCollisionCircles(e, i, r, o, n, s, a, l, c, h, u, d, f, _, p) {
                const m = []
                  , g = this.transform.elevation
                  , v = g ? g.getAtTileOffsetFunc(p, this.transform.center.lat, this.transform.worldSize, e.getProjection()) : t => [0, 0, 0]
                  , y = new t.pointGeometry(r.tileAnchorX,r.tileAnchorY)
                  , b = e.getProjection().projectTilePoint(r.tileAnchorX, r.tileAnchorY, p.canonical)
                  , x = v(y)
                  , w = [b.x + x[0], b.y + x[1], b.z + x[2]]
                  , T = "globe" === e.projection.name
                  , E = this.projectAndGetPerspectiveRatio(a, [w[0], w[1], w[2]], p, T || !!g || this.transform.pitch > 0, e.getProjection())
                  , {perspectiveRatio: S} = E
                  , C = (u ? s / S : s * S) / t.ONE_EM
                  , A = Bi(new t.pointGeometry(w[0],w[1]), l, w[2]).point
                  , M = E.signedDistanceFromCamera > 0 ? Fi(C, n, r.lineOffsetX * C, r.lineOffsetY * C, !1, A, y, r, o, l, {}, g && !u ? v : null, u && !!g, e.getProjection(), p, u) : null;
                let I = !1
                  , z = !1
                  , P = !0;
                if (M && !E.occluded) {
                    const e = .5 * f * S + _
                      , r = new t.pointGeometry(-100,-100)
                      , o = new t.pointGeometry(this.screenRightBoundary,this.screenBottomBoundary)
                      , n = new Ai
                      , s = M.first
                      , a = M.last;
                    let l = [];
                    for (let t = s.path.length - 1; t >= 1; t--)
                        l.push(s.path[t]);
                    for (let t = 1; t < a.path.length; t++)
                        l.push(a.path[t]);
                    const u = 2.5 * e;
                    if (c) {
                        const t = l.map(g && !T ? (t, e) => {
                            const i = v(e < s.path.length - 1 ? s.tilePath[s.path.length - 1 - e] : a.tilePath[e - s.path.length + 2]);
                            return t[2] = i[2],
                            Li(t, c)
                        }
                        : t => Li(t, c));
                        l = t.some((t => t.signedDistanceFromCamera <= 0)) ? [] : t.map((t => t.point));
                    }
                    let p = [];
                    if (l.length > 0) {
                        const e = l.map((e => new t.pointGeometry(e[0],e[1])));
                        let i = 1 / 0
                          , n = -1 / 0
                          , s = 1 / 0
                          , a = -1 / 0;
                        for (let t = 0; t < e.length; t++)
                            i = Math.min(i, e[t].x),
                            s = Math.min(s, e[t].y),
                            n = Math.max(n, e[t].x),
                            a = Math.max(a, e[t].y);
                        p = i >= r.x && n <= o.x && s >= r.y && a <= o.y ? [e] : n < r.x || i > o.x || a < r.y || s > o.y ? [] : t.clipLine([e], r.x, r.y, o.x, o.y);
                    }
                    for (const t of p) {
                        n.reset(t, .25 * e);
                        let r = 0;
                        r = n.length <= .5 * e ? 1 : Math.ceil(n.paddedLength / u) + 1;
                        for (let t = 0; t < r; t++) {
                            const o = t / Math.max(r - 1, 1)
                              , s = n.lerp(o)
                              , a = s.x + Hi
                              , l = s.y + Hi;
                            m.push(a, l, e, 0);
                            const c = a - e
                              , u = l - e
                              , f = a + e
                              , _ = l + e;
                            if (P = P && this.isOffscreen(c, u, f, _),
                            z = z || this.isInsideGrid(c, u, f, _),
                            !i && this.grid.hitTestCircle(a, l, e, d) && (I = !0,
                            !h))
                                return {
                                    circles: [],
                                    offscreen: !1,
                                    collisionDetected: I,
                                    occluded: !1
                                }
                        }
                    }
                }
                return {
                    circles: !h && I || !z ? [] : m,
                    offscreen: P,
                    collisionDetected: I,
                    occluded: E.occluded
                }
            }
            queryRenderedSymbols(e) {
                if (0 === e.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength())
                    return {};
                const i = [];
                let r = 1 / 0
                  , o = 1 / 0
                  , n = -1 / 0
                  , s = -1 / 0;
                for (const a of e) {
                    const e = new t.pointGeometry(a.x + Hi,a.y + Hi);
                    r = Math.min(r, e.x),
                    o = Math.min(o, e.y),
                    n = Math.max(n, e.x),
                    s = Math.max(s, e.y),
                    i.push(e);
                }
                const a = this.grid.query(r, o, n, s).concat(this.ignoredGrid.query(r, o, n, s))
                  , l = {}
                  , c = {};
                for (const e of a) {
                    const r = e.key;
                    if (void 0 === l[r.bucketInstanceId] && (l[r.bucketInstanceId] = {}),
                    l[r.bucketInstanceId][r.featureIndex])
                        continue;
                    const o = [new t.pointGeometry(e.x1,e.y1), new t.pointGeometry(e.x2,e.y1), new t.pointGeometry(e.x2,e.y2), new t.pointGeometry(e.x1,e.y2)];
                    t.polygonIntersectsPolygon(i, o) && (l[r.bucketInstanceId][r.featureIndex] = !0,
                    void 0 === c[r.bucketInstanceId] && (c[r.bucketInstanceId] = []),
                    c[r.bucketInstanceId].push(r.featureIndex));
                }
                return c
            }
            insertCollisionBox(t, e, i, r, o) {
                (e ? this.ignoredGrid : this.grid).insert({
                    bucketInstanceId: i,
                    featureIndex: r,
                    collisionGroupID: o
                }, t[0], t[1], t[2], t[3]);
            }
            insertCollisionCircles(t, e, i, r, o) {
                const n = e ? this.ignoredGrid : this.grid
                  , s = {
                    bucketInstanceId: i,
                    featureIndex: r,
                    collisionGroupID: o
                };
                for (let e = 0; e < t.length; e += 4)
                    n.insertCircle(s, t[e], t[e + 1], t[e + 2]);
            }
            projectAndGetPerspectiveRatio(e, i, r, o, n) {
                const s = [i[0], i[1], i[2], 1];
                let a = !1;
                if (i[2] || this.transform.pitch > 0) {
                    t.transformMat4$1(s, s, e);
                    const o = "globe" === n.name;
                    this.fogState && r && !o && (a = function(e, i, r, o, n, s) {
                        const a = s.calculateFogTileMatrix(n)
                          , l = [i, r, o];
                        return t.transformMat4(l, l, a),
                        O(e, l, s.pitch, s._fov)
                    }(this.fogState, i[0], i[1], i[2], r.toUnwrapped(), this.transform) > .9);
                } else
                    qi(s, s, e);
                return {
                    point: new t.pointGeometry((s[0] / s[3] + 1) / 2 * this.transform.width + Hi,(-s[1] / s[3] + 1) / 2 * this.transform.height + Hi),
                    perspectiveRatio: Math.min(.5 + this.transform.getCameraToCenterDistance(n) / s[3] * .5, 1.5),
                    signedDistanceFromCamera: s[3],
                    occluded: o && s[2] > s[3] || a
                }
            }
            isOffscreen(t, e, i, r) {
                return i < Hi || t >= this.screenRightBoundary || r < Hi || e > this.screenBottomBoundary
            }
            isInsideGrid(t, e, i, r) {
                return i >= 0 && t < this.gridRightBoundary && r >= 0 && e < this.gridBottomBoundary
            }
            getViewportMatrix() {
                const e = t.identity([]);
                return t.translate(e, e, [-100, -100, 0]),
                e
            }
        }
        function Yi(e, i, r) {
            const o = i.createTileMatrix(e, e.worldSize, r.toUnwrapped());
            return t.multiply(new Float32Array(16), e.projMatrix, o)
        }
        function Ki(t, e, i) {
            if (e.projection.name === i.projection.name)
                return t.projMatrix;
            const r = i.clone();
            return r.setProjection(e.projection),
            Yi(r, e.getProjection(), t)
        }
        function Ji(t, e, i) {
            return e.name === i.projection.name ? t.projMatrix : Yi(i, e, t)
        }
        class $i {
            constructor(t, e, i, r) {
                this.opacity = t ? Math.max(0, Math.min(1, t.opacity + (t.placed ? e : -e))) : r && i ? 1 : 0,
                this.placed = i;
            }
            isHidden() {
                return 0 === this.opacity && !this.placed
            }
        }
        class Qi {
            constructor(t, e, i, r, o, n=!1) {
                this.text = new $i(t ? t.text : null,e,i,o),
                this.icon = new $i(t ? t.icon : null,e,r,o),
                this.clipped = n;
            }
            isHidden() {
                return this.text.isHidden() && this.icon.isHidden()
            }
        }
        class tr {
            constructor(t, e, i, r=!1) {
                this.text = t,
                this.icon = e,
                this.skipFade = i,
                this.clipped = r;
            }
        }
        class er {
            constructor() {
                this.invProjMatrix = t.create(),
                this.viewportMatrix = t.create(),
                this.circles = [];
            }
        }
        class ir {
            constructor(t, e, i, r, o) {
                this.bucketInstanceId = t,
                this.featureIndex = e,
                this.sourceLayerIndex = i,
                this.bucketIndex = r,
                this.tileID = o;
            }
        }
        class rr {
            constructor(t) {
                this.crossSourceCollisions = t,
                this.maxGroupID = 0,
                this.collisionGroups = {};
            }
            get(t) {
                if (this.crossSourceCollisions)
                    return {
                        ID: 0,
                        predicate: null
                    };
                if (!this.collisionGroups[t]) {
                    const e = ++this.maxGroupID;
                    this.collisionGroups[t] = {
                        ID: e,
                        predicate: t => t.collisionGroupID === e
                    };
                }
                return this.collisionGroups[t]
            }
        }
        function or(e, i, r, o, n) {
            const {horizontalAlign: s, verticalAlign: a} = t.getAnchorAlignment(e)
              , l = -(s - .5) * i
              , c = -(a - .5) * r
              , h = t.evaluateVariableOffset(e, o);
            return new t.pointGeometry(l + h[0] * n,c + h[1] * n)
        }
        function nr(e, i, r, o, n) {
            const s = new t.pointGeometry(e,i);
            return r && s._rotate(o ? n : -n),
            s
        }
        class sr {
            constructor(t, e, i, r, o) {
                this.transform = t.clone(),
                this.projection = t.projection.name,
                this.collisionIndex = new Xi(this.transform,o),
                this.placements = {},
                this.opacities = {},
                this.variableOffsets = {},
                this.stale = !1,
                this.commitTime = 0,
                this.fadeDuration = e,
                this.retainedQueryData = {},
                this.collisionGroups = new rr(i),
                this.collisionCircleArrays = {},
                this.prevPlacement = r,
                r && (r.prevPlacement = void 0),
                this.placedOrientations = {};
            }
            getBucketParts(e, i, r, o) {
                const n = r.getBucket(i)
                  , s = r.latestFeatureIndex;
                if (!n || !s || i.id !== n.layerIds[0])
                    return;
                const a = n.layers[0].layout
                  , l = r.collisionBoxArray
                  , c = Math.pow(2, this.transform.zoom - r.tileID.overscaledZ)
                  , h = r.tileSize / t.EXTENT
                  , u = r.tileID.toUnwrapped();
                this.transform.setProjection(n.projection);
                const d = (f = r.tileID,
                _ = n.getProjection(),
                p = this.transform,
                _.name === this.projection ? p.calculateProjMatrix(f.toUnwrapped()) : Yi(p, _, f));
                var f, _, p;
                const m = "map" === a.get("text-pitch-alignment")
                  , g = "map" === a.get("text-rotation-alignment");
                i.compileFilter();
                const v = i.dynamicFilter()
                  , y = i.dynamicFilterNeedsFeature()
                  , b = this.transform.calculatePixelsToTileUnitsMatrix(r)
                  , x = Pi(d, r.tileID.canonical, m, g, this.transform, n.getProjection(), b);
                let w = null;
                if (m) {
                    const e = Di(d, r.tileID.canonical, m, g, this.transform, n.getProjection(), b);
                    w = t.multiply([], this.transform.labelPlaneMatrix, e);
                }
                let T = null;
                v && r.latestFeatureIndex && (T = {
                    unwrappedTileID: u,
                    dynamicFilter: v,
                    dynamicFilterNeedsFeature: y,
                    featureIndex: r.latestFeatureIndex
                }),
                this.retainedQueryData[n.bucketInstanceId] = new ir(n.bucketInstanceId,s,n.sourceLayerIndex,n.index,r.tileID);
                const E = {
                    bucket: n,
                    layout: a,
                    posMatrix: d,
                    textLabelPlaneMatrix: x,
                    labelToScreenMatrix: w,
                    clippingData: T,
                    scale: c,
                    textPixelRatio: h,
                    holdingForFade: r.holdingForFade(),
                    collisionBoxArray: l,
                    partiallyEvaluatedTextSize: t.evaluateSizeForZoom(n.textSizeData, this.transform.zoom),
                    partiallyEvaluatedIconSize: t.evaluateSizeForZoom(n.iconSizeData, this.transform.zoom),
                    collisionGroup: this.collisionGroups.get(n.sourceID)
                };
                if (o)
                    for (const t of n.sortKeyRanges) {
                        const {sortKey: i, symbolInstanceStart: r, symbolInstanceEnd: o} = t;
                        e.push({
                            sortKey: i,
                            symbolInstanceStart: r,
                            symbolInstanceEnd: o,
                            parameters: E
                        });
                    }
                else
                    e.push({
                        symbolInstanceStart: 0,
                        symbolInstanceEnd: n.symbolInstances.length,
                        parameters: E
                    });
            }
            attemptAnchorPlacement(t, e, i, r, o, n, s, a, l, c, h, u, d, f, _, p, m, g) {
                const v = [u.textOffset0, u.textOffset1]
                  , y = or(t, i, r, v, o)
                  , b = this.collisionIndex.placeCollisionBox(f, o, e, nr(y.x, y.y, n, s, this.transform.angle), h, a, l, c.predicate);
                if ((!p || 0 !== this.collisionIndex.placeCollisionBox(f, f.getSymbolInstanceIconSize(g, this.transform.zoom, d), p, nr(y.x, y.y, n, s, this.transform.angle), h, a, l, c.predicate).box.length) && b.box.length > 0) {
                    let e;
                    return this.prevPlacement && this.prevPlacement.variableOffsets[u.crossTileID] && this.prevPlacement.placements[u.crossTileID] && this.prevPlacement.placements[u.crossTileID].text && (e = this.prevPlacement.variableOffsets[u.crossTileID].anchor),
                    this.variableOffsets[u.crossTileID] = {
                        textOffset: v,
                        width: i,
                        height: r,
                        anchor: t,
                        textScale: o,
                        prevAnchor: e
                    },
                    this.markUsedJustification(f, t, u, _),
                    f.allowVerticalPlacement && (this.markUsedOrientation(f, _, u),
                    this.placedOrientations[u.crossTileID] = _),
                    {
                        shift: y,
                        placedGlyphBoxes: b
                    }
                }
            }
            placeLayerBucketPart(e, i, r, o) {
                const {bucket: n, layout: s, posMatrix: a, textLabelPlaneMatrix: l, labelToScreenMatrix: c, clippingData: h, textPixelRatio: u, holdingForFade: d, collisionBoxArray: f, partiallyEvaluatedTextSize: _, partiallyEvaluatedIconSize: p, collisionGroup: m} = e.parameters
                  , g = s.get("text-optional")
                  , v = s.get("icon-optional")
                  , y = s.get("text-allow-overlap")
                  , b = s.get("icon-allow-overlap")
                  , x = "map" === s.get("text-rotation-alignment")
                  , w = "map" === s.get("text-pitch-alignment")
                  , T = "none" !== s.get("icon-text-fit")
                  , E = "viewport-y" === s.get("symbol-z-order");
                this.transform.setProjection(n.projection);
                let S = y && (b || !n.hasIconData() || v)
                  , C = b && (y || !n.hasTextData() || g);
                !n.collisionArrays && f && n.deserializeCollisionBoxes(f);
                const A = this.transform.zoom;
                var M = n.feature_values.map((t => t[0]));
                r && o && n.updateCollisionDebugBuffers(this.transform.zoom, f);
                const I = (e, o, f) => {
                    if (h) {
                        const r = {
                            zoom: this.transform.zoom,
                            pitch: this.transform.pitch
                        };
                        let o = null;
                        if (h.dynamicFilterNeedsFeature) {
                            const t = this.retainedQueryData[n.bucketInstanceId];
                            o = h.featureIndex.loadFeature({
                                featureIndex: e.featureIndex,
                                bucketIndex: t.bucketIndex,
                                sourceLayerIndex: t.sourceLayerIndex,
                                layoutVertexArrayOffset: 0
                            });
                        }
                        if (!(0,
                        h.dynamicFilter)(r, o, this.retainedQueryData[n.bucketInstanceId].tileID.canonical, new t.pointGeometry(e.tileAnchorX,e.tileAnchorY), this.transform.calculateDistanceTileData(h.unwrappedTileID)))
                            return this.placements[e.crossTileID] = new tr(!1,!1,!1,!0),
                            void (i[e.crossTileID] = !0)
                    }
                    if (i[e.crossTileID])
                        return;
                    if (d)
                        return void (this.placements[e.crossTileID] = new tr(!1,!1,!1));
                    const E = M.indexOf(e.featureIndex);
                    if (E >= 0) {
                        const t = n.feature_values[E];
                        if (t && (A < t[1] || A > t[2]))
                            return
                    }
                    let I = !1
                      , z = !1
                      , P = !0
                      , D = !1
                      , B = !1
                      , L = null
                      , R = {
                        box: null,
                        offscreen: null,
                        occluded: null
                    }
                      , k = {
                        box: null,
                        offscreen: null,
                        occluded: null
                    }
                      , O = null
                      , F = null
                      , U = null
                      , N = 0
                      , j = 0
                      , G = 0;
                    f.textFeatureIndex ? N = f.textFeatureIndex : e.useRuntimeCollisionCircles && (N = e.featureIndex),
                    f.verticalTextFeatureIndex && (j = f.verticalTextFeatureIndex);
                    const V = t => {
                        t.tileID = this.retainedQueryData[n.bucketInstanceId].tileID,
                        (this.transform.elevation || t.elevation) && (t.elevation = this.transform.elevation ? this.transform.elevation.getAtTileOffset(this.retainedQueryData[n.bucketInstanceId].tileID, t.tileAnchorX, t.tileAnchorY) : 0);
                    }
                      , Z = f.textBox;
                    if (Z) {
                        V(Z);
                        const i = i => {
                            let r = t.WritingMode.horizontal;
                            if (n.allowVerticalPlacement && !i && this.prevPlacement) {
                                const t = this.prevPlacement.placedOrientations[e.crossTileID];
                                t && (this.placedOrientations[e.crossTileID] = t,
                                r = t,
                                this.markUsedOrientation(n, r, e));
                            }
                            return r
                        }
                          , r = (i, r) => {
                            if (n.allowVerticalPlacement && e.numVerticalGlyphVertices > 0 && f.verticalTextBox) {
                                for (const e of n.writingModes)
                                    if (e === t.WritingMode.vertical ? (R = r(),
                                    k = R) : R = i(),
                                    R && R.box && R.box.length)
                                        break
                            } else
                                R = i();
                        }
                        ;
                        if (s.get("text-variable-anchor")) {
                            let l = s.get("text-variable-anchor");
                            if (this.prevPlacement && this.prevPlacement.variableOffsets[e.crossTileID]) {
                                const t = this.prevPlacement.variableOffsets[e.crossTileID];
                                l.indexOf(t.anchor) > 0 && (l = l.filter((e => e !== t.anchor)),
                                l.unshift(t.anchor));
                            }
                            const c = (t, i, r) => {
                                const s = n.getSymbolInstanceTextSize(_, e, this.transform.zoom, o)
                                  , c = (t.x2 - t.x1) * s + 2 * t.padding
                                  , h = (t.y2 - t.y1) * s + 2 * t.padding
                                  , d = T && !b ? i : null;
                                d && V(d);
                                let f = {
                                    box: [],
                                    offscreen: !1,
                                    occluded: !1
                                };
                                const g = y ? 2 * l.length : l.length;
                                for (let i = 0; i < g; ++i) {
                                    const g = this.attemptAnchorPlacement(l[i % l.length], t, c, h, s, x, w, u, a, m, i >= l.length, e, o, n, r, d, _, p);
                                    if (g && (f = g.placedGlyphBoxes,
                                    f && f.box && f.box.length)) {
                                        I = !0,
                                        L = g.shift;
                                        break
                                    }
                                }
                                return f
                            }
                            ;
                            r(( () => c(Z, f.iconBox, t.WritingMode.horizontal)), ( () => {
                                const i = f.verticalTextBox;
                                return i && V(i),
                                n.allowVerticalPlacement && !(R && R.box && R.box.length) && e.numVerticalGlyphVertices > 0 && i ? c(i, f.verticalIconBox, t.WritingMode.vertical) : {
                                    box: null,
                                    offscreen: null,
                                    occluded: null
                                }
                            }
                            )),
                            R && (I = R.box,
                            P = R.offscreen,
                            D = R.occluded);
                            const h = i(R && R.box);
                            if (!I && this.prevPlacement) {
                                const t = this.prevPlacement.variableOffsets[e.crossTileID];
                                t && (this.variableOffsets[e.crossTileID] = t,
                                this.markUsedJustification(n, t.anchor, e, h));
                            }
                        } else {
                            const s = (i, r) => {
                                const s = n.getSymbolInstanceTextSize(_, e, this.transform.zoom, o)
                                  , l = this.collisionIndex.placeCollisionBox(n, s, i, new t.pointGeometry(0,0), y, u, a, m.predicate);
                                return l && l.box && l.box.length && (this.markUsedOrientation(n, r, e),
                                this.placedOrientations[e.crossTileID] = r),
                                l
                            }
                            ;
                            r(( () => s(Z, t.WritingMode.horizontal)), ( () => {
                                const i = f.verticalTextBox;
                                return n.allowVerticalPlacement && e.numVerticalGlyphVertices > 0 && i ? (V(i),
                                s(i, t.WritingMode.vertical)) : {
                                    box: null,
                                    offscreen: null,
                                    occluded: null
                                }
                            }
                            )),
                            i(R && R.box && R.box.length);
                        }
                    }
                    if (O = R,
                    I = O && O.box && O.box.length > 0,
                    P = O && O.offscreen,
                    D = O && O.occluded,
                    e.useRuntimeCollisionCircles) {
                        const i = n.text.placedSymbolArray.get(e.centerJustifiedTextSymbolIndex >= 0 ? e.centerJustifiedTextSymbolIndex : e.verticalPlacedTextSymbolIndex)
                          , o = t.evaluateSizeForFeature(n.textSizeData, _, i)
                          , h = s.get("text-padding");
                        F = this.collisionIndex.placeCollisionCircles(n, y, i, n.lineVertexArray, n.glyphOffsetArray, o, a, l, c, r, w, m.predicate, e.collisionCircleDiameter * o / t.ONE_EM, h, this.retainedQueryData[n.bucketInstanceId].tileID),
                        I = y || F.circles.length > 0 && !F.collisionDetected,
                        P = P && F.offscreen,
                        D = F.occluded;
                    }
                    if (f.iconFeatureIndex && (G = f.iconFeatureIndex),
                    f.iconBox) {
                        const e = e => {
                            V(e);
                            const i = T && L ? nr(L.x, L.y, x, w, this.transform.angle) : new t.pointGeometry(0,0)
                              , r = n.getSymbolInstanceIconSize(p, this.transform.zoom, o);
                            return this.collisionIndex.placeCollisionBox(n, r, e, i, b, u, a, m.predicate)
                        }
                        ;
                        k && k.box && k.box.length && f.verticalIconBox ? (U = e(f.verticalIconBox),
                        z = U.box.length > 0) : (U = e(f.iconBox),
                        z = U.box.length > 0),
                        P = P && U.offscreen,
                        B = U.occluded;
                    }
                    const W = g || 0 === e.numHorizontalGlyphVertices && 0 === e.numVerticalGlyphVertices
                      , q = v || 0 === e.numIconVertices;
                    if (W || q ? q ? W || (z = z && I) : I = z && I : z = I = z && I,
                    I && O && O.box && this.collisionIndex.insertCollisionBox(O.box, s.get("text-ignore-placement"), n.bucketInstanceId, k && k.box && j ? j : N, m.ID),
                    z && U && this.collisionIndex.insertCollisionBox(U.box, s.get("icon-ignore-placement"), n.bucketInstanceId, G, m.ID),
                    F && (I && this.collisionIndex.insertCollisionCircles(F.circles, s.get("text-ignore-placement"), n.bucketInstanceId, N, m.ID),
                    r)) {
                        const t = n.bucketInstanceId;
                        let e = this.collisionCircleArrays[t];
                        void 0 === e && (e = this.collisionCircleArrays[t] = new er);
                        for (let t = 0; t < F.circles.length; t += 4)
                            e.circles.push(F.circles[t + 0]),
                            e.circles.push(F.circles[t + 1]),
                            e.circles.push(F.circles[t + 2]),
                            e.circles.push(F.collisionDetected ? 1 : 0);
                    }
                    const H = "globe" !== n.projection.name;
                    S = S && (H || !D),
                    C = C && (H || !B),
                    this.placements[e.crossTileID] = new tr(I || S,z || C,P || n.justReloaded),
                    i[e.crossTileID] = !0;
                }
                ;
                if (E) {
                    const t = n.getSortedSymbolIndexes(this.transform.angle);
                    for (let e = t.length - 1; e >= 0; --e) {
                        const i = t[e];
                        I(n.symbolInstances.get(i), i, n.collisionArrays[i]);
                    }
                } else
                    for (let t = e.symbolInstanceStart; t < e.symbolInstanceEnd; t++)
                        I(n.symbolInstances.get(t), t, n.collisionArrays[t]);
                if (r && n.bucketInstanceId in this.collisionCircleArrays) {
                    const e = this.collisionCircleArrays[n.bucketInstanceId];
                    t.invert(e.invProjMatrix, a),
                    e.viewportMatrix = this.collisionIndex.getViewportMatrix();
                }
                n.justReloaded = !1;
            }
            markUsedJustification(e, i, r, o) {
                let n;
                n = o === t.WritingMode.vertical ? r.verticalPlacedTextSymbolIndex : {
                    left: r.leftJustifiedTextSymbolIndex,
                    center: r.centerJustifiedTextSymbolIndex,
                    right: r.rightJustifiedTextSymbolIndex
                }[t.getAnchorJustification(i)];
                const s = [r.leftJustifiedTextSymbolIndex, r.centerJustifiedTextSymbolIndex, r.rightJustifiedTextSymbolIndex, r.verticalPlacedTextSymbolIndex];
                for (const t of s)
                    t >= 0 && (e.text.placedSymbolArray.get(t).crossTileID = n >= 0 && t !== n ? 0 : r.crossTileID);
            }
            markUsedOrientation(e, i, r) {
                const o = i === t.WritingMode.horizontal || i === t.WritingMode.horizontalOnly ? i : 0
                  , n = i === t.WritingMode.vertical ? i : 0
                  , s = [r.leftJustifiedTextSymbolIndex, r.centerJustifiedTextSymbolIndex, r.rightJustifiedTextSymbolIndex];
                for (const t of s)
                    e.text.placedSymbolArray.get(t).placedOrientation = o;
                r.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(r.verticalPlacedTextSymbolIndex).placedOrientation = n);
            }
            commit(t) {
                this.commitTime = t,
                this.zoomAtLastRecencyCheck = this.transform.zoom;
                const e = this.prevPlacement;
                let i = !1;
                this.prevZoomAdjustment = e ? e.zoomAdjustment(this.transform.zoom) : 0;
                const r = e ? e.symbolFadeChange(t) : 1
                  , o = e ? e.opacities : {}
                  , n = e ? e.variableOffsets : {}
                  , s = e ? e.placedOrientations : {};
                for (const t in this.placements) {
                    const e = this.placements[t]
                      , n = o[t];
                    n ? (this.opacities[t] = new Qi(n,r,e.text,e.icon,null,e.clipped),
                    i = i || e.text !== n.text.placed || e.icon !== n.icon.placed) : (this.opacities[t] = new Qi(null,r,e.text,e.icon,e.skipFade,e.clipped),
                    i = i || e.text || e.icon);
                }
                for (const t in o) {
                    const e = o[t];
                    if (!this.opacities[t]) {
                        const o = new Qi(e,r,!1,!1);
                        o.isHidden() || (this.opacities[t] = o,
                        i = i || e.text.placed || e.icon.placed);
                    }
                }
                for (const t in n)
                    this.variableOffsets[t] || !this.opacities[t] || this.opacities[t].isHidden() || (this.variableOffsets[t] = n[t]);
                for (const t in s)
                    this.placedOrientations[t] || !this.opacities[t] || this.opacities[t].isHidden() || (this.placedOrientations[t] = s[t]);
                i ? this.lastPlacementChangeTime = t : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = e ? e.lastPlacementChangeTime : t);
            }
            updateLayerOpacities(t, e) {
                const i = {};
                for (const r of e) {
                    const e = r.getBucket(t);
                    e && r.latestFeatureIndex && t.id === e.layerIds[0] && this.updateBucketOpacities(e, i, r.collisionBoxArray);
                }
            }
            updateBucketOpacities(e, i, r) {
                e.hasTextData() && e.text.opacityVertexArray.clear(),
                e.hasIconData() && e.icon.opacityVertexArray.clear(),
                e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(),
                e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
                const o = e.layers[0].layout
                  , n = !!e.layers[0].dynamicFilter()
                  , s = new Qi(null,0,!1,!1,!0)
                  , a = o.get("text-allow-overlap")
                  , l = o.get("icon-allow-overlap")
                  , c = o.get("text-variable-anchor")
                  , h = "map" === o.get("text-rotation-alignment")
                  , u = "map" === o.get("text-pitch-alignment")
                  , d = "none" !== o.get("icon-text-fit")
                  , f = new Qi(null,0,a && (l || !e.hasIconData() || o.get("icon-optional")),l && (a || !e.hasTextData() || o.get("text-optional")),!0);
                !e.collisionArrays && r && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(r);
                const _ = (t, e, i) => {
                    for (let r = 0; r < e / 4; r++)
                        t.opacityVertexArray.emplaceBack(i);
                }
                ;
                let p = 0;
                for (let r = 0; r < e.symbolInstances.length; r++) {
                    const o = e.symbolInstances.get(r)
                      , {numHorizontalGlyphVertices: a, numVerticalGlyphVertices: l, crossTileID: m} = o;
                    let g = this.opacities[m];
                    i[m] ? g = s : g || (g = f,
                    this.opacities[m] = g),
                    i[m] = !0;
                    const v = a > 0 || l > 0
                      , y = o.numIconVertices > 0
                      , b = this.placedOrientations[o.crossTileID]
                      , x = b === t.WritingMode.vertical
                      , w = b === t.WritingMode.horizontal || b === t.WritingMode.horizontalOnly;
                    if (!v && !y || g.isHidden() || p++,
                    v) {
                        const t = pr(g.text);
                        _(e.text, a, x ? mr : t),
                        _(e.text, l, w ? mr : t);
                        const i = g.text.isHidden();
                        [o.rightJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.leftJustifiedTextSymbolIndex].forEach((t => {
                            t >= 0 && (e.text.placedSymbolArray.get(t).hidden = i || x ? 1 : 0);
                        }
                        )),
                        o.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(o.verticalPlacedTextSymbolIndex).hidden = i || w ? 1 : 0);
                        const r = this.variableOffsets[o.crossTileID];
                        r && this.markUsedJustification(e, r.anchor, o, b);
                        const n = this.placedOrientations[o.crossTileID];
                        n && (this.markUsedJustification(e, "left", o, n),
                        this.markUsedOrientation(e, n, o));
                    }
                    if (y) {
                        const t = pr(g.icon);
                        o.placedIconSymbolIndex >= 0 && (_(e.icon, o.numIconVertices, x ? mr : t),
                        e.icon.placedSymbolArray.get(o.placedIconSymbolIndex).hidden = g.icon.isHidden()),
                        o.verticalPlacedIconSymbolIndex >= 0 && (_(e.icon, o.numVerticalIconVertices, w ? mr : t),
                        e.icon.placedSymbolArray.get(o.verticalPlacedIconSymbolIndex).hidden = g.icon.isHidden());
                    }
                    if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
                        const i = e.collisionArrays[r];
                        if (i) {
                            let r = new t.pointGeometry(0,0)
                              , o = !0;
                            if (i.textBox || i.verticalTextBox) {
                                if (c) {
                                    const t = this.variableOffsets[m];
                                    t ? (r = or(t.anchor, t.width, t.height, t.textOffset, t.textScale),
                                    h && r._rotate(u ? this.transform.angle : -this.transform.angle)) : o = !1;
                                }
                                n && (o = !g.clipped),
                                i.textBox && ar(e.textCollisionBox.collisionVertexArray, g.text.placed, !o || x, r.x, r.y),
                                i.verticalTextBox && ar(e.textCollisionBox.collisionVertexArray, g.text.placed, !o || w, r.x, r.y);
                            }
                            const s = o && Boolean(!w && i.verticalIconBox);
                            i.iconBox && ar(e.iconCollisionBox.collisionVertexArray, g.icon.placed, s, d ? r.x : 0, d ? r.y : 0),
                            i.verticalIconBox && ar(e.iconCollisionBox.collisionVertexArray, g.icon.placed, !s, d ? r.x : 0, d ? r.y : 0);
                        }
                    }
                }
                if (e.fullyClipped = 0 === p,
                e.sortFeatures(this.transform.angle),
                this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder),
                e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray),
                e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray),
                e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray),
                e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray),
                e.bucketInstanceId in this.collisionCircleArrays) {
                    const t = this.collisionCircleArrays[e.bucketInstanceId];
                    e.placementInvProjMatrix = t.invProjMatrix,
                    e.placementViewportMatrix = t.viewportMatrix,
                    e.collisionCircleArray = t.circles,
                    delete this.collisionCircleArrays[e.bucketInstanceId];
                }
            }
            symbolFadeChange(t) {
                return 0 === this.fadeDuration ? 1 : (t - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment
            }
            zoomAdjustment(t) {
                return Math.max(0, (this.transform.zoom - t) / 1.5)
            }
            hasTransitions(t) {
                return this.stale || t - this.lastPlacementChangeTime < this.fadeDuration
            }
            stillRecent(t, e) {
                const i = this.zoomAtLastRecencyCheck === e ? 1 - this.zoomAdjustment(e) : 1;
                return this.zoomAtLastRecencyCheck = e,
                this.commitTime + this.fadeDuration * i > t
            }
            setStale() {
                this.stale = !0;
            }
        }
        function ar(t, e, i, r, o) {
            t.emplaceBack(e ? 1 : 0, i ? 1 : 0, r || 0, o || 0),
            t.emplaceBack(e ? 1 : 0, i ? 1 : 0, r || 0, o || 0),
            t.emplaceBack(e ? 1 : 0, i ? 1 : 0, r || 0, o || 0),
            t.emplaceBack(e ? 1 : 0, i ? 1 : 0, r || 0, o || 0);
        }
        const lr = Math.pow(2, 25)
          , cr = Math.pow(2, 24)
          , hr = Math.pow(2, 17)
          , ur = Math.pow(2, 16)
          , dr = Math.pow(2, 9)
          , fr = Math.pow(2, 8)
          , _r = Math.pow(2, 1);
        function pr(t) {
            if (0 === t.opacity && !t.placed)
                return 0;
            if (1 === t.opacity && t.placed)
                return 4294967295;
            const e = t.placed ? 1 : 0
              , i = Math.floor(127 * t.opacity);
            return i * lr + e * cr + i * hr + e * ur + i * dr + e * fr + i * _r + e
        }
        const mr = 0;
        class gr {
            constructor(t) {
                this._sortAcrossTiles = "viewport-y" !== t.layout.get("symbol-z-order") && void 0 !== t.layout.get("symbol-sort-key").constantOr(1),
                this._currentTileIndex = 0,
                this._currentPartIndex = 0,
                this._seenCrossTileIDs = {},
                this._bucketParts = [];
            }
            continuePlacement(t, e, i, r, o) {
                const n = this._bucketParts;
                for (; this._currentTileIndex < t.length; )
                    if (e.getBucketParts(n, r, t[this._currentTileIndex], this._sortAcrossTiles),
                    this._currentTileIndex++,
                    o())
                        return !0;
                for (this._sortAcrossTiles && (this._sortAcrossTiles = !1,
                n.sort(( (t, e) => t.sortKey - e.sortKey))); this._currentPartIndex < n.length; ) {
                    const t = n[this._currentPartIndex];
                    if (e.placeLayerBucketPart(t, this._seenCrossTileIDs, i, 0 === t.symbolInstanceStart),
                    this._currentPartIndex++,
                    o())
                        return !0
                }
                return !1
            }
        }
        class vr {
            constructor(t, e, i, r, o, n, s, a) {
                this.placement = new sr(t,o,n,s,a),
                this._currentPlacementIndex = e.length - 1,
                this._forceFullPlacement = i,
                this._showCollisionBoxes = r,
                this._done = !1;
            }
            isDone() {
                return this._done
            }
            continuePlacement(e, i, r) {
                const o = t.exported.now()
                  , n = () => {
                    const e = t.exported.now() - o;
                    return !this._forceFullPlacement && e > 2
                }
                ;
                for (; this._currentPlacementIndex >= 0; ) {
                    const t = i[e[this._currentPlacementIndex]]
                      , o = this.placement.collisionIndex.transform.zoom;
                    if ("symbol" === t.type && (!t.minzoom || t.minzoom <= o) && (!t.maxzoom || t.maxzoom > o)) {
                        if (this._inProgressLayer || (this._inProgressLayer = new gr(t)),
                        !(r[t.source].length <= 0) && this._inProgressLayer.continuePlacement(r[t.source], this.placement, this._showCollisionBoxes, t, n))
                            return;
                        delete this._inProgressLayer;
                    }
                    this._currentPlacementIndex--;
                }
                this._done = !0;
            }
            commit(t) {
                return this.placement.commit(t),
                this.placement
            }
        }
        const yr = 512 / t.EXTENT / 2;
        class br {
            constructor(t, e, i) {
                this.tileID = t,
                this.indexedSymbolInstances = {},
                this.bucketInstanceId = i;
                for (let i = 0; i < e.length; i++) {
                    const r = e.get(i)
                      , o = r.key;
                    this.indexedSymbolInstances[o] || (this.indexedSymbolInstances[o] = []),
                    this.indexedSymbolInstances[o].push({
                        crossTileID: r.crossTileID,
                        coord: this.getScaledCoordinates(r, t)
                    });
                }
            }
            getScaledCoordinates(e, i) {
                const r = yr / Math.pow(2, i.canonical.z - this.tileID.canonical.z);
                return {
                    x: Math.floor((i.canonical.x * t.EXTENT + e.tileAnchorX) * r),
                    y: Math.floor((i.canonical.y * t.EXTENT + e.tileAnchorY) * r)
                }
            }
            findMatches(t, e, i) {
                const r = this.tileID.canonical.z < e.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e.canonical.z);
                for (let o = 0; o < t.length; o++) {
                    const n = t.get(o);
                    if (n.crossTileID)
                        continue;
                    const s = this.indexedSymbolInstances[n.key];
                    if (!s)
                        continue;
                    const a = this.getScaledCoordinates(n, e);
                    for (const t of s)
                        if (Math.abs(t.coord.x - a.x) <= r && Math.abs(t.coord.y - a.y) <= r && !i[t.crossTileID]) {
                            i[t.crossTileID] = !0,
                            n.crossTileID = t.crossTileID;
                            break
                        }
                }
            }
        }
        class xr {
            constructor() {
                this.maxCrossTileID = 0;
            }
            generate() {
                return ++this.maxCrossTileID
            }
        }
        class wr {
            constructor() {
                this.indexes = {},
                this.usedCrossTileIDs = {},
                this.lng = 0;
            }
            handleWrapJump(t) {
                const e = Math.round((t - this.lng) / 360);
                if (0 !== e)
                    for (const t in this.indexes) {
                        const i = this.indexes[t]
                          , r = {};
                        for (const t in i) {
                            const o = i[t];
                            o.tileID = o.tileID.unwrapTo(o.tileID.wrap + e),
                            r[o.tileID.key] = o;
                        }
                        this.indexes[t] = r;
                    }
                this.lng = t;
            }
            addBucket(t, e, i) {
                if (this.indexes[t.overscaledZ] && this.indexes[t.overscaledZ][t.key]) {
                    if (this.indexes[t.overscaledZ][t.key].bucketInstanceId === e.bucketInstanceId)
                        return !1;
                    this.removeBucketCrossTileIDs(t.overscaledZ, this.indexes[t.overscaledZ][t.key]);
                }
                for (let t = 0; t < e.symbolInstances.length; t++)
                    e.symbolInstances.get(t).crossTileID = 0;
                this.usedCrossTileIDs[t.overscaledZ] || (this.usedCrossTileIDs[t.overscaledZ] = {});
                const r = this.usedCrossTileIDs[t.overscaledZ];
                for (const i in this.indexes) {
                    const o = this.indexes[i];
                    if (Number(i) > t.overscaledZ)
                        for (const i in o) {
                            const n = o[i];
                            n.tileID.isChildOf(t) && n.findMatches(e.symbolInstances, t, r);
                        }
                    else {
                        const n = o[t.scaledTo(Number(i)).key];
                        n && n.findMatches(e.symbolInstances, t, r);
                    }
                }
                for (let t = 0; t < e.symbolInstances.length; t++) {
                    const o = e.symbolInstances.get(t);
                    o.crossTileID || (o.crossTileID = i.generate(),
                    r[o.crossTileID] = !0);
                }
                return void 0 === this.indexes[t.overscaledZ] && (this.indexes[t.overscaledZ] = {}),
                this.indexes[t.overscaledZ][t.key] = new br(t,e.symbolInstances,e.bucketInstanceId),
                !0
            }
            removeBucketCrossTileIDs(t, e) {
                for (const i in e.indexedSymbolInstances)
                    for (const r of e.indexedSymbolInstances[i])
                        delete this.usedCrossTileIDs[t][r.crossTileID];
            }
            removeStaleBuckets(t) {
                let e = !1;
                for (const i in this.indexes) {
                    const r = this.indexes[i];
                    for (const o in r)
                        t[r[o].bucketInstanceId] || (this.removeBucketCrossTileIDs(i, r[o]),
                        delete r[o],
                        e = !0);
                }
                return e
            }
        }
        class Tr {
            constructor() {
                this.layerIndexes = {},
                this.crossTileIDs = new xr,
                this.maxBucketInstanceId = 0,
                this.bucketsInCurrentPlacement = {};
            }
            addLayer(t, e, i, r) {
                let o = this.layerIndexes[t.id];
                void 0 === o && (o = this.layerIndexes[t.id] = new wr);
                let n = !1;
                const s = {};
                "globe" !== r.name && o.handleWrapJump(i);
                for (const i of e) {
                    const e = i.getBucket(t);
                    e && t.id === e.layerIds[0] && (e.bucketInstanceId || (e.bucketInstanceId = ++this.maxBucketInstanceId),
                    o.addBucket(i.tileID, e, this.crossTileIDs) && (n = !0),
                    s[e.bucketInstanceId] = !0);
                }
                return o.removeStaleBuckets(s) && (n = !0),
                n
            }
            pruneUnusedLayers(t) {
                const e = {};
                t.forEach((t => {
                    e[t] = !0;
                }
                ));
                for (const t in this.layerIndexes)
                    e[t] || delete this.layerIndexes[t];
            }
        }
        const Er = (e, i) => t.emitValidationErrors(e, i && i.filter((t => "source.canvas" !== t.identifier)))
          , Sr = t.pick(yi, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setProjection"])
          , Cr = t.pick(yi, ["setCenter", "setZoom", "setBearing", "setPitch"])
          , Ar = {
            version: 8,
            layers: [],
            sources: {}
        }
          , Mr = {
            fill: !0,
            line: !0,
            background: !0,
            hillshade: !0,
            raster: !0
        };
        class Ir extends t.Evented {
            constructor(e, i={}) {
                super(),
                this.map = e,
                this.dispatcher = new G(mi(),this),
                this.imageManager = new z,
                this.imageManager.setEventedParent(this),
                this.glyphManager = new t.GlyphManager(e._requestManager,i.localFontFamily ? t.LocalGlyphMode.all : i.localIdeographFontFamily ? t.LocalGlyphMode.ideographs : t.LocalGlyphMode.none,i.localFontFamily || i.localIdeographFontFamily),
                this.lineAtlas = new t.LineAtlas(256,512),
                this.crossTileSymbolIndex = new Tr,
                this._layers = {},
                this._num3DLayers = 0,
                this._numSymbolLayers = 0,
                this._numCircleLayers = 0,
                this._serializedLayers = {},
                this._sourceCaches = {},
                this._otherSourceCaches = {},
                this._symbolSourceCaches = {},
                this.zoomHistory = new t.ZoomHistory,
                this._loaded = !1,
                this._availableImages = [],
                this._order = [],
                this._drapedFirstOrder = [],
                this._markersNeedUpdate = !1,
                this._resetUpdates(),
                this.dispatcher.broadcast("setReferrer", t.getReferrer());
                const r = this;
                this._rtlTextPluginCallback = Ir.registerForPluginStateChange((e => {
                    r.dispatcher.broadcast("syncRTLPluginState", {
                        pluginStatus: e.pluginStatus,
                        pluginURL: e.pluginURL
                    }, ( (e, i) => {
                        if (t.triggerPluginCompletionEvent(e),
                        i && i.every((t => t)))
                            for (const t in r._sourceCaches) {
                                const e = r._sourceCaches[t]
                                  , i = e.getSource().type;
                                "vector" !== i && "geojson" !== i && "geobuf" !== i && "flatgeobuf" !== i || e.reload();
                            }
                    }
                    ));
                }
                )),
                this.on("data", (t => {
                    if ("source" !== t.dataType || "metadata" !== t.sourceDataType)
                        return;
                    const e = this.getSource(t.sourceId);
                    if (e && e.vectorLayerIds)
                        for (const t in this._layers) {
                            const i = this._layers[t];
                            i.source === e.id && this._validateLayer(i);
                        }
                }
                ));
            }
            loadURL(e, i={}) {
                this.fire(new t.Event("dataloading",{
                    dataType: "style"
                }));
                const r = "boolean" == typeof i.validate ? i.validate : !t.issgmapURL(e);
                e.indexOf(".sg") == e.length - 3 || (e = this.map._requestManager.normalizeStyleURL(e, i.accessToken));
                const o = this.map._requestManager.transformRequest(e, t.ResourceType.Style);
                this._request = e.indexOf(".sg") == e.length - 3 ? getArrayBuffer(o, ( (e, i, o, n) => {
                    if (this._request = null,
                    e)
                        this.fire(new t.ErrorEvent(e));
                    else if (i) {
                        var s = t.BufferTostyle(new t.pbf(i));
                        this._load(s, r, i);
                    }
                }
                )) : t.getJSON(o, ( (e, i) => {
                    this._request = null,
                    e ? this.fire(new t.ErrorEvent(e)) : i && this._load(i, r);
                }
                ));
            }
            loadJSON(e, i={}) {
                this.fire(new t.Event("dataloading",{
                    dataType: "style"
                })),
                this._request = t.exported.frame(( () => {
                    this._request = null,
                    this._load(e, !1 !== i.validate);
                }
                ));
            }
            loadEmpty() {
                this.fire(new t.Event("dataloading",{
                    dataType: "style"
                })),
                this._load(Ar, !1);
            }
            _updateLayerCount(t, e) {
                const i = e ? 1 : -1;
                t.is3D() && (this._num3DLayers += i),
                "circle" === t.type && (this._numCircleLayers += i),
                "symbol" === t.type && (this._numSymbolLayers += i);
            }
            _resetOldstyle(t) {
                return t ? t.map((t => (t.paint && (delete t.paint["line-pattern-mode"],
                delete t.paint["line-outline-pattern"]),
                t))) : []
            }
            _load(e, i, r) {
                e.layers = this._resetOldstyle(e.layers),
                this._loaded = !0,
                this.stylesheet = t.clone$1(e),
                this._updateMapProjection();
                for (const t in e.sources)
                    this.addSource(t, e.sources[t], {
                        validate: !1
                    });
                this._changed = !1,
                e.sprite ? this._loadSprite(e.sprite) : (this.imageManager.setLoaded(!0),
                this.dispatcher.broadcast("spriteLoaded", !0)),
                this.glyphManager.setURL(e.glyphs);
                const o = vi(this.stylesheet.layers);
                this._order = o.map((t => t.id)),
                this._layers = {},
                this._serializedLayers = {};
                for (let e of o)
                    e = t.createStyleLayer(e),
                    e.setEventedParent(this, {
                        layer: {
                            id: e.id
                        }
                    }),
                    this._layers[e.id] = e,
                    this._serializedLayers[e.id] = e.serialize(),
                    this._updateLayerCount(e, !0);
                r ? this.dispatcher.broadcast("setLayersbuffer", isIE11() ? [].slice.call(new Uint8Array(data)) : r.slice(0)) : (this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)),
                e.xml && this.dispatcher.broadcast("setXml", e.xml)),
                this.light = new B(this.stylesheet.light),
                this.stylesheet.terrain && !this.terrainSetForDrapingOnly() && this._createTerrain(this.stylesheet.terrain, 1),
                this.stylesheet.fog && this._createFog(this.stylesheet.fog),
                this._updateDrapeFirstLayers(),
                this.fire(new t.Event("data",{
                    dataType: "style"
                })),
                this.fire(new t.Event("style.load"));
            }
            terrainSetForDrapingOnly() {
                return !!this.terrain && 0 === this.terrain.drapeRenderMode
            }
            setProjection(t) {
                t ? this.stylesheet.projection = t : delete this.stylesheet.projection,
                this._updateMapProjection();
            }
            applyProjectionUpdate() {
                this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions),
                this.map.transform.projection.requiresDraping ? this.getTerrain() || this.stylesheet.terrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null));
            }
            _updateMapProjection() {
                this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.stylesheet.projection);
            }
            _loadSprite(e) {
                this._spriteRequest = M(e, this.map._requestManager, ( (e, i) => {
                    if (this._spriteRequest = null,
                    e)
                        this.fire(new t.ErrorEvent(e));
                    else if (i)
                        for (const t in i)
                            this.imageManager.addImage(t, i[t]);
                    this.imageManager.setLoaded(!0),
                    this._availableImages = this.imageManager.listImages(),
                    this.dispatcher.broadcast("setImages", this._availableImages),
                    this.dispatcher.broadcast("spriteLoaded", !0),
                    this.fire(new t.Event("data",{
                        dataType: "style"
                    }));
                }
                ));
            }
            _validateLayer(e) {
                const i = this.getSource(e.source);
                if (!i)
                    return;
                const r = e.sourceLayer;
                r && ("geojson" === i.type || "geobuf" === i.type || "flatgeobuf" === i.type || i.vectorLayerIds && -1 === i.vectorLayerIds.indexOf(r)) && this.fire(new t.ErrorEvent(new Error(`Source layer "${r}" does not exist on source "${i.id}" as specified by style layer "${e.id}"`)));
            }
            loaded() {
                if (!this._loaded)
                    return !1;
                if (Object.keys(this._updatedSources).length)
                    return !1;
                for (const t in this._sourceCaches)
                    if (!this._sourceCaches[t].loaded())
                        return !1;
                return !!this.imageManager.isLoaded()
            }
            _serializeLayers(t) {
                const e = [];
                for (const i of t) {
                    const t = this._layers[i];
                    "custom" !== t.type && e.push(t.serialize());
                }
                return e
            }
            hasTransitions() {
                if (this.light && this.light.hasTransition())
                    return !0;
                if (this.fog && this.fog.hasTransition())
                    return !0;
                for (const t in this._sourceCaches)
                    if (this._sourceCaches[t].hasTransition())
                        return !0;
                for (const t in this._layers)
                    if (this._layers[t].hasTransition())
                        return !0;
                return !1
            }
            get order() {
                return this.map._optimizeForTerrain && this.terrain ? this._drapedFirstOrder : this._order
            }
            isLayerDraped(t) {
                return !!this.terrain && Mr[t.type]
            }
            _checkLoaded() {
                if (!this._loaded)
                    throw new Error("Style is not done loading")
            }
            update(e) {
                if (!this._loaded)
                    return;
                const i = this._changed;
                if (this._changed) {
                    const t = Object.keys(this._updatedLayers)
                      , i = Object.keys(this._removedLayers);
                    (t.length || i.length) && this._updateWorkerLayers(t, i);
                    for (const t in this._updatedSources) {
                        const e = this._updatedSources[t];
                        "reload" === e ? this._reloadSource(t) : "clear" === e && this._clearSource(t);
                    }
                    this._updateTilesForChangedImages();
                    for (const t in this._updatedPaintProps)
                        this._layers[t].updateTransitions(e);
                    this.light.updateTransitions(e),
                    this.fog && this.fog.updateTransitions(e),
                    this._resetUpdates();
                }
                const r = {};
                for (const t in this._sourceCaches) {
                    const e = this._sourceCaches[t];
                    r[t] = e.used,
                    e.used = !1;
                }
                for (const t of this._order) {
                    const i = this._layers[t];
                    if (i.recalculate(e, this._availableImages),
                    !i.isHidden(e.zoom)) {
                        const t = this._getLayerSourceCache(i);
                        t && (t.used = !0);
                    }
                    const r = this.map.painter;
                    if (r) {
                        const t = i.getProgramIds();
                        if (!t)
                            continue;
                        const o = i.getProgramConfiguration(e.zoom);
                        for (const e of t)
                            r.useProgram(e, o);
                    }
                }
                for (const e in r) {
                    const i = this._sourceCaches[e];
                    r[e] !== i.used && i.getSource().fire(new t.Event("data",{
                        sourceDataType: "visibility",
                        dataType: "source",
                        sourceId: i.getSource().id
                    }));
                }
                this.light.recalculate(e),
                this.terrain && this.terrain.recalculate(e),
                this.fog && this.fog.recalculate(e),
                this.z = e.zoom,
                this._markersNeedUpdate && (this._updateMarkersOpacity(),
                this._markersNeedUpdate = !1),
                i && this.fire(new t.Event("data",{
                    dataType: "style"
                }));
            }
            _updateTilesForChangedImages() {
                const t = Object.keys(this._changedImages);
                if (t.length) {
                    for (const e in this._sourceCaches)
                        this._sourceCaches[e].reloadTilesForDependencies(["icons", "patterns"], t);
                    this._changedImages = {};
                }
            }
            _updateWorkerLayers(t, e) {
                this.dispatcher.broadcast("updateLayers", {
                    layers: this._serializeLayers(t),
                    removedIds: e
                });
            }
            _resetUpdates() {
                this._changed = !1,
                this._updatedLayers = {},
                this._removedLayers = {},
                this._updatedSources = {},
                this._updatedPaintProps = {},
                this._changedImages = {};
            }
            setState(e) {
                if (this._checkLoaded(),
                Er(this, t.validateStyle(e)))
                    return !1;
                (e = t.clone$1(e)).layers = vi(e.layers);
                const i = function(t, e) {
                    if (!t)
                        return [{
                            command: yi.setStyle,
                            args: [e]
                        }];
                    let i = [];
                    try {
                        if (!c(t.version, e.version))
                            return [{
                                command: yi.setStyle,
                                args: [e]
                            }];
                        c(t.center, e.center) || i.push({
                            command: yi.setCenter,
                            args: [e.center]
                        }),
                        c(t.zoom, e.zoom) || i.push({
                            command: yi.setZoom,
                            args: [e.zoom]
                        }),
                        c(t.bearing, e.bearing) || i.push({
                            command: yi.setBearing,
                            args: [e.bearing]
                        }),
                        c(t.pitch, e.pitch) || i.push({
                            command: yi.setPitch,
                            args: [e.pitch]
                        }),
                        c(t.sprite, e.sprite) || i.push({
                            command: yi.setSprite,
                            args: [e.sprite]
                        }),
                        c(t.glyphs, e.glyphs) || i.push({
                            command: yi.setGlyphs,
                            args: [e.glyphs]
                        }),
                        c(t.transition, e.transition) || i.push({
                            command: yi.setTransition,
                            args: [e.transition]
                        }),
                        c(t.light, e.light) || i.push({
                            command: yi.setLight,
                            args: [e.light]
                        }),
                        c(t.fog, e.fog) || i.push({
                            command: yi.setFog,
                            args: [e.fog]
                        }),
                        c(t.projection, e.projection) || i.push({
                            command: yi.setProjection,
                            args: [e.projection]
                        });
                        const r = {}
                          , o = [];
                        !function(t, e, i, r) {
                            let o;
                            for (o in e = e || {},
                            t = t || {})
                                t.hasOwnProperty(o) && (e.hasOwnProperty(o) || xi(o, i, r));
                            for (o in e)
                                e.hasOwnProperty(o) && (t.hasOwnProperty(o) ? c(t[o], e[o]) || ("geojson" === t[o].type && "geojson" === e[o].type && Ti(t, e, o) ? i.push({
                                    command: yi.setGeoJSONSourceData,
                                    args: [o, e[o].data]
                                }) : wi(o, e, i, r)) : bi(o, e, i));
                        }(t.sources, e.sources, o, r);
                        const n = [];
                        t.layers && t.layers.forEach((t => {
                            t.source && r[t.source] ? i.push({
                                command: yi.removeLayer,
                                args: [t.id]
                            }) : n.push(t);
                        }
                        ));
                        let s = t.terrain;
                        s && r[s.source] && (i.push({
                            command: yi.setTerrain,
                            args: [void 0]
                        }),
                        s = void 0),
                        i = i.concat(o),
                        c(s, e.terrain) || i.push({
                            command: yi.setTerrain,
                            args: [e.terrain]
                        }),
                        function(t, e, i) {
                            e = e || [];
                            const r = (t = t || []).map(Si)
                              , o = e.map(Si)
                              , n = t.reduce(Ci, {})
                              , s = e.reduce(Ci, {})
                              , a = r.slice()
                              , l = Object.create(null);
                            let h, u, d, f, _, p, m;
                            for (h = 0,
                            u = 0; h < r.length; h++)
                                d = r[h],
                                s.hasOwnProperty(d) ? u++ : (i.push({
                                    command: yi.removeLayer,
                                    args: [d]
                                }),
                                a.splice(a.indexOf(d, u), 1));
                            for (h = 0,
                            u = 0; h < o.length; h++)
                                d = o[o.length - 1 - h],
                                a[a.length - 1 - h] !== d && (n.hasOwnProperty(d) ? (i.push({
                                    command: yi.removeLayer,
                                    args: [d]
                                }),
                                a.splice(a.lastIndexOf(d, a.length - u), 1)) : u++,
                                p = a[a.length - h],
                                i.push({
                                    command: yi.addLayer,
                                    args: [s[d], p]
                                }),
                                a.splice(a.length - h, 0, d),
                                l[d] = !0);
                            for (h = 0; h < o.length; h++)
                                if (d = o[h],
                                f = n[d],
                                _ = s[d],
                                !l[d] && !c(f, _))
                                    if (c(f.source, _.source) && c(f["source-layer"], _["source-layer"]) && c(f.type, _.type)) {
                                        for (m in Ei(f.layout, _.layout, i, d, null, yi.setLayoutProperty),
                                        Ei(f.paint, _.paint, i, d, null, yi.setPaintProperty),
                                        c(f.filter, _.filter) || i.push({
                                            command: yi.setFilter,
                                            args: [d, _.filter]
                                        }),
                                        c(f.minzoom, _.minzoom) && c(f.maxzoom, _.maxzoom) || i.push({
                                            command: yi.setLayerZoomRange,
                                            args: [d, _.minzoom, _.maxzoom]
                                        }),
                                        f)
                                            f.hasOwnProperty(m) && "layout" !== m && "paint" !== m && "filter" !== m && "metadata" !== m && "minzoom" !== m && "maxzoom" !== m && (0 === m.indexOf("paint.") ? Ei(f[m], _[m], i, d, m.slice(6), yi.setPaintProperty) : c(f[m], _[m]) || i.push({
                                                command: yi.setLayerProperty,
                                                args: [d, m, _[m]]
                                            }));
                                        for (m in _)
                                            _.hasOwnProperty(m) && !f.hasOwnProperty(m) && "layout" !== m && "paint" !== m && "filter" !== m && "metadata" !== m && "minzoom" !== m && "maxzoom" !== m && (0 === m.indexOf("paint.") ? Ei(f[m], _[m], i, d, m.slice(6), yi.setPaintProperty) : c(f[m], _[m]) || i.push({
                                                command: yi.setLayerProperty,
                                                args: [d, m, _[m]]
                                            }));
                                    } else
                                        i.push({
                                            command: yi.removeLayer,
                                            args: [d]
                                        }),
                                        p = a[a.lastIndexOf(d) + 1],
                                        i.push({
                                            command: yi.addLayer,
                                            args: [_, p]
                                        });
                        }(n, e.layers, i);
                    } catch (t) {
                        console.warn("Unable to compute style diff:", t),
                        i = [{
                            command: yi.setStyle,
                            args: [e]
                        }];
                    }
                    return i
                }(this.serialize(), e).filter((t => !(t.command in Cr)));
                if (0 === i.length)
                    return !1;
                const r = i.filter((t => !(t.command in Sr)));
                if (r.length > 0)
                    throw new Error(`Unimplemented: ${r.map((t => t.command)).join(", ")}.`);
                return i.forEach((t => {
                    "setTransition" !== t.command && "setProjection" !== t.command && this[t.command].apply(this, t.args);
                }
                )),
                this.stylesheet = e,
                this._updateMapProjection(),
                !0
            }
            addImage(e, i) {
                return this.getImage(e) ? this.fire(new t.ErrorEvent(new Error("An image with this name already exists."))) : (this.imageManager.addImage(e, i),
                this._afterImageUpdated(e),
                this)
            }
            updateImage(t, e) {
                this.imageManager.updateImage(t, e);
            }
            getImage(t) {
                return this.imageManager.getImage(t)
            }
            removeImage(e) {
                return this.getImage(e) ? (this.imageManager.removeImage(e),
                this._afterImageUpdated(e),
                this) : this.fire(new t.ErrorEvent(new Error("No image with this name exists.")))
            }
            _afterImageUpdated(e) {
                this._availableImages = this.imageManager.listImages(),
                this._changedImages[e] = !0,
                this._changed = !0,
                this.dispatcher.broadcast("setImages", this._availableImages),
                this.fire(new t.Event("data",{
                    dataType: "style"
                }));
            }
            listImages() {
                return this._checkLoaded(),
                this._availableImages.slice()
            }
            addSource(e, i, r={}) {
                if (this._checkLoaded(),
                void 0 !== this.getSource(e))
                    throw new Error("There is already a source with this ID");
                if (!i.type)
                    throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(", ")}.`);
                if (["vector", "raster", "geojson", "video", "image"].indexOf(i.type) >= 0 && this._validate(t.validateSource, `sources.${e}`, i, null, r))
                    return;
                i.tiles && t.checkCustomTileSource(e, i, this.map),
                this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);
                const o = ai(e, i, this.dispatcher, this);
                o.setEventedParent(this, ( () => ({
                    isSourceLoaded: this._isSourceCacheLoaded(e),
                    source: o.serialize(),
                    sourceId: e
                })));
                const n = i => {
                    const r = (i ? "symbol:" : "other:") + e
                      , n = this._sourceCaches[r] = new t.SourceCache(r,o,i);
                    (i ? this._symbolSourceCaches : this._otherSourceCaches)[e] = n,
                    n.style = this,
                    n.onAdd(this.map);
                }
                ;
                n(!1),
                "vector" !== i.type && "geojson" !== i.type && "geobuf" !== i.type && "flatgeobuf" !== i.type || n(!0),
                o.onAdd && o.onAdd(this.map),
                this._changed = !0;
            }
            removeSource(e) {
                this._checkLoaded();
                const i = this.getSource(e);
                if (!i)
                    throw new Error("There is no source with this ID");
                for (const i in this._layers)
                    if (this._layers[i].source === e)
                        return this.fire(new t.ErrorEvent(new Error(`Source "${e}" cannot be removed while layer "${i}" is using it.`)));
                if (this.terrain && this.terrain.get().source === e)
                    return this.fire(new t.ErrorEvent(new Error(`Source "${e}" cannot be removed while terrain is using it.`)));
                const r = this._getSourceCaches(e);
                for (const e of r)
                    delete this._sourceCaches[e.id],
                    delete this._updatedSources[e.id],
                    e.fire(new t.Event("data",{
                        sourceDataType: "metadata",
                        dataType: "source",
                        sourceId: e.getSource().id
                    })),
                    e.setEventedParent(null),
                    e.clearTiles();
                return delete this._otherSourceCaches[e],
                delete this._symbolSourceCaches[e],
                i.setEventedParent(null),
                i.onRemove && i.onRemove(this.map),
                this._changed = !0,
                this
            }
            setGeoJSONSourceData(t, e) {
                this._checkLoaded(),
                this.getSource(t).setData(e),
                this._changed = !0;
            }
            getSource(t) {
                const e = this._getSourceCache(t);
                return e && e.getSource()
            }
            addLayer(e, i, r={}) {
                this._checkLoaded();
                const o = e.id;
                if (this.getLayer(o))
                    return void this.fire(new t.ErrorEvent(new Error(`Layer with id "${o}" already exists on this map`)));
                let n;
                if ("esymbol" === e.type || "eline" === e.type) {
                    if (!window.SGMap.pluginData && !this.arrowVertexArray)
                        return void this.fire(new t.ErrorEvent(new Error("请预先加载电网符号绘制插件")));
                    !this.arrowVertexArray && window.SGMap.pluginData && this.getArrowVertexArray();
                }
                if ("custom" === e.type) {
                    if (Er(this, t.validateCustomStyleLayer(e)))
                        return;
                    n = t.createStyleLayer(e);
                } else {
                    if ("object" == typeof e.source && (this.addSource(o, e.source),
                    e = t.clone$1(e),
                    e = t.extend(e, {
                        source: o
                    })),
                    this._validate(t.validateLayer, `layers.${o}`, e, {
                        arrayIndex: -1
                    }, r))
                        return;
                    n = t.createStyleLayer(e),
                    this._validateLayer(n),
                    n.setEventedParent(this, {
                        layer: {
                            id: o
                        }
                    }),
                    this._serializedLayers[n.id] = n.serialize(),
                    this._updateLayerCount(n, !0);
                }
                const s = i ? this._order.indexOf(i) : this._order.length;
                if (i && -1 === s)
                    return void this.fire(new t.ErrorEvent(new Error(`Layer with id "${i}" does not exist on this map.`)));
                this._order.splice(s, 0, o),
                this._layerOrderChanged = !0,
                this._layers[o] = n;
                const a = this._getLayerSourceCache(n);
                if (this._removedLayers[o] && n.source && a && "custom" !== n.type) {
                    const t = this._removedLayers[o];
                    delete this._removedLayers[o],
                    t.type !== n.type ? this._updatedSources[n.source] = "clear" : (this._updatedSources[n.source] = "reload",
                    a.pause());
                }
                this._updateLayer(n),
                n.onAdd && n.onAdd(this.map),
                this._updateDrapeFirstLayers();
            }
            moveLayer(e, i) {
                if (this._checkLoaded(),
                this._changed = !0,
                !this._layers[e])
                    return void this.fire(new t.ErrorEvent(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
                if (e === i)
                    return;
                if (i && -1 === this._order.indexOf(i))
                    return void this.fire(new t.ErrorEvent(new Error(`Layer with id "${i}" does not exist on this map.`)));
                const r = this._order.indexOf(e);
                this._order.splice(r, 1);
                const o = i ? this._order.indexOf(i) : this._order.length;
                i && -1 === o ? this.fire(new t.ErrorEvent(new Error(`Layer with id "${i}" does not exist on this map.`))) : (this._order.splice(o, 0, e),
                this._layerOrderChanged = !0,
                this._updateDrapeFirstLayers());
            }
            removeLayer(e) {
                this._checkLoaded();
                const i = this._layers[e];
                if (!i)
                    return void this.fire(new t.ErrorEvent(new Error(`The layer '${e}' does not exist in the map's style and cannot be removed.`)));
                i.setEventedParent(null),
                this._updateLayerCount(i, !1);
                const r = this._order.indexOf(e);
                this._order.splice(r, 1),
                this._layerOrderChanged = !0,
                this._changed = !0,
                this._removedLayers[e] = i,
                delete this._layers[e],
                delete this._serializedLayers[e],
                delete this._updatedLayers[e],
                delete this._updatedPaintProps[e],
                i.onRemove && i.onRemove(this.map),
                this._updateDrapeFirstLayers();
            }
            getLayer(t) {
                return this._layers[t]
            }
            hasLayer(t) {
                return t in this._layers
            }
            hasLayerType(t) {
                for (const e in this._layers)
                    if (this._layers[e].type === t)
                        return !0;
                return !1
            }
            setLayerZoomRange(e, i, r) {
                this._checkLoaded();
                const o = this.getLayer(e);
                o ? o.minzoom === i && o.maxzoom === r || (null != i && (o.minzoom = i),
                null != r && (o.maxzoom = r),
                this._updateLayer(o)) : this.fire(new t.ErrorEvent(new Error(`The layer '${e}' does not exist in the map's style and cannot have zoom extent.`)));
            }
            setFilter(e, i, r={}) {
                this._checkLoaded();
                const o = this.getLayer(e);
                if (o) {
                    if (!c(o.filter, i))
                        return null == i ? (o.filter = void 0,
                        void this._updateLayer(o)) : void (this._validate(t.validateFilter, `layers.${o.id}.filter`, i, {
                            layerType: o.type
                        }, r) || (o.filter = t.clone$1(i),
                        this._updateLayer(o)))
                } else
                    this.fire(new t.ErrorEvent(new Error(`The layer '${e}' does not exist in the map's style and cannot be filtered.`)));
            }
            getFilter(e) {
                const i = this.getLayer(e);
                return i && t.clone$1(i.filter)
            }
            setLayoutProperty(e, i, r, o={}) {
                this._checkLoaded();
                const n = this.getLayer(e);
                n ? c(n.getLayoutProperty(i), r) || (n.setLayoutProperty(i, r, o),
                this._updateLayer(n)) : this.fire(new t.ErrorEvent(new Error(`The layer '${e}' does not exist in the map's style and cannot be styled.`)));
            }
            getLayoutProperty(e, i) {
                const r = this.getLayer(e);
                if (r)
                    return r.getLayoutProperty(i);
                this.fire(new t.ErrorEvent(new Error(`The layer '${e}' does not exist in the map's style.`)));
            }
            setPaintProperty(e, i, r, o={}) {
                this._checkLoaded();
                const n = this.getLayer(e);
                n ? c(n.getPaintProperty(i), r) || (n.setPaintProperty(i, r, o) && this._updateLayer(n),
                this._changed = !0,
                this._updatedPaintProps[e] = !0) : this.fire(new t.ErrorEvent(new Error(`The layer '${e}' does not exist in the map's style and cannot be styled.`)));
            }
            getPaintProperty(t, e) {
                const i = this.getLayer(t);
                return i && i.getPaintProperty(e)
            }
            setFeatureState(e, i) {
                this._checkLoaded();
                const r = e.source
                  , o = e.sourceLayer
                  , n = this.getSource(r);
                if (!n)
                    return void this.fire(new t.ErrorEvent(new Error(`The source '${r}' does not exist in the map's style.`)));
                const s = n.type;
                if (("geojson" === s || "geobuf" === s || "flatgeobuf" === s) && o)
                    return void this.fire(new t.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
                if ("vector" === s && !o)
                    return void this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
                void 0 === e.id && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided.")));
                const a = this._getSourceCaches(r);
                for (const t of a)
                    t.setFeatureState(o, e.id, i);
            }
            removeFeatureState(e, i) {
                this._checkLoaded();
                const r = e.source
                  , o = this.getSource(r);
                if (!o)
                    return void this.fire(new t.ErrorEvent(new Error(`The source '${r}' does not exist in the map's style.`)));
                const n = o.type
                  , s = "vector" === n ? e.sourceLayer : void 0;
                if ("vector" === n && !s)
                    return void this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
                if (i && "string" != typeof e.id && "number" != typeof e.id)
                    return void this.fire(new t.ErrorEvent(new Error("A feature id is required to remove its specific state property.")));
                const a = this._getSourceCaches(r);
                for (const t of a)
                    t.removeFeatureState(s, e.id, i);
            }
            getFeatureState(e) {
                this._checkLoaded();
                const i = e.source
                  , r = e.sourceLayer
                  , o = this.getSource(i);
                if (o) {
                    if ("vector" !== o.type || r)
                        return void 0 === e.id && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))),
                        this._getSourceCaches(i)[0].getFeatureState(r, e.id);
                    this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
                } else
                    this.fire(new t.ErrorEvent(new Error(`The source '${i}' does not exist in the map's style.`)));
            }
            getTransition() {
                return t.extend({
                    duration: 300,
                    delay: 0
                }, this.stylesheet && this.stylesheet.transition)
            }
            serialize() {
                const e = {};
                for (const t in this._sourceCaches) {
                    const i = this._sourceCaches[t].getSource();
                    e[i.id] || (e[i.id] = i.serialize());
                }
                return t.filterObject({
                    version: this.stylesheet.version,
                    name: this.stylesheet.name,
                    metadata: this.stylesheet.metadata,
                    light: this.stylesheet.light,
                    terrain: this.getTerrain() || void 0,
                    fog: this.stylesheet.fog,
                    center: this.stylesheet.center,
                    zoom: this.stylesheet.zoom,
                    bearing: this.stylesheet.bearing,
                    pitch: this.stylesheet.pitch,
                    sprite: this.stylesheet.sprite,
                    glyphs: this.stylesheet.glyphs,
                    transition: this.stylesheet.transition,
                    projection: this.stylesheet.projection,
                    sources: e,
                    layers: this._serializeLayers(this._order),
                    xml: this.stylesheet.xml
                }, (t => void 0 !== t))
            }
            _updateLayer(t) {
                this._updatedLayers[t.id] = !0;
                const e = this._getLayerSourceCache(t);
                t.source && !this._updatedSources[t.source] && e && "raster" !== e.getSource().type && (this._updatedSources[t.source] = "reload",
                e.pause()),
                this._changed = !0,
                t.invalidateCompiledFilter();
            }
            _flattenAndSortRenderedFeatures(t) {
                const e = t => "fill-extrusion" === this._layers[t].type
                  , i = {}
                  , r = [];
                for (let o = this._order.length - 1; o >= 0; o--) {
                    const n = this._order[o];
                    if (e(n)) {
                        i[n] = o;
                        for (const e of t) {
                            const t = e[n];
                            if (t)
                                for (const e of t)
                                    r.push(e);
                        }
                    }
                }
                r.sort(( (t, e) => e.intersectionZ - t.intersectionZ));
                const o = [];
                for (let n = this._order.length - 1; n >= 0; n--) {
                    const s = this._order[n];
                    if (e(s))
                        for (let t = r.length - 1; t >= 0; t--) {
                            const e = r[t].feature;
                            if (i[e.layer.id] < n)
                                break;
                            o.push(e),
                            r.pop();
                        }
                    else
                        for (const e of t) {
                            const t = e[s];
                            if (t)
                                for (const e of t)
                                    o.push(e.feature);
                        }
                }
                return o
            }
            queryRenderedFeatures(e, i, r) {
                i && i.filter && this._validate(t.validateFilter, "queryRenderedFeatures.filter", i.filter, null, i);
                const o = {};
                if (i && i.layers) {
                    if (!Array.isArray(i.layers))
                        return this.fire(new t.ErrorEvent(new Error("parameters.layers must be an Array."))),
                        [];
                    for (const e of i.layers) {
                        const i = this._layers[e];
                        if (!i)
                            return this.fire(new t.ErrorEvent(new Error(`The layer '${e}' does not exist in the map's style and cannot be queried for features.`))),
                            [];
                        o[i.source] = !0;
                    }
                }
                const n = [];
                i.availableImages = this._availableImages;
                const s = i && i.layers ? i.layers.some((t => {
                    const e = this.getLayer(t);
                    return e && e.is3D()
                }
                )) : this.has3DLayers()
                  , a = Z.createFromScreenPoints(e, r);
                for (const t in this._sourceCaches) {
                    const e = this._sourceCaches[t].getSource().id;
                    i.layers && !o[e] || n.push(ci(this._sourceCaches[t], this._layers, this._serializedLayers, a, i, r, s, !!this.map._showQueryGeometry));
                }
                return this.placement && n.push(function(t, e, i, r, o, n, s) {
                    const a = {}
                      , l = n.queryRenderedSymbols(r)
                      , c = [];
                    for (const t of Object.keys(l).map(Number))
                        c.push(s[t]);
                    c.sort(ui);
                    for (const i of c) {
                        const r = i.featureIndex.lookupSymbolFeatures(l[i.bucketInstanceId], e, i.bucketIndex, i.sourceLayerIndex, o.filter, o.layers, o.availableImages, t);
                        for (const t in r) {
                            const e = a[t] = a[t] || []
                              , o = r[t];
                            o.sort(( (t, e) => {
                                const r = i.featureSortOrder;
                                if (r) {
                                    const i = r.indexOf(t.featureIndex);
                                    return r.indexOf(e.featureIndex) - i
                                }
                                return e.featureIndex - t.featureIndex
                            }
                            ));
                            for (const t of o)
                                e.push(t);
                        }
                    }
                    for (const e in a)
                        a[e].forEach((r => {
                            const o = r.feature
                              , n = i(t[e]).getFeatureState(o.layer["source-layer"], o.id);
                            o.source = o.layer.source,
                            o.layer["source-layer"] && (o.sourceLayer = o.layer["source-layer"]),
                            o.state = n;
                        }
                        ));
                    return a
                }(this._layers, this._serializedLayers, this._getLayerSourceCache.bind(this), a.screenGeometry, i, this.placement.collisionIndex, this.placement.retainedQueryData)),
                this._flattenAndSortRenderedFeatures(n)
            }
            querySourceFeatures(e, i) {
                i && i.filter && this._validate(t.validateFilter, "querySourceFeatures.filter", i.filter, null, i);
                const r = this._getSourceCaches(e);
                let o = [];
                for (const t of r)
                    o = o.concat(hi(t, i));
                return o
            }
            addSourceType(t, e, i) {
                return Ir.getSourceType(t) ? i(new Error(`A source type called "${t}" already exists.`)) : (Ir.setSourceType(t, e),
                e.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", {
                    name: t,
                    url: e.workerSourceURL
                }, i) : i(null, null))
            }
            getLight() {
                return this.light.getLight()
            }
            setLight(t, e={}) {
                this._checkLoaded();
                const i = this.light.getLight();
                let r = !1;
                for (const e in t)
                    if (!c(t[e], i[e])) {
                        r = !0;
                        break
                    }
                if (!r)
                    return;
                const o = this._setTransitionParameters({
                    duration: 300,
                    delay: 0
                });
                this.light.setLight(t, e),
                this.light.updateTransitions(o);
            }
            getTerrain() {
                return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null
            }
            setTerrainForDraping() {
                this.setTerrain({
                    source: "",
                    exaggeration: 0
                }, 0);
            }
            setTerrain(e, i=1) {
                if (this._checkLoaded(),
                !e)
                    return delete this.terrain,
                    delete this.stylesheet.terrain,
                    this.dispatcher.broadcast("enableTerrain", !1),
                    this._force3DLayerUpdate(),
                    void (this._markersNeedUpdate = !0);
                if (1 === i) {
                    if ("object" == typeof e.source) {
                        const i = "terrain-dem-src";
                        this.addSource(i, e.source),
                        e = t.clone$1(e),
                        e = t.extend(e, {
                            source: i
                        });
                    }
                    if (this._validate(t.validateTerrain, "terrain", e))
                        return
                }
                if (!this.terrain || this.terrain && i !== this.terrain.drapeRenderMode)
                    this._createTerrain(e, i);
                else {
                    const i = this.terrain
                      , r = i.get();
                    for (const i of Object.keys(t.spec.terrain))
                        !e.hasOwnProperty(i) && t.spec.terrain[i].default && (e[i] = t.spec.terrain[i].default);
                    for (const t in e)
                        if (!c(e[t], r[t])) {
                            i.set(e),
                            this.stylesheet.terrain = e;
                            const t = this._setTransitionParameters({
                                duration: 0
                            });
                            i.updateTransitions(t);
                            break
                        }
                }
                this._updateDrapeFirstLayers(),
                this._markersNeedUpdate = !0;
            }
            _createFog(t) {
                const e = this.fog = new j(t,this.map.transform);
                this.stylesheet.fog = t;
                const i = this._setTransitionParameters({
                    duration: 0
                });
                e.updateTransitions(i);
            }
            _updateMarkersOpacity() {
                0 !== this.map._markers.length && this.map._requestDomTask(( () => {
                    for (const t of this.map._markers)
                        t._evaluateOpacity();
                }
                ));
            }
            getFog() {
                return this.fog ? this.fog.get() : null
            }
            setFog(t) {
                if (this._checkLoaded(),
                !t)
                    return delete this.fog,
                    delete this.stylesheet.fog,
                    void (this._markersNeedUpdate = !0);
                if (this.fog) {
                    const e = this.fog
                      , i = e.get();
                    0 === Object.keys(t).length && e.set(t);
                    for (const r in t)
                        if (!c(t[r], i[r])) {
                            e.set(t),
                            this.stylesheet.fog = t;
                            const i = this._setTransitionParameters({
                                duration: 0
                            });
                            e.updateTransitions(i);
                            break
                        }
                } else
                    this._createFog(t);
                this._markersNeedUpdate = !0;
            }
            _setTransitionParameters(e) {
                return {
                    now: t.exported.now(),
                    transition: t.extend(e, this.stylesheet.transition)
                }
            }
            _updateDrapeFirstLayers() {
                if (!this.map._optimizeForTerrain || !this.terrain)
                    return;
                const t = this._order.filter((t => this.isLayerDraped(this._layers[t])))
                  , e = this._order.filter((t => !this.isLayerDraped(this._layers[t])));
                this._drapedFirstOrder = [],
                this._drapedFirstOrder.push(...t),
                this._drapedFirstOrder.push(...e);
            }
            _createTerrain(t, e) {
                const i = this.terrain = new k(t,e);
                this.stylesheet.terrain = t,
                this.dispatcher.broadcast("enableTerrain", !this.terrainSetForDrapingOnly()),
                this._force3DLayerUpdate();
                const r = this._setTransitionParameters({
                    duration: 0
                });
                i.updateTransitions(r);
            }
            _force3DLayerUpdate() {
                for (const t in this._layers) {
                    const e = this._layers[t];
                    "fill-extrusion" === e.type && this._updateLayer(e);
                }
            }
            _forceSymbolLayerUpdate() {
                for (const t in this._layers) {
                    const e = this._layers[t];
                    "symbol" === e.type && this._updateLayer(e);
                }
            }
            _validate(e, i, r, o, n={}) {
                return (!n || !1 !== n.validate) && Er(this, e.call(t.validateStyle, t.extend({
                    key: i,
                    style: this.serialize(),
                    value: r,
                    styleSpec: t.spec
                }, o)))
            }
            _remove() {
                this._request && (this._request.cancel(),
                this._request = null),
                this._spriteRequest && (this._spriteRequest.cancel(),
                this._spriteRequest = null),
                t.evented.off("pluginStateChange", this._rtlTextPluginCallback);
                for (const t in this._layers)
                    this._layers[t].setEventedParent(null);
                for (const t in this._sourceCaches)
                    this._sourceCaches[t].clearTiles(),
                    this._sourceCaches[t].setEventedParent(null);
                this.imageManager.setEventedParent(null),
                this.setEventedParent(null),
                this.dispatcher.remove();
            }
            _clearSource(t) {
                const e = this._getSourceCaches(t);
                for (const t of e)
                    t.clearTiles();
            }
            _reloadSource(t) {
                const e = this._getSourceCaches(t);
                for (const t of e)
                    t.resume(),
                    t.reload();
            }
            _updateSources(t) {
                for (const e in this._sourceCaches)
                    this._sourceCaches[e].update(t);
            }
            _generateCollisionBoxes() {
                for (const t in this._sourceCaches) {
                    const e = this._sourceCaches[t];
                    e.resume(),
                    e.reload();
                }
            }
            _updatePlacement(e, i, r, o, n=!1) {
                let s = !1
                  , a = !1;
                const l = {};
                for (const t of this._order) {
                    const i = this._layers[t];
                    if ("symbol" !== i.type)
                        continue;
                    if (!l[i.source]) {
                        const t = this._getLayerSourceCache(i);
                        if (!t)
                            continue;
                        l[i.source] = t.getRenderableIds(!0).map((e => t.getTileByID(e))).sort(( (t, e) => e.tileID.overscaledZ - t.tileID.overscaledZ || (t.tileID.isLessThan(e.tileID) ? -1 : 1)));
                    }
                    const r = this.crossTileSymbolIndex.addLayer(i, l[i.source], e.center.lng, e.projection);
                    s = s || r;
                }
                if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order),
                n = n || this._layerOrderChanged || 0 === r,
                this._layerOrderChanged && this.fire(new t.Event("neworder")),
                (n || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(t.exported.now(), e.zoom)) && (this.pauseablePlacement = new vr(e,this._order,n,i,r,o,this.placement,this.fog && e.projection.supportsFog ? this.fog.state : null),
                this._layerOrderChanged = !1),
                this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l),
                this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(t.exported.now()),
                a = !0),
                s && this.pauseablePlacement.placement.setStale()),
                a || s)
                    for (const t of this._order) {
                        const e = this._layers[t];
                        "symbol" === e.type && this.placement.updateLayerOpacities(e, l[e.source]);
                    }
                return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(t.exported.now())
            }
            _releaseSymbolFadeTiles() {
                for (const t in this._sourceCaches)
                    this._sourceCaches[t].releaseSymbolFadeTiles();
            }
            getImages(t, e, i) {
                this.imageManager.getImages(e.icons, i),
                this._updateTilesForChangedImages();
                const r = t => {
                    t && t.setDependencies(e.tileID.key, e.type, e.icons);
                }
                ;
                r(this._otherSourceCaches[e.source]),
                r(this._symbolSourceCaches[e.source]);
            }
            getGlyphs(t, e, i) {
                this.glyphManager.getGlyphs(e.stacks, i);
            }
            getResource(e, i, r) {
                return t.makeRequest(i, r)
            }
            _getSourceCache(t) {
                return this._otherSourceCaches[t]
            }
            _getLayerSourceCache(t) {
                return "symbol" === t.type ? this._symbolSourceCaches[t.source] : this._otherSourceCaches[t.source]
            }
            _getSourceCaches(t) {
                const e = [];
                return this._otherSourceCaches[t] && e.push(this._otherSourceCaches[t]),
                this._symbolSourceCaches[t] && e.push(this._symbolSourceCaches[t]),
                e
            }
            _isSourceCacheLoaded(e) {
                const i = this._getSourceCaches(e);
                return 0 === i.length ? (this.fire(new t.ErrorEvent(new Error(`There is no source with ID '${e}'`))),
                !1) : i.every((t => t.loaded()))
            }
            has3DLayers() {
                return this._num3DLayers > 0
            }
            hasSymbolLayers() {
                return this._numSymbolLayers > 0
            }
            hasCircleLayers() {
                return this._numCircleLayers > 0
            }
            _clearWorkerCaches() {
                this.dispatcher.broadcast("clearCaches");
            }
            destroy() {
                this._clearWorkerCaches(),
                this.terrainSetForDrapingOnly() && (delete this.terrain,
                delete this.stylesheet.terrain);
            }
            getArrowVertexArray() {
                this.arrowVertexArray = window.SGMap.pluginData.esymbolData;
                let t = window.SGMap.pluginData.elineData;
                for (var e in t) {
                    let i = t[e].width
                      , r = t[e].height
                      , o = new Uint8Array(t[e].data);
                    this.map.hasImage(e) || this.map.addImage(e, {
                        width: i,
                        height: r,
                        data: o
                    }, {
                        sdf: !0
                    });
                }
            }
            getEleSymbolVertexs(t, e, i) {
                var r = {};
                if (this.arrowVertexArray && 0 != this.arrowVertexArray.length) {
                    for (let t = 0; t < e.eleSymbolVertexs.length; t++) {
                        const i = e.eleSymbolVertexs[t]
                          , o = this.arrowVertexArray[0].indexOf(i);
                        o < 0 ? console.log("符号：" + i + "没有找到") : r[i] = [this.arrowVertexArray[o / 5 + 1], this.arrowVertexArray[0][o + 1], this.arrowVertexArray[0][o + 2], this.arrowVertexArray[0][o + 3], this.arrowVertexArray[0][o + 4]];
                    }
                    return i(null, r)
                }
            }
        }
        Ir.getSourceType = function(t) {
            return si[t]
        }
        ,
        Ir.setSourceType = function(t, e) {
            si[t] = e;
        }
        ,
        Ir.registerForPluginStateChange = t.registerForPluginStateChange;
        var zr = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#define EXTENT 8192.0\n#define HALF_PI PI/2.0\n#define QUARTER_PI PI/4.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0"
          , Pr = "attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}"
          , Dr = "\n#define ELEVATION_SCALE 7.0\r\n#define ELEVATION_OFFSET 450.0\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nuniform vec3 u_tile_tl_up;\r\nuniform vec3 u_tile_tr_up;\r\nuniform vec3 u_tile_br_up;\r\nuniform vec3 u_tile_bl_up;\r\nuniform float u_tile_up_scale;\r\nvec3 elevationVector(vec2 pos) {\r\nvec2 uv=pos/EXTENT;\r\nvec3 up=normalize(mix(\r\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));\r\nreturn up*u_tile_up_scale;\r\n}\r\n#else\r\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\r\n#endif\r\n#ifdef TERRAIN\r\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\r\nuniform highp sampler2D u_dem;\r\nuniform highp sampler2D u_dem_6;uniform highp sampler2D u_dem_prev;\r\n#else\r\nuniform sampler2D u_dem;\r\nuniform sampler2D u_dem_6;uniform sampler2D u_dem_prev;\r\n#endif\r\nuniform vec4 u_dem_unpack;\r\nuniform vec2 u_dem_tl;\r\nuniform vec2 u_dem_tl_prev;\r\nuniform float u_dem_scale;\r\nuniform float u_dem_scale_prev;\r\nuniform float u_dem_size;\r\nuniform float u_dem_lerp;\r\nuniform float u_exaggeration;\r\nuniform float u_meter_to_dem;\r\nuniform mat4 u_label_plane_matrix_inv;\r\nuniform sampler2D u_depth;\r\nuniform vec2 u_depth_size_inv;\r\nuniform vec2 u_dem_tile_radio;uniform float u_dem_scale_6;uniform vec2 u_dem_tl_6;vec4 tileUvToDemSample(vec2 pos,float dem_size) {\r\nvec2 f=fract(pos);\r\nreturn vec4((pos-f+0.5)/(dem_size+2.0),f);\r\n}\r\nfloat decodeElevation(vec4 v) {\r\nreturn dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);\r\n}vec4 getTexture(float flag,sampler2D dem,vec2 pos) {\r\nif(flag==0.0){\r\nreturn texture2D(dem,pos);\r\n}else{\r\nreturn texture2D(u_dem_6,pos);\r\n}\r\n}\r\nfloat currentElevation(vec2 apos) {vec2 tile_uv=apos/8192.0*u_dem_tile_radio*u_dem_scale+u_dem_tl;\r\nfloat textureNo=0.0;\r\nif(u_dem_tile_radio.y!=1.0){\r\ntextureNo=(tile_uv.y <=1.0 && tile_uv.y >=0.0 ) ? 0.0: 6.0;\r\nif( textureNo==6.0 ){\r\ntile_uv=apos/8192.0*u_dem_tile_radio*u_dem_scale_6+u_dem_tl_6;\r\n}\r\n}  \r\nvec2 uv_pos=u_dem_size*tile_uv+1.0;\r\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\r\nvec2 pos=(u_dem_size*tile_uv+1.5)/(u_dem_size+2.0);\r\nreturn u_exaggeration*getTexture(u_dem,pos).a;\r\n#else\r\nfloat dd=1.0/(u_dem_size+2.0);\r\nvec4 r=tileUvToDemSample(uv_pos,u_dem_size);\r\nvec2 pos=r.xy;\r\nvec2 f=r.zw;\r\nfloat tl=decodeElevation(getTexture(textureNo,u_dem,pos));\r\n#ifdef TERRAIN_DEM_NEAREST_FILTER\r\nreturn u_exaggeration*tl;\r\n#endif\r\nfloat tr=decodeElevation(getTexture(textureNo,u_dem,pos+vec2(dd,0.0)));\r\nfloat bl=decodeElevation(getTexture(textureNo,u_dem,pos+vec2(0.0,dd)));\r\nfloat br=decodeElevation(getTexture(textureNo,u_dem,pos+vec2(dd,dd)));\r\nreturn u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\r\n#endif\r\n}\r\nfloat prevElevation(vec2 apos) {\r\nvec2 tile_uv=apos/8192.0*u_dem_tile_radio*u_dem_scale_prev+u_dem_tl_prev;\r\nfloat textureNo=0.0;\r\nif(u_dem_tile_radio.y!=1.0){\r\ntextureNo=(tile_uv.y <=1.0 && tile_uv.y >=0.0)? 0.0: 6.0;\r\nif( textureNo==6.0 ){\r\ntile_uv=apos/8192.0*u_dem_tile_radio*u_dem_scale_6+u_dem_tl_6;\r\n}\r\n}  \r\nvec2 uv_pos=u_dem_size*tile_uv+1.0;\r\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\r\nvec2 pos=(u_dem_size*tile_uv+1.5)/(u_dem_size+2.0);\r\nreturn u_exaggeration*getTexture(textureNo,u_dem_prev,pos).a;\r\n#else\r\nfloat dd=1.0/(u_dem_size+2.0);\r\nvec4 r=tileUvToDemSample(uv_pos,u_dem_size);\r\nvec2 pos=r.xy;\r\nvec2 f=r.zw;\r\nfloat tl=decodeElevation(getTexture(textureNo,u_dem_prev,pos));\r\nfloat tr=decodeElevation(getTexture(textureNo,u_dem_prev,pos+vec2(dd,0.0)));\r\nfloat bl=decodeElevation(getTexture(textureNo,u_dem_prev,pos+vec2(0.0,dd)));\r\nfloat br=decodeElevation(getTexture(textureNo,u_dem_prev,pos+vec2(dd,dd)));\r\nreturn u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\r\n#endif\r\n}\r\n#ifdef TERRAIN_VERTEX_MORPHING\r\nfloat elevation(vec2 apos) {\r\nfloat nextElevation=currentElevation(apos);\r\nfloat prevElevation=prevElevation(apos);\r\nreturn mix(prevElevation,nextElevation,u_dem_lerp);\r\n}\r\n#else\r\nfloat elevation(vec2 apos) {\r\nreturn currentElevation(apos);\r\n}\r\n#endif\nhighp float unpack_depth(highp vec4 rgba_depth)\r\n{\r\nconst highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);\r\nreturn dot(rgba_depth,bit_shift)*2.0-1.0;\r\n}\r\nbool isOccluded(vec4 frag) {\r\nvec3 coord=frag.xyz/frag.w;\r\nfloat depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));\r\nreturn coord.z > depth+0.0005;\r\n}\r\nfloat occlusionFade(vec4 frag) {\r\nvec3 coord=frag.xyz/frag.w;\r\nvec3 df=vec3(5.0*u_depth_size_inv,0.0);\r\nvec2 uv=0.5*coord.xy+0.5;\r\nvec4 depth=vec4(\r\nunpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))\r\n);\r\nreturn dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));\r\n}vec4 fourSample(vec2 pos,vec2 off) {\r\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\r\nfloat tl=texture2D(u_dem,pos).a;\r\nfloat tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;\r\nfloat bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;\r\nfloat br=texture2D(u_dem,pos+off).a;\r\n#else\r\nvec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);\r\nfloat tl=dot(demtl,u_dem_unpack);\r\nvec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);\r\nfloat tr=dot(demtr,u_dem_unpack);\r\nvec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);\r\nfloat bl=dot(dembl,u_dem_unpack);\r\nvec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);\r\nfloat br=dot(dembr,u_dem_unpack);\r\n#endif\r\nreturn vec4(tl,tr,bl,br);\r\n}\r\nfloat flatElevation(vec2 pack) {\r\nvec2 apos=floor(pack/8.0);\r\nvec2 span=10.0*(pack-apos*8.0);\r\nvec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;\r\nfloat size=u_dem_size+2.0;\r\nfloat dd=1.0/size;\r\nvec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;\r\nvec2 f=fract(pos);\r\npos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));\r\nfloat z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);\r\nvec2 w=floor(0.5*(span*u_meter_to_dem-1.0));\r\nvec2 d=dd*w;\r\nvec4 bounds=vec4(d,vec2(1.0)-d);h=fourSample(pos-d,2.0*d+vec2(dd));\r\nvec4 diff=abs(h.xzxy-h.ywzw);\r\nvec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));\r\nvec2 fix=slope*span;\r\nfloat base=z+max(fix.x,fix.y);\r\nreturn u_exaggeration*base;\r\n}\r\nfloat elevationFromUint16(float word) {\r\nreturn u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);\r\n}\n#else\r\nfloat elevation(vec2 pos) { return 0.0; }\r\nbool isOccluded(vec4 frag) { return false; }\r\nfloat occlusionFade(vec4 frag) { return 1.0; }\r\n#endif"
          , Br = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif"
          , Lr = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump float u_fog_temporal_offset;varying vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec3 fog_dither(vec3 color) {vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif";
        function Rr(t, e, i) {
            if (!i)
                return t;
            var r = t.indexOf("#pragma sgmap: define")
              , o = (t = t.slice(0, r = r >= 0 ? r : 0) + "\n     #pragma sgmap: define lowp float minzoom\n     #pragma sgmap: define lowp float maxzoom\n     uniform lowp float u_featureZoom;\n    " + t.slice(r)).indexOf("#pragma sgmap: initialize");
            if (o < 0) {
                var n = "void main() {";
                o = t.indexOf(n) + n.length;
            }
            if (t = t.slice(0, o) + "\n     #pragma sgmap: initialize lowp float minzoom\n     #pragma sgmap: initialize lowp float maxzoom\n    " + t.slice(o),
            "fragment" == e) {
                var s = "#pragma sgmap: initialize lowp float opacity"
                  , a = t.indexOf(s);
                a < 0 && (a = t.indexOf(s = "#pragma sgmap: initialize lowp float maxzoom"));
                var l = "fill" == i ? "(maxzoom+1.0)" : "maxzoom";
                t = t.slice(0, a += s.length) + `\n        float feature_maxzoom = (maxzoom>=19.0)? 25.0: (maxzoom>minzoom?${l}:(minzoom+1.0));\n        float feature_minzoom = (minzoom<=3.0)? 0.0: (minzoom-1.0);\n        float zoom_opacity= 1.0;\n        #ifndef HAS_UNIFORM_u_opacity\n        if(u_featureZoom+0.005<feature_minzoom || u_featureZoom+0.005>feature_maxzoom){\n            zoom_opacity=0.0;\n        }else{\n            zoom_opacity=1.0;\n        }\n        #else\n        if(u_featureZoom+0.005<feature_minzoom || u_featureZoom+0.005>feature_maxzoom){\n            opacity=0.0;\n            zoom_opacity=0.0;\n        }else{\n            zoom_opacity=1.0;\n        }\n        #endif` + t.slice(a);
            }
            return t
        }
        let kr = {}
          , Or = {};
        const Fr = [];
        Vr(zr, Fr),
        Vr(Dr, Fr),
        Vr(Br, Fr),
        Vr(Lr, Fr),
        kr = Zr("", Dr),
        Or = Zr(Lr, Br);
        const Ur = Zr("\nhighp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}", "\nfloat wrap(float n,float min,float max) {\r\nfloat d=max-min;\r\nfloat w=mod(mod(n-min,d)+d,d)+min;\r\nreturn (w==min) ? max : w;\r\n}\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec4 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;\r\nvec2 mercator=vec2( (tile_anchor.x/EXTENT+tile_id.x)/tiles,(tile_anchor.y/EXTENT*tile_id.w+tile_id.y)/tiles);mercator-=mercator_center;\r\nmercator.x=wrap(mercator.x,-0.5,0.5);\r\nvec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);\r\nmercator_tile=matrix*mercator_tile;\r\nreturn mercator_tile.xyz;\r\n#else\r\nreturn vec3(0.0);\r\n#endif\r\n}\r\nvec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {\r\nreturn mix(globe,mercator,t);\r\n}\r\nmat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {\r\nvec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));\r\nvec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));\r\nvec3 yAxis=normalize(cross(normal,xAxis));\r\nreturn mat3(xAxis,yAxis,normal);\r\n}\r\n#endif\nvec2 unpack_float(const float packedValue) {\r\nint packedIntValue=int(packedValue);\r\nint v0=packedIntValue/256;\r\nreturn vec2(v0,packedIntValue-v0*256);\r\n}\r\nvec2 unpack_opacity(const float packedOpacity) {\r\nint intOpacity=int(packedOpacity)/2;\r\nreturn vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));\r\n}vec4 decode_color(const vec2 encodedColor) {\r\nreturn vec4(\r\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\r\n);\r\n}float unpack_mix_vec2(const vec2 packedValue,const float t) {\r\nreturn mix(packedValue[0],packedValue[1],t);\r\n}vec4 unpack_mix_color(const vec4 packedColors,const float t) {\r\nvec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));\r\nvec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));\r\nreturn mix(minColor,maxColor,t);\r\n}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {\r\nvec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);\r\nreturn (tile_units_to_pixels*pos+offset)/pattern_size;\r\n}\r\nconst vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered.")
          , Nr = zr
          , jr = "\n#ifdef GL_ES\nprecision mediump float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif";
        var Gr = {
            background: Zr("uniform vec4 u_color;uniform float u_opacity;void main() {vec4 out_color=u_color;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            backgroundPattern: Zr("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 out_color=mix(color1,color2,u_mix);\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            circle: Zr("varying vec3 v_data;varying float v_visibility;\n#pragma sgmap: define highp vec4 color\n#pragma sgmap: define mediump float radius\n#pragma sgmap: define lowp float blur\n#pragma sgmap: define lowp float opacity\n#pragma sgmap: define highp vec4 stroke_color\n#pragma sgmap: define mediump float stroke_width\n#pragma sgmap: define lowp float stroke_opacity\nvoid main() {\n#pragma sgmap: initialize highp vec4 color\n#pragma sgmap: initialize mediump float radius\n#pragma sgmap: initialize lowp float blur\n#pragma sgmap: initialize lowp float opacity\n#pragma sgmap: initialize highp vec4 stroke_color\n#pragma sgmap: initialize mediump float stroke_width\n#pragma sgmap: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\ngl_FragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec3 v_data;varying float v_visibility;\n#pragma sgmap: define highp vec4 color\n#pragma sgmap: define mediump float radius\n#pragma sgmap: define lowp float blur\n#pragma sgmap: define lowp float opacity\n#pragma sgmap: define highp vec4 stroke_color\n#pragma sgmap: define mediump float stroke_width\n#pragma sgmap: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma sgmap: initialize highp vec4 color\n#pragma sgmap: initialize mediump float radius\n#pragma sgmap: initialize lowp float blur\n#pragma sgmap: initialize lowp float opacity\n#pragma sgmap: initialize highp vec4 stroke_color\n#pragma sgmap: initialize mediump float stroke_width\n#pragma sgmap: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);vec4 world_center=vec4(pos,1);\n#else \nmat3 surface_vectors=mat3(1.0);float height=circle_elevation(circle_center);vec4 world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);vec4 occlusion_world_center=vec4(circle_center,cantilevered_height,1);vec4 occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nvec4 occlusion_world_center=world_center;vec4 occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}"),
            clippingMask: Zr("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),
            heatmap: Zr("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma sgmap: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma sgmap: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {gl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec2 v_extrude;\n#pragma sgmap: define highp float weight\n#pragma sgmap: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma sgmap: initialize highp float weight\n#pragma sgmap: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\nvec3 pos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
            heatmapTexture: Zr("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"),
            collisionBox: Zr("varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", "attribute vec3 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
            collisionCircle: Zr("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
            debug: Zr("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;\n#endif\nvarying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}"),
            fill: Zr("#pragma sgmap: define highp vec4 color\n#pragma sgmap: define lowp float opacity\nvoid main() {\n#pragma sgmap: initialize highp vec4 color\n#pragma sgmap: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma sgmap: define highp vec4 color\n#pragma sgmap: define lowp float opacity\nvoid main() {\n#pragma sgmap: initialize highp vec4 color\n#pragma sgmap: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            fillOutline: Zr("varying vec2 v_pos;\n#pragma sgmap: define highp vec4 outline_color\n#pragma sgmap: define lowp float opacity\nvoid main() {\n#pragma sgmap: initialize highp vec4 outline_color\n#pragma sgmap: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma sgmap: define highp vec4 outline_color\n#pragma sgmap: define lowp float opacity\nvoid main() {\n#pragma sgmap: initialize highp vec4 outline_color\n#pragma sgmap: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}", 0, "fillOutline"),
            fillOutlinePattern: Zr("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma sgmap: define lowp float opacity\n#pragma sgmap: define lowp vec4 pattern_from\n#pragma sgmap: define lowp vec4 pattern_to\nvoid main() {\n#pragma sgmap: initialize lowp float opacity\n#pragma sgmap: initialize mediump vec4 pattern_from\n#pragma sgmap: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=mix(color1,color2,u_fade);\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma sgmap: define lowp float opacity\n#pragma sgmap: define lowp vec4 pattern_from\n#pragma sgmap: define lowp vec4 pattern_to\n#pragma sgmap: define lowp float pixel_ratio_from\n#pragma sgmap: define lowp float pixel_ratio_to\nvoid main() {\n#pragma sgmap: initialize lowp float opacity\n#pragma sgmap: initialize mediump vec4 pattern_from\n#pragma sgmap: initialize mediump vec4 pattern_to\n#pragma sgmap: initialize lowp float pixel_ratio_from\n#pragma sgmap: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}", 0, "fillOutlinePattern"),
            fillPattern: Zr("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma sgmap: define lowp float opacity\n#pragma sgmap: define lowp vec4 pattern_from\n#pragma sgmap: define lowp vec4 pattern_to\nvoid main() {\n#pragma sgmap: initialize lowp float opacity\n#pragma sgmap: initialize mediump vec4 pattern_from\n#pragma sgmap: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 out_color=mix(color1,color2,u_fade);\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma sgmap: define lowp float opacity\n#pragma sgmap: define lowp vec4 pattern_from\n#pragma sgmap: define lowp vec4 pattern_to\n#pragma sgmap: define lowp float pixel_ratio_from\n#pragma sgmap: define lowp float pixel_ratio_to\nvoid main() {\n#pragma sgmap: initialize lowp float opacity\n#pragma sgmap: initialize mediump vec4 pattern_from\n#pragma sgmap: initialize mediump vec4 pattern_to\n#pragma sgmap: initialize lowp float pixel_ratio_from\n#pragma sgmap: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}", 0, "fillPattern"),
            fillExtrusion: Zr("uniform lowp vec3 u_lightpos;\r\nvarying vec4 v_color;\r\n#ifdef RENDER_SHADOWS\r\nvarying highp vec4 v_pos_light_view_0;\r\nvarying highp vec4 v_pos_light_view_1;\r\nvarying float v_depth;\r\nvarying highp vec3 v_normal;\r\n#endif\r\n#ifdef FAUX_AO\r\nuniform lowp vec2 u_ao;\r\nvarying vec3 v_ao;\r\n#endif\r\nvoid main() {\r\nvec4 color=v_color;\r\ncolor=color*zoom_opacity;\n#ifdef FAUX_AO\r\nfloat intensity=u_ao[0];\r\nfloat h=max(0.0,v_ao.z);\r\nfloat h_floors=h/u_ao[1];\r\nfloat y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);\r\nfloat shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\r\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);\r\nshade*=mix(1.0,x_shade*x_shade*x_shade,concave);\r\ncolor.rgb=color.rgb*shade;\r\n#endif\r\n#ifdef RENDER_SHADOWS\r\ncolor.xyz=shadowed_color_normal(color.xyz,normalize(v_normal),v_pos_light_view_0,v_pos_light_view_1,v_depth);\r\n#endif\r\n#ifdef FOG\r\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\r\n#endif\r\ngl_FragColor=color;\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", "uniform mat4 u_matrix;\r\nuniform vec3 u_lightcolor;\r\nuniform lowp vec3 u_lightpos;\r\nuniform lowp float u_lightintensity;\r\nuniform float u_vertical_gradient;\r\nuniform lowp float u_opacity;\r\nuniform float u_edge_radius;\r\nattribute vec4 a_pos_normal_ed;\r\nattribute vec2 a_centroid_pos;\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;\r\nuniform vec2 u_merc_center;\r\nuniform vec3 u_tile_id;\r\nuniform float u_zoom_transition;\r\nuniform vec3 u_up_dir;\r\nuniform float u_height_lift;\r\n#endif\r\nvarying vec4 v_color;\r\n#ifdef RENDER_SHADOWS\r\nuniform mat4 u_light_matrix_0;\r\nuniform mat4 u_light_matrix_1;\r\nvarying highp vec4 v_pos_light_view_0;\r\nvarying highp vec4 v_pos_light_view_1;\r\nvarying highp vec3 v_normal;\r\nvarying float v_depth;\r\n#endif\r\n#ifdef FAUX_AO\r\nuniform lowp vec2 u_ao;\r\nvarying vec3 v_ao;\r\n#endif\r\n#pragma sgmap: define highp float base\r\n#pragma sgmap: define highp float height\r\n#pragma sgmap: define highp vec4 color\r\n#pragma sgmap: define highp vec4 topcolor\r\nvoid main() {\r\n#pragma sgmap: initialize highp float base\r\n#pragma sgmap: initialize highp float height\r\n#pragma sgmap: initialize highp vec4 color\r\n#pragma sgmap: initialize highp vec4 topcolor\r\nvec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;\r\nvec3 top_up_ny=top_up_ny_start.xyz;\r\nfloat x_normal=pos_nx.z/8192.0;\r\nvec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\r\nbase=max(0.0,base);\r\nheight=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);\r\nfloat t=top_up_ny.x;\r\nvec2 centroid_pos=vec2(0.0);\r\n#if defined(HAS_CENTROID) || defined(TERRAIN)\r\ncentroid_pos=a_centroid_pos;\r\n#endif\r\nfloat ele=0.0;\r\nfloat h=0.0;\r\n#ifdef TERRAIN\r\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;\r\nele=elevation(pos_nx.xy);\r\nfloat c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);\r\nvec3 pos=vec3(pos_nx.xy,h);\r\n#else\r\nh=t > 0.0 ? height : base;\r\nvec3 pos=vec3(pos_nx.xy,h);\r\n#endif\r\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;\r\nh+=lift;\r\nvec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));\r\nvec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);\r\nvec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;\r\npos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\r\n#endif\r\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);\r\ngl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);\r\n#ifdef RENDER_SHADOWS\r\nv_pos_light_view_0=u_light_matrix_0*vec4(pos,1);\r\nv_pos_light_view_1=u_light_matrix_1*vec4(pos,1);\r\nv_normal=normal;\r\nv_depth=gl_Position.w;\r\n#endif\nfloat colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;\r\nv_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);float directional=clamp(dot(normal,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=(\r\n(1.0-u_vertical_gradient)+\n(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));\r\n}\r\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;\r\nfloat start=top_up_ny_start.w;\r\nfloat y_ground=1.0-clamp(t+base,0.0,1.0);\r\nfloat top_height=height;\r\n#ifdef TERRAIN\r\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;\r\ny_ground+=y_ground*5.0/max(3.0,top_height);\r\n#endif\r\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);\r\ndirectional*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\r\ntop_height+=u_height_lift;\r\n#endif\r\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\r\n#endif\nfloat ambientStrength=u_lightintensity+0.39;\r\nvec3 ambient=ambientStrength*u_lightcolor;\r\nfloat lightStrength=0.1;\r\nfloat nDotL=max(dot(normal,u_lightpos),0.0);\r\nvec3 diff=lightStrength*u_lightcolor*nDotL;\r\nv_color=t > 0.0 ? (topcolor.a==0.0?color: topcolor): color ;\r\nv_color.rgb*=diff+ambient;\r\nv_color*=u_opacity;\r\n#ifdef FOG\r\nv_fog_pos=fog_position(pos);\r\n#endif\r\n}", 0, "fillExtrusion"),
            fillExtrusionPattern: Zr("uniform vec2 u_texsize;\r\nuniform float u_fade;\r\nuniform sampler2D u_image;\r\n#ifdef FAUX_AO\r\nuniform lowp vec2 u_ao;\r\nvarying vec3 v_ao;\r\n#endif\r\nvarying vec2 v_pos_a;\r\nvarying vec2 v_pos_b;\r\nvarying vec4 v_lighting;\r\nvarying float flag_top;\n#pragma sgmap: define lowp float base\r\n#pragma sgmap: define lowp float height\r\n#pragma sgmap: define lowp vec4 pattern_from\r\n#pragma sgmap: define lowp vec4 pattern_to\r\n#pragma sgmap: define lowp float pixel_ratio_from\r\n#pragma sgmap: define lowp float pixel_ratio_to\r\n#pragma sgmap: define highp vec4 color\r\n#pragma sgmap: define highp vec4 topcolor\r\nvoid main() {\r\n#pragma sgmap: initialize lowp float base\r\n#pragma sgmap: initialize lowp float height\r\n#pragma sgmap: initialize mediump vec4 pattern_from\r\n#pragma sgmap: initialize mediump vec4 pattern_to\r\n#pragma sgmap: initialize lowp float pixel_ratio_from\r\n#pragma sgmap: initialize lowp float pixel_ratio_to\r\n#pragma sgmap: initialize highp vec4 color\r\n#pragma sgmap: initialize highp vec4 topcolor\r\nvec2 pattern_tl_a=pattern_from.xy;\r\nvec2 pattern_br_a=pattern_from.zw;\r\nvec2 pattern_tl_b=pattern_to.xy;\r\nvec2 pattern_br_b=pattern_to.zw;\r\nvec2 imagecoord=mod(v_pos_a,1.0);\r\nvec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);\r\nvec4 color1=texture2D(u_image,pos);\r\nvec2 imagecoord_b=mod(v_pos_b,1.0);\r\nvec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);\r\nvec4 color2=texture2D(u_image,pos2);\r\nvec4 out_color=mix(color1,color2,u_fade);vec4 buildTopColor=v_lighting;\r\nif(topcolor.a!=0.0){\r\nbuildTopColor= topcolor*buildTopColor;}\r\nout_color=flag_top+0.005>=1.0? buildTopColor : (out_color*v_lighting);\n#ifdef FAUX_AO\r\nfloat intensity=u_ao[0];\r\nfloat h=max(0.0,v_ao.z);\r\nfloat h_floors=h/u_ao[1];\r\nfloat y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);\r\nfloat shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\r\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);\r\nshade*=mix(1.0,x_shade*x_shade*x_shade,concave);\r\nout_color.rgb=out_color.rgb*shade;\r\n#endif\r\n#ifdef FOG\r\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\r\n#endif\r\ngl_FragColor=out_color;\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", "uniform mat4 u_matrix;\r\nuniform vec2 u_pixel_coord_upper;\r\nuniform vec2 u_pixel_coord_lower;\r\nuniform float u_height_factor;\r\nuniform vec3 u_scale;\r\nuniform float u_vertical_gradient;\r\nuniform lowp float u_opacity;\r\nuniform vec3 u_lightcolor;\r\nuniform lowp vec3 u_lightpos;\r\nuniform lowp float u_lightintensity;\r\nattribute vec4 a_pos_normal_ed;\r\nattribute vec2 a_centroid_pos;\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;\r\nuniform vec2 u_merc_center;\r\nuniform vec3 u_tile_id;\r\nuniform float u_zoom_transition;\r\nuniform vec3 u_up_dir;\r\nuniform float u_height_lift;\r\n#endif\r\nvarying vec2 v_pos_a;\r\nvarying vec2 v_pos_b;\r\nvarying vec4 v_lighting;\r\nvarying float flag_top;\n#ifdef FAUX_AO\r\nuniform lowp vec2 u_ao;\r\nvarying vec3 v_ao;\r\n#endif\r\n#pragma sgmap: define lowp float base\r\n#pragma sgmap: define lowp float height\r\n#pragma sgmap: define lowp vec4 pattern_from\r\n#pragma sgmap: define lowp vec4 pattern_to\r\n#pragma sgmap: define lowp float pixel_ratio_from\r\n#pragma sgmap: define lowp float pixel_ratio_to\r\n#pragma sgmap: define highp vec4 color\r\n#pragma sgmap: define highp vec4 topcolor\r\nvoid main() {\r\n#pragma sgmap: initialize lowp float base\r\n#pragma sgmap: initialize lowp float height\r\n#pragma sgmap: initialize mediump vec4 pattern_from\r\n#pragma sgmap: initialize mediump vec4 pattern_to\r\n#pragma sgmap: initialize lowp float pixel_ratio_from\r\n#pragma sgmap: initialize lowp float pixel_ratio_to\r\n#pragma sgmap: initialize highp vec4 color\r\n#pragma sgmap: initialize highp vec4 topcolor\nvec2 pattern_tl_a=pattern_from.xy;\r\nvec2 pattern_br_a=pattern_from.zw;\r\nvec2 pattern_tl_b=pattern_to.xy;\r\nvec2 pattern_br_b=pattern_to.zw;\r\nfloat tileRatio=u_scale.x;\r\nfloat fromScale=u_scale.y;\r\nfloat toScale=u_scale.z;\r\nvec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;\r\nmediump vec3 top_up_ny=top_up_ny_start.xyz;\r\nfloat x_normal=pos_nx.z/8192.0;\r\nvec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\r\nfloat edgedistance=a_pos_normal_ed.w;\r\nvec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;\r\nvec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\r\nbase=max(0.0,base);\r\nheight=max(0.0,height);\r\nfloat t=top_up_ny.x;\r\nfloat z=t > 0.0 ? height : base;\r\nvec2 centroid_pos=vec2(0.0);\r\n#if defined(HAS_CENTROID) || defined(TERRAIN)\r\ncentroid_pos=a_centroid_pos;\r\n#endif\r\nfloat ele=0.0;\r\nfloat h=z;\r\n#ifdef TERRAIN\r\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;\r\nele=elevation(pos_nx.xy);\r\nfloat c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);\r\nvec3 p=vec3(pos_nx.xy,h);\r\n#else\r\nvec3 p=vec3(pos_nx.xy,z);\r\n#endif\r\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;\r\nh+=lift;\r\nvec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));\r\nvec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));\r\nvec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;\r\np=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\r\n#endif\r\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);\r\ngl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);\r\nflag_top=normal.z==1.0 ?1.0 :0.0;vec2 pos=normal.z==1.0\r\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos_a=tileRatio*pos/display_size_a;\r\nv_pos_b=tileRatio*pos/display_size_b;\r\nv_lighting=vec4(0.0,0.0,0.0,1.0);\r\nfloat directional=clamp(dot(normal,u_lightpos),0.0,1.0);\r\ndirectional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);\r\nif (normal.y !=0.0) {directional*=(\r\n(1.0-u_vertical_gradient)+\n(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));\r\n}\r\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;\r\nfloat start=top_up_ny_start.w;\r\nfloat y_ground=1.0-clamp(t+base,0.0,1.0);\r\nfloat top_height=height;\r\n#ifdef TERRAIN\r\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;\r\ny_ground+=y_ground*5.0/max(3.0,top_height);\r\n#endif\r\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);\r\ndirectional*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\r\ntop_height+=u_height_lift;\r\n#endif\r\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\r\n#endif\nvec3 ambientLightColor=u_lightcolor;\r\nfloat ambientStrength=u_lightintensity+0.39;\r\nvec3 ambient=ambientStrength*ambientLightColor;vec3 lightDir=u_lightpos;\r\nvec3 lightColor=u_lightcolor;\r\nfloat lightStrength=0.1;\r\nfloat nDotL=max(dot(normal/16384.0,lightDir),0.0);\r\nvec3 diff=lightStrength*lightColor*nDotL;\r\nv_lighting.rgb+=diff+ambient;\r\nv_lighting*=u_opacity;\r\n#ifdef FOG\r\nv_fog_pos=fog_position(p);\r\n#endif\r\n}", 0, "fillExtrusionPattern"),
            hillshadePrepare: Zr("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nreturn texture2D(u_image,coord).a/4.0;\n#else\nvec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;\n#endif\n}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos);float f=getElevation(v_pos+vec2(epsilon.x,0));float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float h=getElevation(v_pos+vec2(0,epsilon.y));float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
            hillshade: Zr("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef FOG\ngl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            line: Zr("uniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;uniform float u_mix;uniform vec3 u_scale;varying vec2 v_tex_a;varying vec2 v_tex_b;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\n#pragma sgmap: define highp vec4 color\n#pragma sgmap: define lowp float floorwidth\n#pragma sgmap: define lowp vec4 dash_from\n#pragma sgmap: define lowp vec4 dash_to\n#pragma sgmap: define lowp float blur\n#pragma sgmap: define lowp float opacity\nvoid main() {\n#pragma sgmap: initialize highp vec4 color\n#pragma sgmap: initialize lowp float floorwidth\n#pragma sgmap: initialize lowp vec4 dash_from\n#pragma sgmap: initialize lowp vec4 dash_to\n#pragma sgmap: initialize lowp float blur\n#pragma sgmap: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist_a=texture2D(u_dash_image,v_tex_a).a;float sdfdist_b=texture2D(u_dash_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfwidth=min(dash_from.z*u_scale.y,dash_to.z*u_scale.z);float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/sdfwidth;alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\n#ifdef RENDER_LINE_GRADIENT\nhighp vec4 out_color=texture2D(u_gradient_image,v_uv.xy);\n#else\nvec4 out_color=color;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);}}\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef RENDER_LINE_ALPHA_DISCARD\nif (alpha < u_alpha_discard_threshold) {discard;}\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define EXTRUDE_SCALE 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nattribute highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nattribute float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform mediump vec3 u_scale;varying vec2 v_tex_a;varying vec2 v_tex_b;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#pragma sgmap: define highp vec4 color\n#pragma sgmap: define lowp float floorwidth\n#pragma sgmap: define lowp vec4 dash_from\n#pragma sgmap: define lowp vec4 dash_to\n#pragma sgmap: define lowp float blur\n#pragma sgmap: define lowp float opacity\n#pragma sgmap: define mediump float gapwidth\n#pragma sgmap: define lowp float offset\n#pragma sgmap: define mediump float width\nvoid main() {\n#pragma sgmap: initialize highp vec4 color\n#pragma sgmap: initialize lowp float floorwidth\n#pragma sgmap: initialize lowp vec4 dash_from\n#pragma sgmap: initialize lowp vec4 dash_to\n#pragma sgmap: initialize lowp float blur\n#pragma sgmap: initialize lowp float opacity\n#pragma sgmap: initialize mediump float gapwidth\n#pragma sgmap: initialize lowp float offset\n#pragma sgmap: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;float scaleA=dash_from.z==0.0 ? 0.0 : tileZoomRatio/(dash_from.z*fromScale);float scaleB=dash_to.z==0.0 ? 0.0 : tileZoomRatio/(dash_to.z*toScale);float heightA=dash_from.y;float heightB=dash_to.y;v_tex_a=vec2(a_linesofar*scaleA/floorwidth,(-normal.y*heightA+dash_from.x+0.5)/u_texsize.y);v_tex_b=vec2(a_linesofar*scaleB/floorwidth,(-normal.y*heightB+dash_to.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
            linePattern: Zr("uniform lowp float u_device_pixel_ratio;\r\nuniform vec2 u_texsize;\r\nuniform float u_fade;\r\nuniform mediump vec3 u_scale;\r\nuniform sampler2D u_image;\r\nuniform float u_use_color;uniform lowp float u_outline;varying vec2 v_normal;\r\nvarying vec2 v_width2;\r\nvarying float v_linesofar;\r\nvarying float v_gamma_scale;\r\nvarying float v_width;\n#pragma sgmap: define highp vec4 color\r\n#pragma sgmap: define lowp vec4 pattern_from\r\n#pragma sgmap: define lowp vec4 pattern_to\r\n#pragma sgmap: define lowp float pixel_ratio_from\r\n#pragma sgmap: define lowp float pixel_ratio_to\r\n#pragma sgmap: define lowp float blur\r\n#pragma sgmap: define lowp float opacity\r\nvoid main() {\n#pragma sgmap: initialize highp vec4 color\r\n#pragma sgmap: initialize mediump vec4 pattern_from\r\n#pragma sgmap: initialize mediump vec4 pattern_to\r\n#pragma sgmap: initialize lowp float pixel_ratio_from\r\n#pragma sgmap: initialize lowp float pixel_ratio_to\r\n#pragma sgmap: initialize lowp float blur\r\n#pragma sgmap: initialize lowp float opacity\r\nvec2 pattern_tl_a=pattern_from.xy;\r\nvec2 pattern_br_a=pattern_from.zw;\r\nvec2 pattern_tl_b=pattern_to.xy;\r\nvec2 pattern_br_b=pattern_to.zw;\r\nfloat tileZoomRatio=u_scale.x;\r\nfloat fromScale=u_scale.y;\r\nfloat toScale=u_scale.z;\r\nvec2 display_size_a=(pattern_br_a-pattern_tl_a)/u_device_pixel_ratio;\r\nvec2 display_size_b=(pattern_br_b-pattern_tl_b)/u_device_pixel_ratio;\r\nvec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);\r\nvec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);\r\nfloat aspect_a=display_size_a.y/v_width;\r\nfloat aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;\r\nfloat alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\r\nfloat x_a=mod(v_linesofar/pattern_size_a.x,1.0);\r\nfloat x_b=mod(v_linesofar/pattern_size_b.x,1.0);\r\nfloat y=0.5*v_normal.y+0.5;\r\nfloat y_a=0.5+(v_normal.y*clamp(v_width2.s,0.0,(pattern_size_a.y+2.0)/2.0)/pattern_size_a.y);\r\nfloat y_b=0.5+(v_normal.y*clamp(v_width2.s,0.0,(pattern_size_b.y+2.0)/2.0)/pattern_size_b.y);\r\nvec2 texel_size=1.0/u_texsize;\r\nvec2 pos_a=mix(pattern_tl_a*texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));\r\nvec2 pos_b=mix(pattern_tl_b*texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));\r\nvec4 img_color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);\n#ifdef FOG\r\nimg_color=fog_dither(fog_apply_premultiplied(img_color,v_fog_pos));\n#endif\r\nif(u_use_color==1.0 ){gl_FragColor= color*img_color*alpha*opacity;\r\n}else{\r\ngl_FragColor=img_color*alpha*opacity;\r\n}\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", "\n#define scale 0.015873016\r\nattribute vec2 a_pos_normal;\r\nattribute vec4 a_data;\r\nattribute float a_linesofar;\r\nuniform mat4 u_matrix;\r\nuniform vec2 u_units_to_pixels;\r\nuniform mat2 u_pixels_to_tile_units;\r\nuniform lowp float u_device_pixel_ratio;\r\nvarying vec2 v_normal;\r\nvarying vec2 v_width2;\r\nvarying float v_linesofar;\r\nvarying float v_gamma_scale;\r\nvarying float v_width;\r\n#pragma sgmap: define lowp float blur\r\n#pragma sgmap: define lowp float opacity\r\n#pragma sgmap: define lowp float offset\r\n#pragma sgmap: define mediump float gapwidth\r\n#pragma sgmap: define mediump float width\r\n#pragma sgmap: define lowp float floorwidth\r\n#pragma sgmap: define lowp vec4 pattern_from\r\n#pragma sgmap: define lowp vec4 pattern_to\r\n#pragma sgmap: define lowp float pixel_ratio_from\r\n#pragma sgmap: define lowp float pixel_ratio_to\n#pragma sgmap: define highp vec4 color\r\nvoid main() {\r\n#pragma sgmap: initialize lowp float blur\r\n#pragma sgmap: initialize lowp float opacity\r\n#pragma sgmap: initialize lowp float offset\r\n#pragma sgmap: initialize mediump float gapwidth\r\n#pragma sgmap: initialize mediump float width\r\n#pragma sgmap: initialize lowp float floorwidth\r\n#pragma sgmap: initialize mediump vec4 pattern_from\r\n#pragma sgmap: initialize mediump vec4 pattern_to\r\n#pragma sgmap: initialize lowp float pixel_ratio_from\r\n#pragma sgmap: initialize lowp float pixel_ratio_to\n#pragma sgmap: initialize highp vec4 color\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;\r\nvec2 a_extrude=a_data.xy-128.0;\r\nfloat a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;\r\nnormal.y=normal.y*2.0-1.0;\r\nv_normal=normal;gapwidth=gapwidth/2.0;\r\nfloat halfwidth=width/2.0;\r\noffset=-1.0*offset;\r\nfloat inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);\r\nfloat outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;\r\nmediump float t=1.0-abs(u);\r\nmediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);\r\nvec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);\r\ngl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\r\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);\r\nfloat extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);\r\nv_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\r\n#else\r\nv_gamma_scale=1.0;\r\n#endif\r\nv_linesofar=a_linesofar;\r\nv_width2=vec2(outset,inset);\r\nv_width=floorwidth;\r\n#ifdef FOG\r\nv_fog_pos=fog_position(pos);\r\n#endif\r\n}"),
            raster: Zr("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef FOG\nout_color=fog_dither(fog_apply(out_color,v_fog_pos));\n#endif\ngl_FragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {float w=1.0+dot(a_texture_pos,u_perspective_transform);gl_Position=u_matrix*vec4(a_pos*w,0,w);v_pos0=a_texture_pos/8192.0;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            symbolIcon: Zr("uniform sampler2D u_texture;\r\nvarying vec2 v_tex;\r\nvarying float v_fade_opacity;\r\n#pragma sgmap: define lowp float opacity\r\nvoid main() {\r\n#pragma sgmap: initialize lowp float opacity\r\nlowp float alpha=opacity*v_fade_opacity;\r\nvec4 color=texture2D(u_texture,v_tex);\n#ifdef FOG\r\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\r\ngl_FragColor=color*alpha*zoom_opacity;\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", "attribute vec4 a_pos_offset;\r\nattribute vec4 a_tex_size;\r\nattribute vec4 a_pixeloffset;\r\nattribute vec4 a_projected_pos;\r\nattribute float a_fade_opacity;\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nattribute vec3 a_globe_anchor;\r\nattribute vec3 a_globe_normal;\r\n#endif\r\nuniform bool u_is_size_zoom_constant;\r\nuniform bool u_is_size_feature_constant;\r\nuniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;\r\nuniform bool u_rotate_symbol;\r\nuniform highp float u_aspect_ratio;\r\nuniform float u_fade_change;\r\nuniform mat4 u_matrix;\r\nuniform mat4 u_label_plane_matrix;\r\nuniform mat4 u_coord_matrix;\r\nuniform bool u_is_text;\r\nuniform bool u_pitch_with_map;\r\nuniform vec2 u_texsize;\r\nuniform vec3 u_up_vector;\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nuniform vec3 u_tile_id;\r\nuniform mat4 u_inv_rot_matrix;\r\nuniform vec2 u_merc_center;\r\nuniform vec3 u_camera_forward;\r\nuniform float u_zoom_transition;\r\nuniform vec3 u_ecef_origin;\r\nuniform mat4 u_tile_matrix;\r\n#endif\r\nvarying vec2 v_tex;\r\nvarying float v_fade_opacity;\r\n#pragma sgmap: define lowp float opacity\r\nvoid main() {\r\n#pragma sgmap: initialize lowp float opacity\r\nvec2 a_pos=a_pos_offset.xy;\r\nvec2 a_offset=a_pos_offset.zw;\r\nvec2 a_tex=a_tex_size.xy;\r\nvec2 a_size=a_tex_size.zw;\r\nfloat a_size_min=floor(a_size[0]*0.5);\r\nvec2 a_pxoffset=a_pixeloffset.xy;\r\nvec2 a_min_font_scale=a_pixeloffset.zw/256.0;\r\nhighp float segment_angle=-a_projected_pos[3];\r\nfloat size;\r\nif (!u_is_size_zoom_constant && !u_is_size_feature_constant) {\r\nsize=mix(a_size_min,a_size[1],u_size_t)/128.0;\r\n} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {\r\nsize=a_size_min/128.0;\r\n} else {\r\nsize=u_size;\r\n}\r\nvec2 tile_anchor=a_pos;\r\nvec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nvec3 mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);\r\nvec3 world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);\r\nvec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);\r\nvec3 origin_to_point=ecef_point.xyz-u_ecef_origin;float globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\r\n#else\r\nvec3 world_pos=vec3(tile_anchor,0)+h;\r\nfloat globe_occlusion_fade=1.0;\r\n#endif\r\nvec4 projected_point=u_matrix*vec4(world_pos,1);\r\nhighp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\r\ncamera_to_anchor_distance/u_camera_to_center_distance :\r\nu_camera_to_center_distance/camera_to_anchor_distance;\r\nhighp float perspective_ratio=clamp(\r\n0.5+0.5*distance_ratio,0.0,1.5);\r\nsize*=perspective_ratio;\r\nfloat font_scale=u_is_text ? size/24.0 : size;\r\nhighp float symbol_rotation=0.0;\r\nif (u_rotate_symbol) {\n#ifdef PROJECTION_GLOBE_VIEW\r\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);\r\nvec4 offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\r\n#else\r\nvec4 offsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\r\n#endif\r\nvec2 a=projected_point.xy/projected_point.w;\r\nvec2 b=offsetProjected_point.xy/offsetProjected_point.w;\r\nsymbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);\r\n}\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);\r\nvec4 projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\r\n#else\r\nvec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\r\n#endif\r\nhighp float angle_sin=sin(segment_angle+symbol_rotation);\r\nhighp float angle_cos=cos(segment_angle+symbol_rotation);\r\nmat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);\r\nfloat z=0.0;\r\nvec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\r\n#ifdef PITCH_WITH_MAP_TERRAIN\r\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);\r\nz=elevation(tile_pos.xy);\r\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\r\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);\r\nvec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);\r\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\r\n#else\r\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\r\n#endif\r\nfloat projection_transition_fade=1.0;\r\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\r\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\r\n#endif\r\nv_tex=a_tex/u_texsize;\r\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);\r\nfloat fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;\r\nv_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;\r\n#ifdef FOG\r\nv_fog_pos=fog_position(world_pos.xyz);\n#endif\r\n}", 0, "symbolIcon"),
            symbolSDF: Zr("#define SDF_PX 8.0\r\nuniform bool u_is_halo;\r\nuniform sampler2D u_texture;\r\nuniform highp float u_gamma_scale;\r\nuniform lowp float u_device_pixel_ratio;\r\nuniform bool u_is_text;\r\nuniform highp float u_scale_ratio;varying vec2 v_data0;\r\nvarying vec3 v_data1;\r\nvarying float v_scaleable;\n#pragma sgmap: define highp vec4 fill_color\r\n#pragma sgmap: define highp vec4 halo_color\r\n#pragma sgmap: define lowp float opacity\r\n#pragma sgmap: define lowp float halo_width\r\n#pragma sgmap: define lowp float halo_blur\r\nvoid main() {\r\n#pragma sgmap: initialize highp vec4 fill_color\r\n#pragma sgmap: initialize highp vec4 halo_color\r\n#pragma sgmap: initialize lowp float opacity\r\n#pragma sgmap: initialize lowp float halo_width\r\n#pragma sgmap: initialize lowp float halo_blur\r\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;\r\nvec2 tex=v_data0.xy;\r\nfloat gamma_scale=v_data1.x;\r\nfloat size=v_data1.y;\r\nfloat fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0*(v_scaleable==0.0?u_scale_ratio:1.0) : size;\r\nlowp vec4 color=fill_color;\r\nhighp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);\r\nlowp float buff=(256.0-64.0)/256.0;\r\nif (u_is_halo) {\r\ncolor=halo_color;\r\ngamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);\r\nbuff=(6.0-halo_width/fontScale)/SDF_PX;\r\n}\r\nlowp float dist=texture2D(u_texture,tex).a;\r\nhighp float gamma_scaled=gamma*gamma_scale;\r\nhighp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);\r\n#ifdef FOG\r\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\r\ngl_FragColor=color*(alpha*opacity*fade_opacity*zoom_opacity);\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", "attribute vec4 a_pos_offset;\r\nattribute vec4 a_tex_size;\r\nattribute vec4 a_pixeloffset;\r\nattribute vec4 a_projected_pos;\r\nattribute float a_fade_opacity;\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nattribute vec3 a_globe_anchor;\r\nattribute vec3 a_globe_normal;\r\n#endif\nuniform bool u_is_size_zoom_constant;\r\nuniform bool u_is_size_feature_constant;\r\nuniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;\r\nuniform mat4 u_label_plane_matrix;\r\nuniform mat4 u_coord_matrix;\r\nuniform bool u_is_text;\r\nuniform bool u_pitch_with_map;\r\nuniform bool u_rotate_symbol;\r\nuniform highp float u_aspect_ratio;\r\nuniform highp float u_camera_to_center_distance;\r\nuniform float u_fade_change;\r\nuniform vec2 u_texsize;\r\nuniform vec3 u_up_vector;\r\nuniform highp float u_scale_ratio;\n#ifdef PROJECTION_GLOBE_VIEW\r\nuniform vec3 u_tile_id;\r\nuniform mat4 u_inv_rot_matrix;\r\nuniform vec2 u_merc_center;\r\nuniform vec3 u_camera_forward;\r\nuniform float u_zoom_transition;\r\nuniform vec3 u_ecef_origin;\r\nuniform mat4 u_tile_matrix;\r\n#endif\r\nvarying vec2 v_data0;\r\nvarying vec3 v_data1;\r\nvarying float v_scaleable;\n#pragma sgmap: define highp vec4 fill_color\r\n#pragma sgmap: define highp vec4 halo_color\r\n#pragma sgmap: define lowp float opacity\r\n#pragma sgmap: define lowp float halo_width\r\n#pragma sgmap: define lowp float halo_blur\r\nvoid main() {\r\n#pragma sgmap: initialize highp vec4 fill_color\r\n#pragma sgmap: initialize highp vec4 halo_color\r\n#pragma sgmap: initialize lowp float opacity\r\n#pragma sgmap: initialize lowp float halo_width\r\n#pragma sgmap: initialize lowp float halo_blur\r\nvec2 a_pos=a_pos_offset.xy;\r\nvec2 a_offset=a_pos_offset.zw;\r\nvec2 a_tex=a_tex_size.xy;\r\nvec2 a_size=a_tex_size.zw;\r\nfloat a_size_min=floor(a_size[0]*0.5);\r\nvec2 a_pxoffset=a_pixeloffset.xy;\r\nhighp float segment_angle=-a_projected_pos[3];vec4 my_projected_pos=a_projected_pos;\r\nfloat a_scaleable=1.0;\r\nif(a_projected_pos[2]+100.0<=0.0){\r\na_scaleable=0.0;\r\nsegment_angle=a_projected_pos[2]+100.0;\r\nmy_projected_pos.z=my_projected_pos.z*-1.0-100.0;\r\n}\r\nfloat size;\r\nif (!u_is_size_zoom_constant && !u_is_size_feature_constant) {\r\nsize=mix(a_size_min,a_size[1],u_size_t)/128.0;\r\n} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {\r\nsize=a_size_min/128.0;\r\n} else {\r\nsize=u_size;\r\n}\r\nvec2 tile_anchor=a_pos;\r\nvec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nvec3 mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);\r\nvec3 world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);\r\nvec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);\r\nvec3 origin_to_point=ecef_point.xyz-u_ecef_origin;float globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\r\n#else\r\nvec3 world_pos=vec3(tile_anchor,0)+h;\r\nfloat globe_occlusion_fade=1.0;\r\n#endif\r\nvec4 projected_point=u_matrix*vec4(world_pos,1);\r\nhighp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\r\ncamera_to_anchor_distance/u_camera_to_center_distance :\r\nu_camera_to_center_distance/camera_to_anchor_distance;\r\nhighp float perspective_ratio=clamp(\r\n0.5+0.5*distance_ratio,0.0,1.5);\r\nsize*=perspective_ratio;\r\nfloat fontScale=u_is_text ? size/24.0*(a_scaleable==0.0?u_scale_ratio:1.0) : size;v_scaleable=a_scaleable;highp float symbol_rotation=0.0;\r\nif (u_rotate_symbol) {\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);\r\nvec4 offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\r\n#else\r\nvec4 offsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\r\n#endif\r\nvec2 a=projected_point.xy/projected_point.w;\r\nvec2 b=offsetprojected_point.xy/offsetprojected_point.w;\r\nsymbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);\r\n}\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nvec3 proj_pos=mix_globe_mercator(my_projected_pos.xyz+h,mercator_pos,u_zoom_transition);\r\nvec4 projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\r\n#else\r\nvec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\r\n#endif\r\nhighp float angle_sin=sin(segment_angle+symbol_rotation);\r\nhighp float angle_cos=cos(segment_angle+symbol_rotation);\r\nmat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);\r\nfloat z=0.0;\r\nvec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\r\n#ifdef PITCH_WITH_MAP_TERRAIN\r\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);\r\nz=elevation(tile_pos.xy);\r\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\r\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);\r\nvec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);\r\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\r\n#else\r\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\r\n#endif\r\nfloat gamma_scale=gl_Position.w;\r\nfloat projection_transition_fade=1.0;\r\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\r\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\r\n#endif\r\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);\r\nfloat fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;\r\nfloat interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));\r\nv_data0=a_tex/u_texsize;\r\nv_data1=vec3(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade);\r\n#ifdef FOG\r\nv_fog_pos=fog_position(world_pos.xyz);\n#endif\r\n}", 0, "symbolSDF"),
            symbolTextAndIcon: Zr("#define SDF_PX 8.0\r\n#define SDF 1.0\r\n#define ICON 0.0\r\nuniform bool u_is_halo;\r\nuniform sampler2D u_texture;\r\nuniform sampler2D u_texture_icon;\r\nuniform highp float u_gamma_scale;\r\nuniform lowp float u_device_pixel_ratio;\r\nvarying vec4 v_data0;\r\nvarying vec4 v_data1;\r\n#pragma sgmap: define highp vec4 fill_color\r\n#pragma sgmap: define highp vec4 halo_color\r\n#pragma sgmap: define lowp float opacity\r\n#pragma sgmap: define lowp float halo_width\r\n#pragma sgmap: define lowp float halo_blur\r\nvoid main() {\r\n#pragma sgmap: initialize highp vec4 fill_color\r\n#pragma sgmap: initialize highp vec4 halo_color\r\n#pragma sgmap: initialize lowp float opacity\r\n#pragma sgmap: initialize lowp float halo_width\r\n#pragma sgmap: initialize lowp float halo_blur\r\nfloat fade_opacity=v_data1[2];\r\nif (v_data1.w==ICON) {\r\nvec2 tex_icon=v_data0.zw;\r\nlowp float alpha=opacity*fade_opacity;\r\ngl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\nreturn;\r\n}\r\nvec2 tex=v_data0.xy;\r\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;\r\nfloat gamma_scale=v_data1.x;\r\nfloat size=v_data1.y;\r\nfloat fontScale=size/24.0;\r\nlowp vec4 color=fill_color;\r\nhighp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);\r\nlowp float buff=(256.0-64.0)/256.0;\r\nif (u_is_halo) {\r\ncolor=halo_color;\r\ngamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);\r\nbuff=(6.0-halo_width/fontScale)/SDF_PX;\r\n}\r\nlowp float dist=texture2D(u_texture,tex).a;\r\nhighp float gamma_scaled=gamma*gamma_scale;\r\nhighp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);\r\n#ifdef FOG\r\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\r\ngl_FragColor=color*(alpha*opacity*fade_opacity);\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", "attribute vec4 a_pos_offset;\r\nattribute vec4 a_tex_size;\r\nattribute vec4 a_projected_pos;\r\nattribute float a_fade_opacity;\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nattribute vec3 a_globe_anchor;\r\nattribute vec3 a_globe_normal;\r\n#endif\nuniform bool u_is_size_zoom_constant;\r\nuniform bool u_is_size_feature_constant;\r\nuniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;\r\nuniform mat4 u_label_plane_matrix;\r\nuniform mat4 u_coord_matrix;\r\nuniform bool u_is_text;\r\nuniform bool u_pitch_with_map;\r\nuniform bool u_rotate_symbol;\r\nuniform highp float u_aspect_ratio;\r\nuniform highp float u_camera_to_center_distance;\r\nuniform float u_fade_change;\r\nuniform vec2 u_texsize;\r\nuniform vec3 u_up_vector;\r\nuniform vec2 u_texsize_icon;\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nuniform vec3 u_tile_id;\r\nuniform mat4 u_inv_rot_matrix;\r\nuniform vec2 u_merc_center;\r\nuniform vec3 u_camera_forward;\r\nuniform float u_zoom_transition;\r\nuniform vec3 u_ecef_origin;\r\nuniform mat4 u_tile_matrix;\r\n#endif\r\nvarying vec4 v_data0;\r\nvarying vec4 v_data1;\r\n#pragma sgmap: define highp vec4 fill_color\r\n#pragma sgmap: define highp vec4 halo_color\r\n#pragma sgmap: define lowp float opacity\r\n#pragma sgmap: define lowp float halo_width\r\n#pragma sgmap: define lowp float halo_blur\r\nvoid main() {\r\n#pragma sgmap: initialize highp vec4 fill_color\r\n#pragma sgmap: initialize highp vec4 halo_color\r\n#pragma sgmap: initialize lowp float opacity\r\n#pragma sgmap: initialize lowp float halo_width\r\n#pragma sgmap: initialize lowp float halo_blur\r\nvec2 a_pos=a_pos_offset.xy;\r\nvec2 a_offset=a_pos_offset.zw;\r\nvec2 a_tex=a_tex_size.xy;\r\nvec2 a_size=a_tex_size.zw;\r\nfloat a_size_min=floor(a_size[0]*0.5);\r\nfloat is_sdf=a_size[0]-2.0*a_size_min;\r\nhighp float segment_angle=-a_projected_pos[3];\r\nfloat size;\r\nif (!u_is_size_zoom_constant && !u_is_size_feature_constant) {\r\nsize=mix(a_size_min,a_size[1],u_size_t)/128.0;\r\n} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {\r\nsize=a_size_min/128.0;\r\n} else {\r\nsize=u_size;\r\n}\r\nvec2 tile_anchor=a_pos;\r\nvec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nvec3 mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);\r\nvec3 world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);\r\nvec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);\r\nvec3 origin_to_point=ecef_point.xyz-u_ecef_origin;float globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\r\n#else\r\nvec3 world_pos=vec3(tile_anchor,0)+h;\r\nfloat globe_occlusion_fade=1.0;\r\n#endif\r\nvec4 projected_point=u_matrix*vec4(world_pos,1);\r\nhighp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\r\ncamera_to_anchor_distance/u_camera_to_center_distance :\r\nu_camera_to_center_distance/camera_to_anchor_distance;\r\nhighp float perspective_ratio=clamp(\r\n0.5+0.5*distance_ratio,0.0,1.5);\r\nsize*=perspective_ratio;\r\nfloat font_scale=size/24.0;\r\nhighp float symbol_rotation=0.0;\r\nif (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);\r\nvec2 a=projected_point.xy/projected_point.w;\r\nvec2 b=offset_projected_point.xy/offset_projected_point.w;\r\nsymbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);\r\n}\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);\r\nvec4 projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\r\n#else\r\nvec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\r\n#endif\r\nhighp float angle_sin=sin(segment_angle+symbol_rotation);\r\nhighp float angle_cos=cos(segment_angle+symbol_rotation);\r\nmat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);\r\nfloat z=0.0;\r\nvec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\r\n#ifdef PITCH_WITH_MAP_TERRAIN\r\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);\r\nz=elevation(tile_pos.xy);\r\n#endif\r\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\r\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);\r\nvec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);\r\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\r\n#else\r\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\r\n#endif\r\nfloat gamma_scale=gl_Position.w;\r\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);\r\nfloat fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;\r\nfloat interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));\r\nfloat projection_transition_fade=1.0;\r\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\r\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\r\n#endif\r\nv_data0.xy=a_tex/u_texsize;\r\nv_data0.zw=a_tex/u_texsize_icon;\r\nv_data1=vec4(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade,is_sdf);\r\n#ifdef FOG\r\nv_fog_pos=fog_position(world_pos.xyz);\n#endif\r\n}", 0, "symbolTextAndIcon"),
            terrainRaster: Zr("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nvarying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nvoid main() {vec4 color=texture2D(u_image0,v_pos0);\n#ifdef RENDER_SHADOWS\ncolor.xyz=shadowed_color(color.xyz,v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nconst float skirtOffset=24575.0;const float wireframeOffset=0.00015;void main() {v_pos0=a_texture_pos/8192.0;float skirt=float(a_pos.x >=skirtOffset);float elevation=elevation(a_texture_pos)-skirt*u_skirt_height;\n#ifdef TERRAIN_WIREFRAME\nelevation+=u_skirt_height*u_skirt_height*wireframeOffset;\n#endif\nvec2 decodedPos=a_pos-vec2(skirt*skirtOffset,0.0);gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);v_depth=gl_Position.w;\n#endif\n}"),
            terrainDepth: Zr("#ifdef GL_ES\nprecision highp float;\n#endif\nvarying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying float v_depth;void main() {float elevation=elevation(a_texture_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}"),
            skybox: Zr("\nvarying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", Pr),
            skyboxGradient: Zr("varying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", Pr),
            skyboxCapture: Zr("\nvarying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}", "attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"),
            globeRaster: Zr("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture2D(u_image0,v_pos0);vec4 color=vec4(raster.rgb*antialias,raster.a*antialias);\n#else\nvec4 color=texture2D(u_image0,v_pos0);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\nuniform mat4 u_proj_matrix;\r\nuniform mat4 u_normalize_matrix;\r\nuniform mat4 u_globe_matrix;\r\nuniform mat4 u_merc_matrix;\r\nuniform float u_zoom_transition;\r\nuniform vec2 u_merc_center;\r\nuniform mat3 u_grid_matrix;\r\n#ifdef GLOBE_POLES\r\nattribute vec3 a_globe_pos;\r\nattribute vec2 a_uv;\r\n#else\r\nattribute vec2 a_pos;\r\n#endif\r\nvarying vec2 v_pos0;\r\nconst float wireframeOffset=1e3;\r\nfloat mercatorXfromLng(float lng) {\r\nreturn (180.0+lng)/360.0;\r\n}\r\nfloat mercatorYfromLat(float lat) {\r\nreturn (180.0-(RAD_TO_DEG*log(tan(QUARTER_PI+lat/2.0*DEG_TO_RAD))))/360.0;\r\n}\r\nvec3 latLngToECEF(vec2 latLng) {\r\nlatLng=DEG_TO_RAD*latLng;\r\nfloat cosLat=cos(latLng[0]);\r\nfloat sinLat=sin(latLng[0]);\r\nfloat cosLng=cos(latLng[1]);\r\nfloat sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;\r\nfloat sy=-sinLat*GLOBE_RADIUS;\r\nfloat sz=cosLat*cosLng*GLOBE_RADIUS;\r\nreturn vec3(sx,sy,sz);\r\n}\r\nvoid main() {\r\n#ifdef GLOBE_POLES\r\nvec3 globe_pos=a_globe_pos;\r\nvec2 uv=a_uv;\r\n#else\nfloat tiles=u_grid_matrix[0][2];\r\nfloat idx=u_grid_matrix[1][2];\r\nfloat idy=u_grid_matrix[2][2];\r\nvec3 latLng=u_grid_matrix*vec3(a_pos,1.0);\r\nfloat mercatorY=mercatorYfromLat(latLng[0]);\r\nfloat uvY=mercatorY*tiles-idy;\r\nfloat mercatorX=mercatorXfromLng(latLng[1]);\r\nfloat uvX=mercatorX*tiles-idx;\r\nvec3 globe_pos=latLngToECEF(latLng.xy);\r\nvec2 merc_pos=vec2(mercatorX,mercatorY);\r\nvec2 uv=vec2(uvX,uvY);\r\n#endif\r\nv_pos0=uv;\r\nvec2 tile_pos=uv*EXTENT;\r\n#ifdef GLOBE_POLES\nvec3 up_vector=normalize(globe_pos)*u_tile_up_scale;\r\n#else\r\nvec3 up_vector=elevationVector(tile_pos);\r\n#endif\r\nfloat height=elevation(tile_pos);\r\n#ifdef TERRAIN_WIREFRAME\r\nheight+=wireframeOffset;\r\n#endif\r\nglobe_pos+=up_vector*height;\r\n#ifdef GLOBE_POLES\r\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\r\n#else\r\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);\r\nvec4 merc_world_pos=vec4(0.0);\r\nif (u_zoom_transition > 0.0) {\r\nmerc_world_pos=vec4(merc_pos,height,1.0);\r\nmerc_world_pos.xy-=u_merc_center;\r\nmerc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);\r\nmerc_world_pos=u_merc_matrix*merc_world_pos;\r\n}\r\nvec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\r\n#endif\r\ngl_Position=u_proj_matrix*interpolated_pos;\r\n#ifdef FOG\r\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\r\n#endif\r\n}"),
            globeAtmosphere: Zr("uniform float u_transition;\r\nuniform highp float u_fadeout_range;\r\nuniform highp float u_temporal_offset;\r\nuniform vec3 u_start_color;\r\nuniform vec4 u_color;\r\nuniform vec4 u_space_color;\r\nuniform vec4 u_high_color;\r\nuniform float u_star_intensity;\r\nuniform float u_star_size;\r\nuniform float u_star_density;\r\nuniform float u_horizon_angle;\r\nuniform mat4 u_rotation_matrix;\r\nvarying highp vec3 v_ray_dir;\r\nvarying highp vec3 v_horizon_dir;\r\nhighp float random(highp vec3 p) {\r\np=fract(p*vec3(23.2342,97.1231,91.2342));\r\np+=dot(p.zxy,p.yxz+123.1234);\r\nreturn fract(p.x*p.y);\r\n}\r\nfloat stars(vec3 p,float scale,vec2 offset) {\r\nvec2 uv_scale=(u_viewport/u_star_size)*scale;\r\nvec3 position=vec3(p.xy*uv_scale+offset*u_viewport,p.z);\r\nvec3 q=fract(position)-0.5;\r\nvec3 id=floor(position);\r\nfloat random_visibility=step(random(id),u_star_density);\r\nfloat circle=smoothstep(0.5+u_star_intensity,0.5,length(q));\r\nreturn circle*random_visibility;\r\n}\r\nvoid main() {\r\nhighp vec3 dir=normalize(v_ray_dir);\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nfloat globe_pos_dot_dir=dot(u_globe_pos,dir);\r\nhighp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;\r\nfloat norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {\r\ndiscard;\r\nreturn;\r\n}\r\n#endif\r\nhighp vec3 horizon_dir=normalize(v_horizon_dir);\r\nfloat horizon_angle_mercator=dir.y < horizon_dir.y ?\r\n0.0 : max(acos(dot(dir,horizon_dir)),0.005);\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;\r\nfloat closest_point_to_center=length(closest_point-u_globe_pos);\r\nfloat theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));float horizon_angle=globe_pos_dot_dir < 0.0 ?\r\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);\r\nhorizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\r\n#else\r\nfloat horizon_angle=horizon_angle_mercator;\r\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);\r\nfloat alpha_0=u_color.a;\r\nfloat alpha_1=u_high_color.a;\r\nfloat alpha_2=u_space_color.a;\r\nvec3 color_stop_0=u_color.rgb;\r\nvec3 color_stop_1=u_high_color.rgb;\r\nvec3 color_stop_2=u_space_color.rgb;\r\nvec3 c0=mix(color_stop_2,color_stop_1,alpha_1);\r\nvec3 c1=mix(c0,color_stop_0,alpha_0);\r\nvec3 c2=mix(c0,c1,t);\r\nvec3 c =mix(color_stop_2,c2,t);float a0=mix(alpha_2,1.0,alpha_1);\r\nfloat a1=mix(a0,1.0,alpha_0);\r\nfloat a2=mix(a0,a1,t);\r\nfloat a =mix(alpha_2,a2,t);\r\nvec2 uv=gl_FragCoord.xy/u_viewport-0.5;\r\nfloat aspect_ratio=u_viewport.x/u_viewport.y;\r\nvec4 uv_dir=vec4(normalize(vec3(uv.x*aspect_ratio,uv.y,1.0)),1.0);\r\nuv_dir=u_rotation_matrix*uv_dir;\r\nvec3 n=abs(uv_dir.xyz);\r\nvec2 uv_remap=(n.x > n.y && n.x > n.z) ? uv_dir.yz/uv_dir.x:\r\n(n.y > n.x && n.y > n.z) ? uv_dir.zx/uv_dir.y:\r\nuv_dir.xy/uv_dir.z;\r\nuv_remap.x/=aspect_ratio;\r\nvec3 D=vec3(uv_remap,1.0);highp float star_field=0.0;\r\nif (u_star_intensity > 0.0) {star_field+=stars(D,1.2,vec2(0.0,0.0));\r\nstar_field+=stars(D,1.0,vec2(1.0,0.0));\r\nstar_field+=stars(D,0.8,vec2(0.0,1.0));\r\nstar_field+=stars(D,0.6,vec2(1.0,1.0));star_field*=(1.0-pow(t,0.25+(1.0-u_high_color.a)*0.75));c+=star_field*alpha_2;\r\n}c=dither(c,gl_FragCoord.xy+u_temporal_offset);\r\ngl_FragColor=vec4(c,a);\r\n}", "attribute vec3 a_pos;attribute vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}"),
            eleSymbol: Zr("uniform lowp float u_device_pixel_ratio;\r\nvarying vec3 v_normal;\r\nvarying float v_gap;\r\nvarying vec4 v_ecolor;\r\n#pragma sgmap: define highp vec4 color\r\n#pragma sgmap: define lowp float blur\r\n#pragma sgmap: define lowp float opacity\r\nvoid main() {\r\n#pragma sgmap: initialize highp vec4 color\r\n#pragma sgmap: initialize lowp float blur\r\n#pragma sgmap: initialize lowp float opacity\r\nfloat extrude_length=length(v_normal);float gap=v_gap;float antiblur;\r\nif(v_gap==0.0 || 1.0-extrude_length>=gap){\r\nantiblur=1.0;\r\n}else{antiblur=smoothstep(0.0,gap,1.0-extrude_length);\r\n}\r\nvec4 out_color=v_ecolor;\r\n#ifdef FOG\r\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\r\n#endif\r\ngl_FragColor=out_color*(opacity*zoom_opacity)*antiblur;\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", "\n#define scale 0.015873016\r\nattribute vec2 a_pos;\r\nattribute vec2 a_eoffset;attribute vec4 a_normal;attribute float a_ecolor;attribute float a_erotate;attribute float a_esize;uniform vec2 u_units_to_pixels;\r\nuniform mat4 u_matrix;\r\nuniform mat4 u_label_plane_matrix;\r\nuniform mat4 u_coord_matrix;\r\nuniform lowp float u_device_pixel_ratio;\r\nuniform highp float u_scale_ratio;\n#ifdef PROJECTION_GLOBE_VIEW\r\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;\r\nuniform vec2 u_merc_center;\r\nuniform vec3 u_tile_id;\r\nuniform float u_zoom_transition;\r\nuniform vec3 u_up_dir;\r\nuniform vec3 u_ecef_origin;\r\nuniform mat4 u_tile_matrix;\r\nuniform vec3 u_camera_forward;\r\n#endif\r\nvarying vec3 v_normal;\r\nvarying float v_gap;varying vec4 v_ecolor;\r\n#pragma sgmap: define highp vec4 color\r\n#pragma sgmap: define lowp float blur\r\n#pragma sgmap: define lowp float opacity\r\n#pragma sgmap: define mediump float gapwidth\r\n#pragma sgmap: define mediump float width\r\nvoid main() {\r\n#pragma sgmap: initialize highp vec4 color\r\n#pragma sgmap: initialize lowp float blur\r\n#pragma sgmap: initialize lowp float opacity\r\n#pragma sgmap: initialize mediump float gapwidth\r\n#pragma sgmap: initialize mediump float width\r\nfloat symbol_size=abs(a_esize);\r\nfloat scale_ratio=1.0;if(a_esize>=0.0){\r\nscale_ratio=u_scale_ratio;\r\n}\r\nfloat ANTIALIASING=1.3/u_device_pixel_ratio;\r\nvec3 normal=normalize(vec3(a_normal));vec2 tile_anchor=a_pos.xy;\r\nvec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nvec3 mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);\r\nvec3 world_pos=mix_globe_mercator(a_pos_3+h,mercator_pos,u_zoom_transition);\r\nvec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);\r\nvec3 origin_to_point=ecef_point.xyz-u_ecef_origin;float globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\r\n#else\r\nvec3 world_pos=vec3(tile_anchor,0)+h;\r\nfloat globe_occlusion_fade=1.0;\r\n#endif\r\nvec4 projected_point=u_matrix*vec4(world_pos,1);\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nvec3 proj_pos=mix_globe_mercator(a_pos_3.xyz+h,mercator_pos,u_zoom_transition);\r\nvec4 projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\r\n#else\r\nvec4 projected_pos=u_label_plane_matrix*vec4(a_pos.xy,h.z,1.0);\r\n#endif\r\nhighp float angle_sin=sin((a_erotate/180.0)*PI );\r\nhighp float angle_cos=cos((a_erotate/180.0)*PI );\r\nmat2 rotation_matrix=mat2(angle_cos,angle_sin,-1.0*angle_sin,angle_cos);\r\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\r\nfloat z=0.0;\r\nvec2 offset=rotation_matrix*(a_eoffset*scale_ratio*symbol_size);\r\nvec2 new_offset=rotation_matrix*(a_normal.xy*scale_ratio*symbol_size);\r\nmat3 surface_vectors=mat3(1.0);\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nvec3 pos_normal_3=a_pos_normal_3;\r\nsurface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);\r\nvec4 geoPos=u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+offset.x*surface_vectors[0]+offset.y*surface_vectors[1],1.0);\r\nvec4 new_vect=u_coord_matrix*vec4(new_offset.x*surface_vectors[0]+new_offset.y*surface_vectors[1],0.0);\r\n#else\r\nvec4 geoPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0);\r\nvec4 new_vect=u_coord_matrix*vec4( new_offset,z,0.0);\r\n#endif\r\ngeoPos=mix( geoPos,AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\r\nfloat halp=length(new_vect.xyz);vec3 blurNormal=new_vect.xyz/length( new_vect.xyz/geoPos.w*vec3(u_units_to_pixels,1.0))*ANTIALIASING;float blurLength=length(blurNormal.xyz);v_gap=blurLength/(halp+blurLength);v_normal=normal;\r\nif(a_normal.x==0.0 && a_normal.y==0.0){v_gap=0.0;\r\nblurNormal=vec3(0.0,0.0,0.0);\r\n}\r\nif(a_ecolor>=0.0){\r\nv_ecolor=color;\r\n}else{\r\nfloat staticColor=a_ecolor;if(a_ecolor==-0.1){\r\nstaticColor=0.0;\r\n}float color_b=mod(0.0-staticColor,256.0);\r\nfloat color_g=mod(0.0-staticColor-color_b,256.0*256.0)/256.0;\r\nfloat color_r=(0.0-staticColor-color_b-color_g*256.0)/(256.0*256.0);\r\nv_ecolor=vec4( color_r/256.0,color_g/256.0,color_b/256.0,1.0);\r\n}\r\ngl_Position=geoPos+vec4(blurNormal.xyz,0.0);\r\n#ifdef FOG\r\nv_fog_pos=fog_position(world_pos.xyz);\r\n#endif\r\n}", 0, "eleSymbol")
        };
        function Vr(t, e) {
            const i = t.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
            for (let t of i)
                if (t = t.trim(),
                "#" === t[0] && t.includes("if") && !t.includes("endif")) {
                    t = t.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
                    const i = t.split(" ");
                    for (const t of i)
                        e.includes(t) || e.push(t);
                }
        }
        function Zr(t, e, i, r) {
            const o = /#pragma sgmap: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g;
            t = Rr(t, "fragment", r);
            const n = (e = (e = Rr(e, "vertex", r)).replace("uniform vec3 u_tile_id", "uniform vec4 u_tile_id")).match(/attribute (highp |mediump |lowp )?([\w]+) ([\w]+)/g)
              , s = {}
              , a = [...Fr];
            return Vr(t, a),
            Vr(e, a),
            {
                fragmentSource: t = t.replace(o, ( (t, e, i, r, o) => (s[o] = !0,
                "define" === e ? `\n#ifndef HAS_UNIFORM_u_${o}\nvarying ${i} ${r} ${o};\n#else\nuniform ${i} ${r} u_${o};\n#endif\n` : `\n#ifdef HAS_UNIFORM_u_${o}\n    ${i} ${r} ${o} = u_${o};\n#endif\n`))),
                vertexSource: e = e.replace(o, ( (t, e, i, r, o) => {
                    const n = "float" === r ? "vec2" : "vec4"
                      , a = o.match(/color/) ? "color" : n;
                    return s[o] ? "define" === e ? `\n#ifndef HAS_UNIFORM_u_${o}\nuniform lowp float u_${o}_t;\nattribute ${i} ${n} a_${o};\nvarying ${i} ${r} ${o};\n#else\nuniform ${i} ${r} u_${o};\n#endif\n` : "vec4" === a ? `\n#ifndef HAS_UNIFORM_u_${o}\n    ${o} = a_${o};\n#else\n    ${i} ${r} ${o} = u_${o};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${o}\n    ${o} = unpack_mix_${a}(a_${o}, u_${o}_t);\n#else\n    ${i} ${r} ${o} = u_${o};\n#endif\n` : "define" === e ? `\n#ifndef HAS_UNIFORM_u_${o}\nuniform lowp float u_${o}_t;\nattribute ${i} ${n} a_${o};\n#else\nuniform ${i} ${r} u_${o};\n#endif\n` : "vec4" === a ? `\n#ifndef HAS_UNIFORM_u_${o}\n    ${i} ${r} ${o} = a_${o};\n#else\n    ${i} ${r} ${o} = u_${o};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${o}\n    ${i} ${r} ${o} = unpack_mix_${a}(a_${o}, u_${o}_t);\n#else\n    ${i} ${r} ${o} = u_${o};\n#endif\n`
                }
                )),
                staticAttributes: n,
                usedDefines: a
            }
        }
        class Wr {
            constructor() {
                this.boundProgram = null,
                this.boundLayoutVertexBuffer = null,
                this.boundPaintVertexBuffers = [],
                this.boundIndexBuffer = null,
                this.boundVertexOffset = null,
                this.boundDynamicVertexBuffers = [],
                this.vao = null;
            }
            bind(t, e, i, r, o, n, s) {
                this.context = t;
                let a = this.boundPaintVertexBuffers.length !== r.length;
                for (let t = 0; !a && t < r.length; t++)
                    this.boundPaintVertexBuffers[t] !== r[t] && (a = !0);
                let l = this.boundDynamicVertexBuffers.length !== s.length;
                for (let t = 0; !l && t < s.length; t++)
                    this.boundDynamicVertexBuffers[t] !== s[t] && (l = !0);
                if (!t.extVertexArrayObject || !this.vao || this.boundProgram !== e || this.boundLayoutVertexBuffer !== i || a || l || this.boundIndexBuffer !== o || this.boundVertexOffset !== n)
                    this.freshBind(e, i, r, o, n, s);
                else {
                    t.bindVertexArrayOES.set(this.vao);
                    for (const t of s)
                        t && t.bind();
                    o && o.dynamicDraw && o.bind();
                }
            }
            freshBind(t, e, i, r, o, n) {
                let s;
                const a = t.numAttributes
                  , l = this.context
                  , c = l.gl;
                if (l.extVertexArrayObject)
                    this.vao && this.destroy(),
                    this.vao = l.extVertexArrayObject.createVertexArrayOES(),
                    l.bindVertexArrayOES.set(this.vao),
                    s = 0,
                    this.boundProgram = t,
                    this.boundLayoutVertexBuffer = e,
                    this.boundPaintVertexBuffers = i,
                    this.boundIndexBuffer = r,
                    this.boundVertexOffset = o,
                    this.boundDynamicVertexBuffers = n;
                else {
                    s = l.currentNumAttributes || 0;
                    for (let t = a; t < s; t++)
                        c.disableVertexAttribArray(t);
                }
                e.enableAttributes(c, t),
                e.bind(),
                e.setVertexAttribPointers(c, t, o);
                for (const e of i)
                    e.enableAttributes(c, t),
                    e.bind(),
                    e.setVertexAttribPointers(c, t, o);
                for (const e of n)
                    e && (e.enableAttributes(c, t),
                    e.bind(),
                    e.setVertexAttribPointers(c, t, o));
                r && r.bind(),
                l.currentNumAttributes = a;
            }
            destroy() {
                this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao),
                this.vao = null);
            }
        }
        function qr(e, i) {
            const r = Math.pow(2, i.canonical.z)
              , o = i.canonical.y;
            return [new t.MercatorCoordinate(0,o / r).toLngLat().lat, new t.MercatorCoordinate(0,(o + 1) / r).toLngLat().lat]
        }
        function Hr(e, i, r, o, n, s, a) {
            const l = e.context
              , c = l.gl
              , h = r.fbo;
            if (!h)
                return;
            e.prepareDrawTile();
            const u = e.useProgram("hillshade");
            l.activeTexture.set(c.TEXTURE0),
            c.bindTexture(c.TEXTURE_2D, h.colorAttachment.get());
            const d = ( (t, e, i, r) => {
                const o = i.paint.get("hillshade-shadow-color")
                  , n = i.paint.get("hillshade-highlight-color")
                  , s = i.paint.get("hillshade-accent-color");
                let a = i.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
                "viewport" === i.paint.get("hillshade-illumination-anchor") && (a -= t.transform.angle);
                const l = !t.options.moving;
                return {
                    u_matrix: r || t.transform.calculateProjMatrix(e.tileID.toUnwrapped(), l),
                    u_image: 0,
                    u_latrange: qr(0, e.tileID),
                    u_light: [i.paint.get("hillshade-exaggeration"), a],
                    u_shadow: o,
                    u_highlight: n,
                    u_accent: s
                }
            }
            )(e, r, o, e.terrain ? i.projMatrix : null);
            e.prepareDrawProgram(l, u, i.toUnwrapped());
            const {tileBoundsBuffer: f, tileBoundsIndexBuffer: _, tileBoundsSegments: p} = e.getTileBoundsBuffers(r);
            u.draw(l, c.TRIANGLES, n, s, a, t.CullFaceMode.disabled, d, o.id, f, _, p);
        }
        function Xr(e, i, r) {
            if (!i.needsDEMTextureUpload)
                return;
            const o = e.context
              , n = o.gl;
            o.pixelStoreUnpackPremultiplyAlpha.set(!1),
            i.demTexture = i.demTexture || e.getTileTexture(r.stride);
            const s = r.getPixels();
            i.demTexture ? i.demTexture.update(s, {
                premultiply: !1
            }) : i.demTexture = new t.Texture(o,s,n.RGBA,{
                premultiply: !1
            }),
            i.needsDEMTextureUpload = !1;
        }
        function Yr(e, i, r, o, n, s) {
            const a = e.context
              , l = a.gl;
            if (!i.dem)
                return;
            const c = i.dem;
            if (a.activeTexture.set(l.TEXTURE1),
            Xr(e, i, c),
            !i.demTexture)
                return;
            i.demTexture.bind(l.NEAREST, l.CLAMP_TO_EDGE);
            const h = c.dim;
            a.activeTexture.set(l.TEXTURE0);
            let u = i.fbo;
            if (!u) {
                const e = new t.Texture(a,{
                    width: h,
                    height: h,
                    data: null
                },l.RGBA);
                e.bind(l.LINEAR, l.CLAMP_TO_EDGE),
                u = i.fbo = a.createFramebuffer(h, h, !0),
                u.colorAttachment.set(e.texture);
            }
            a.bindFramebuffer.set(u.framebuffer),
            a.viewport.set([0, 0, h, h]);
            const {tileBoundsBuffer: d, tileBoundsIndexBuffer: f, tileBoundsSegments: _} = e.getMercatorTileBoundsBuffers();
            e.useProgram("hillshadePrepare").draw(a, l.TRIANGLES, o, n, s, t.CullFaceMode.disabled, ( (e, i) => {
                const r = i.stride
                  , o = t.create();
                return t.ortho(o, 0, t.EXTENT, -t.EXTENT, 0, 0, 1),
                t.translate(o, o, [0, -t.EXTENT, 0]),
                {
                    u_matrix: o,
                    u_image: 1,
                    u_dimension: [r, r],
                    u_zoom: e.overscaledZ,
                    u_unpack: i.unpackVector
                }
            }
            )(i.tileID, c), r.id, d, f, _),
            i.needsHillshadePrepare = !1;
        }
        const Kr = e => ({
            u_matrix: new t.UniformMatrix4f(e),
            u_image0: new t.Uniform1i(e),
            u_skirt_height: new t.Uniform1f(e)
        })
          , Jr = (t, e) => ({
            u_matrix: t,
            u_image0: 0,
            u_skirt_height: e
        })
          , $r = (t, e, i, r, o, n, s, a, l, c, h, u, d, f) => ({
            u_proj_matrix: Float32Array.from(t),
            u_globe_matrix: e,
            u_normalize_matrix: Float32Array.from(r),
            u_merc_matrix: i,
            u_zoom_transition: o,
            u_merc_center: n,
            u_image0: 0,
            u_frustum_tl: s,
            u_frustum_tr: a,
            u_frustum_br: l,
            u_frustum_bl: c,
            u_globe_pos: h,
            u_globe_radius: u,
            u_viewport: d,
            u_grid_matrix: f ? Float32Array.from(f) : new Float32Array(9)
        });
        function Qr(t, e) {
            return null != t && null != e && !(!t.hasData() || !e.hasData()) && null != t.demTexture && null != e.demTexture && t.tileID.key !== e.tileID.key
        }
        const to = new class {
            constructor() {
                this.operations = {};
            }
            newMorphing(t, e, i, r, o) {
                if (t in this.operations) {
                    const e = this.operations[t];
                    e.to.tileID.key !== i.tileID.key && (e.queued = i);
                } else
                    this.operations[t] = {
                        startTime: r,
                        phase: 0,
                        duration: o,
                        from: e,
                        to: i,
                        queued: null
                    };
            }
            getMorphValuesForProxy(t) {
                if (!(t in this.operations))
                    return null;
                const e = this.operations[t];
                return {
                    from: e.from,
                    to: e.to,
                    phase: e.phase
                }
            }
            update(t) {
                for (const e in this.operations) {
                    const i = this.operations[e];
                    for (i.phase = (t - i.startTime) / i.duration; i.phase >= 1 || !this._validOp(i); )
                        if (!this._nextOp(i, t)) {
                            delete this.operations[e];
                            break
                        }
                }
            }
            _nextOp(t, e) {
                return !!t.queued && (t.from = t.to,
                t.to = t.queued,
                t.queued = null,
                t.phase = 0,
                t.startTime = e,
                !0)
            }
            _validOp(t) {
                return t.from.hasData() && t.to.hasData()
            }
        }
          , eo = {
            0: null,
            1: "TERRAIN_VERTEX_MORPHING",
            2: "TERRAIN_WIREFRAME"
        };
        function io(t, e) {
            const i = 1 << t.z;
            return !e && (0 === t.x || t.x === i - 1) || 0 === t.y || t.y === i - 1
        }
        const ro = t => ({
            u_matrix: t
        });
        function oo(e, i, r, o, n) {
            if (n > 0) {
                const s = t.exported.now()
                  , a = (s - e.timeAdded) / n
                  , l = i ? (s - i.timeAdded) / n : -1
                  , c = r.getSource()
                  , h = o.coveringZoomLevel({
                    tileSize: c.tileSize,
                    roundZoom: c.roundZoom
                })
                  , u = !i || Math.abs(i.tileID.overscaledZ - h) > Math.abs(e.tileID.overscaledZ - h)
                  , d = u && e.refreshedUponExpiration ? 1 : t.clamp(u ? a : 1 - l, 0, 1);
                return e.refreshedUponExpiration && a >= 1 && (e.refreshedUponExpiration = !1),
                i ? {
                    opacity: 1,
                    mix: 1 - d
                } : {
                    opacity: d,
                    mix: 0
                }
            }
            return {
                opacity: 1,
                mix: 0
            }
        }
        class no extends t.SourceCache {
            constructor(t) {
                const e = {
                    type: "raster-dem",
                    maxzoom: t.transform.maxZoom
                }
                  , i = new G(mi(),null)
                  , r = ai("mock-dem", e, i, t.style);
                super("mock-dem", r, !1),
                r.setEventedParent(this),
                this._sourceLoaded = !0;
            }
            _loadTile(t, e) {
                t.state = "loaded",
                e(null);
            }
        }
        class so extends t.SourceCache {
            constructor(t) {
                const e = ai("proxy", {
                    type: "geojson",
                    maxzoom: t.transform.maxZoom
                }, new G(mi(),null), t.style);
                super("proxy", e, !1),
                e.setEventedParent(this),
                this.map = this.getSource().map = t,
                this.used = this._sourceLoaded = !0,
                this.renderCache = [],
                this.renderCachePool = [],
                this.proxyCachedFBO = {};
            }
            update(e, i, r) {
                if (e.freezeTileCoverage)
                    return;
                this.transform = e;
                const o = e.coveringTiles({
                    tileSize: this._source.tileSize,
                    minzoom: this._source.minzoom,
                    maxzoom: this._source.maxzoom,
                    roundZoom: this._source.roundZoom,
                    reparseOverscaled: this._source.reparseOverscaled,
                    reference: this._source.reference,
                    zoomRule: this._source.zoomRule,
                    sourceID: this._source.id
                }).reduce(( (i, r) => {
                    if (i[r.key] = "",
                    !this._tiles[r.key]) {
                        const i = new t.Tile(r,this._source.tileSize * r.overscaleFactor(),e.tileZoom);
                        i.state = "loaded",
                        this._tiles[r.key] = i;
                    }
                    return i
                }
                ), {});
                for (const t in this._tiles)
                    t in o || (this.freeFBO(t),
                    this._tiles[t].unloadVectorData(),
                    delete this._tiles[t]);
            }
            freeFBO(t) {
                const e = this.proxyCachedFBO[t];
                if (void 0 !== e) {
                    const i = Object.values(e);
                    this.renderCachePool.push(...i),
                    delete this.proxyCachedFBO[t];
                }
            }
            deallocRenderCache() {
                this.renderCache.forEach((t => t.fb.destroy())),
                this.renderCache = [],
                this.renderCachePool = [],
                this.proxyCachedFBO = {};
            }
        }
        class ao extends t.OverscaledTileID {
            constructor(t, e, i) {
                super(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y, t),
                this.proxyTileKey = e,
                this.projMatrix = i;
            }
        }
        class lo extends t.Elevation {
            constructor(e, i) {
                super(),
                this.painter = e,
                this.terrainTileForTile = {},
                this.prevTerrainTileForTile = {},
                this._offscreenCanvas = null,
                this._offscreenCanvas2 = null;
                const [r,o,n] = function(e) {
                    const i = new t.StructArrayLayout4i8
                      , r = new t.StructArrayLayout3ui6
                      , o = 131;
                    i.reserve(17161),
                    r.reserve(33800);
                    const n = t.EXTENT / 128
                      , s = t.EXTENT + n / 2
                      , a = s + n;
                    for (let e = -n; e < a; e += n)
                        for (let r = -n; r < a; r += n) {
                            const o = r < 0 || r > s || e < 0 || e > s ? 24575 : 0
                              , n = t.clamp(Math.round(r), 0, t.EXTENT)
                              , a = t.clamp(Math.round(e), 0, t.EXTENT);
                            i.emplaceBack(n + o, a, n, a);
                        }
                    const l = (t, e) => {
                        const i = e * o + t;
                        r.emplaceBack(i + 1, i, i + o),
                        r.emplaceBack(i + o, i + o + 1, i + 1);
                    }
                    ;
                    for (let t = 1; t < 129; t++)
                        for (let e = 1; e < 129; e++)
                            l(e, t);
                    return [0, 129].forEach((t => {
                        for (let e = 0; e < 130; e++)
                            l(e, t),
                            l(t, e);
                    }
                    )),
                    [i, r, 32768]
                }()
                  , s = e.context;
                this.gridBuffer = s.createVertexBuffer(r, t.boundsAttributes.members),
                this.gridIndexBuffer = s.createIndexBuffer(o),
                this.gridSegments = t.SegmentVector.simpleSegment(0, 0, r.length, o.length),
                this.gridNoSkirtSegments = t.SegmentVector.simpleSegment(0, 0, r.length, n),
                this.proxyCoords = [],
                this.proxiedCoords = {},
                this._visibleDemTiles = [],
                this._drapedRenderBatches = [],
                this._sourceTilesOverlap = {},
                this.proxySourceCache = new so(i.map),
                this.orthoMatrix = t.create(),
                t.ortho(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? .015 : 0, t.EXTENT, 0, t.EXTENT, 0, 1);
                const a = s.gl;
                this._overlapStencilMode = new t.StencilMode({
                    func: a.GEQUAL,
                    mask: 255
                },0,255,a.KEEP,a.KEEP,a.REPLACE),
                this._previousZoom = e.transform.zoom,
                this.pool = [],
                this._findCoveringTileCache = {},
                this._tilesDirty = {},
                this.style = i,
                this._useVertexMorphing = !0,
                this._exaggeration = 1,
                this._mockSourceCache = new no(i.map);
            }
            set style(t) {
                t.on("data", this._onStyleDataEvent.bind(this)),
                t.on("neworder", this._checkRenderCacheEfficiency.bind(this)),
                this._style = t,
                this._checkRenderCacheEfficiency();
            }
            update(e, i, r) {
                if (e && e.terrain) {
                    this._style !== e && (this.style = e),
                    this.enabled = !0;
                    const o = e.terrain.properties;
                    this.sourceCache = 0 === e.terrain.drapeRenderMode ? this._mockSourceCache : e._getSourceCache(o.get("source")),
                    this._exaggeration = o ? o.get("exaggeration") : 0;
                    const n = () => {
                        this.sourceCache.used && t.warnOnce(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
                        const e = this.getScaledDemTileSize();
                        this.sourceCache.update(i, e, !0),
                        this.resetTileLookupCache(this.sourceCache.id);
                    }
                    ;
                    this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id),
                    this.sourceCache.usedForTerrain = !0,
                    n(),
                    this._initializing = !0),
                    n(),
                    i.updateElevation(!r),
                    this.resetTileLookupCache(this.proxySourceCache.id),
                    this.proxySourceCache.update(i),
                    this._emptyDEMTextureDirty = !0;
                } else
                    this._disable();
            }
            resetTileLookupCache(t) {
                this._findCoveringTileCache[t] = {};
            }
            getScaledDemTileSize() {
                return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize
            }
            _checkRenderCacheEfficiency() {
                const e = this.renderCacheEfficiency(this._style);
                this._style.map._optimizeForTerrain || 100 !== e.efficiency && t.warnOnce(`Terrain render cache efficiency is not optimal (${e.efficiency}%) and performance\n                may be affected negatively, consider placing all background, fill and line layers before layer\n                with id '${e.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`);
            }
            _onStyleDataEvent(t) {
                t.coord && "source" === t.dataType ? this._clearRenderCacheForTile(t.sourceCacheId, t.coord) : "style" === t.dataType && (this._invalidateRenderCache = !0);
            }
            _disable() {
                if (this.enabled && (this.enabled = !1,
                this._sharedDepthStencil = void 0,
                this.proxySourceCache.deallocRenderCache(),
                this._style))
                    for (const t in this._style._sourceCaches)
                        this._style._sourceCaches[t].usedForTerrain = !1;
            }
            destroy() {
                this._disable(),
                this._emptyDEMTexture && this._emptyDEMTexture.destroy(),
                this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(),
                this.pool.forEach((t => t.fb.destroy())),
                this.pool = [],
                this._depthFBO && (this._depthFBO.destroy(),
                this._depthFBO = void 0,
                this._depthTexture = void 0);
            }
            _source() {
                return this.enabled ? this.sourceCache : null
            }
            isUsingMockSource() {
                return this.sourceCache === this._mockSourceCache
            }
            exaggeration() {
                return this._exaggeration
            }
            get visibleDemTiles() {
                return this._visibleDemTiles
            }
            get drapeBufferSize() {
                const t = 2 * this.proxySourceCache.getSource().tileSize;
                return [t, t]
            }
            set useVertexMorphing(t) {
                this._useVertexMorphing = t;
            }
            updateTileBinding(e) {
                if (!this.enabled)
                    return;
                this.prevTerrainTileForTile = this.terrainTileForTile;
                const i = this.proxySourceCache
                  , r = this.painter.transform;
                this._initializing && (this._initializing = 0 === r._centerAltitude && -1 === this.getAtPointOrZero(t.MercatorCoordinate.fromLngLat(r.center), -1),
                this._emptyDEMTextureDirty = !this._initializing);
                const o = this.proxyCoords = i.getIds().map((t => {
                    const e = i.getTileByID(t).tileID;
                    return e.projMatrix = r.calculateProjMatrix(e.toUnwrapped()),
                    e
                }
                ));
                !function(e, i) {
                    const r = i.transform.pointCoordinate(i.transform.getCameraPoint())
                      , o = new t.pointGeometry(r.x,r.y);
                    e.sort(( (e, i) => {
                        if (i.overscaledZ - e.overscaledZ)
                            return i.overscaledZ - e.overscaledZ;
                        const r = new t.pointGeometry(e.canonical.x + (1 << e.canonical.z) * e.wrap,e.canonical.y)
                          , n = new t.pointGeometry(i.canonical.x + (1 << i.canonical.z) * i.wrap,i.canonical.y)
                          , s = o.mult(1 << e.canonical.z);
                        return s.x -= .5,
                        s.y -= .5,
                        s.distSqr(r) - s.distSqr(n)
                    }
                    ));
                }(o, this.painter),
                this._previousZoom = r.zoom;
                const n = this.proxyToSource || {};
                this.proxyToSource = {},
                o.forEach((t => {
                    this.proxyToSource[t.key] = {};
                }
                )),
                this.terrainTileForTile = {};
                const s = this._style._sourceCaches;
                for (const t in s) {
                    const i = s[t];
                    if (!i.used)
                        continue;
                    if (i !== this.sourceCache && this.resetTileLookupCache(i.id),
                    this._setupProxiedCoordsForOrtho(i, e[t], n),
                    i.usedForTerrain)
                        continue;
                    const r = e[t];
                    i.getSource().reparseOverscaled && (this._assignTerrainTiles(r),
                    this._assignTerrainTiles_sg4326(i));
                }
                this.proxiedCoords[i.id] = o.map((t => new ao(t,t.key,this.orthoMatrix))),
                this._assignTerrainTiles(o),
                this._prepareDEMTextures(),
                this._setupDrapedRenderBatches(),
                this._initFBOPool(),
                this._setupRenderCache(n),
                this.renderingToTexture = !1,
                this._updateTimestamp = t.exported.now();
                const a = {};
                this._visibleDemTiles = [];
                for (const t of this.proxyCoords) {
                    const e = this.terrainTileForTile[t.key];
                    if (!e)
                        continue;
                    const i = e.tileID.key;
                    i in a || (this._visibleDemTiles.push(e),
                    a[i] = i);
                }
            }
            _assignTerrainTiles(t) {
                this._initializing || t.forEach((t => {
                    if (this.terrainTileForTile[t.key])
                        return;
                    const e = this._findTileCoveringTileID(t, this.sourceCache);
                    e && (this.terrainTileForTile[t.key] = e);
                }
                ));
            }
            _assignTerrainTiles_sg4326(e) {
                if (this._initializing)
                    return;
                let i = this
                  , r = this.sourceCache;
                for (let o in e._tiles) {
                    let n = e._tiles[o].tileID;
                    if ("Sg4326" != n.reference)
                        break;
                    if (i.terrainTileForTile[n.key])
                        continue;
                    let s = Object.values(r._tiles).sort(( (t, e) => t.tileID.canonical.z - e.tileID.canonical.z));
                    for (let t = 0; t < s.length; t++) {
                        let e = s[t].tileID
                          , r = this._get_tile_bbox(e)
                          , o = this._get_tile_bbox(n);
                        if (i._is_overCover(r, o)) {
                            this.terrainTileForTile[n.key] = s[t];
                            break
                        }
                        i._tileContain_sg4326(e, n) && (this.terrainTileForTile[n.key] || (this.terrainTileForTile[n.key] = []),
                        this.terrainTileForTile[n.key].push(s[t]));
                    }
                    if (this.terrainTileForTile[n.key] && Array.isArray(this.terrainTileForTile[n.key]) && this.terrainTileForTile[n.key].length > 0) {
                        const i = this.terrainTileForTile[n.key].length;
                        if (1 == i)
                            this.terrainTileForTile[n.key] = this.terrainTileForTile[n.key][0];
                        else if (i > 2) {
                            let r = n.canonical
                              , s = null
                              , a = 0;
                            for (let t = 0; t < i; t++) {
                                let e = this.terrainTileForTile[n.key][t]
                                  , i = e.tileID.canonical
                                  , o = Math.pow(2, r.z - i.z);
                                if (!e.dem)
                                    return;
                                let l = e.dem.getPixels();
                                this._offscreenCanvas || (this._offscreenCanvas = new OffscreenCanvas(l.width,l.height),
                                this._offscreenCanvasContext = this._offscreenCanvas.getContext("2d", {
                                    willReadFrequently: !0
                                }),
                                this._offscreenCanvas.width = l.width,
                                this._offscreenCanvas.height = l.height,
                                this._offscreenCanvas2 = new OffscreenCanvas(l.width,l.height),
                                this._offscreenCanvasContext2 = this._offscreenCanvas2.getContext("2d", {
                                    willReadFrequently: !0
                                }),
                                this._offscreenCanvas2.width = l.width,
                                this._offscreenCanvas2.height = l.height),
                                s || (s = e.dem);
                                let c = new ImageData(new Uint8ClampedArray(l.data),l.width,l.height);
                                this._offscreenCanvasContext2.putImageData(c, 0, 0),
                                this._offscreenCanvasContext.drawImage(this._offscreenCanvas2, 0, 0, l.width, l.height, (i.x * o - r.x) * l.width, (i.y * o - r._tileY) * l.height, l.width * o, l.height * o),
                                a++;
                            }
                            if (a == i) {
                                this.terrainTileForTile[n.key] = e._tiles[o];
                                let i = this.sourceCache.getSource().tileSize
                                  , r = 1
                                  , a = this._offscreenCanvasContext.getImageData(-r, -r, i + 2 * r, i + 2 * r);
                                this.terrainTileForTile[n.key].dem = new t.DEMData(this.terrainTileForTile[n.key].uid,a,s.encoding,s.borderReady,!0),
                                this.terrainTileForTile[n.key].needsDEMTextureUpload = !0;
                            }
                            this._offscreenCanvasContext.clearRect(0, 0, this._offscreenCanvas.width, this._offscreenCanvas.height),
                            this._offscreenCanvasContext2.clearRect(0, 0, this._offscreenCanvas2.width, this._offscreenCanvas2.height);
                        }
                    }
                }
            }
            _is_overCover(t, e) {
                return t[0][0] <= e[0][0] && t[0][1] <= e[0][1] && t[1][0] >= e[1][0] && t[1][1] >= e[1][1]
            }
            _prepareDEMTextures() {
                const t = this.painter.context
                  , e = t.gl;
                for (const i in this.terrainTileForTile) {
                    const r = this.terrainTileForTile[i];
                    if (Array.isArray(r)) {
                        let i = [1, 5];
                        for (let o = 0; o < r.length; o++) {
                            let n = r[o];
                            const s = n.dem;
                            !s || n.demTexture && !n.needsDEMTextureUpload || (t.activeTexture.set(e["TEXTURE" + i[o]]),
                            Xr(this.painter, n, s));
                        }
                    } else {
                        const i = r.dem;
                        !i || r.demTexture && !r.needsDEMTextureUpload || (t.activeTexture.set(e.TEXTURE1),
                        Xr(this.painter, r, i));
                    }
                }
            }
            _prepareDemTileUniforms(t, e, i, r) {
                if (!e || null == e.demTexture)
                    return !1;
                const o = t.tileID.canonical
                  , n = e.tileID.canonical
                  , s = Math.pow(2, n.z - o.z)
                  , a = r || "";
                return i["u_dem_tl" + a] = [o.x * s % 1, (o._tileY * s - n.y) % 1],
                i["u_dem_scale" + a] = s,
                i.u_dem_tile_radio = [1, o._tileH],
                !0
            }
            get emptyDEMTexture() {
                return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture()
            }
            get emptyDepthBufferTexture() {
                const e = this.painter.context
                  , i = e.gl;
                if (!this._emptyDepthBufferTexture) {
                    const r = new t.RGBAImage({
                        width: 1,
                        height: 1
                    },Uint8Array.of(255, 255, 255, 255));
                    this._emptyDepthBufferTexture = new t.Texture(e,r,i.RGBA,{
                        premultiply: !1
                    });
                }
                return this._emptyDepthBufferTexture
            }
            _getLoadedAreaMinimum() {
                let t = 0;
                const e = this._visibleDemTiles.reduce(( (e, i) => {
                    if (!i.dem)
                        return e;
                    const r = i.dem.tree.minimums[0];
                    return r > 0 && t++,
                    e + r
                }
                ), 0);
                return t ? e / t : 0
            }
            _updateEmptyDEMTexture() {
                const e = this.painter.context
                  , i = e.gl;
                e.activeTexture.set(i.TEXTURE2);
                const r = this._getLoadedAreaMinimum()
                  , o = new t.RGBAImage({
                    width: 1,
                    height: 1
                },new Uint8Array(t.DEMData.pack(r, this.sourceCache.getSource().encoding)));
                this._emptyDEMTextureDirty = !1;
                let n = this._emptyDEMTexture;
                return n ? n.update(o, {
                    premultiply: !1
                }) : n = this._emptyDEMTexture = new t.Texture(e,o,i.RGBA,{
                    premultiply: !1
                }),
                n
            }
            setupElevationDraw(e, i, r) {
                const o = this.painter.context
                  , n = o.gl
                  , s = (a = this.sourceCache.getSource().encoding,
                {
                    u_dem: 2,
                    u_dem_prev: 4,
                    u_dem_unpack: t.DEMData.getUnpackVector(a),
                    u_dem_tl: [0, 0],
                    u_dem_tl_prev: [0, 0],
                    u_dem_scale: 0,
                    u_dem_scale_prev: 0,
                    u_dem_size: 0,
                    u_dem_lerp: 1,
                    u_depth: 3,
                    u_depth_size_inv: [0, 0],
                    u_exaggeration: 0,
                    u_tile_tl_up: [0, 0, 1],
                    u_tile_tr_up: [0, 0, 1],
                    u_tile_br_up: [0, 0, 1],
                    u_tile_bl_up: [0, 0, 1],
                    u_tile_up_scale: 1,
                    u_dem_tile_radio: [1, 1],
                    u_dem_6: 6,
                    u_dem_tl_6: [0, 0],
                    u_dem_scale_6: 0
                });
                var a;
                s.u_dem_size = this.sourceCache.getSource().tileSize,
                s.u_exaggeration = this.exaggeration();
                const l = this.painter.transform
                  , c = l.projection
                  , h = e.tileID.canonical;
                s.u_tile_tl_up = c.upVector(h, 0, 0),
                s.u_tile_tr_up = c.upVector(h, t.EXTENT, 0),
                s.u_tile_br_up = c.upVector(h, t.EXTENT, t.EXTENT),
                s.u_tile_bl_up = c.upVector(h, 0, t.EXTENT),
                s.u_tile_up_scale = r && r.useDenormalizedUpVectorScale ? t.GLOBE_METERS_TO_ECEF : c.upVectorScale(h, l.center.lat, l.worldSize).metersToTile;
                let u = null
                  , d = null
                  , f = 1;
                if (r && r.morphing && this._useVertexMorphing) {
                    const t = r.morphing.srcDemTile
                      , i = r.morphing.dstDemTile;
                    f = r.morphing.phase,
                    t && i && (this._prepareDemTileUniforms(e, t, s, "_prev") && (d = t),
                    this._prepareDemTileUniforms(e, i, s) && (u = i));
                }
                if (d && u)
                    o.activeTexture.set(n.TEXTURE2),
                    u.demTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE, n.NEAREST),
                    o.activeTexture.set(n.TEXTURE4),
                    d.demTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE, n.NEAREST),
                    s.u_dem_lerp = f;
                else if (u = this.terrainTileForTile[e.tileID.key],
                Array.isArray(u))
                    for (var _ = [2, 6], p = [null, "_6"], m = 0; m < u.length; m++) {
                        var g = u[m];
                        o.activeTexture.set(n["TEXTURE" + _[m]]),
                        (this._prepareDemTileUniforms(e, g, s, p[m]) ? g.demTexture : this.emptyDEMTexture).bind(n.NEAREST, n.CLAMP_TO_EDGE);
                    }
                else
                    o.activeTexture.set(n.TEXTURE2),
                    (this._prepareDemTileUniforms(e, u, s) ? u.demTexture : this.emptyDEMTexture).bind(n.NEAREST, n.CLAMP_TO_EDGE);
                if (o.activeTexture.set(n.TEXTURE3),
                r && r.useDepthForOcclusion ? (this._depthTexture && this._depthTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE),
                this._depthFBO && (s.u_depth_size_inv = [1 / this._depthFBO.width, 1 / this._depthFBO.height])) : (this.emptyDepthBufferTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE),
                s.u_depth_size_inv = [1, 1]),
                r && r.useMeterToDem && u)
                    if (Array.isArray(u)) {
                        p = ["", "_6"];
                        let e = this.painter.transform.center.lat
                          , i = this.sourceCache.getSource().tileSize;
                        for (m = 0; m < u.length; m++) {
                            const r = (1 << (g = u[m]).tileID.canonical.z) * t.mercatorZfromAltitude(1, e) * i;
                            s["u_meter_to_dem" + p[m]] = r;
                        }
                    } else {
                        const e = (1 << u.tileID.canonical.z) * t.mercatorZfromAltitude(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
                        s.u_meter_to_dem = e;
                    }
                r && r.labelPlaneMatrixInv && (s.u_label_plane_matrix_inv = r.labelPlaneMatrixInv),
                i.setTerrainUniformValues(o, s);
            }
            renderToBackBuffer(e) {
                const i = this.painter
                  , r = this.painter.context;
                0 !== e.length && (r.bindFramebuffer.set(null),
                r.viewport.set([0, 0, i.width, i.height]),
                i.gpuTimingDeferredRenderStart(),
                this.renderingToTexture = !1,
                function(e, i, r, o, n) {
                    if ("globe" === e.transform.projection.name)
                        !function(e, i, r, o, n) {
                            const s = e.context
                              , a = s.gl;
                            let l, c;
                            const h = e.options.showTerrainWireframe ? 2 : 0
                              , u = e.transform
                              , d = t.globeUseCustomAntiAliasing(e, s, u)
                              , f = (t, i) => {
                                if (c === t)
                                    return;
                                const r = [eo[t], "PROJECTION_GLOBE_VIEW"];
                                d && r.push("CUSTOM_ANTIALIASING"),
                                i && r.push(eo[h]),
                                l = e.useProgram("globeRaster", null, r),
                                c = t;
                            }
                              , _ = e.colorModeForRenderPass()
                              , p = new t.DepthMode(a.LEQUAL,t.DepthMode.ReadWrite,e.depthRangeFor3D);
                            to.update(n);
                            const m = t.calculateGlobeMercatorMatrix(u)
                              , g = [t.mercatorXfromLng(u.center.lng), t.mercatorYfromLat(u.center.lat)]
                              , v = h ? [!1, !0] : [!1]
                              , y = e.globeSharedBuffers
                              , b = [u.width * t.exported.devicePixelRatio, u.height * t.exported.devicePixelRatio]
                              , x = Float32Array.from(u.globeMatrix)
                              , w = {
                                useDenormalizedUpVectorScale: !0
                            };
                            if (v.forEach((h => {
                                c = -1;
                                const d = h ? a.LINES : a.TRIANGLES;
                                for (const c of o) {
                                    const o = r.getTile(c)
                                      , v = t.StencilMode.disabled
                                      , T = i.prevTerrainTileForTile[c.key]
                                      , E = i.terrainTileForTile[c.key];
                                    Qr(T, E) && to.newMorphing(c.key, T, E, n, 250),
                                    s.activeTexture.set(a.TEXTURE0),
                                    o.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);
                                    const S = to.getMorphValuesForProxy(c.key)
                                      , C = S ? 1 : 0;
                                    S && t.extend$1(w, {
                                        morphing: {
                                            srcDemTile: S.from,
                                            dstDemTile: S.to,
                                            phase: t.easeCubicInOut(S.phase)
                                        }
                                    });
                                    const A = t.tileCornersToBounds(c.canonical)
                                      , M = t.getLatitudinalLod(A.getCenter().lat)
                                      , I = t.getGridMatrix(c.canonical, A, M, u.worldSize / u._pixelsPerMercatorPixel)
                                      , z = t.globeNormalizeECEF(t.globeTileBounds(c.canonical))
                                      , P = $r(u.projMatrix, x, m, z, t.globeToMercatorTransition(u.zoom), g, u.frustumCorners.TL, u.frustumCorners.TR, u.frustumCorners.BR, u.frustumCorners.BL, u.globeCenterInViewSpace, u.globeRadius, b, I);
                                    if (f(C, h),
                                    i.setupElevationDraw(o, l, w),
                                    e.prepareDrawProgram(s, l, c.toUnwrapped()),
                                    y) {
                                        const [i,r,o] = h ? y.getWirefameBuffers(e.context, M) : y.getGridBuffers(M);
                                        l.draw(s, d, p, v, _, t.CullFaceMode.backCCW, P, "globe_raster", i, r, o);
                                    }
                                }
                            }
                            )),
                            y) {
                                const n = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                                d && n.push("CUSTOM_ANTIALIASING"),
                                l = e.useProgram("globeRaster", null, n);
                                for (const n of o) {
                                    const {x: o, y: c, z: h} = n.canonical
                                      , d = 0 === c
                                      , f = c === (1 << h) - 1
                                      , [m,v,x,T] = y.getPoleBuffers(h);
                                    if (T && (d || f)) {
                                        const c = r.getTile(n);
                                        s.activeTexture.set(a.TEXTURE0),
                                        c.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);
                                        let y = t.globePoleMatrixForTile(h, o, u);
                                        const E = t.globeNormalizeECEF(t.globeTileBounds(n.canonical))
                                          , S = (e, i) => e.draw(s, a.TRIANGLES, p, t.StencilMode.disabled, _, t.CullFaceMode.disabled, $r(u.projMatrix, y, y, E, 0, g, u.frustumCorners.TL, u.frustumCorners.TR, u.frustumCorners.BR, u.frustumCorners.BL, u.globeCenterInViewSpace, u.globeRadius, b), "globe_pole_raster", i, x, T);
                                        i.setupElevationDraw(c, l, w),
                                        e.prepareDrawProgram(s, l, n.toUnwrapped()),
                                        d && S(l, m),
                                        f && (y = t.scale(t.create(), y, [1, -1, 1]),
                                        S(l, v));
                                    }
                                }
                            }
                        }(e, i, r, o, n);
                    else {
                        const s = e.context
                          , a = s.gl;
                        let l, c;
                        const h = e.options.showTerrainWireframe ? 2 : 0
                          , u = (t, i) => {
                            if (c === t)
                                return;
                            const r = [eo[t]];
                            i && r.push(eo[h]),
                            l = e.useProgram("terrainRaster", null, r),
                            c = t;
                        }
                          , d = e.colorModeForRenderPass()
                          , f = new t.DepthMode(a.LEQUAL,t.DepthMode.ReadWrite,e.depthRangeFor3D);
                        to.update(n);
                        const _ = e.transform
                          , p = 6 * Math.pow(1.5, 22 - _.zoom) * i.exaggeration();
                        (h ? [!1, !0] : [!1]).forEach((h => {
                            c = -1;
                            const m = h ? a.LINES : a.TRIANGLES
                              , [g,v] = h ? i.getWirefameBuffer() : [i.gridIndexBuffer, i.gridSegments];
                            for (const c of o) {
                                const o = r.getTile(c)
                                  , y = t.StencilMode.disabled
                                  , b = i.prevTerrainTileForTile[c.key]
                                  , x = i.terrainTileForTile[c.key];
                                Qr(b, x) && to.newMorphing(c.key, b, x, n, 250),
                                s.activeTexture.set(a.TEXTURE0),
                                o.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST);
                                const w = to.getMorphValuesForProxy(c.key)
                                  , T = w ? 1 : 0;
                                let E;
                                w && (E = {
                                    morphing: {
                                        srcDemTile: w.from,
                                        dstDemTile: w.to,
                                        phase: t.easeCubicInOut(w.phase)
                                    }
                                });
                                const S = Jr(c.projMatrix, io(c.canonical, _.renderWorldCopies) ? p / 10 : p);
                                u(T, h),
                                i.setupElevationDraw(o, l, E),
                                e.prepareDrawProgram(s, l, c.toUnwrapped()),
                                l.draw(s, m, f, y, d, t.CullFaceMode.backCCW, S, "terrain_raster", i.gridBuffer, g, v);
                            }
                        }
                        ));
                    }
                }(i, this, this.proxySourceCache, e, this._updateTimestamp),
                this.renderingToTexture = !0,
                i.gpuTimingDeferredRenderEnd(),
                e.splice(0, e.length));
            }
            renderBatch(e) {
                if (0 === this._drapedRenderBatches.length)
                    return e + 1;
                this.renderingToTexture = !0;
                const i = this.painter
                  , r = this.painter.context
                  , o = this.proxySourceCache
                  , n = this.proxiedCoords[o.id]
                  , s = this._drapedRenderBatches.shift()
                  , a = []
                  , l = i.style.order;
                let c = 0;
                for (const h of n) {
                    const n = o.getTileByID(h.proxyTileKey)
                      , u = o.proxyCachedFBO[h.key] ? o.proxyCachedFBO[h.key][e] : void 0
                      , d = void 0 !== u ? o.renderCache[u] : this.pool[c++]
                      , f = void 0 !== u;
                    if (n.texture = d.tex,
                    f && !d.dirty) {
                        a.push(n.tileID);
                        continue
                    }
                    let _;
                    r.bindFramebuffer.set(d.fb.framebuffer),
                    this.renderedToTile = !1,
                    d.dirty && (r.clear({
                        color: t.Color.transparent,
                        stencil: 0
                    }),
                    d.dirty = !1);
                    for (let t = s.start; t <= s.end; ++t) {
                        const e = i.style._layers[l[t]];
                        if (e.isHidden(i.transform.zoom))
                            continue;
                        const o = i.style._getLayerSourceCache(e)
                          , n = o ? this.proxyToSource[h.key][o.id] : [h];
                        if (!n)
                            continue;
                        const s = n;
                        r.viewport.set([0, 0, d.fb.width, d.fb.height]),
                        _ !== (o ? o.id : null) && (this._setupStencil(d, n, e, o),
                        _ = o ? o.id : null),
                        i.renderLayer(i, o, e, s);
                    }
                    this.renderedToTile ? (d.dirty = !0,
                    a.push(n.tileID)) : f || --c,
                    5 === c && (c = 0,
                    this.renderToBackBuffer(a));
                }
                return this.renderToBackBuffer(a),
                this.renderingToTexture = !1,
                r.bindFramebuffer.set(null),
                r.viewport.set([0, 0, i.width, i.height]),
                s.end + 1
            }
            postRender() {}
            renderCacheEfficiency(t) {
                const e = t.order.length;
                if (0 === e)
                    return {
                        efficiency: 100
                    };
                let i, r = 0, o = 0, n = !1;
                for (let s = 0; s < e; ++s) {
                    const e = t._layers[t.order[s]];
                    this._style.isLayerDraped(e) ? (n && ++r,
                    ++o) : n || (n = !0,
                    i = e.id);
                }
                return 0 === o ? {
                    efficiency: 100
                } : {
                    efficiency: 100 * (1 - r / o),
                    firstUndrapedLayer: i
                }
            }
            getMinElevationBelowMSL() {
                let t = 0;
                return this._visibleDemTiles.filter((t => t.dem)).forEach((e => {
                    t = Math.min(t, e.dem.tree.minimums[0]);
                }
                )),
                0 === t ? t : (t - 30) * this._exaggeration
            }
            raycast(t, e, i) {
                if (!this._visibleDemTiles)
                    return null;
                const r = this._visibleDemTiles.filter((t => t.dem)).map((r => {
                    const o = r.tileID
                      , n = 1 << o.overscaledZ
                      , {x: s} = o.canonical
                      , a = s / n
                      , l = (s + 1) / n
                      , c = o.canonical._tileY / n
                      , h = (o.canonical._tileY + o.canonical._tileH) / n;
                    return {
                        minx: a,
                        miny: c,
                        maxx: l,
                        maxy: h,
                        t: r.dem.tree.raycastRoot(a, c, l, h, t, e, i),
                        tile: r
                    }
                }
                ));
                r.sort(( (t, e) => (null !== t.t ? t.t : Number.MAX_VALUE) - (null !== e.t ? e.t : Number.MAX_VALUE)));
                for (const o of r) {
                    if (null == o.t)
                        return null;
                    const r = o.tile.dem.tree.raycast(o.minx, o.miny, o.maxx, o.maxy, t, e, i);
                    if (null != r)
                        return r
                }
                return null
            }
            _createFBO() {
                const e = this.painter.context
                  , i = e.gl
                  , r = this.drapeBufferSize;
                e.activeTexture.set(i.TEXTURE0);
                const o = new t.Texture(e,{
                    width: r[0],
                    height: r[1],
                    data: null
                },i.RGBA);
                o.bind(i.LINEAR, i.CLAMP_TO_EDGE);
                const n = e.createFramebuffer(r[0], r[1], !1);
                return n.colorAttachment.set(o.texture),
                n.depthAttachment = new Lt(e,n.framebuffer),
                void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = e.createRenderbuffer(e.gl.DEPTH_STENCIL, r[0], r[1]),
                this._stencilRef = 0,
                n.depthAttachment.set(this._sharedDepthStencil),
                e.clear({
                    stencil: 0
                })) : n.depthAttachment.set(this._sharedDepthStencil),
                e.extTextureFilterAnisotropic && !e.extTextureFilterAnisotropicForceOff && i.texParameterf(i.TEXTURE_2D, e.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, e.extTextureFilterAnisotropicMax),
                {
                    fb: n,
                    tex: o,
                    dirty: !1
                }
            }
            _initFBOPool() {
                for (; this.pool.length < Math.min(5, this.proxyCoords.length); )
                    this.pool.push(this._createFBO());
            }
            _shouldDisableRenderCache() {
                if (this._style.light && this._style.light.hasTransition())
                    return !0;
                for (const t in this._style._sourceCaches)
                    if (this._style._sourceCaches[t].hasTransition())
                        return !0;
                return this._style.order.some((t => {
                    const e = this._style._layers[t]
                      , i = e.isHidden(this.painter.transform.zoom)
                      , r = e.getCrossfadeParameters()
                      , o = !!r && 1 !== r.t
                      , n = e.hasTransition();
                    return "custom" !== e.type && !i && (o || n)
                }
                ))
            }
            _clearRasterFadeFromRenderCache() {
                let t = !1;
                for (const e in this._style._sourceCaches)
                    if (this._style._sourceCaches[e]._source instanceof Ot) {
                        t = !0;
                        break
                    }
                if (t)
                    for (let t = 0; t < this._style.order.length; ++t) {
                        const e = this._style._layers[this._style.order[t]]
                          , i = e.isHidden(this.painter.transform.zoom)
                          , r = this._style._getLayerSourceCache(e);
                        if ("raster" !== e.type || i || !r)
                            continue;
                        const o = e.paint.get("raster-fade-duration");
                        for (const t of this.proxyCoords) {
                            const e = this.proxyToSource[t.key][r.id];
                            if (e)
                                for (const t of e) {
                                    const e = oo(r.getTile(t), r.findLoadedParent(t, 0), r, this.painter.transform, o);
                                    (1 !== e.opacity || 0 !== e.mix) && this._clearRenderCacheForTile(r.id, t);
                                }
                        }
                    }
            }
            _setupDrapedRenderBatches() {
                const t = this._style.order
                  , e = t.length;
                if (0 === e)
                    return;
                const i = [];
                let r, o = 0, n = this._style._layers[t[o]];
                for (; !this._style.isLayerDraped(n) && n.isHidden(this.painter.transform.zoom) && ++o < e; )
                    n = this._style._layers[t[o]];
                for (; o < e; ++o) {
                    const e = this._style._layers[t[o]];
                    e.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(e) ? void 0 === r && (r = o) : void 0 !== r && (i.push({
                        start: r,
                        end: o - 1
                    }),
                    r = void 0));
                }
                void 0 !== r && i.push({
                    start: r,
                    end: o - 1
                }),
                this._drapedRenderBatches = i;
            }
            _setupRenderCache(t) {
                const e = this.proxySourceCache;
                if (this._shouldDisableRenderCache() || this._invalidateRenderCache) {
                    if (this._invalidateRenderCache = !1,
                    e.renderCache.length > e.renderCachePool.length) {
                        const t = Object.values(e.proxyCachedFBO);
                        e.proxyCachedFBO = {};
                        for (let i = 0; i < t.length; ++i) {
                            const r = Object.values(t[i]);
                            e.renderCachePool.push(...r);
                        }
                    }
                    return
                }
                this._clearRasterFadeFromRenderCache();
                const i = this.proxyCoords
                  , r = this._tilesDirty;
                for (let o = i.length - 1; o >= 0; o--) {
                    const n = i[o];
                    if (e.getTileByID(n.key),
                    void 0 !== e.proxyCachedFBO[n.key]) {
                        const i = t[n.key]
                          , o = this.proxyToSource[n.key];
                        let s = 0;
                        for (const t in o) {
                            const e = o[t]
                              , n = i[t];
                            if (!n || n.length !== e.length || e.some(( (e, i) => e !== n[i] || r[t] && r[t].hasOwnProperty(e.key)))) {
                                s = -1;
                                break
                            }
                            ++s;
                        }
                        for (const t in e.proxyCachedFBO[n.key])
                            e.renderCache[e.proxyCachedFBO[n.key][t]].dirty = s < 0 || s !== Object.values(i).length;
                    }
                }
                const o = [...this._drapedRenderBatches];
                o.sort(( (t, e) => e.end - e.start - (t.end - t.start)));
                for (const t of o)
                    for (const r of i) {
                        if (e.proxyCachedFBO[r.key])
                            continue;
                        let i = e.renderCachePool.pop();
                        void 0 === i && e.renderCache.length < 50 && (i = e.renderCache.length,
                        e.renderCache.push(this._createFBO())),
                        void 0 !== i && (e.proxyCachedFBO[r.key] = {},
                        e.proxyCachedFBO[r.key][t.start] = i,
                        e.renderCache[i].dirty = !0);
                    }
                this._tilesDirty = {};
            }
            _setupStencil(t, e, i, r) {
                if (!r || !this._sourceTilesOverlap[r.id])
                    return void (this._overlapStencilType && (this._overlapStencilType = !1));
                const o = this.painter.context
                  , n = o.gl;
                if (e.length <= 1)
                    return void (this._overlapStencilType = !1);
                let s;
                if (i.isTileClipped())
                    s = e.length,
                    this._overlapStencilMode.test = {
                        func: n.EQUAL,
                        mask: 255
                    },
                    this._overlapStencilType = "Clip";
                else {
                    if (!(e[0].overscaledZ > e[e.length - 1].overscaledZ))
                        return void (this._overlapStencilType = !1);
                    s = 1,
                    this._overlapStencilMode.test = {
                        func: n.GREATER,
                        mask: 255
                    },
                    this._overlapStencilType = "Mask";
                }
                this._stencilRef + s > 255 && (o.clear({
                    stencil: 0
                }),
                this._stencilRef = 0),
                this._stencilRef += s,
                this._overlapStencilMode.ref = this._stencilRef,
                i.isTileClipped() && this._renderTileClippingMasks(e, this._overlapStencilMode.ref);
            }
            clipOrMaskOverlapStencilType() {
                return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType
            }
            stencilModeForRTTOverlap(e) {
                return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[e.key]),
                this._overlapStencilMode) : t.StencilMode.disabled
            }
            _renderTileClippingMasks(e, i) {
                const r = this.painter
                  , o = this.painter.context
                  , n = o.gl;
                r._tileClippingMaskIDs = {},
                o.setColorMode(t.ColorMode.disabled),
                o.setDepthMode(t.DepthMode.disabled);
                const s = r.useProgram("clippingMask");
                for (const a of e) {
                    const e = r._tileClippingMaskIDs[a.key] = --i;
                    s.draw(o, n.TRIANGLES, t.DepthMode.disabled, new t.StencilMode({
                        func: n.ALWAYS,
                        mask: 0
                    },e,255,n.KEEP,n.KEEP,n.REPLACE), t.ColorMode.disabled, t.CullFaceMode.disabled, ro(a.projMatrix), "$clipping", r.tileExtentBuffer, r.quadTriangleIndexBuffer, r.tileExtentSegments);
                }
            }
            pointCoordinate(e) {
                const i = this.painter.transform;
                if (e.x < 0 || e.x > i.width || e.y < 0 || e.y > i.height)
                    return null;
                const r = [e.x, e.y, 1, 1];
                t.transformMat4$1(r, r, i.pixelMatrixInverse),
                t.scale$1(r, r, 1 / r[3]),
                r[0] /= i.worldSize,
                r[1] /= i.worldSize;
                const o = i._camera.position
                  , n = t.mercatorZfromAltitude(1, i.center.lat)
                  , s = [o[0], o[1], o[2] / n, 0]
                  , a = t.subtract([], r.slice(0, 3), s);
                t.normalize(a, a);
                const l = this.raycast(s, a, this._exaggeration);
                return null !== l && l ? (t.scaleAndAdd(s, s, a, l),
                s[3] = s[2],
                s[2] *= n,
                s) : null
            }
            drawDepth() {
                const e = this.painter
                  , i = e.context
                  , r = this.proxySourceCache
                  , o = Math.ceil(e.width)
                  , n = Math.ceil(e.height);
                if (!this._depthFBO || this._depthFBO.width === o && this._depthFBO.height === n || (this._depthFBO.destroy(),
                this._depthFBO = void 0,
                this._depthTexture = void 0),
                !this._depthFBO) {
                    const e = i.gl
                      , r = i.createFramebuffer(o, n, !0);
                    i.activeTexture.set(e.TEXTURE0);
                    const s = new t.Texture(i,{
                        width: o,
                        height: n,
                        data: null
                    },e.RGBA);
                    s.bind(e.NEAREST, e.CLAMP_TO_EDGE),
                    r.colorAttachment.set(s.texture);
                    const a = i.createRenderbuffer(i.gl.DEPTH_COMPONENT16, o, n);
                    r.depthAttachment.set(a),
                    this._depthFBO = r,
                    this._depthTexture = s;
                }
                i.bindFramebuffer.set(this._depthFBO.framebuffer),
                i.viewport.set([0, 0, o, n]),
                function(e, i, r, o) {
                    if ("globe" === e.transform.projection.name)
                        return;
                    const n = e.context
                      , s = n.gl;
                    n.clear({
                        depth: 1
                    });
                    const a = e.useProgram("terrainDepth")
                      , l = new t.DepthMode(s.LESS,t.DepthMode.ReadWrite,e.depthRangeFor3D);
                    for (const e of o) {
                        const o = r.getTile(e)
                          , c = Jr(e.projMatrix, 0);
                        i.setupElevationDraw(o, a),
                        a.draw(n, s.TRIANGLES, l, t.StencilMode.disabled, t.ColorMode.unblended, t.CullFaceMode.backCCW, c, "terrain_depth", i.gridBuffer, i.gridIndexBuffer, i.gridNoSkirtSegments);
                    }
                }(e, this, r, this.proxyCoords);
            }
            _setupProxiedCoordsForOrtho(e, i, r) {
                if (e.getSource()instanceof jt)
                    return this._setupProxiedCoordsForImageSource(e, i, r);
                this._findCoveringTileCache[e.id] = this._findCoveringTileCache[e.id] || {};
                const o = this.proxiedCoords[e.id] = []
                  , n = this.proxyCoords;
                let s = "Sg4326" == e.getSource().reference;
                for (let i = 0; i < n.length; i++) {
                    const a = n[i]
                      , l = this._findTileCoveringTileID(a, e);
                    if (s)
                        this._findTileCoveringTileID_sg4326(a, e).forEach((i => {
                            const r = a.canonical.z - i.tileID.canonical.z
                              , n = i.tileID.wrap - a.wrap << a.overscaledZ;
                            let s, l, c;
                            if (r > 0) {
                                let e = Math.pow(2, r);
                                s = t.EXTENT >> r,
                                l = s * ((i.tileID.canonical.x << r) - a.canonical.x + n),
                                c = s * (i.tileID._tileY * e - a.canonical.y);
                            } else
                                s = t.EXTENT << -r,
                                l = t.EXTENT * (i.tileID.canonical.x - (a.canonical.x + n << -r)),
                                c = t.EXTENT * (i.tileID._tileY - (a.canonical.y << -r));
                            let h = t.create();
                            t.ortho(h, 0, s, 0, s, 0, 1),
                            t.translate(h, h, [l, c, 0]),
                            t.scale(h, h, [1, i.tileID._tileH, 1]);
                            let u = new ao(i.tileID,a.key,h);
                            o.push(u),
                            this.proxyToSource[a.key][e.id] || (this.proxyToSource[a.key][e.id] = []),
                            this.proxyToSource[a.key][e.id].push(u);
                        }
                        ));
                    else if (l) {
                        const t = this._createProxiedId(a, l, r[a.key] && r[a.key][e.id]);
                        o.push(t),
                        this.proxyToSource[a.key][e.id] = [t];
                    }
                }
                let a = !1;
                for (let t = 0; t < i.length; t++) {
                    const n = e.getTile(i[t]);
                    if (!n || !n.hasData())
                        continue;
                    const s = this._findTileCoveringTileID(n.tileID, this.proxySourceCache);
                    if (s && s.tileID.canonical.z !== n.tileID.canonical.z) {
                        const t = this.proxyToSource[s.tileID.key][e.id]
                          , i = this._createProxiedId(s.tileID, n, r[s.tileID.key] && r[s.tileID.key][e.id]);
                        t ? t.splice(t.length - 1, 0, i) : this.proxyToSource[s.tileID.key][e.id] = [i],
                        o.push(i),
                        a = !0;
                    }
                }
                this._sourceTilesOverlap[e.id] = a;
            }
            _setupProxiedCoordsForImageSource(e, i, r) {
                if (!e.getSource().loaded())
                    return;
                const o = this.proxiedCoords[e.id] = []
                  , n = this.proxyCoords
                  , s = e.getSource()
                  , a = new t.pointGeometry(s.tileID.x,s.tileID.y)._div(1 << s.tileID.z)
                  , l = s.coordinates.map(t.MercatorCoordinate.fromLngLat).reduce(( (t, e) => (t.min.x = Math.min(t.min.x, e.x - a.x),
                t.min.y = Math.min(t.min.y, e.y - a.y),
                t.max.x = Math.max(t.max.x, e.x - a.x),
                t.max.y = Math.max(t.max.y, e.y - a.y),
                t)), {
                    min: new t.pointGeometry(Number.MAX_VALUE,Number.MAX_VALUE),
                    max: new t.pointGeometry(-Number.MAX_VALUE,-Number.MAX_VALUE)
                })
                  , c = (e, i) => {
                    const r = e.wrap + e.canonical.x / (1 << e.canonical.z)
                      , o = e.canonical.y / (1 << e.canonical.z)
                      , n = t.EXTENT / (1 << e.canonical.z)
                      , s = i.wrap + i.canonical.x / (1 << i.canonical.z)
                      , a = i.canonical.y / (1 << i.canonical.z);
                    return r + n < s + l.min.x || r > s + l.max.x || o + n < a + l.min.y || o > a + l.max.y
                }
                ;
                for (let t = 0; t < n.length; t++) {
                    const s = n[t];
                    for (let t = 0; t < i.length; t++) {
                        const n = e.getTile(i[t]);
                        if (!n || !n.hasData())
                            continue;
                        if (c(s, n.tileID))
                            continue;
                        const a = this._createProxiedId(s, n, r[s.key] && r[s.key][e.id])
                          , l = this.proxyToSource[s.key][e.id];
                        l ? l.push(a) : this.proxyToSource[s.key][e.id] = [a],
                        o.push(a);
                    }
                }
            }
            _createProxiedId(e, i, r) {
                let o = this.orthoMatrix;
                if (r) {
                    const t = r.find((t => t.key === i.tileID.key));
                    if (t)
                        return t
                }
                if (i.tileID.key !== e.key) {
                    const r = e.canonical.z - i.tileID.canonical.z;
                    let n, s, a;
                    o = t.create();
                    const l = i.tileID.wrap - e.wrap << e.overscaledZ;
                    r > 0 ? (n = t.EXTENT >> r,
                    s = n * ((i.tileID.canonical.x << r) - e.canonical.x + l),
                    a = n * ((i.tileID.canonical.y << r) - e.canonical.y)) : (n = t.EXTENT << -r,
                    s = t.EXTENT * (i.tileID.canonical.x - (e.canonical.x + l << -r)),
                    a = t.EXTENT * (i.tileID.canonical.y - (e.canonical.y << -r))),
                    t.ortho(o, 0, n, 0, n, 0, 1),
                    t.translate(o, o, [s, a, 0]);
                }
                return new ao(i.tileID,e.key,o)
            }
            _findTileCoveringTileID(e, i) {
                let r = i.getTile(e);
                if (r && r.hasData())
                    return r;
                const o = this._findCoveringTileCache[i.id]
                  , n = o[e.key];
                if (r = n ? i.getTileByID(n) : null,
                r && r.hasData() || null === n)
                    return r;
                let s = r ? r.tileID : e
                  , a = s.overscaledZ;
                const l = i.getSource().minzoom
                  , c = [];
                if (!n) {
                    const o = i.getSource().maxzoom;
                    if (e.canonical.z >= o) {
                        const r = e.canonical.z - o
                          , {reference: n, sourceID: l, zoomRule: c, _mapZoom: h} = e.canonical
                          , u = {
                            reference: n,
                            sourceID: l,
                            zoomRule: c,
                            _mapZoom: h
                        };
                        i.getSource().reparseOverscaled ? (a = Math.max(e.canonical.z + 2, i.transform.tileZoom),
                        s = new t.OverscaledTileID(a,e.wrap,o,e.canonical.x >> r,e.canonical.y >> r,u)) : 0 !== r && (a = o,
                        s = new t.OverscaledTileID(a,e.wrap,o,e.canonical.x >> r,e.canonical.y >> r,u));
                    }
                    s.key !== e.key && (c.push(s.key),
                    r = i.getTile(s));
                }
                const h = t => {
                    c.forEach((e => {
                        o[e] = t;
                    }
                    )),
                    c.length = 0;
                }
                ;
                for (a -= 1; a >= l && (!r || !r.hasData()); a--) {
                    r && h(r.tileID.key);
                    const t = s.calculateScaledKey(a);
                    if (r = i.getTileByID(t),
                    r && r.hasData())
                        break;
                    const e = o[t];
                    if (null === e)
                        break;
                    void 0 === e ? c.push(t) : r = i.getTileByID(e);
                }
                return h(r ? r.tileID.key : null),
                r && r.hasData() ? r : null
            }
            _get_tile_bbox(t) {
                let e = t.canonical
                  , i = 1 << e.z;
                return [[e.x / i, e._tileY / i], [(e.x + 1) / i, (e._tileY + e._tileH) / i]]
            }
            _tileContain_sg4326(t, e) {
                let i = this._get_tile_bbox(t)
                  , r = this._get_tile_bbox(e)
                  , o = Math.min(i[0][0], i[1][0], r[0][0], r[1][0])
                  , n = Math.max(i[0][0], i[1][0], r[0][0], r[1][0])
                  , s = Math.min(i[0][1], i[1][1], r[0][1], r[1][1])
                  , a = Math.max(i[0][1], i[1][1], r[0][1], r[1][1]);
                return n - o < i[1][0] - i[0][0] + (r[1][0] - r[0][0]) && a - s < i[1][1] - i[0][1] + (r[1][1] - r[0][1])
            }
            _findTileCoveringTileID_sg4326(t, e) {
                let i = this;
                var r = [];
                for (let o in e._tiles)
                    e._tiles[o].hasData() && i._tileContain_sg4326(t, e._tiles[o].tileID) && r.push(e._tiles[o]);
                return r
            }
            findDEMTileFor(t) {
                return this.enabled ? this._findTileCoveringTileID(t, this.sourceCache) : null
            }
            prepareDrawTile() {
                this.renderedToTile = !0;
            }
            _clearRenderCacheForTile(t, e) {
                let i = this._tilesDirty[t];
                i || (i = this._tilesDirty[t] = {}),
                i[e.key] = !0;
            }
            getWirefameBuffer() {
                if (!this.wireframeSegments) {
                    const e = function(e) {
                        let i = 0;
                        const r = new t.StructArrayLayout2ui4
                          , o = 131;
                        for (let t = 1; t < 129; t++) {
                            for (let e = 1; e < 129; e++)
                                i = t * o + e,
                                r.emplaceBack(i, i + 1),
                                r.emplaceBack(i, i + o),
                                r.emplaceBack(i + 1, i + o),
                                128 === t && r.emplaceBack(i + o, i + o + 1);
                            r.emplaceBack(i + 1, i + 1 + o);
                        }
                        return r
                    }();
                    this.wireframeIndexBuffer = this.painter.context.createIndexBuffer(e),
                    this.wireframeSegments = t.SegmentVector.simpleSegment(0, 0, this.gridBuffer.length, e.length);
                }
                return [this.wireframeIndexBuffer, this.wireframeSegments]
            }
        }
        class co {
            static cacheKey(t, e, i, r) {
                let o = `${e}${r ? r.cacheKey : ""}`;
                for (const e of i)
                    t.usedDefines.includes(e) && (o += `/${e}`);
                return o
            }
            constructor(e, i, r, o, n, s) {
                const a = e.gl;
                this.program = a.createProgram();
                const l = function(t) {
                    const e = [];
                    for (let i = 0; i < t.length; i++) {
                        if (null === t[i])
                            continue;
                        const r = t[i].split(" ");
                        e.push(r.pop());
                    }
                    return e
                }(r.staticAttributes)
                  , c = o ? o.getBinderAttributes() : []
                  , h = l.concat(c);
                let u = o ? o.defines() : [];
                u = u.concat(s.map((t => `#define ${t}`)));
                const d = u.concat(e.extStandardDerivatives ? "#extension GL_OES_standard_derivatives : enable\n".concat(jr) : jr, jr, Nr, Ur.fragmentSource, Or.fragmentSource, r.fragmentSource).join("\n")
                  , f = u.concat("\n#ifdef GL_ES\nprecision highp float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif", Nr, Ur.vertexSource, Or.vertexSource, kr.vertexSource, r.vertexSource).join("\n")
                  , _ = a.createShader(a.FRAGMENT_SHADER);
                if (a.isContextLost())
                    return void (this.failedToCreate = !0);
                a.shaderSource(_, d),
                a.compileShader(_),
                a.attachShader(this.program, _);
                const p = a.createShader(a.VERTEX_SHADER);
                if (a.isContextLost())
                    this.failedToCreate = !0;
                else {
                    a.shaderSource(p, f),
                    a.compileShader(p),
                    a.attachShader(this.program, p),
                    this.attributes = {},
                    this.numAttributes = h.length;
                    for (let t = 0; t < this.numAttributes; t++)
                        h[t] && (a.bindAttribLocation(this.program, t, h[t]),
                        this.attributes[h[t]] = t);
                    a.linkProgram(this.program),
                    a.deleteShader(p),
                    a.deleteShader(_),
                    this.fixedUniforms = n(e),
                    this.binderUniforms = o ? o.getUniforms(e) : [],
                    -1 !== s.indexOf("TERRAIN") && (this.terrainUniforms = (e => ({
                        u_dem: new t.Uniform1i(e),
                        u_dem_prev: new t.Uniform1i(e),
                        u_dem_unpack: new t.Uniform4f(e),
                        u_dem_tl: new t.Uniform2f(e),
                        u_dem_scale: new t.Uniform1f(e),
                        u_dem_tl_prev: new t.Uniform2f(e),
                        u_dem_scale_prev: new t.Uniform1f(e),
                        u_dem_size: new t.Uniform1f(e),
                        u_dem_lerp: new t.Uniform1f(e),
                        u_exaggeration: new t.Uniform1f(e),
                        u_depth: new t.Uniform1i(e),
                        u_depth_size_inv: new t.Uniform2f(e),
                        u_meter_to_dem: new t.Uniform1f(e),
                        u_label_plane_matrix_inv: new t.UniformMatrix4f(e),
                        u_tile_tl_up: new t.Uniform3f(e),
                        u_tile_tr_up: new t.Uniform3f(e),
                        u_tile_br_up: new t.Uniform3f(e),
                        u_tile_bl_up: new t.Uniform3f(e),
                        u_tile_up_scale: new t.Uniform1f(e),
                        u_dem_tile_radio: new t.Uniform2f(e),
                        u_dem_6: new t.Uniform1i(e),
                        u_dem_tl_6: new t.Uniform2f(e),
                        u_dem_scale_6: new t.Uniform1f(e),
                        u_meter_to_dem_6: new t.Uniform1f(e)
                    }))(e)),
                    -1 !== s.indexOf("FOG") && (this.fogUniforms = (e => ({
                        u_fog_matrix: new t.UniformMatrix4f(e),
                        u_fog_range: new t.Uniform2f(e),
                        u_fog_color: new t.Uniform4f(e),
                        u_fog_horizon_blend: new t.Uniform1f(e),
                        u_fog_temporal_offset: new t.Uniform1f(e),
                        u_frustum_tl: new t.Uniform3f(e),
                        u_frustum_tr: new t.Uniform3f(e),
                        u_frustum_br: new t.Uniform3f(e),
                        u_frustum_bl: new t.Uniform3f(e),
                        u_globe_pos: new t.Uniform3f(e),
                        u_globe_radius: new t.Uniform1f(e),
                        u_globe_transition: new t.Uniform1f(e),
                        u_is_globe: new t.Uniform1i(e),
                        u_viewport: new t.Uniform2f(e)
                    }))(e));
                }
            }
            setTerrainUniformValues(t, e) {
                if (!this.terrainUniforms)
                    return;
                const i = this.terrainUniforms;
                if (!this.failedToCreate) {
                    t.program.set(this.program);
                    for (const t in e)
                        i[t].set(this.program, t, e[t]);
                }
            }
            setFogUniformValues(t, e) {
                if (!this.fogUniforms)
                    return;
                const i = this.fogUniforms;
                if (!this.failedToCreate) {
                    t.program.set(this.program);
                    for (const t in e)
                        i[t].set(this.program, t, e[t]);
                }
            }
            draw(t, e, i, r, o, n, s, a, l, c, h, u, d, f, _) {
                const p = t.gl;
                if (this.failedToCreate)
                    return;
                t.program.set(this.program),
                t.setDepthMode(i),
                t.setStencilMode(r),
                t.setColorMode(o),
                t.setCullFace(n);
                for (const t of Object.keys(this.fixedUniforms))
                    this.fixedUniforms[t].set(this.program, t, s[t]);
                f && f.setUniforms(this.program, t, this.binderUniforms, u, {
                    zoom: d
                });
                const m = {
                    [p.LINES]: 2,
                    [p.TRIANGLES]: 3,
                    [p.LINE_STRIP]: 1
                }[e];
                for (const i of h.get()) {
                    const r = i.vaos || (i.vaos = {});
                    (r[a] || (r[a] = new Wr)).bind(t, this, l, f ? f.getPaintVertexBuffers() : [], c, i.vertexOffset, _ || []),
                    p.drawElements(e, i.primitiveLength * m, p.UNSIGNED_SHORT, i.primitiveOffset * m * 2);
                }
            }
        }
        const ho = t.create()
          , uo = (e, i, r, o, n, s, a, l, c, h, u) => {
            const d = i.style.light
              , f = d.properties.get("position")
              , _ = [f.x, f.y, f.z]
              , p = t.create$1();
            "viewport" === d.properties.get("anchor") && (t.fromRotation(p, -i.transform.angle),
            t.transformMat3(_, _, p));
            const m = d.properties.get("color")
              , g = i.transform
              , v = {
                u_matrix: e,
                u_lightpos: _,
                u_lightintensity: d.properties.get("intensity"),
                u_lightcolor: [m.r, m.g, m.b],
                u_vertical_gradient: +r,
                u_opacity: o,
                u_tile_id: [0, 0, 0, 0],
                u_zoom_transition: 0,
                u_inv_rot_matrix: ho,
                u_merc_center: [0, 0],
                u_up_dir: [0, 0, 0],
                u_height_lift: 0,
                u_ao: n,
                u_edge_radius: s,
                u_featureZoom: i.transform.zoom
            };
            if ("globe" === g.projection.name) {
                v.u_tile_id = [a.canonical.x, a.canonical.y, 1 << a.canonical.z],
                v.u_zoom_transition = c,
                v.u_inv_rot_matrix = u,
                v.u_merc_center = h;
                const {reference: e, sourceID: i, _tileY: r, _tileH: o} = a.canonical;
                v.u_up_dir = g.projection.upVector(new t.CanonicalTileID(0,0,0,{
                    reference: e,
                    sourceID: i,
                    _tileY: r,
                    _tileH: o
                }), h[0] * t.EXTENT, h[1] * t.EXTENT),
                v.u_height_lift = l;
            }
            return v
        }
          , fo = (e, i, r, o, n, s, a, l, c, h, u, d, f) => {
            const _ = uo(e, i, r, o, n, s, a, h, u, d, f)
              , p = {
                u_height_factor: -Math.pow(2, a.overscaledZ) / c.tileSize / 8
            };
            return t.extend(_, function(t, e, i) {
                const r = 1 / V(i, 1, 18)
                  , o = Math.pow(2, i.tileID.overscaledZ)
                  , n = i.tileSize * Math.pow(2, e.transform.tileZoom) / o
                  , s = n * (i.tileID.canonical.x + i.tileID.wrap * o)
                  , a = n * i.tileID.canonical._tileY;
                return {
                    u_image: 0,
                    u_texsize: i.imageAtlasTexture.size,
                    u_scale: [r, t.fromScale, t.toScale],
                    u_fade: t.t,
                    u_pixel_coord_upper: [s >> 16, a >> 16],
                    u_pixel_coord_lower: [65535 & s, 65535 & a]
                }
            }(l, i, c), p)
        }
          , _o = (t, e) => ({
            u_matrix: t,
            u_featureZoom: e.transform.zoom
        })
          , po = (e, i, r, o) => t.extend(_o(e, i), function(t, e, i) {
            const r = 1 / V(i, 1, e.transform.tileZoom)
              , o = Math.pow(2, i.tileID.overscaledZ)
              , n = i.tileSize * Math.pow(2, e.transform.tileZoom) / o
              , s = n * (i.tileID.canonical.x + i.tileID.wrap * o)
              , a = n * i.tileID.canonical.y;
            return {
                u_image: 0,
                u_texsize: i.imageAtlasTexture.size,
                u_scale: [r, t.fromScale, t.toScale],
                u_fade: t.t,
                u_pixel_coord_upper: [s >> 16, a >> 16],
                u_pixel_coord_lower: [65535 & s, 65535 & a]
            }
        }(r, i, o))
          , mo = (t, e, i) => ({
            u_matrix: t,
            u_world: e,
            u_featureZoom: i.transform.zoom
        })
          , go = (e, i, r, o, n) => t.extend(po(e, i, r, o), {
            u_world: n
        })
          , vo = t.create()
          , yo = (e, i, r, o, n, s) => {
            const a = e.transform
              , l = "globe" === a.projection.name;
            let c;
            if ("map" === s.paint.get("circle-pitch-alignment"))
                if (l) {
                    const e = t.globePixelsToTileUnits(a.zoom, i.canonical) * a._pixelsPerMercatorPixel;
                    c = Float32Array.from([e, 0, 0, e]);
                } else
                    c = a.calculatePixelsToTileUnitsMatrix(r);
            else
                c = new Float32Array([a.pixelsToGLUnits[0], 0, 0, a.pixelsToGLUnits[1]]);
            const h = {
                u_camera_to_center_distance: a.cameraToCenterDistance,
                u_matrix: e.translatePosMatrix(i.projMatrix, r, s.paint.get("circle-translate"), s.paint.get("circle-translate-anchor")),
                u_device_pixel_ratio: t.exported.devicePixelRatio,
                u_extrude_scale: c,
                u_inv_rot_matrix: vo,
                u_merc_center: [0, 0],
                u_tile_id: [0, 0, 0, 0],
                u_zoom_transition: 0,
                u_up_dir: [0, 0, 0],
                u_featureZoom: e.transform.zoom
            };
            if (l) {
                h.u_inv_rot_matrix = o,
                h.u_merc_center = n,
                h.u_tile_id = [i.canonical.x, i.canonical._tileY, 1 << i.canonical.z, i.canonical._tileH],
                h.u_zoom_transition = t.globeToMercatorTransition(a.zoom);
                const e = n[0] * t.EXTENT
                  , r = n[1] * t.EXTENT
                  , {reference: s, sourceID: l, _tileY: c, _tileH: u} = i.canonical;
                h.u_up_dir = a.projection.upVector(new t.CanonicalTileID(0,0,0,{
                    reference: s,
                    sourceID: l,
                    _tileY: c,
                    _tileH: u
                }), e, r);
            }
            return h
        }
          , bo = t => {
            const e = [];
            return "map" === t.paint.get("circle-pitch-alignment") && e.push("PITCH_WITH_MAP"),
            "map" === t.paint.get("circle-pitch-scale") && e.push("SCALE_WITH_MAP"),
            e
        }
          , xo = (e, i, r, o) => {
            const n = t.EXTENT / r.tileSize;
            return {
                u_matrix: e,
                u_camera_to_center_distance: i.getCameraToCenterDistance(o),
                u_extrude_scale: [i.pixelsToGLUnits[0] / n, i.pixelsToGLUnits[1] / n]
            }
        }
          , wo = (t, e, i=1) => ({
            u_matrix: t,
            u_color: e,
            u_overlay: 0,
            u_overlay_scale: i
        })
          , To = t.create()
          , Eo = (e, i, r, o, n, s, a) => {
            const l = e.transform
              , c = "globe" === l.projection.name
              , h = c ? t.globePixelsToTileUnits(l.zoom, i.canonical) * l._pixelsPerMercatorPixel : V(r, 1, s)
              , u = {
                u_matrix: i.projMatrix,
                u_extrude_scale: h,
                u_intensity: a,
                u_inv_rot_matrix: To,
                u_merc_center: [0, 0],
                u_tile_id: [0, 0, 0, 0],
                u_zoom_transition: 0,
                u_up_dir: [0, 0, 0]
            };
            if (c) {
                u.u_inv_rot_matrix = o,
                u.u_merc_center = n,
                u.u_tile_id = [i.canonical.x, i.canonical._tileY, 1 << i.canonical.z, i.canonical._tileH],
                u.u_zoom_transition = t.globeToMercatorTransition(l.zoom);
                const e = n[0] * t.EXTENT
                  , r = n[1] * t.EXTENT;
                u.u_up_dir = l.projection.upVector(new t.CanonicalTileID(0,0,0), e, r);
            }
            return u
        }
          , So = e => ({
            u_matrix: new t.UniformMatrix4f(e),
            u_pixels_to_tile_units: new t.UniformMatrix2f(e),
            u_device_pixel_ratio: new t.Uniform1f(e),
            u_units_to_pixels: new t.Uniform2f(e),
            u_dash_image: new t.Uniform1i(e),
            u_gradient_image: new t.Uniform1i(e),
            u_image_height: new t.Uniform1f(e),
            u_texsize: new t.Uniform2f(e),
            u_scale: new t.Uniform3f(e),
            u_mix: new t.Uniform1f(e),
            u_alpha_discard_threshold: new t.Uniform1f(e),
            u_trim_offset: new t.Uniform2f(e),
            u_featureZoom: new t.Uniform1f(e)
        })
          , Co = (t, e, i, r, o, n, s, a) => {
            const l = t.transform
              , c = l.calculatePixelsToTileUnitsMatrix(e)
              , h = {
                u_matrix: Io(t, e, i, o),
                u_pixels_to_tile_units: c,
                u_device_pixel_ratio: s,
                u_units_to_pixels: [1 / l.pixelsToGLUnits[0], 1 / l.pixelsToGLUnits[1]],
                u_dash_image: 0,
                u_gradient_image: 1,
                u_image_height: n,
                u_texsize: [0, 0],
                u_scale: [0, 0, 0],
                u_mix: 0,
                u_alpha_discard_threshold: 0,
                u_trim_offset: a,
                u_featureZoom: t.transform.zoom
            };
            if (zo(i)) {
                const i = Mo(e, t.transform);
                h.u_texsize = e.lineAtlasTexture.size,
                h.u_scale = [i, r.fromScale, r.toScale],
                h.u_mix = r.t;
            }
            return h
        }
          , Ao = (t, e, i, r, o, n, s, a) => {
            const l = t.transform
              , c = Mo(e, l);
            return {
                u_matrix: Io(t, e, i, o),
                u_texsize: e.imageAtlasTexture.size,
                u_pixels_to_tile_units: l.calculatePixelsToTileUnitsMatrix(e),
                u_device_pixel_ratio: n,
                u_image: 0,
                u_scale: [c, r.fromScale, r.toScale],
                u_fade: r.t,
                u_units_to_pixels: [1 / l.pixelsToGLUnits[0], 1 / l.pixelsToGLUnits[1]],
                u_alpha_discard_threshold: 0,
                u_use_color: s || "eline" == i.type && i.paint && i.paint._values.hasOwnProperty("line-color") ? 1 : 0,
                u_featureZoom: t.transform.zoom,
                u_outline: a || 0
            }
        }
        ;
        function Mo(t, e) {
            return 1 / V(t, 1, e.tileZoom)
        }
        function Io(t, e, i, r) {
            return t.translatePosMatrix(r || e.tileID.projMatrix, e, i.paint.get("line-translate"), i.paint.get("line-translate-anchor"))
        }
        function zo(t) {
            const e = t.paint.get("line-dasharray").value;
            return e.value || "constant" !== e.kind
        }
        const Po = (t, e, i, r, o, n) => {
            return {
                u_matrix: t,
                u_tl_parent: e,
                u_scale_parent: i,
                u_fade_t: r.mix,
                u_opacity: r.opacity * o.paint.get("raster-opacity"),
                u_image0: 0,
                u_image1: 1,
                u_brightness_low: o.paint.get("raster-brightness-min"),
                u_brightness_high: o.paint.get("raster-brightness-max"),
                u_saturation_factor: (a = o.paint.get("raster-saturation"),
                a > 0 ? 1 - 1 / (1.001 - a) : -a),
                u_contrast_factor: (s = o.paint.get("raster-contrast"),
                s > 0 ? 1 / (1 - s) : 1 + s),
                u_spin_weights: Do(o.paint.get("raster-hue-rotate")),
                u_perspective_transform: n
            };
            var s, a;
        }
        ;
        function Do(t) {
            t *= Math.PI / 180;
            const e = Math.sin(t)
              , i = Math.cos(t);
            return [(2 * i + 1) / 3, (-Math.sqrt(3) * e - i + 1) / 3, (Math.sqrt(3) * e - i + 1) / 3]
        }
        const Bo = t.create()
          , Lo = (e, i, r, o, n, s, a, l, c, h, u, d, f, _, p, m, g) => {
            const v = n.transform
              , y = {
                u_is_size_zoom_constant: +("constant" === e || "source" === e),
                u_is_size_feature_constant: +("constant" === e || "camera" === e),
                u_size_t: i ? i.uSizeT : 0,
                u_size: i ? i.uSize : 0,
                u_camera_to_center_distance: v.cameraToCenterDistance,
                u_rotate_symbol: +r,
                u_aspect_ratio: v.width / v.height,
                u_fade_change: n.options.fadeDuration ? n.symbolFadeChange : 1,
                u_matrix: s,
                u_label_plane_matrix: a,
                u_coord_matrix: l,
                u_is_text: +c,
                u_pitch_with_map: +o,
                u_texsize: h,
                u_texture: 0,
                u_tile_id: [0, 0, 0, 0],
                u_zoom_transition: 0,
                u_inv_rot_matrix: Bo,
                u_merc_center: [0, 0],
                u_camera_forward: [0, 0, 0],
                u_ecef_origin: [0, 0, 0],
                u_tile_matrix: Bo,
                u_up_vector: [0, -1, 0],
                u_scale_ratio: g || 1,
                u_featureZoom: n.transform.zoom
            };
            return "globe" === m.name && (y.u_tile_id = [u.canonical.x, u.canonical._tileY, 1 << u.canonical.z, u.canonical._tileH],
            y.u_zoom_transition = d,
            y.u_inv_rot_matrix = _,
            y.u_merc_center = f,
            y.u_camera_forward = v._camera.forward(),
            y.u_ecef_origin = t.globeECEFOrigin(v.globeMatrix, u.toUnwrapped()),
            y.u_tile_matrix = Float32Array.from(v.globeMatrix),
            y.u_up_vector = p),
            y
        }
          , Ro = (e, i, r, o, n, s, a, l, c, h, u, d, f, _, p, m, g, v) => t.extend(Lo(e, i, r, o, n, s, a, l, c, h, d, f, _, p, m, g, v), {
            u_gamma_scale: o ? n.transform.cameraToCenterDistance * Math.cos(n.terrain ? 0 : n.transform._pitch) : 1,
            u_device_pixel_ratio: t.exported.devicePixelRatio,
            u_is_halo: +u
        })
          , ko = (e, i, r, o, n, s, a, l, c, h, u, d, f, _, p, m, g) => t.extend(Ro(e, i, r, o, n, s, a, l, !0, c, !0, u, d, f, _, p, m, g), {
            u_texsize_icon: h,
            u_texture_icon: 1
        })
          , Oo = (t, e, i) => ({
            u_matrix: t,
            u_opacity: e,
            u_color: i
        })
          , Fo = (e, i, r, o, n, s) => t.extend(function(t, e, i, r) {
            const o = i.imageManager.getPattern(t.from.toString())
              , n = i.imageManager.getPattern(t.to.toString())
              , {width: s, height: a} = i.imageManager.getPixelSize()
              , l = Math.pow(2, r.tileID.overscaledZ)
              , c = r.tileSize * Math.pow(2, i.transform.tileZoom) / l
              , h = c * (r.tileID.canonical.x + r.tileID.wrap * l)
              , u = c * r.tileID.canonical.y;
            return {
                u_image: 0,
                u_pattern_tl_a: o.tl,
                u_pattern_br_a: o.br,
                u_pattern_tl_b: n.tl,
                u_pattern_br_b: n.br,
                u_texsize: [s, a],
                u_mix: e.t,
                u_pattern_size_a: o.displaySize,
                u_pattern_size_b: n.displaySize,
                u_scale_a: e.fromScale,
                u_scale_b: e.toScale,
                u_tile_units_to_pixels: 1 / V(r, 1, i.transform.tileZoom),
                u_pixel_coord_upper: [h >> 16, u >> 16],
                u_pixel_coord_lower: [65535 & h, 65535 & u]
            }
        }(o, s, r, n), {
            u_matrix: e,
            u_opacity: i
        })
          , Uo = t.create()
          , No = (e, i, r, o, n, s, a, l, c, h, u) => {
            const d = e.transform
              , f = "globe" === d.projection.name;
            f ? t.globePixelsToTileUnits(d.zoom, i.canonical) : d.calculatePixelsToTileUnitsMatrix(r);
            const _ = {
                u_device_pixel_ratio: t.exported.devicePixelRatio,
                u_inv_rot_matrix: Uo,
                u_merc_center: [0, 0],
                u_tile_id: [0, 0, 0, 0],
                u_zoom_transition: 0,
                u_up_dir: [0, 0, 0],
                u_ecef_origin: [0, 0, 0],
                u_tile_matrix: Uo,
                u_camera_forward: [0, 0, 0],
                u_matrix: a,
                u_label_plane_matrix: l,
                u_coord_matrix: c,
                u_scale_ratio: h || 1,
                u_units_to_pixels: [1 / d.pixelsToGLUnits[0], 1 / d.pixelsToGLUnits[1]],
                u_featureZoom: e.transform.zoom
            };
            if (f) {
                _.u_inv_rot_matrix = o,
                _.u_merc_center = n,
                _.u_tile_id = [i.canonical.x, i.canonical._tileY, 1 << i.canonical.z, i.canonical._tileH],
                _.u_zoom_transition = t.globeToMercatorTransition(d.zoom),
                _.u_ecef_origin = t.globeECEFOrigin(d.globeMatrix, i.toUnwrapped()),
                _.u_tile_matrix = Float32Array.from(d.globeMatrix),
                _.u_camera_forward = d._camera.forward();
                const e = n[0] * t.EXTENT
                  , r = n[1] * t.EXTENT
                  , {reference: s, sourceID: a, _tileY: l, _tileH: c} = i.canonical;
                _.u_up_dir = d.projection.upVector(new t.CanonicalTileID(0,0,0,{
                    reference: s,
                    sourceID: a,
                    _tileY: l,
                    _tileH: c
                }), e, r);
            }
            return _
        }
          , jo = t => {
            const e = [];
            return e.push("PITCH_WITH_MAP"),
            e.push("SCALE_WITH_MAP"),
            e
        }
          , Go = {
            fillExtrusion: e => ({
                u_matrix: new t.UniformMatrix4f(e),
                u_lightpos: new t.Uniform3f(e),
                u_lightintensity: new t.Uniform1f(e),
                u_lightcolor: new t.Uniform3f(e),
                u_vertical_gradient: new t.Uniform1f(e),
                u_opacity: new t.Uniform1f(e),
                u_edge_radius: new t.Uniform1f(e),
                u_ao: new t.Uniform2f(e),
                u_tile_id: new t.Uniform4f(e),
                u_zoom_transition: new t.Uniform1f(e),
                u_inv_rot_matrix: new t.UniformMatrix4f(e),
                u_merc_center: new t.Uniform2f(e),
                u_up_dir: new t.Uniform3f(e),
                u_height_lift: new t.Uniform1f(e),
                u_featureZoom: new t.Uniform1f(e)
            }),
            fillExtrusionPattern: e => ({
                u_matrix: new t.UniformMatrix4f(e),
                u_lightpos: new t.Uniform3f(e),
                u_lightintensity: new t.Uniform1f(e),
                u_lightcolor: new t.Uniform3f(e),
                u_vertical_gradient: new t.Uniform1f(e),
                u_height_factor: new t.Uniform1f(e),
                u_edge_radius: new t.Uniform1f(e),
                u_ao: new t.Uniform2f(e),
                u_tile_id: new t.Uniform4f(e),
                u_zoom_transition: new t.Uniform1f(e),
                u_inv_rot_matrix: new t.UniformMatrix4f(e),
                u_merc_center: new t.Uniform2f(e),
                u_up_dir: new t.Uniform3f(e),
                u_height_lift: new t.Uniform1f(e),
                u_image: new t.Uniform1i(e),
                u_texsize: new t.Uniform2f(e),
                u_pixel_coord_upper: new t.Uniform2f(e),
                u_pixel_coord_lower: new t.Uniform2f(e),
                u_scale: new t.Uniform3f(e),
                u_fade: new t.Uniform1f(e),
                u_opacity: new t.Uniform1f(e),
                u_featureZoom: new t.Uniform1f(e)
            }),
            fill: e => ({
                u_matrix: new t.UniformMatrix4f(e),
                u_featureZoom: new t.Uniform1f(e)
            }),
            fillPattern: e => ({
                u_matrix: new t.UniformMatrix4f(e),
                u_image: new t.Uniform1i(e),
                u_texsize: new t.Uniform2f(e),
                u_pixel_coord_upper: new t.Uniform2f(e),
                u_pixel_coord_lower: new t.Uniform2f(e),
                u_scale: new t.Uniform3f(e),
                u_fade: new t.Uniform1f(e),
                u_featureZoom: new t.Uniform1f(e)
            }),
            fillOutline: e => ({
                u_matrix: new t.UniformMatrix4f(e),
                u_world: new t.Uniform2f(e),
                u_featureZoom: new t.Uniform1f(e)
            }),
            fillOutlinePattern: e => ({
                u_matrix: new t.UniformMatrix4f(e),
                u_world: new t.Uniform2f(e),
                u_image: new t.Uniform1i(e),
                u_texsize: new t.Uniform2f(e),
                u_pixel_coord_upper: new t.Uniform2f(e),
                u_pixel_coord_lower: new t.Uniform2f(e),
                u_scale: new t.Uniform3f(e),
                u_fade: new t.Uniform1f(e),
                u_featureZoom: new t.Uniform1f(e)
            }),
            circle: e => ({
                u_camera_to_center_distance: new t.Uniform1f(e),
                u_extrude_scale: new t.UniformMatrix2f(e),
                u_device_pixel_ratio: new t.Uniform1f(e),
                u_matrix: new t.UniformMatrix4f(e),
                u_inv_rot_matrix: new t.UniformMatrix4f(e),
                u_merc_center: new t.Uniform2f(e),
                u_tile_id: new t.Uniform4f(e),
                u_zoom_transition: new t.Uniform1f(e),
                u_up_dir: new t.Uniform3f(e),
                u_featureZoom: new t.Uniform1f(e)
            }),
            collisionBox: e => ({
                u_matrix: new t.UniformMatrix4f(e),
                u_camera_to_center_distance: new t.Uniform1f(e),
                u_extrude_scale: new t.Uniform2f(e)
            }),
            collisionCircle: e => ({
                u_matrix: new t.UniformMatrix4f(e),
                u_inv_matrix: new t.UniformMatrix4f(e),
                u_camera_to_center_distance: new t.Uniform1f(e),
                u_viewport_size: new t.Uniform2f(e)
            }),
            debug: e => ({
                u_color: new t.UniformColor(e),
                u_matrix: new t.UniformMatrix4f(e),
                u_overlay: new t.Uniform1i(e),
                u_overlay_scale: new t.Uniform1f(e)
            }),
            clippingMask: e => ({
                u_matrix: new t.UniformMatrix4f(e)
            }),
            heatmap: e => ({
                u_extrude_scale: new t.Uniform1f(e),
                u_intensity: new t.Uniform1f(e),
                u_matrix: new t.UniformMatrix4f(e),
                u_inv_rot_matrix: new t.UniformMatrix4f(e),
                u_merc_center: new t.Uniform2f(e),
                u_tile_id: new t.Uniform4f(e),
                u_zoom_transition: new t.Uniform1f(e),
                u_up_dir: new t.Uniform3f(e)
            }),
            heatmapTexture: e => ({
                u_image: new t.Uniform1i(e),
                u_color_ramp: new t.Uniform1i(e),
                u_opacity: new t.Uniform1f(e)
            }),
            hillshade: e => ({
                u_matrix: new t.UniformMatrix4f(e),
                u_image: new t.Uniform1i(e),
                u_latrange: new t.Uniform2f(e),
                u_light: new t.Uniform2f(e),
                u_shadow: new t.UniformColor(e),
                u_highlight: new t.UniformColor(e),
                u_accent: new t.UniformColor(e)
            }),
            hillshadePrepare: e => ({
                u_matrix: new t.UniformMatrix4f(e),
                u_image: new t.Uniform1i(e),
                u_dimension: new t.Uniform2f(e),
                u_zoom: new t.Uniform1f(e),
                u_unpack: new t.Uniform4f(e)
            }),
            line: So,
            linePattern: e => ({
                u_matrix: new t.UniformMatrix4f(e),
                u_texsize: new t.Uniform2f(e),
                u_pixels_to_tile_units: new t.UniformMatrix2f(e),
                u_device_pixel_ratio: new t.Uniform1f(e),
                u_image: new t.Uniform1i(e),
                u_units_to_pixels: new t.Uniform2f(e),
                u_scale: new t.Uniform3f(e),
                u_fade: new t.Uniform1f(e),
                u_alpha_discard_threshold: new t.Uniform1f(e),
                u_use_color: new t.Uniform1f(e),
                u_featureZoom: new t.Uniform1f(e),
                u_outline: new t.Uniform1f(e)
            }),
            raster: e => ({
                u_matrix: new t.UniformMatrix4f(e),
                u_tl_parent: new t.Uniform2f(e),
                u_scale_parent: new t.Uniform1f(e),
                u_fade_t: new t.Uniform1f(e),
                u_opacity: new t.Uniform1f(e),
                u_image0: new t.Uniform1i(e),
                u_image1: new t.Uniform1i(e),
                u_brightness_low: new t.Uniform1f(e),
                u_brightness_high: new t.Uniform1f(e),
                u_saturation_factor: new t.Uniform1f(e),
                u_contrast_factor: new t.Uniform1f(e),
                u_spin_weights: new t.Uniform3f(e),
                u_perspective_transform: new t.Uniform2f(e)
            }),
            symbolIcon: e => ({
                u_is_size_zoom_constant: new t.Uniform1i(e),
                u_is_size_feature_constant: new t.Uniform1i(e),
                u_size_t: new t.Uniform1f(e),
                u_size: new t.Uniform1f(e),
                u_camera_to_center_distance: new t.Uniform1f(e),
                u_rotate_symbol: new t.Uniform1i(e),
                u_aspect_ratio: new t.Uniform1f(e),
                u_fade_change: new t.Uniform1f(e),
                u_matrix: new t.UniformMatrix4f(e),
                u_label_plane_matrix: new t.UniformMatrix4f(e),
                u_coord_matrix: new t.UniformMatrix4f(e),
                u_is_text: new t.Uniform1i(e),
                u_pitch_with_map: new t.Uniform1i(e),
                u_texsize: new t.Uniform2f(e),
                u_tile_id: new t.Uniform4f(e),
                u_zoom_transition: new t.Uniform1f(e),
                u_inv_rot_matrix: new t.UniformMatrix4f(e),
                u_merc_center: new t.Uniform2f(e),
                u_camera_forward: new t.Uniform3f(e),
                u_tile_matrix: new t.UniformMatrix4f(e),
                u_up_vector: new t.Uniform3f(e),
                u_ecef_origin: new t.Uniform3f(e),
                u_texture: new t.Uniform1i(e),
                u_scale_ratio: new t.Uniform1f(e),
                u_featureZoom: new t.Uniform1f(e)
            }),
            symbolSDF: e => ({
                u_is_size_zoom_constant: new t.Uniform1i(e),
                u_is_size_feature_constant: new t.Uniform1i(e),
                u_size_t: new t.Uniform1f(e),
                u_size: new t.Uniform1f(e),
                u_camera_to_center_distance: new t.Uniform1f(e),
                u_rotate_symbol: new t.Uniform1i(e),
                u_aspect_ratio: new t.Uniform1f(e),
                u_fade_change: new t.Uniform1f(e),
                u_matrix: new t.UniformMatrix4f(e),
                u_label_plane_matrix: new t.UniformMatrix4f(e),
                u_coord_matrix: new t.UniformMatrix4f(e),
                u_is_text: new t.Uniform1i(e),
                u_pitch_with_map: new t.Uniform1i(e),
                u_texsize: new t.Uniform2f(e),
                u_texture: new t.Uniform1i(e),
                u_gamma_scale: new t.Uniform1f(e),
                u_device_pixel_ratio: new t.Uniform1f(e),
                u_tile_id: new t.Uniform4f(e),
                u_zoom_transition: new t.Uniform1f(e),
                u_inv_rot_matrix: new t.UniformMatrix4f(e),
                u_merc_center: new t.Uniform2f(e),
                u_camera_forward: new t.Uniform3f(e),
                u_tile_matrix: new t.UniformMatrix4f(e),
                u_up_vector: new t.Uniform3f(e),
                u_ecef_origin: new t.Uniform3f(e),
                u_is_halo: new t.Uniform1i(e),
                u_scale_ratio: new t.Uniform1f(e),
                u_featureZoom: new t.Uniform1f(e)
            }),
            symbolTextAndIcon: e => ({
                u_is_size_zoom_constant: new t.Uniform1i(e),
                u_is_size_feature_constant: new t.Uniform1i(e),
                u_size_t: new t.Uniform1f(e),
                u_size: new t.Uniform1f(e),
                u_camera_to_center_distance: new t.Uniform1f(e),
                u_rotate_symbol: new t.Uniform1i(e),
                u_aspect_ratio: new t.Uniform1f(e),
                u_fade_change: new t.Uniform1f(e),
                u_matrix: new t.UniformMatrix4f(e),
                u_label_plane_matrix: new t.UniformMatrix4f(e),
                u_coord_matrix: new t.UniformMatrix4f(e),
                u_is_text: new t.Uniform1i(e),
                u_pitch_with_map: new t.Uniform1i(e),
                u_texsize: new t.Uniform2f(e),
                u_texsize_icon: new t.Uniform2f(e),
                u_texture: new t.Uniform1i(e),
                u_texture_icon: new t.Uniform1i(e),
                u_gamma_scale: new t.Uniform1f(e),
                u_device_pixel_ratio: new t.Uniform1f(e),
                u_is_halo: new t.Uniform1i(e),
                u_scale_ratio: new t.Uniform1f(e),
                u_featureZoom: new t.Uniform1f(e)
            }),
            background: e => ({
                u_matrix: new t.UniformMatrix4f(e),
                u_opacity: new t.Uniform1f(e),
                u_color: new t.UniformColor(e)
            }),
            backgroundPattern: e => ({
                u_matrix: new t.UniformMatrix4f(e),
                u_opacity: new t.Uniform1f(e),
                u_image: new t.Uniform1i(e),
                u_pattern_tl_a: new t.Uniform2f(e),
                u_pattern_br_a: new t.Uniform2f(e),
                u_pattern_tl_b: new t.Uniform2f(e),
                u_pattern_br_b: new t.Uniform2f(e),
                u_texsize: new t.Uniform2f(e),
                u_mix: new t.Uniform1f(e),
                u_pattern_size_a: new t.Uniform2f(e),
                u_pattern_size_b: new t.Uniform2f(e),
                u_scale_a: new t.Uniform1f(e),
                u_scale_b: new t.Uniform1f(e),
                u_pixel_coord_upper: new t.Uniform2f(e),
                u_pixel_coord_lower: new t.Uniform2f(e),
                u_tile_units_to_pixels: new t.Uniform1f(e)
            }),
            terrainRaster: Kr,
            terrainDepth: Kr,
            skybox: e => ({
                u_matrix: new t.UniformMatrix4f(e),
                u_sun_direction: new t.Uniform3f(e),
                u_cubemap: new t.Uniform1i(e),
                u_opacity: new t.Uniform1f(e),
                u_temporal_offset: new t.Uniform1f(e)
            }),
            skyboxGradient: e => ({
                u_matrix: new t.UniformMatrix4f(e),
                u_color_ramp: new t.Uniform1i(e),
                u_center_direction: new t.Uniform3f(e),
                u_radius: new t.Uniform1f(e),
                u_opacity: new t.Uniform1f(e),
                u_temporal_offset: new t.Uniform1f(e)
            }),
            skyboxCapture: e => ({
                u_matrix_3f: new t.UniformMatrix3f(e),
                u_sun_direction: new t.Uniform3f(e),
                u_sun_intensity: new t.Uniform1f(e),
                u_color_tint_r: new t.Uniform4f(e),
                u_color_tint_m: new t.Uniform4f(e),
                u_luminance: new t.Uniform1f(e)
            }),
            globeRaster: e => ({
                u_proj_matrix: new t.UniformMatrix4f(e),
                u_globe_matrix: new t.UniformMatrix4f(e),
                u_normalize_matrix: new t.UniformMatrix4f(e),
                u_merc_matrix: new t.UniformMatrix4f(e),
                u_zoom_transition: new t.Uniform1f(e),
                u_merc_center: new t.Uniform2f(e),
                u_image0: new t.Uniform1i(e),
                u_grid_matrix: new t.UniformMatrix3f(e),
                u_frustum_tl: new t.Uniform3f(e),
                u_frustum_tr: new t.Uniform3f(e),
                u_frustum_br: new t.Uniform3f(e),
                u_frustum_bl: new t.Uniform3f(e),
                u_globe_pos: new t.Uniform3f(e),
                u_globe_radius: new t.Uniform1f(e),
                u_viewport: new t.Uniform2f(e)
            }),
            globeAtmosphere: e => ({
                u_frustum_tl: new t.Uniform3f(e),
                u_frustum_tr: new t.Uniform3f(e),
                u_frustum_br: new t.Uniform3f(e),
                u_frustum_bl: new t.Uniform3f(e),
                u_horizon: new t.Uniform1f(e),
                u_transition: new t.Uniform1f(e),
                u_fadeout_range: new t.Uniform1f(e),
                u_color: new t.Uniform4f(e),
                u_high_color: new t.Uniform4f(e),
                u_space_color: new t.Uniform4f(e),
                u_star_intensity: new t.Uniform1f(e),
                u_star_density: new t.Uniform1f(e),
                u_star_size: new t.Uniform1f(e),
                u_temporal_offset: new t.Uniform1f(e),
                u_horizon_angle: new t.Uniform1f(e),
                u_rotation_matrix: new t.UniformMatrix4f(e)
            }),
            eleSymbol: e => ({
                u_device_pixel_ratio: new t.Uniform1f(e),
                u_matrix: new t.UniformMatrix4f(e),
                u_inv_rot_matrix: new t.UniformMatrix4f(e),
                u_merc_center: new t.Uniform2f(e),
                u_tile_id: new t.Uniform4f(e),
                u_zoom_transition: new t.Uniform1f(e),
                u_up_dir: new t.Uniform3f(e),
                u_ecef_origin: new t.Uniform3f(e),
                u_tile_matrix: new t.UniformMatrix4f(e),
                u_camera_forward: new t.Uniform3f(e),
                u_label_plane_matrix: new t.UniformMatrix4f(e),
                u_coord_matrix: new t.UniformMatrix4f(e),
                u_scale_ratio: new t.Uniform1f(e),
                u_units_to_pixels: new t.Uniform2f(e),
                u_featureZoom: new t.Uniform1f(e)
            }),
            outline: So
        };
        let Vo;
        function Zo(e, i, r, o, n, s, a) {
            const l = e.context
              , c = l.gl
              , h = e.transform
              , u = e.useProgram("collisionBox")
              , d = [];
            let f = 0
              , _ = 0;
            for (let p = 0; p < o.length; p++) {
                const m = o[p]
                  , g = i.getTile(m)
                  , v = g.getBucket(r);
                if (!v)
                    continue;
                const y = Ki(m, v, h);
                let b = y;
                0 === n[0] && 0 === n[1] || (b = e.translatePosMatrix(y, g, n, s));
                const x = a ? v.textCollisionBox : v.iconCollisionBox
                  , w = v.collisionCircleArray;
                if (w.length > 0) {
                    const e = t.create()
                      , i = b;
                    t.mul(e, v.placementInvProjMatrix, h.glCoordMatrix),
                    t.mul(e, e, v.placementViewportMatrix),
                    d.push({
                        circleArray: w,
                        circleOffset: _,
                        transform: i,
                        invTransform: e,
                        projection: v.getProjection()
                    }),
                    f += w.length / 4,
                    _ = f;
                }
                x && (e.terrain && e.terrain.setupElevationDraw(g, u),
                u.draw(l, c.LINES, t.DepthMode.disabled, t.StencilMode.disabled, e.colorModeForRenderPass(), t.CullFaceMode.disabled, xo(b, h, g, v.getProjection()), r.id, x.layoutVertexBuffer, x.indexBuffer, x.segments, null, h.zoom, null, [x.collisionVertexBuffer, x.collisionVertexBufferExt]));
            }
            if (!a || !d.length)
                return;
            const p = e.useProgram("collisionCircle")
              , m = new t.StructArrayLayout2f1f2i16;
            m.resize(4 * f),
            m._trim();
            let g = 0;
            for (const t of d)
                for (let e = 0; e < t.circleArray.length / 4; e++) {
                    const i = 4 * e
                      , r = t.circleArray[i + 0]
                      , o = t.circleArray[i + 1]
                      , n = t.circleArray[i + 2]
                      , s = t.circleArray[i + 3];
                    m.emplace(g++, r, o, n, s, 0),
                    m.emplace(g++, r, o, n, s, 1),
                    m.emplace(g++, r, o, n, s, 2),
                    m.emplace(g++, r, o, n, s, 3);
                }
            (!Vo || Vo.length < 2 * f) && (Vo = function(e) {
                const i = 2 * e
                  , r = new t.StructArrayLayout3ui6;
                r.resize(i),
                r._trim();
                for (let t = 0; t < i; t++) {
                    const e = 6 * t;
                    r.uint16[e + 0] = 4 * t + 0,
                    r.uint16[e + 1] = 4 * t + 1,
                    r.uint16[e + 2] = 4 * t + 2,
                    r.uint16[e + 3] = 4 * t + 2,
                    r.uint16[e + 4] = 4 * t + 3,
                    r.uint16[e + 5] = 4 * t + 0;
                }
                return r
            }(f));
            const v = l.createIndexBuffer(Vo, !0)
              , y = l.createVertexBuffer(m, t.collisionCircleLayout.members, !0);
            for (const i of d) {
                const o = {
                    u_matrix: i.transform,
                    u_inv_matrix: i.invTransform,
                    u_camera_to_center_distance: (b = h).getCameraToCenterDistance(i.projection),
                    u_viewport_size: [b.width, b.height]
                };
                p.draw(l, c.TRIANGLES, t.DepthMode.disabled, t.StencilMode.disabled, e.colorModeForRenderPass(), t.CullFaceMode.disabled, o, r.id, y, v, t.SegmentVector.simpleSegment(0, 2 * i.circleOffset, i.circleArray.length, i.circleArray.length / 2), null, h.zoom);
            }
            var b;
            y.destroy(),
            v.destroy();
        }
        const Wo = t.create();
        function qo(e, i, r, o, n, s) {
            const {horizontalAlign: a, verticalAlign: l} = t.getAnchorAlignment(e)
              , c = -(a - .5) * i
              , h = -(l - .5) * r
              , u = t.evaluateVariableOffset(e, o);
            return new t.pointGeometry((c / n + u[0]) * s,(h / n + u[1]) * s)
        }
        function Ho(e, i, r, o, n, s, a, l, c, h, u) {
            const d = e.text.placedSymbolArray
              , f = e.text.dynamicLayoutVertexArray
              , _ = e.icon.dynamicLayoutVertexArray
              , p = {}
              , m = Ji(l, e.getProjection(), s)
              , g = s.elevation
              , v = e.getProjection().upVectorScale(l.canonical, s.center.lat, s.worldSize);
            f.clear();
            for (let _ = 0; _ < d.length; _++) {
                const y = d.get(_)
                  , b = e.allowVerticalPlacement && !y.placedOrientation
                  , x = y.hidden || !y.crossTileID || b ? null : o[y.crossTileID];
                if (x) {
                    const o = new t.pointGeometry(y.tileAnchorX,y.tileAnchorY)
                      , d = e.getProjection().upVector(l.canonical, o.x, o.y)
                      , _ = g ? g.getAtTileOffset(l, o.x, o.y) : 0
                      , b = Li([y.projectedAnchorX + _ * d[0] * v.metersToTile, y.projectedAnchorY + _ * d[1] * v.metersToTile, y.projectedAnchorZ + _ * d[2] * v.metersToTile], r ? m : a)
                      , w = Ri(s.getCameraToCenterDistance(e.getProjection()), b.signedDistanceFromCamera);
                    let T = n.evaluateSizeForFeature(e.textSizeData, h, y) * w / t.ONE_EM;
                    r && (T *= e.tilePixelRatio / c);
                    const {width: E, height: S, anchor: C, textOffset: A, textScale: M} = x
                      , I = qo(C, E, S, A, M, T);
                    let z;
                    if (r) {
                        const t = o.add(I)
                          , {x: i, y: r, z: n} = e.getProjection().projectTilePoint(t.x, t.y, l.canonical);
                        z = Li([i + _ * d[0] * v.metersToTile, r + _ * d[1] * v.metersToTile, n + _ * d[2] * v.metersToTile], a).point;
                    } else {
                        const t = i ? I.rotate(-s.angle) : I;
                        z = [b.point[0] + t.x, b.point[1] + t.y, 0];
                    }
                    const P = e.allowVerticalPlacement && y.placedOrientation === t.WritingMode.vertical ? Math.PI / 2 : 0;
                    for (let e = 0; e < y.numGlyphs; e++)
                        t.addDynamicAttributes(f, z[0], z[1], z[2], P);
                    u && y.associatedIconIndex >= 0 && (p[y.associatedIconIndex] = {
                        shiftedAnchor: z,
                        angle: P
                    });
                } else
                    Wi(y.numGlyphs, f);
            }
            if (u) {
                _.clear();
                const i = e.icon.placedSymbolArray;
                for (let e = 0; e < i.length; e++) {
                    const r = i.get(e);
                    if (r.hidden)
                        Wi(r.numGlyphs, _);
                    else {
                        const i = p[e];
                        if (i)
                            for (let e = 0; e < r.numGlyphs; e++)
                                t.addDynamicAttributes(_, i.shiftedAnchor[0], i.shiftedAnchor[1], i.shiftedAnchor[2], i.angle);
                        else
                            Wi(r.numGlyphs, _);
                    }
                }
                e.icon.dynamicLayoutVertexBuffer.updateData(_);
            }
            e.text.dynamicLayoutVertexBuffer.updateData(f);
        }
        function Xo(t, e, i) {
            return i.iconsInText && e ? "symbolTextAndIcon" : t ? "symbolSDF" : "symbolIcon"
        }
        function Yo(e, i, r, o, n, s, a, l, c, h, u, d) {
            const f = e.context
              , _ = f.gl
              , p = e.transform
              , m = "map" === l
              , g = "map" === c
              , v = m && "point" !== r.layout.get("symbol-placement")
              , y = m && !g && !v
              , b = void 0 !== r.layout.get("symbol-sort-key").constantOr(1);
            let x = !1;
            const w = e.depthModeForSublayer(0, t.DepthMode.ReadOnly)
              , T = [t.mercatorXfromLng(p.center.lng), t.mercatorYfromLat(p.center.lat)]
              , E = r.layout.get("text-variable-anchor")
              , S = "globe" === p.projection.name
              , C = []
              , A = [0, -1, 0];
            let M = A;
            !S && !p.mercatorFromTransition || m || (M = function(e) {
                const i = e._camera.getWorldToCamera(e.worldSize, 1)
                  , r = t.multiply([], i, e.globeMatrix);
                t.invert(r, r);
                const o = [0, 0, 0]
                  , n = [0, 1, 0, 0];
                return t.transformMat4$1(n, n, r),
                o[0] = n[0],
                o[1] = n[1],
                o[2] = n[2],
                t.normalize(o, o),
                o
            }(p));
            for (const l of o) {
                const o = i.getTile(l)
                  , c = o.getBucket(r);
                if (!c)
                    continue;
                if ("mercator" === c.projection.name && S)
                    continue;
                const u = n ? c.text : c.icon;
                if (!u || c.fullyClipped || !u.segments.get().length)
                    continue;
                const d = u.programConfigurations.get(r.id)
                  , f = n || c.sdfIcons
                  , w = n ? c.textSizeData : c.iconSizeData
                  , I = g || 0 !== p.pitch
                  , z = t.evaluateSizeForZoom(w, p.zoom);
                let P, D, B, L, R = [0, 0], k = null;
                if (n) {
                    if (D = o.glyphAtlasTexture,
                    B = _.LINEAR,
                    P = o.glyphAtlasTexture.size,
                    c.iconsInText) {
                        R = o.imageAtlasTexture.size,
                        k = o.imageAtlasTexture;
                        const t = "composite" === w.kind || "camera" === w.kind;
                        L = I || e.options.rotating || e.options.zooming || t ? _.LINEAR : _.NEAREST;
                    }
                } else {
                    const t = 1 !== r.layout.get("icon-size").constantOr(0) || c.iconsNeedLinear;
                    D = o.imageAtlasTexture,
                    B = f || e.options.rotating || e.options.zooming || t || I ? _.LINEAR : _.NEAREST,
                    P = o.imageAtlasTexture.size;
                }
                const O = "globe" === c.projection.name
                  , F = O ? M : A
                  , U = O ? t.globeToMercatorTransition(p.zoom) : 0
                  , N = Ji(l, c.getProjection(), p)
                  , j = p.calculatePixelsToTileUnitsMatrix(o)
                  , G = zi(N, o.tileID.canonical, g, m, p, c.getProjection(), j)
                  , V = e.terrain && g && v ? t.invert(t.create(), G) : Wo
                  , Z = Di(N, o.tileID.canonical, g, m, p, c.getProjection(), j)
                  , W = E && c.hasTextData()
                  , q = "none" !== r.layout.get("icon-text-fit") && W && c.hasIconData();
                if (v) {
                    const t = p.elevation
                      , i = t ? t.getAtTileOffsetFunc(l, p.center.lat, p.worldSize, c.getProjection()) : t => [0, 0, 0]
                      , r = Pi(N, o.tileID.canonical, g, m, p, c.getProjection(), j);
                    Oi(c, N, e, n, r, Z, g, h, i, l);
                }
                const H = v || n && E || q
                  , X = e.translatePosMatrix(N, o, s, a)
                  , Y = H ? Wo : G
                  , K = e.translatePosMatrix(Z, o, s, a, !0)
                  , J = c.getProjection().createInversionMatrix(p, l.canonical)
                  , $ = [];
                e.terrain && g && $.push("PITCH_WITH_MAP_TERRAIN"),
                O && $.push("PROJECTION_GLOBE_VIEW"),
                H && $.push("PROJECTED_POS_ON_VIEWPORT");
                const Q = f && 0 !== r.paint.get(n ? "text-halo-width" : "icon-halo-width").constantOr(1);
                let tt, et = 1;
                if (0 != r.layout.get("symbol-scaleable").constantOr(0) && c.collisionArrays) {
                    n && e.transform.zoom > 18 && (et = Math.pow(2, e.transform.zoom - 19));
                    const t = o.latestFeatureIndex.loadVTLayers()._geojsonTileLayer;
                    if (t && 1 != et)
                        for (let e = 0; e < t.length; ++e)
                            if (r.layout.get("symbol-scaleable").evaluate(t.feature(e), {}))
                                for (let t = 0; t < c.collisionArrays.length; t++) {
                                    let e = c.collisionArrays[t];
                                    e.textBox && (e.oldBox || (e.oldBox = JSON.parse(JSON.stringify(e.textBox))),
                                    e.textBox.x1 = e.oldBox.x1 * et,
                                    e.textBox.y1 = e.oldBox.y1 * et,
                                    e.textBox.x2 = e.oldBox.x2 * et,
                                    e.textBox.y2 = e.oldBox.y2 * et);
                                }
                }
                tt = f ? c.iconsInText ? ko(w.kind, z, y, g, e, X, Y, K, P, R, l, U, T, J, F, c.getProjection(), et) : Ro(w.kind, z, y, g, e, X, Y, K, n, P, !0, l, U, T, J, F, c.getProjection(), et) : Lo(w.kind, z, y, g, e, X, Y, K, n, P, l, U, T, J, F, c.getProjection(), et);
                const it = {
                    program: e.useProgram(Xo(f, n, c), d, $),
                    buffers: u,
                    uniformValues: tt,
                    atlasTexture: D,
                    atlasTextureIcon: k,
                    atlasInterpolation: B,
                    atlasInterpolationIcon: L,
                    isSDF: f,
                    hasHalo: Q,
                    tile: o,
                    labelPlaneMatrixInv: V,
                    coord: l
                };
                if (b && c.canOverlap) {
                    x = !0;
                    const e = u.segments.get();
                    for (const i of e)
                        C.push({
                            segments: new t.SegmentVector([i]),
                            sortKey: i.sortKey,
                            state: it
                        });
                } else
                    C.push({
                        segments: u.segments,
                        sortKey: 0,
                        state: it
                    });
            }
            x && C.sort(( (t, e) => t.sortKey - e.sortKey));
            for (const t of C) {
                const i = t.state;
                if (e.terrain && e.terrain.setupElevationDraw(i.tile, i.program, {
                    useDepthForOcclusion: !S,
                    labelPlaneMatrixInv: i.labelPlaneMatrixInv
                }),
                f.activeTexture.set(_.TEXTURE0),
                i.atlasTexture.bind(i.atlasInterpolation, _.CLAMP_TO_EDGE),
                i.atlasTextureIcon && (f.activeTexture.set(_.TEXTURE1),
                i.atlasTextureIcon && i.atlasTextureIcon.bind(i.atlasInterpolationIcon, _.CLAMP_TO_EDGE)),
                i.isSDF) {
                    const o = i.uniformValues;
                    i.hasHalo && (o.u_is_halo = 1,
                    Ko(i.buffers, t.segments, r, e, i.program, w, u, d, o, i.coord)),
                    o.u_is_halo = 0;
                }
                Ko(i.buffers, t.segments, r, e, i.program, w, u, d, i.uniformValues, i.coord);
            }
        }
        function Ko(e, i, r, o, n, s, a, l, c, h) {
            const u = o.context
              , d = u.gl
              , f = [e.dynamicLayoutVertexBuffer, e.opacityVertexBuffer, e.globeExtVertexBuffer];
            o.prepareDrawProgram(o.context, n, h.toUnwrapped()),
            n.draw(u, d.TRIANGLES, s, a, l, t.CullFaceMode.disabled, c, r.id, e.layoutVertexBuffer, e.indexBuffer, i, r.paint, o.transform.zoom, e.programConfigurations.get(r.id), f);
        }
        function Jo(e, i, r, o) {
            if ("translucent" !== e.renderPass)
                return;
            const n = r.paint.get("line-opacity")
              , s = r.paint.get("line-width")
              , a = r.paint.get("line-outline-width");
            if (0 === n.constantOr(1) || 0 === s.constantOr(1) && 0 === a.constantOr(1))
                return;
            const l = e.depthModeForSublayer(0, t.DepthMode.ReadOnly)
              , c = e.colorModeForRenderPass();
            0 !== a.constantOr(1) && $o(e, i, r, o, l, c, !0),
            0 !== s.constantOr(1) && 0 !== n.constantOr(1) && $o(e, i, r, o, l, c, !1);
        }
        function $o(e, i, r, o, n, s, a) {
            const l = e.terrain && e.terrain.renderingToTexture ? 1 : t.exported.devicePixelRatio
              , c = r.paint.get(a ? "line-outline-dasharray" : "line-dasharray")
              , h = c.constantOr(1)
              , u = r.layout.get("line-cap")
              , d = r.paint.get("line-pattern")
              , f = d.constantOr(1)
              , _ = r.paint.get("line-gradient")
              , p = r.getCrossfadeParameters()
              , m = f ? "linePattern" : "line"
              , g = e.context
              , v = g.gl
              , y = (t => {
                const e = [];
                zo(t) && e.push("RENDER_LINE_DASH"),
                t.paint.get("line-gradient") && e.push("RENDER_LINE_GRADIENT");
                const i = t.paint.get("line-trim-offset");
                0 === i[0] && 0 === i[1] || e.push("RENDER_LINE_TRIM_OFFSET");
                const r = t.paint.get("line-pattern").constantOr(1)
                  , o = 1 !== t.paint.get("line-opacity").constantOr(1);
                return !r && o && e.push("RENDER_LINE_ALPHA_DISCARD"),
                e
            }
            )(r);
            let b = y.includes("RENDER_LINE_ALPHA_DISCARD");
            e.terrain && e.terrain.clipOrMaskOverlapStencilType() && (b = !1);
            for (const x of o) {
                const o = i.getTile(x);
                if (f && !o.patternsLoaded())
                    continue;
                const w = o.getBucket(r);
                if (!w)
                    continue;
                e.prepareDrawTile();
                const T = a ? w.programConfigurations_outline.get(r.id) : w.programConfigurations.get(r.id)
                  , E = e.useProgram(m, T, y)
                  , S = d.constantOr(null);
                if (S && o.imageAtlas) {
                    const t = o.imageAtlas
                      , e = t.patternPositions[S.to.toString()]
                      , i = t.patternPositions[S.from.toString()];
                    e && i && T.setConstantPatternPositions(e, i);
                }
                const C = c.constantOr(null)
                  , A = u.constantOr(null);
                if (!f && C && A && o.lineAtlas) {
                    const t = o.lineAtlas
                      , e = t.getDash(C.to, A)
                      , i = t.getDash(C.from, A);
                    e && i && T.setConstantPatternPositions(e, i);
                }
                let[M,I] = r.paint.get("line-trim-offset");
                if ("round" === A || "square" === A) {
                    const t = 1;
                    M !== I && (0 === M && (M -= t),
                    1 === I && (I += t));
                }
                const z = e.terrain ? x.projMatrix : null
                  , P = f ? Ao(e, o, r, p, z, l, a ? 1 : 0) : Co(e, o, r, p, z, w.lineClipsArray.length, l, [M, I]);
                if (_) {
                    const o = w.gradients[r.id];
                    let n = o.texture;
                    if (r.gradientVersion !== o.version) {
                        let s = 256;
                        if (r.stepInterpolant) {
                            const r = i.getSource().maxzoom
                              , o = x.canonical.z === r ? Math.ceil(1 << e.transform.maxZoom - x.canonical.z) : 1;
                            s = t.clamp(t.nextPowerOfTwo(w.maxLineLength / t.EXTENT * 1024 * o), 256, g.maxTextureSize);
                        }
                        o.gradient = t.renderColorRamp({
                            expression: r.gradientExpression(),
                            evaluationKey: "lineProgress",
                            resolution: s,
                            image: o.gradient || void 0,
                            clips: w.lineClipsArray
                        }),
                        o.texture ? o.texture.update(o.gradient) : o.texture = new t.Texture(g,o.gradient,v.RGBA),
                        o.version = r.gradientVersion,
                        n = o.texture;
                    }
                    g.activeTexture.set(v.TEXTURE1),
                    n.bind(r.stepInterpolant ? v.NEAREST : v.LINEAR, v.CLAMP_TO_EDGE);
                }
                h && (g.activeTexture.set(v.TEXTURE0),
                o.lineAtlasTexture.bind(v.LINEAR, v.REPEAT),
                T.updatePaintBuffers(p)),
                f && (g.activeTexture.set(v.TEXTURE0),
                o.imageAtlasTexture.bind(v.LINEAR, v.CLAMP_TO_EDGE),
                T.updatePaintBuffers(p)),
                e.prepareDrawProgram(g, E, x.toUnwrapped());
                const D = i => {
                    E.draw(g, v.TRIANGLES, n, i, s, t.CullFaceMode.disabled, P, r.id, w.layoutVertexBuffer, w.indexBuffer, w.segments, r.paint, e.transform.zoom, T, [w.layoutVertexBuffer2]);
                }
                ;
                if (b) {
                    const i = e.stencilModeForClipping(x).ref;
                    0 === i && e.terrain && g.clear({
                        stencil: 0
                    });
                    const r = {
                        func: v.EQUAL,
                        mask: 255
                    };
                    P.u_alpha_discard_threshold = .8,
                    D(new t.StencilMode(r,i,255,v.KEEP,v.KEEP,v.INVERT)),
                    P.u_alpha_discard_threshold = 0,
                    D(new t.StencilMode(r,i,255,v.KEEP,v.KEEP,v.KEEP));
                } else
                    D(e.stencilModeForClipping(x));
            }
            b && (e.resetStencilClippingMasks(),
            e.terrain && g.clear({
                stencil: 0
            }));
        }
        function Qo(e, i, r, o, n, s, a) {
            const l = e.context.gl
              , c = r.paint.get("fill-pattern")
              , h = c && c.constantOr(1)
              , u = r.getCrossfadeParameters();
            let d, f, _, p, m;
            a ? (f = h && !r.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline",
            d = l.LINES) : (f = h ? "fillPattern" : "fill",
            d = l.TRIANGLES);
            for (const g of o) {
                const o = i.getTile(g);
                if (h && !o.patternsLoaded())
                    continue;
                const v = o.getBucket(r);
                if (!v)
                    continue;
                e.prepareDrawTile();
                const y = v.programConfigurations.get(r.id)
                  , b = e.useProgram(f, y);
                h && (e.context.activeTexture.set(l.TEXTURE0),
                o.imageAtlasTexture.bind(l.LINEAR, l.CLAMP_TO_EDGE),
                y.updatePaintBuffers(u));
                const x = c.constantOr(null);
                if (x && o.imageAtlas) {
                    const t = o.imageAtlas
                      , e = t.patternPositions[x.to.toString()]
                      , i = t.patternPositions[x.from.toString()];
                    e && i && y.setConstantPatternPositions(e, i);
                }
                const w = e.translatePosMatrix(g.projMatrix, o, r.paint.get("fill-translate"), r.paint.get("fill-translate-anchor"));
                if (a) {
                    p = v.indexBuffer2,
                    m = v.segments2;
                    const t = e.terrain && e.terrain.renderingToTexture ? e.terrain.drapeBufferSize : [l.drawingBufferWidth, l.drawingBufferHeight];
                    _ = "fillOutlinePattern" === f && h ? go(w, e, u, o, t) : mo(w, t, e);
                } else
                    p = v.indexBuffer,
                    m = v.segments,
                    _ = h ? po(w, e, u, o) : _o(w, e);
                e.prepareDrawProgram(e.context, b, g.toUnwrapped()),
                b.draw(e.context, d, n, e.stencilModeForClipping(g), s, t.CullFaceMode.disabled, _, r.id, v.layoutVertexBuffer, p, m, r.paint, e.transform.zoom, y);
            }
        }
        function tn(e, i, r, o, n, s, a) {
            const l = e.context
              , c = l.gl
              , h = e.transform
              , u = r.paint.get("fill-extrusion-pattern")
              , d = u.constantOr(1)
              , f = r.getCrossfadeParameters()
              , _ = r.paint.get("fill-extrusion-opacity")
              , p = [r.paint.get("fill-extrusion-ambient-occlusion-intensity"), r.paint.get("fill-extrusion-ambient-occlusion-radius")]
              , m = r.layout.get("fill-extrusion-edge-radius")
              , g = "globe" === h.projection.name ? t.fillExtrusionHeightLift() : 0
              , v = "globe" === h.projection.name
              , y = v ? t.globeToMercatorTransition(h.zoom) : 0
              , b = [t.mercatorXfromLng(h.center.lng), t.mercatorYfromLat(h.center.lat)]
              , x = [];
            v && (x.push("PROJECTION_GLOBE_VIEW"),
            e.style.terrainSetForDrapingOnly() && x.push("TERRAIN")),
            p[0] > 0 && x.push("FAUX_AO");
            for (const w of o) {
                const o = i.getTile(w)
                  , T = o.getBucket(r);
                if (!T || T.projection.name !== h.projection.name)
                    continue;
                const E = T.programConfigurations.get(r.id)
                  , S = e.useProgram(d ? "fillExtrusionPattern" : "fillExtrusion", E, x);
                if (e.terrain) {
                    const t = e.terrain;
                    if (e.style.terrainSetForDrapingOnly())
                        t.setupElevationDraw(o, S, {
                            useMeterToDem: !0
                        });
                    else {
                        if (!T.enableTerrain)
                            continue;
                        if (t.setupElevationDraw(o, S, {
                            useMeterToDem: !0
                        }),
                        en(l, i, w, T, r, t),
                        !T.centroidVertexBuffer) {
                            const t = S.attributes.a_centroid_pos;
                            void 0 !== t && c.vertexAttrib2f(t, 0, 0);
                        }
                    }
                }
                d && (e.context.activeTexture.set(c.TEXTURE0),
                o.imageAtlasTexture.bind(c.LINEAR, c.CLAMP_TO_EDGE),
                E.updatePaintBuffers(f));
                const C = u.constantOr(null);
                if (C && o.imageAtlas) {
                    const t = o.imageAtlas
                      , e = t.patternPositions[C.to.toString()]
                      , i = t.patternPositions[C.from.toString()];
                    e && i && E.setConstantPatternPositions(e, i);
                }
                const A = e.translatePosMatrix(w.projMatrix, o, r.paint.get("fill-extrusion-translate"), r.paint.get("fill-extrusion-translate-anchor"))
                  , M = h.projection.createInversionMatrix(h, w.canonical)
                  , I = r.paint.get("fill-extrusion-vertical-gradient")
                  , z = d ? fo(A, e, I, _, p, m, w, f, o, g, y, b, M) : uo(A, e, I, _, p, m, w, g, y, b, M);
                e.prepareDrawProgram(l, S, w.toUnwrapped());
                const P = [];
                e.terrain && P.push(T.centroidVertexBuffer),
                v && P.push(T.layoutVertexExtBuffer),
                S.draw(l, l.gl.TRIANGLES, n, s, a, t.CullFaceMode.backCCW, z, r.id, T.layoutVertexBuffer, T.indexBuffer, T.segments, r.paint, e.transform.zoom, E, P);
            }
        }
        function en(e, i, r, o, n, s) {
            const a = [e => {
                let i = e.canonical.x - 1
                  , r = e.wrap;
                return i < 0 && (i = (1 << e.canonical.z) - 1,
                r--),
                new t.OverscaledTileID(e.overscaledZ,r,e.canonical.z,i,e.canonical.y)
            }
            , e => {
                let i = e.canonical.x + 1
                  , r = e.wrap;
                return i === 1 << e.canonical.z && (i = 0,
                r++),
                new t.OverscaledTileID(e.overscaledZ,r,e.canonical.z,i,e.canonical.y)
            }
            , e => new t.OverscaledTileID(e.overscaledZ,e.wrap,e.canonical.z,e.canonical.x,(0 === e.canonical.y ? 1 << e.canonical.z : e.canonical.y) - 1), e => new t.OverscaledTileID(e.overscaledZ,e.wrap,e.canonical.z,e.canonical.x,e.canonical.y === (1 << e.canonical.z) - 1 ? 0 : e.canonical.y + 1)]
              , l = t => {
                const e = i.getSource().minzoom
                  , r = t => {
                    const e = i.getTileByID(t);
                    if (e && e.hasData())
                        return e.getBucket(n)
                }
                  , o = [0, -1, 1];
                for (const i of o) {
                    if (t.overscaledZ + i < e)
                        continue;
                    const o = r(t.calculateScaledKey(t.overscaledZ + i));
                    if (o)
                        return o
                }
            }
              , c = [0, 0, 0]
              , h = (e, i) => (c[0] = Math.min(e.min.y, i.min.y),
            c[1] = Math.max(e.max.y, i.max.y),
            c[2] = t.EXTENT - i.min.x > e.max.x ? i.min.x - t.EXTENT : e.max.x,
            c)
              , u = (e, i) => (c[0] = Math.min(e.min.x, i.min.x),
            c[1] = Math.max(e.max.x, i.max.x),
            c[2] = t.EXTENT - i.min.y > e.max.y ? i.min.y - t.EXTENT : e.max.y,
            c)
              , d = [ (t, e) => h(t, e), (t, e) => h(e, t), (t, e) => u(t, e), (t, e) => u(e, t)]
              , f = new t.pointGeometry(0,0);
            let _, p, m;
            const g = (e, i, o, n, a) => {
                const l = [[n ? o : e, n ? e : o, 0], [n ? o : i, n ? i : o, 0]]
                  , c = a < 0 ? t.EXTENT + a : a
                  , h = [n ? c : (e + i) / 2, n ? (e + i) / 2 : c, 0];
                return 0 === o && a < 0 || 0 !== o && a > 0 ? s.getForTilePoints(m, [h], !0, p) : l.push(h),
                s.getForTilePoints(r, l, !0, _),
                Math.max(l[0][2], l[1][2], h[2]) / s.exaggeration()
            }
            ;
            for (let e = 0; e < 4; e++) {
                const i = (e < 2 ? 1 : 5) - e
                  , n = o.borders[e];
                if (0 === n.length)
                    continue;
                const c = m = a[e](r)
                  , h = l(c);
                if (!(h && h instanceof t.FillExtrusionBucket && h.enableTerrain))
                    continue;
                if (o.borderDoneWithNeighborZ[e] === h.canonical.z && h.borderDoneWithNeighborZ[i] === o.canonical.z)
                    continue;
                if (p = s.findDEMTileFor(c),
                !p || !p.dem)
                    continue;
                if (!_) {
                    const t = s.findDEMTileFor(r);
                    if (!t || !t.dem)
                        return;
                    _ = t;
                }
                const u = h.borders[i];
                let v = 0;
                const y = h.borderDoneWithNeighborZ[i] !== o.canonical.z;
                if (o.canonical.z === h.canonical.z) {
                    for (let r = 0; r < n.length; r++) {
                        const s = o.featuresOnBorder[n[r]]
                          , a = s.borders[e];
                        let l;
                        for (; v < u.length && (l = h.featuresOnBorder[u[v]],
                        !(l.borders[i][1] > a[0] + 3)); )
                            y && h.encodeCentroid(void 0, l, !1),
                            v++;
                        if (l && v < u.length) {
                            const r = v;
                            let n = 0;
                            for (; !(l.borders[i][0] > a[1] - 3) && (n++,
                            ++v !== u.length); )
                                l = h.featuresOnBorder[u[v]];
                            if (l = h.featuresOnBorder[u[r]],
                            s.intersectsCount() > 1 || l.intersectsCount() > 1 || 1 !== n) {
                                1 !== n && (v = r),
                                o.encodeCentroid(void 0, s, !1),
                                y && h.encodeCentroid(void 0, l, !1);
                                continue
                            }
                            const c = d[e](s, l)
                              , _ = e % 2 ? t.EXTENT - 1 : 0;
                            f.x = g(c[0], Math.min(t.EXTENT - 1, c[1]), _, e < 2, c[2]),
                            f.y = 0,
                            o.encodeCentroid(f, s, !1),
                            y && h.encodeCentroid(f, l, !1);
                        } else
                            o.encodeCentroid(void 0, s, !1);
                    }
                    o.borderDoneWithNeighborZ[e] = h.canonical.z,
                    o.needsCentroidUpdate = !0,
                    y && (h.borderDoneWithNeighborZ[i] = o.canonical.z,
                    h.needsCentroidUpdate = !0);
                } else {
                    for (const t of n)
                        o.encodeCentroid(void 0, o.featuresOnBorder[t], !1);
                    if (y) {
                        for (const t of u)
                            h.encodeCentroid(void 0, h.featuresOnBorder[t], !1);
                        h.borderDoneWithNeighborZ[i] = o.canonical.z,
                        h.needsCentroidUpdate = !0;
                    }
                    o.borderDoneWithNeighborZ[e] = h.canonical.z,
                    o.needsCentroidUpdate = !0;
                }
            }
            (o.needsCentroidUpdate || !o.centroidVertexBuffer && 0 !== o.centroidVertexArray.length) && o.uploadCentroid(e);
        }
        const rn = new t.Color(1,0,0,1)
          , on = new t.Color(0,1,0,1)
          , nn = new t.Color(0,0,1,1)
          , sn = new t.Color(1,0,1,1)
          , an = new t.Color(0,1,1,1);
        function ln(e, i, r) {
            const o = e.context
              , n = e.transform
              , s = o.gl
              , a = "globe" === n.projection.name
              , l = a ? ["PROJECTION_GLOBE_VIEW"] : null;
            let c = r.projMatrix;
            if (a && t.globeToMercatorTransition(n.zoom) > 0) {
                const e = t.transitionTileAABBinECEF(r.canonical, n)
                  , i = t.globeDenormalizeECEF(e);
                c = t.multiply(new Float32Array(16), n.globeMatrix, i),
                t.multiply(c, n.projMatrix, c);
            }
            const h = e.useProgram("debug", null, l)
              , u = i.getTileByID(r.key);
            e.terrain && e.terrain.setupElevationDraw(u, h);
            const d = t.DepthMode.disabled
              , f = t.StencilMode.disabled
              , _ = e.colorModeForRenderPass()
              , p = "$debug";
            o.activeTexture.set(s.TEXTURE0),
            e.emptyTexture.bind(s.LINEAR, s.CLAMP_TO_EDGE),
            a ? u._makeGlobeTileDebugBuffers(e.context, n) : u._makeDebugTileBoundsBuffers(e.context, n.projection);
            const m = u._tileDebugBuffer || e.debugBuffer
              , g = u._tileDebugIndexBuffer || e.debugIndexBuffer
              , v = u._tileDebugSegments || e.debugSegments;
            h.draw(o, s.LINE_STRIP, d, f, _, t.CullFaceMode.disabled, wo(c, t.Color.red), p, m, g, v, null, null, null, [u._globeTileDebugBorderBuffer]);
            const y = u.latestRawTileData
              , b = Math.floor((y && y.byteLength || 0) / 1024)
              , x = i.getTile(r).tileSize
              , w = 512 / Math.min(x, 512) * (r.overscaledZ / n.zoom) * .5;
            let T = r.canonical.toString();
            r.overscaledZ !== r.canonical.z && (T += ` => ${r.overscaledZ}`),
            T += ` ${b}kb`,
            function(t, e) {
                t.initDebugOverlayCanvas();
                const i = t.debugOverlayCanvas
                  , r = t.context.gl
                  , o = t.debugOverlayCanvas.getContext("2d");
                o.clearRect(0, 0, i.width, i.height),
                o.shadowColor = "white",
                o.shadowBlur = 2,
                o.lineWidth = 1.5,
                o.strokeStyle = "white",
                o.textBaseline = "top",
                o.font = "bold 36px Open Sans, sans-serif",
                o.fillText(e, 5, 5),
                o.strokeText(e, 5, 5),
                t.debugOverlayTexture.update(i),
                t.debugOverlayTexture.bind(r.LINEAR, r.CLAMP_TO_EDGE);
            }(e, T);
            const E = u._tileDebugTextBuffer || e.debugBuffer
              , S = u._tileDebugTextIndexBuffer || e.quadTriangleIndexBuffer
              , C = u._tileDebugTextSegments || e.debugSegments;
            h.draw(o, s.TRIANGLES, d, f, t.ColorMode.alphaBlended, t.CullFaceMode.disabled, wo(c, t.Color.transparent, w), p, E, S, C, null, null, null, [u._globeTileDebugTextBuffer]);
        }
        function cn(t, e, i, r) {
            un(t, 0, e + i / 2, t.transform.width, i, r);
        }
        function hn(t, e, i, r) {
            un(t, e - i / 2, 0, i, t.transform.height, r);
        }
        function un(e, i, r, o, n, s) {
            const a = e.context
              , l = a.gl;
            l.enable(l.SCISSOR_TEST),
            l.scissor(i * t.exported.devicePixelRatio, r * t.exported.devicePixelRatio, o * t.exported.devicePixelRatio, n * t.exported.devicePixelRatio),
            a.clear({
                color: s
            }),
            l.disable(l.SCISSOR_TEST);
        }
        const dn = t.createLayout([{
            name: "a_pos_3f",
            components: 3,
            type: "Float32"
        }])
          , {members: fn} = dn;
        function _n(t, e, i, r) {
            t.emplaceBack(e, i, r);
        }
        class pn {
            constructor(e) {
                this.vertexArray = new t.StructArrayLayout3f12,
                this.indices = new t.StructArrayLayout3ui6,
                _n(this.vertexArray, -1, -1, 1),
                _n(this.vertexArray, 1, -1, 1),
                _n(this.vertexArray, -1, 1, 1),
                _n(this.vertexArray, 1, 1, 1),
                _n(this.vertexArray, -1, -1, -1),
                _n(this.vertexArray, 1, -1, -1),
                _n(this.vertexArray, -1, 1, -1),
                _n(this.vertexArray, 1, 1, -1),
                this.indices.emplaceBack(5, 1, 3),
                this.indices.emplaceBack(3, 7, 5),
                this.indices.emplaceBack(6, 2, 0),
                this.indices.emplaceBack(0, 4, 6),
                this.indices.emplaceBack(2, 6, 7),
                this.indices.emplaceBack(7, 3, 2),
                this.indices.emplaceBack(5, 4, 0),
                this.indices.emplaceBack(0, 1, 5),
                this.indices.emplaceBack(0, 2, 3),
                this.indices.emplaceBack(3, 1, 0),
                this.indices.emplaceBack(7, 6, 4),
                this.indices.emplaceBack(4, 5, 7),
                this.vertexBuffer = e.createVertexBuffer(this.vertexArray, fn),
                this.indexBuffer = e.createIndexBuffer(this.indices),
                this.segment = t.SegmentVector.simpleSegment(0, 0, 36, 12);
            }
        }
        function mn(e, i, r, o, n, s) {
            const a = e.gl
              , l = i.paint.get("sky-atmosphere-color")
              , c = i.paint.get("sky-atmosphere-halo-color")
              , h = i.paint.get("sky-atmosphere-sun-intensity")
              , u = ( (t, e, i, r, o) => ({
                u_matrix_3f: t,
                u_sun_direction: e,
                u_sun_intensity: i,
                u_color_tint_r: [r.r, r.g, r.b, r.a],
                u_color_tint_m: [o.r, o.g, o.b, o.a],
                u_luminance: 5e-5
            }))(t.fromMat4(t.create$1(), o), n, h, l, c);
            a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_CUBE_MAP_POSITIVE_X + s, i.skyboxTexture, 0),
            r.draw(e, a.TRIANGLES, t.DepthMode.disabled, t.StencilMode.disabled, t.ColorMode.unblended, t.CullFaceMode.frontCW, u, "skyboxCapture", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);
        }
        const gn = t.createLayout([{
            type: "Float32",
            name: "a_pos",
            components: 3
        }, {
            type: "Float32",
            name: "a_uv",
            components: 2
        }]);
        class vn {
            constructor(e) {
                const i = new t.StructArrayLayout5f20;
                i.emplaceBack(-1, 1, 1, 0, 0),
                i.emplaceBack(1, 1, 1, 1, 0),
                i.emplaceBack(1, -1, 1, 1, 1),
                i.emplaceBack(-1, -1, 1, 0, 1);
                const r = new t.StructArrayLayout3ui6;
                r.emplaceBack(0, 1, 2),
                r.emplaceBack(2, 3, 0),
                this.vertexBuffer = e.createVertexBuffer(i, gn.members),
                this.indexBuffer = e.createIndexBuffer(r),
                this.segments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
            }
            destroy() {
                this.vertexBuffer.destroy(),
                this.indexBuffer.destroy(),
                this.segments.destroy();
            }
        }
        class yn {
            constructor(t) {
                this.id = "LogoWebglLayer" + (new Date).getTime(),
                this.type = "custom",
                this.renderingMode = "2d",
                this.logoWidth = 64,
                this.logoHeight = 22,
                this.logoLeft = 4,
                this.logoBottom = 2,
                this.updateSize(t);
            }
            updateSize(t) {
                this.context = t.context,
                this.width = t.width,
                this.height = t.height;
                const e = t.logoSize ? parseInt(t.logoSize) > 20 ? t.logoSize : 20 : "";
                e && (this.logoWidth = e * (this.logoWidth / this.logoHeight),
                this.logoHeight = e);
            }
            onAdd(e, i) {
                this.num = 4;
                let r = this.context;
                const o = i.createShader(i.VERTEX_SHADER);
                i.shaderSource(o, "\n        uniform mat4 u_Matrix;\n        attribute vec4 a_Position;\n        attribute vec2 a_TexCoord;\n        varying vec2 v_TexCoord;\n        void main(){\n            gl_Position = u_Matrix*a_Position;\n            v_TexCoord = a_TexCoord;\n        }"),
                i.compileShader(o);
                const n = i.createShader(i.FRAGMENT_SHADER);
                i.shaderSource(n, "\n        precision mediump float;\n        uniform sampler2D u_Sampler;\n        varying vec2 v_TexCoord;\n        void main(){\n            gl_FragColor = texture2D(u_Sampler,v_TexCoord);\n        }"),
                i.compileShader(n),
                this.program = i.createProgram(),
                i.attachShader(this.program, o),
                i.attachShader(this.program, n),
                i.linkProgram(this.program),
                this.vertexSizeBuffer = i.createBuffer(),
                this.a_Position = i.getAttribLocation(this.program, "a_Position"),
                this.a_TexCoord = i.getAttribLocation(this.program, "a_TexCoord"),
                this.u_Matrix = i.getUniformLocation(this.program, "u_Matrix");
                var s = new Image;
                if (s.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPoAAABTCAYAAAC2/xobAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAFcVJREFUeNrsXW+MVcUVHxRbQWG3YqHWwK6JEayFfZBGUwX2kUrSJiqblEYNpi71Q0lL0/ULppjGp40m7hfXio1+sC6JRpqmcUETTbTJLqyY2oTddduKiU13MbSFWPoWGpFiur2/uzO7c8+dmTv3vbn3vgfzS25g35/77p05f37nzJlz501PTzMPD48LG5f4IfDw8Iru4eHhFd3Dw8MruoeHh1d0Dw8Pr+geHh5e0T08PLyie3h4eEX38PCK7uHh4RXdw8OjuTDfD4FHg6EUHK38/4N+OJpP0TGBXcFR5hPZUcD9TgbHRHCMciEacHju9uCo8Hts4a9N8d/p80KbCIxdd3C0kdf38vcmMvjNVi6X7fwoGhPkcIZ5OexeK/OJ6mxA4Zrk19Zf53m6uTK3GD7zdHD0pPBmWQhQEd5ZGPZRfkwolG0wwfBP8fOMOlLubn50sMbFJJdLyFW17rNB0TM8+qabAwPB0VrjPZZT/E6P4vvtwdEfHNWM77HKf6c14zkXYzKhuY5Bfs/is4Mprr+9zuvqyWGcs5i3nnrnJKuJhjCNNtmAjtaoBBMpf0cW1q4CBA+/V7K8t26iiBPcWJQTvmN7Dd0pr72/Dpnsn25u1OOMMqPuiH23aDnJJ2fZsX+dzZ0LtSyYz9asWGz6yBiniNUU1HQkwjE/Pc9eeud48O/nbNtt17K2qxfQ7zzI6ViJU9aWAmjhFP/9CcN99SdQW1UoEhsPi3xJLKR7Yv9H7Meb21jLwsuU4WYN94t7uf8CyGOM8TFuiBgdsc+LKuXGBL42coKdPvt5oaN1x9qlgSC1sw0rr6o1lhbA556SX7hnzxH2+sjJ8P+LA8Py9z230+/s5wm7wYLzFnv5XKli2AlLA/Qoz3FYGXgb/PCFcfby4eNsxZIFbN/OtSrDvElKbJalRGhVSrTSJN8jqt+CLI4fO8MOfniqYTR5YyCTq1csYneuXVZPricXRZ+gmVMMKCawaAWneO4Hq9l9gddV4DqDtysToxbxFF/d+XbkPt/YdTM1KGNc+F6lJ37/2OlZI+ESG1ZdpTJqU5rEX1rvJ4/VtOqenjjwEXs+GGuNh57FoUDhvtP73uzf64NrfjMYPwUTaEtgCj3c6MAA/E11TffsGSmEVdoChu75B1brnNGmtKs4rpfXYssjGNRGVHJgx6/Hw38Vyl5ReLsKFyCjp7O4zw6dkn87EPJMxukAY0/esypkMXIkw2kg9YD3q65tKrguCJ8iFOnhR9l0T/gXSpuk7BZos3j/Vc5YWK7j7BAwQjB6GmdUUY13noreRV/Yte9obFBBaUFNFEKjBejVsESxYO03qq2dEtUgdoa3pFZ81ysfBNeylApgOeXyT92A18tS+JAz0NB03X3Pxsu4NjFvH/R20rHSxowYb3FP4x+fYe8Hx4YUc1YnYLA+o/mTZlByKp8YM6IrnZytTBSl6GU6sMMk/vnR7W3s4S3Xp7fsgcDJ54KS7w7Okwa9994YJsqEJxceWCGAbdJAVlgO6637dq6bjU+zAOi7JsxKNLAJYyUMRncD6snl8h+Ye6rkyNcgaWqIiXMDQtzXj5yM5LHw78vBdStkvcxS1H+4VvQIrYVQUE9ek5I7BGgQJlw2GoeOnlIJr+C5P83r2hCT3bd+hqa9NHw8ovTbbr129r0k5nLvnmjiG+xHcX+TzE0RTTun/21Zj49YrcE9IokmG6I1yxclytb7x87ExgUG1uZ307DPWgFjExqcF1hk7nGPu9XjXhh1jyZXjp6KKVmRSi6ApRtZ0TUDqQxFBJ2iRsxEvVT33LpwvjJBJRSSjh0EzYb2gmpTPKxmPhULKu8iZrZWYsTPqnga/ybRbcwnwhMYS62if3w6Jo/6UOd8MHdHwwQhjMvxZ76Vm+xCPmVFH3awKpDrppbWBlDylNcRiz/T0utxg0FwmKCaFc49b03YevN+Sbn7WLRGPzPDLwyY8MQmJcbraYR8MiGLTufCpOjPvjUZ86p50fuEWo/GV/QmRGuSV6jXi1UDL+RK0SGcVGnAGgze3HnRDhjFwdC7no8plkjqNTpUBvPYJ2ebWpC9opuB2DNSAAIPDE88bknddRAFIa5iP5VwIq5XnH+Me/N210r+bPD7WSkzxmtFcC8IedYsn/F4SDDK6+6u8Pj++ArIQ/uOhodL7L7relMFoFf0HIGii0hVFSbl3cpt2i9c+cCbkb8VBTPW3l4GqqXMuYD4MqZmVaJH8upOqbpmCS8Ri3lpMmUBq5cvchra2OJXb0/m8jswippipuZWdGS7ay03pNSpnnNBoFJ49CFWQKkqjTdNeQUYBZo3wDKmhi1AwX/OFIUx8MhUWWPjPnw8ligUwgrvhHnRVZwJhiGW+mgBDq2Mg4K3NEhep9mRq6JDAFyVHbo8VwKQpPq3SrkQj/beuyqVMCKZh3VSrOmbkkFp42LqIR/W1xjAaL2hOocN7VYmIg8w9ucnO0Ol/UtvZ5hgw5hg/Vc+J5YHcyyYqRmoRoPBcir7io1cWMPPazw8dU9GbCebXEYJL6TZfBEDviOyyFh2c6HoKm++c3N7kvG5gr5Q78YOCLHwzllkjfPEfWEBzdLAIJ9UVaXVxGTlIi0RlmgSpV7RGwVyaScEHH/bCPcwqTJLE6qgIETJEIgAwZuDQqcFvmOzXq0ChLYZPHUa1iUbz4TdjolsizKlInIPuSo6soxpy1Z1A1bPuWgs2IigNE8lFIdI/b+I5e/eE98SDg9lKljCGvHG3qtihUBgHnKCDJtjZKNmsce/6UDzIzDkOJBTgEG0KfxCHghGmO5GLCrB6D16E+NZspxmyl3AIEC4TOEC3qdeiwoklPpC8t4qIL+hcgQYV7HMJkqSVWMBAwxWoIrJbbbrZgHf1z0Z5dw9CqHt8CRKxVyQTmBottxDDSjvKzvXhoqpA6g9jMHXdg3x1YrzM148UHC8TpUcqyCoq9co+Zj36BchqJCs0CSD4FFELbYNNEml3wXHd/2ox0MZHGGy853j2mVD2csjP6Lako36e0P5LDoOYRm3wyu6h9bzYDlLBznLH35evVV1K5vrud9Vg8ChU00/m1mdeORCG2MYR+SCcGBZFGXGuvp7quTYZwCqnpC138LqbL9VOHVvWRi1I43Smyu2M2xJuuWTqn3BjZPra11Ymz2mAqnI3A/xf+FRKqyGXmT8u/je4MXg5ZFIA623QdhGa/9HsV15RSBTj04TFRA83HTRWVpaE67xdPoJJJnppPLUeoHMLbLfKLKxNhZEyZHtVcSHo8zDWmlB31VdinQIm0YcnukrgPHHEp2im1FTKvqYTP2g0DRuQVM+2yUK13iJx1qUYmnWqK09lOvtt6odcqi/xnjaFtm8duSE0eimvceLDUisgYGCXSUpN2QcRUpV3upbVYuAJUoUzezibdSgA3k6PNeKPkhjPAyAvP4tJy/qAc7pYqcU4ijFgA8VKWRVzeYQeHUYJRsBoeu3GtbiFV0CEm/IoIOx2eyDFwou70AT7cpoF6OivbzrGL2PvoAkxurlixpyYsOMqLoMsV/6f3sRNFFHBcGIkjbl4PvUAymyvmBfVa/eTGKbR0LmlKTkcA6oh0fP/t2K9lVgXYjlUf+PZTXImQrCy9+4ayi2pNroio7gN9ZmFzeNG24kYLKw3dSwX7swRTeVoUKBadmrKkSRoVkPHvCqPQd4clOPATgrVAVCeSHPNiEUZAseHgYBhkHn8DDfquKnRqbuwhtGtkDC4uGGQVNeHzkRNumbLKB5vmhaAME30N/EzDO1+CuWuGscSL05hAPXLNdeg5Yjm6srAaa0/Q71Gq5XdOKFsUVXhIOYU+Q1EPK4oNY4Pw7ML5bo6BOLDmW8IpWFoldMFo48RKARkZrOuuwQOqmoccdWWCToZI+ja1oAAZJpO2ijwvugs4LPuJNxhuHcxscKcwovC3YE5cRYw+DWO9dwMCig6f10Vbg7Do6v1g0zRSo6tLhTleRI2rstngZie8OIU5E00Tw9xOgxoSTwchr61U28eilPgRsnLYnRvx5jhlwCffjA3c8ciYUf8BYJsTnNQTQtXO8Zl402SluFwQSDE11nZE9vmxjVGRbh5fNAFooemwxkiyGgU2fPK/toyzvTQFVNrZqEkst921DAYNuhE0+OwcQJ+vtu5VZqfLqIordSo5Ul6PlF0ZHwBHLP9pnk3JHZ8VLtZtPQ+wtC0WnDjY0OvSLCO1VLKSi/yJoLxrSRM6tG3vDjOhlXVim68EJQLlUsIlfM2TRdhCeXP0e9WJKRkCfttfhDDdtMXpxms9c7nlhK3WWPAWOG7bkRBhCMAzZSAI8TwV+vbpqApcOJZlVuUW0me9zZfIbDwiXsYNNly2kiDXKN5WJsZkHPQDghXOOhBnpKa+YePcvEVQJE9j+SGITFlY0EYiQFfSpLMWyu/eKSylbhoelz6OBd4PnpdzXtpPocX3IpL4ag6tQyq+TLFzntuw6Wh2w5DAsUFsfBo6esGnMMi/k5MHdtgu6LUKzZFb1ErW+WiasE9HNljSj6neuWRSiZ5jHF3TqFyHKrJ6Xt8CgqofhNEKp8s3I44tEozTQ8uMF1tr2FpXvMck1AklGn5IZ6iLoBRoVDJJExR4d4xZztzsFxzkDFHNmEp41O3TtMNHR9/vELMuj7qUenlAxCpLiPdmaxhu4yLqSlr7pED5QffepM1DLFY5iaAhhn1To0GkDgCa+KsTqXxXXAUYEBIl+CnYN4VBNyRKgTsS0Mg9KrHp3VLB69nOT91hRTITfIyDZAULzIuvSRkyraV1bFslkm42jG3TReEGzUJqi8nKa76CRrsiScvGsPxg2FKigWwjIX4vGE5S4wl7trYVVQQsiHnGHXNYnEdc0+HFHIPff4BxXJUQFsrKq1FVrjKTqNN4vZtYYJfyqiCOuWRhQdHv15FqN+XSr6Hl/ndjeEB1OOFzwLhJLSR/EkE+qMeEjSr8mt9DDNQyXzwgZeWgrjpeqSOsNk1tmc6mlWY3kvDIlQTlOGfYN6j8TsfeDYLYWwIs5HsRjmrZYGno2i6BEhUT17q6ClB3jlyK466r3D537Ht8+CBSTuvHFpvGhOI4kBoaBDFSNiqRIeT8FS+njeYpTQ+VQNI+D1kMQUCSps7EChiYv8y8yuxvn1JK0e5fdUU5ii6xcn5EQ0ipTD0Y2S17eJ84uAK0Vvp/H5QUW23VUiDueSt79ahAQD9PpAb+UJQ0a3N660sZkZzmjJBMoT2z5rMCIwCo8b4jwsubXtWkDP0cLHosQ9HhQ/1fPfVU0PYVgw36DWLlBj9nyMOWiAEXriu643PnGGykOjZdizTMbFKB/i3qy8OQwGhArKjmSMpiFDlSg6iWOjwqTJvpdtBCOLRJwpcSlaCcuGgSbm8B4+o9jp1sbHo5yk5GE5LclJ6IS/dWEhXcnQxgrLqJvY3JNh6wZi53oSbciuo7Dp2p/8Plzvh3GE4Zgs8ImsrmanWyUkNC52CXgqze4zgRFi7YnXWMp2EAHGRJDzLTHlHFwiTeISfdtpWCSMnZycC4tpgr8VcW0n0ywfznRROaEzfDEs5o0UUN5cAMTSnry8N8QcJR1pok1uRmG7Z53G+YcfubWQXJULRY/Rdrozpw46lujZLdGhmkRYaVo8Q+Io4/i4XC6kRkTX3gregQpY2GOcF/1ACOlON8TyiviwQxXz2zQEQeiE0Ac1CWkYDQzphpWZy3QnPz50blVqzLDTZF/ea+iuFL0nibab+mPrvEoexf74DVmw8bumhElWxTKqxKVqfZ4+KkjEhFjTnfPs8Z1uuMekOmxcgynmx+9gvEzZ5rhiRMULKwR5beIIsFJloOTQAw6pXgdEM+yHZj3+aWUlnU3MnkUzSRcxejcVGCqM2xImlwo1NsHkEc/QOB3KYereQru/uiqWUSUuqUDolJwmwMQSFI3ZsdMtaUxlocf3YaCx3IVYFV4IRjAN7aSfhZLlXShiyqek2SORKpkXxPiYA5TQgqqjYQXGEvG+TcKSXpcL5livRy/zOEmykieVMZxxcEBTD0QTSTc9NOSkftnUZALUP27lT2q9Du3+6moNnTIFyoBg+KiSY1x1T/7AfSXtdFPR0nCfdMgIzjhJMooqRNmrIUMP5oR7dN1UM6GhSPDeomAc5/4G1caYbAufnrosE+OSZmkNbADPn6dzrcnXTOSp6KUkobUZQAgEXe4SHtZmN5sJqECCFdUJAN2OqNnkYuWxsorPqYGB8uCeTDkKsdNNbqBpM5aq568lAMmvAX6A3UXW5KnBEZ5dtQW0XuBexXPadaEawhPZ8NB18UbDzNNxlUZiMG/qHh3M9VEl0VQAPUpfQBVUFrXwoqGiKU63DTN6AwomKDH+VVlaSplbpL+RNFN9jlJmU0gglNzGyIBCyuzAZtulTUqBzSxpbQ+OL3FW18c9TD9/P3Jvz+X4HHBT6CXKaB2NQy7AaoqLrcaXViqVeq7jchqj46IQC4rWPJtXf5l+B5tMdnBBmW3qcPlll4ZKt4J//+Tp/zqziAMPfoMta/mi8n28DuUOu9UEv/2Lrfq0MD57wzVXsJVfuZI9tvWG4F4Xxj6z+etXs9++9w927vP/hQIu3z+y1Lg39CZ7LPgdoazw4DN0dhnbu6MUu1aECH/861T4/i+/f5NOyWE85zFS5IPrwTXgaTRbb7lG9d3/BMcXEoZxkiv3z/jcwXujuu4zmsbgMlGmzAcG58Tpc+yfU+fCsckCdLx1c4gxeetPn4QdjRrZk/fv6GDfu/ka1dvb0yr6vOnp6XqvCT+YpnB3O7f8oP0jaShtLXBZkWcLZE1RE59V3KfAXm5wW7kCtqX8LuYDqydbJK89yhV6kKXvL2d8aCCM3THHzUENz2n/Q3DconpD1Azo+ugXARQe3REu4WkbUj7Nanh0lgtFR1XcqyniOdnaQzhfZB4ulFzOm4ykoOEl5r7jTCtTPMyjIFzHZure778A5nqM60/qDTsuYvQBpujlrqF/tFQWnmQTjeuyDuM4q5iyHNjtTaTkwpvaXnM3y6atVJUL5P6Cx+dBfn/dljLayBiqVclDwKM7OrqCY2Jajf7gaDV8F+9VgqM6nS1w/hL/zZLheoE+6Zrb+T3Q6xsNjm5+uMZgcAwY7qMnYT7KhvsblMYh66MrYZyzgmp8enKQsSxQqXceXFB3FW0r86SQ2BJZTfHdLun7nQ6t4QCbe443DT3KnMKOcg8wYPB0rUy9gaLEKeIWBSuo8M93Scky8Tut3OO082NQOhh/rUtKXIrY2RYliUlVa4y5XaDE7zPr9tm4t76E+evh19LWwB5ctP3qc8G6slB0j7k8RBoj55E/hHEtMdLWuyBUJZlxaoy9ont4XAS4xA+Bh4dXdA8PD6/oHh4eXtE9PDy8ont4eHhF9/Dw8Iru4eHhFd3Dw8MruoeHV3QPDw+v6B4eHs2F/wswAD9f5ORzGtg8AAAAAElFTkSuQmCC",
                s.complete)
                    this.image = s,
                    this.Texture = new t.Texture(r,this.image,i.RGBA),
                    this.Texture.bind(i.LINEAR, i.CLAMP_TO_EDGE);
                else {
                    let e = this
                      , o = i;
                    s.onload = function() {
                        e.image = s,
                        e.Texture = new t.Texture(r,e.image,o.RGBA),
                        e.Texture.bind(o.LINEAR, o.CLAMP_TO_EDGE);
                    }
                    ;
                }
                var a = this.logoLeft
                  , l = this.logoLeft + this.logoWidth
                  , c = this.logoHeight + this.logoBottom
                  , h = this.logoBottom
                  , u = new Float32Array([a, c, 0, 0, a, h, 0, 1, l, c, 1, 0, l, h, 1, 1]);
                i.bindBuffer(i.ARRAY_BUFFER, this.vertexSizeBuffer),
                i.bufferData(i.ARRAY_BUFFER, u, i.STATIC_DRAW),
                this.fsize = u.BYTES_PER_ELEMENT;
            }
            onRemove(t, e) {
                this.Texture && this.Texture.destroy(),
                this.image = null,
                this.Texture = null;
            }
            render(e, i) {
                if (this.Texture) {
                    e.useProgram(this.program),
                    e.bindBuffer(e.ARRAY_BUFFER, this.vertexSizeBuffer),
                    e.vertexAttribPointer(this.a_Position, 2, e.FLOAT, !1, 4 * this.fsize, 0),
                    e.enableVertexAttribArray(this.a_Position),
                    e.vertexAttribPointer(this.a_TexCoord, 2, e.FLOAT, !1, 4 * this.fsize, 2 * this.fsize),
                    e.enableVertexAttribArray(this.a_TexCoord);
                    let i = t.exported.devicePixelRatio;
                    var r = t.identity(new Array(16));
                    t.translate(r, r, [-1, -1, 0]),
                    t.scale(r, r, [2 / this.width, 2 / this.height, 1]),
                    t.scale(r, r, [i, i, 1]),
                    e.uniformMatrix4fv(this.u_Matrix, !1, r),
                    this.Texture.update(this.image, {
                        useMipmap: !0
                    }),
                    e.drawArrays(e.TRIANGLE_STRIP, 0, this.num);
                }
            }
        }
        class bn {
            constructor(e) {
                this.id = "watermarkLayer" + (new Date).getTime(),
                this.type = "custom",
                this.renderingMode = "2d",
                this.radio = t.exported.devicePixelRatio,
                this.width = 512,
                this.height = 512,
                this.setOptions(e);
            }
            setOptions(t) {
                this.text = t.text || "",
                this.color = t.color || "#ccc",
                this.rotate = t.rotate || 0,
                this.size = t.size || 30;
            }
            onAdd(e, i) {
                this._map = e;
                let r = e.painter.context;
                this.num = 4;
                const o = i.createShader(i.VERTEX_SHADER);
                i.shaderSource(o, "\n        attribute vec4 a_Position;\n        attribute vec2 a_TexCoord;\n        varying vec2 v_TexCoord;\n        void main(){\n            gl_Position = vec4(a_Position.x,a_Position.y,0.0,1.0);\n            v_TexCoord = a_TexCoord;\n        }"),
                i.compileShader(o);
                const n = i.createShader(i.FRAGMENT_SHADER);
                i.shaderSource(n, "\n        precision mediump float;\n        uniform sampler2D u_Sampler;\n        varying vec2 v_TexCoord;\n        void main(){\n            gl_FragColor = texture2D(u_Sampler,v_TexCoord);\n        }"),
                i.compileShader(n),
                this.program = i.createProgram(),
                i.attachShader(this.program, o),
                i.attachShader(this.program, n),
                i.linkProgram(this.program),
                this.vertexSizeBuffer = i.createBuffer(),
                this.a_Position = i.getAttribLocation(this.program, "a_Position"),
                this.a_TexCoord = i.getAttribLocation(this.program, "a_TexCoord"),
                this.Texture = new t.Texture(r,this.createCanvas(),i.RGBA,{
                    premultiply: !0
                }),
                this.Texture.bind(i.LINEAR, i.REPEAT);
            }
            isSame(t) {
                return t.text == this.text && t.color == this.color && t.rotate == this.rotate
            }
            createCanvas() {
                let t = this.height / 2 - 32.5
                  , e = this.width / 2 - 113;
                var i = document.createElement("canvas")
                  , r = i.getContext("2d");
                i.width = this.width,
                i.height = this.height,
                r.font = "bold " + this.size + "px Arial",
                r.fillStyle = this.color,
                r.translate(e, t),
                r.rotate(this.rotate / 180 * Math.PI),
                r.strokeStyle = "rgba(255,255,255,0.2)",
                r.lineWidth = 1;
                let o = this.text.split("\n");
                for (let t = 0; t < o.length; t++)
                    r.fillText(o[t], 0, this.size * t),
                    r.strokeText(o[t], 0, this.size * t);
                return i
            }
            onRemove(t, e) {
                this.Texture && this.Texture.destroy(),
                this.Texture = null,
                this.text = null,
                this.color = null,
                this.rotate = null,
                t._update(!0);
            }
            render(t, e) {
                if (this.Texture) {
                    t.useProgram(this.program);
                    let e = this._map.getCanvas()
                      , r = e.offsetWidth / this.width
                      , o = e.offsetHeight / this.height;
                    e.offsetWidth <= 256 && (r = 1),
                    e.offsetHeight <= 256 && (o = 1);
                    var i = new Float32Array([-1, 1, 0, 0, -1, -1, 0, o, 1, 1, r, 0, 1, -1, r, o]);
                    t.bindBuffer(t.ARRAY_BUFFER, this.vertexSizeBuffer),
                    t.bufferData(t.ARRAY_BUFFER, i, t.STATIC_DRAW),
                    this.fsize = i.BYTES_PER_ELEMENT,
                    t.vertexAttribPointer(this.a_Position, 2, t.FLOAT, !1, 4 * this.fsize, 0),
                    t.enableVertexAttribArray(this.a_Position),
                    t.vertexAttribPointer(this.a_TexCoord, 2, t.FLOAT, !1, 4 * this.fsize, 2 * this.fsize),
                    t.enableVertexAttribArray(this.a_TexCoord),
                    this.Texture.update(this.createCanvas(), {
                        useMipmap: !0
                    }),
                    t.drawArrays(t.TRIANGLE_STRIP, 0, this.num);
                }
            }
        }
        const xn = {
            symbol: function(e, i, r, o, n) {
                if ("translucent" !== e.renderPass)
                    return;
                const s = t.StencilMode.disabled
                  , a = e.colorModeForRenderPass();
                r.layout.get("text-variable-anchor") && function(e, i, r, o, n, s, a) {
                    const l = i.transform
                      , c = "map" === n
                      , h = "map" === s;
                    for (const i of e) {
                        const e = o.getTile(i)
                          , n = e.getBucket(r);
                        if (!n || !n.text || !n.text.segments.get().length)
                            continue;
                        const s = t.evaluateSizeForZoom(n.textSizeData, l.zoom)
                          , u = Ji(i, n.getProjection(), l)
                          , d = l.calculatePixelsToTileUnitsMatrix(e)
                          , f = zi(u, e.tileID.canonical, h, c, l, n.getProjection(), d)
                          , _ = "none" !== r.layout.get("icon-text-fit") && n.hasIconData();
                        if (s) {
                            const r = Math.pow(2, l.zoom - e.tileID.overscaledZ);
                            Ho(n, c, h, a, t.symbolSize, l, f, i, r, s, _);
                        }
                    }
                }(o, e, r, i, r.layout.get("text-rotation-alignment"), r.layout.get("text-pitch-alignment"), n),
                0 !== r.paint.get("icon-opacity").constantOr(1) && Yo(e, i, r, o, !1, r.paint.get("icon-translate"), r.paint.get("icon-translate-anchor"), r.layout.get("icon-rotation-alignment"), r.layout.get("icon-pitch-alignment"), r.layout.get("icon-keep-upright"), s, a),
                0 !== r.paint.get("text-opacity").constantOr(1) && Yo(e, i, r, o, !0, r.paint.get("text-translate"), r.paint.get("text-translate-anchor"), r.layout.get("text-rotation-alignment"), r.layout.get("text-pitch-alignment"), r.layout.get("text-keep-upright"), s, a),
                i.map.showCollisionBoxes && (Zo(e, i, r, o, r.paint.get("text-translate"), r.paint.get("text-translate-anchor"), !0),
                Zo(e, i, r, o, r.paint.get("icon-translate"), r.paint.get("icon-translate-anchor"), !1));
            },
            circle: function(e, i, r, o) {
                if ("translucent" !== e.renderPass)
                    return;
                const n = r.paint.get("circle-opacity")
                  , s = r.paint.get("circle-stroke-width")
                  , a = r.paint.get("circle-stroke-opacity")
                  , l = void 0 !== r.layout.get("circle-sort-key").constantOr(1);
                if (0 === n.constantOr(1) && (0 === s.constantOr(1) || 0 === a.constantOr(1)))
                    return;
                const c = e.context
                  , h = c.gl
                  , u = e.transform
                  , d = e.depthModeForSublayer(0, t.DepthMode.ReadOnly)
                  , f = t.StencilMode.disabled
                  , _ = e.colorModeForRenderPass()
                  , p = "globe" === u.projection.name
                  , m = [t.mercatorXfromLng(u.center.lng), t.mercatorYfromLat(u.center.lat)]
                  , g = [];
                for (let n = 0; n < o.length; n++) {
                    const s = o[n]
                      , a = i.getTile(s)
                      , c = a.getBucket(r);
                    if (!c || c.projection.name !== u.projection.name)
                        continue;
                    const h = c.programConfigurations.get(r.id)
                      , d = bo(r);
                    p && d.push("PROJECTION_GLOBE_VIEW");
                    const f = e.useProgram("circle", h, d)
                      , _ = c.layoutVertexBuffer
                      , v = c.globeExtVertexBuffer
                      , y = c.indexBuffer
                      , b = u.projection.createInversionMatrix(u, s.canonical)
                      , x = {
                        programConfiguration: h,
                        program: f,
                        layoutVertexBuffer: _,
                        globeExtVertexBuffer: v,
                        indexBuffer: y,
                        uniformValues: yo(e, s, a, b, m, r),
                        tile: a
                    };
                    if (l) {
                        const e = c.segments.get();
                        for (const i of e)
                            g.push({
                                segments: new t.SegmentVector([i]),
                                sortKey: i.sortKey,
                                state: x
                            });
                    } else
                        g.push({
                            segments: c.segments,
                            sortKey: 0,
                            state: x
                        });
                }
                l && g.sort(( (t, e) => t.sortKey - e.sortKey));
                const v = {
                    useDepthForOcclusion: !p
                };
                for (const i of g) {
                    const {programConfiguration: o, program: n, layoutVertexBuffer: s, globeExtVertexBuffer: a, indexBuffer: l, uniformValues: p, tile: m} = i.state
                      , g = i.segments;
                    e.terrain && e.terrain.setupElevationDraw(m, n, v),
                    e.prepareDrawProgram(c, n, m.tileID.toUnwrapped()),
                    n.draw(c, h.TRIANGLES, d, f, _, t.CullFaceMode.disabled, p, r.id, s, l, g, r.paint, u.zoom, o, [a]);
                }
            },
            heatmap: function(e, i, r, o) {
                if (0 !== r.paint.get("heatmap-opacity"))
                    if ("offscreen" === e.renderPass) {
                        const n = e.context
                          , s = n.gl
                          , a = t.StencilMode.disabled
                          , l = new t.ColorMode([s.ONE, s.ONE],t.Color.transparent,[!0, !0, !0, !0]);
                        !function(t, e, i, r) {
                            const o = t.gl
                              , n = e.width * r
                              , s = e.height * r;
                            t.activeTexture.set(o.TEXTURE1),
                            t.viewport.set([0, 0, n, s]);
                            let a = i.heatmapFbo;
                            if (!a || a && (a.width !== n || a.height !== s)) {
                                a && a.destroy();
                                const e = o.createTexture();
                                o.bindTexture(o.TEXTURE_2D, e),
                                o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, o.CLAMP_TO_EDGE),
                                o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, o.CLAMP_TO_EDGE),
                                o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, o.LINEAR),
                                o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, o.LINEAR),
                                a = i.heatmapFbo = t.createFramebuffer(n, s, !1),
                                function(t, e, i, r, o, n) {
                                    const s = t.gl;
                                    s.texImage2D(s.TEXTURE_2D, 0, s.RGBA, o, n, 0, s.RGBA, t.extRenderToTextureHalfFloat ? t.extTextureHalfFloat.HALF_FLOAT_OES : s.UNSIGNED_BYTE, null),
                                    r.colorAttachment.set(i);
                                }(t, 0, e, a, n, s);
                            } else
                                o.bindTexture(o.TEXTURE_2D, a.colorAttachment.get()),
                                t.bindFramebuffer.set(a.framebuffer);
                        }(n, e, r, "globe" === e.transform.projection.name ? .5 : .25),
                        n.clear({
                            color: t.Color.transparent
                        });
                        const c = e.transform
                          , h = "globe" === c.projection.name
                          , u = h ? ["PROJECTION_GLOBE_VIEW"] : null
                          , d = h ? t.CullFaceMode.frontCCW : t.CullFaceMode.disabled
                          , f = [t.mercatorXfromLng(c.center.lng), t.mercatorYfromLat(c.center.lat)];
                        for (let _ = 0; _ < o.length; _++) {
                            const p = o[_];
                            if (i.hasRenderableParent(p))
                                continue;
                            const m = i.getTile(p)
                              , g = m.getBucket(r);
                            if (!g || g.projection.name !== c.projection.name)
                                continue;
                            const v = g.programConfigurations.get(r.id)
                              , y = e.useProgram("heatmap", v, u)
                              , {zoom: b} = e.transform;
                            e.terrain && e.terrain.setupElevationDraw(m, y),
                            e.prepareDrawProgram(n, y, p.toUnwrapped());
                            const x = c.projection.createInversionMatrix(c, p.canonical);
                            y.draw(n, s.TRIANGLES, t.DepthMode.disabled, a, l, d, Eo(e, p, m, x, f, b, r.paint.get("heatmap-intensity")), r.id, g.layoutVertexBuffer, g.indexBuffer, g.segments, r.paint, e.transform.zoom, v, h ? [g.globeExtVertexBuffer] : null);
                        }
                        n.viewport.set([0, 0, e.width, e.height]);
                    } else
                        "translucent" === e.renderPass && (e.context.setColorMode(e.colorModeForRenderPass()),
                        function(e, i) {
                            const r = e.context
                              , o = r.gl
                              , n = i.heatmapFbo;
                            if (!n)
                                return;
                            r.activeTexture.set(o.TEXTURE0),
                            o.bindTexture(o.TEXTURE_2D, n.colorAttachment.get()),
                            r.activeTexture.set(o.TEXTURE1);
                            let s = i.colorRampTexture;
                            s || (s = i.colorRampTexture = new t.Texture(r,i.colorRamp,o.RGBA)),
                            s.bind(o.LINEAR, o.CLAMP_TO_EDGE),
                            e.useProgram("heatmapTexture").draw(r, o.TRIANGLES, t.DepthMode.disabled, t.StencilMode.disabled, e.colorModeForRenderPass(), t.CullFaceMode.disabled, ( (t, e, i, r) => ({
                                u_image: 0,
                                u_color_ramp: 1,
                                u_opacity: e.paint.get("heatmap-opacity")
                            }))(0, i), i.id, e.viewportBuffer, e.quadTriangleIndexBuffer, e.viewportSegments, i.paint, e.transform.zoom);
                        }(e, r));
            },
            line: Jo,
            fill: function(e, i, r, o) {
                const n = r.paint.get("fill-color")
                  , s = r.paint.get("fill-opacity");
                if (0 === s.constantOr(1))
                    return;
                const a = e.colorModeForRenderPass()
                  , l = r.paint.get("fill-pattern")
                  , c = e.opaquePassEnabledForLayer() && !l.constantOr(1) && 1 === n.constantOr(t.Color.transparent).a && 1 === s.constantOr(0) && 0 == r.paint.get("fill-minzoom").constantOr(1) && 24 == r.paint.get("fill-maxzoom").constantOr(1) ? "opaque" : "translucent";
                if (e.renderPass === c) {
                    const n = e.depthModeForSublayer(1, "opaque" === e.renderPass ? t.DepthMode.ReadWrite : t.DepthMode.ReadOnly);
                    Qo(e, i, r, o, n, a, !1);
                }
                if ("translucent" === e.renderPass && r.paint.get("fill-antialias")) {
                    const n = e.depthModeForSublayer(r.getPaintProperty("fill-outline-color") ? 2 : 0, t.DepthMode.ReadOnly);
                    Qo(e, i, r, o, n, a, !0);
                }
            },
            "fill-extrusion": function(e, i, r, o) {
                const n = r.paint.get("fill-extrusion-opacity");
                if (0 !== n && "translucent" === e.renderPass) {
                    const s = new t.DepthMode(e.context.gl.LEQUAL,t.DepthMode.ReadWrite,e.depthRangeFor3D);
                    if (1 !== n || r.paint.get("fill-extrusion-pattern").constantOr(1))
                        tn(e, i, r, o, s, t.StencilMode.disabled, t.ColorMode.disabled),
                        tn(e, i, r, o, s, e.stencilModeFor3D(), e.colorModeForRenderPass()),
                        e.resetStencilClippingMasks();
                    else {
                        const n = e.colorModeForRenderPass();
                        tn(e, i, r, o, s, t.StencilMode.disabled, n);
                    }
                }
            },
            hillshade: function(e, i, r, o) {
                if ("offscreen" !== e.renderPass && "translucent" !== e.renderPass)
                    return;
                const n = e.context
                  , s = e.depthModeForSublayer(0, t.DepthMode.ReadOnly)
                  , a = e.colorModeForRenderPass()
                  , l = e.terrain && e.terrain.renderingToTexture
                  , [c,h] = "translucent" !== e.renderPass || l ? [{}, o] : e.stencilConfigForOverlap(o);
                for (const o of h) {
                    const n = i.getTile(o);
                    if (n.needsHillshadePrepare && "offscreen" === e.renderPass)
                        Yr(e, n, r, s, t.StencilMode.disabled, a);
                    else if ("translucent" === e.renderPass) {
                        const t = l && e.terrain ? e.terrain.stencilModeForRTTOverlap(o) : c[o.overscaledZ];
                        Hr(e, o, n, r, s, t, a);
                    }
                }
                n.viewport.set([0, 0, e.width, e.height]),
                e.resetStencilClippingMasks();
            },
            raster: function(e, i, r, o, n, s) {
                if ("translucent" !== e.renderPass)
                    return;
                if (0 === r.paint.get("raster-opacity"))
                    return;
                if (!o.length)
                    return;
                const a = e.context
                  , l = a.gl
                  , c = i.getSource()
                  , h = e.useProgram("raster")
                  , u = e.colorModeForRenderPass()
                  , d = e.terrain && e.terrain.renderingToTexture
                  , [f,_] = c instanceof jt || d ? [{}, o] : e.stencilConfigForOverlap(o)
                  , p = _[_.length - 1].overscaledZ
                  , m = !e.options.moving;
                for (const o of _) {
                    const n = d ? t.DepthMode.disabled : e.depthModeForSublayer(o.overscaledZ - p, 1 === r.paint.get("raster-opacity") ? t.DepthMode.ReadWrite : t.DepthMode.ReadOnly, l.LESS)
                      , _ = o.toUnwrapped()
                      , g = i.getTile(o);
                    if (d && (!g || !g.hasData()))
                        continue;
                    const v = d ? o.projMatrix : e.transform.calculateProjMatrix(_, m)
                      , y = e.terrain && d ? e.terrain.stencilModeForRTTOverlap(o) : f[o.overscaledZ]
                      , b = s ? 0 : r.paint.get("raster-fade-duration");
                    g.registerFadeDuration(b);
                    const x = i.findLoadedParent(o, 0)
                      , w = oo(g, x, i, e.transform, b);
                    let T, E;
                    e.terrain && e.terrain.prepareDrawTile();
                    const S = "nearest" === r.paint.get("raster-resampling") ? l.NEAREST : l.LINEAR;
                    a.activeTexture.set(l.TEXTURE0),
                    g.texture.bind(S, l.CLAMP_TO_EDGE),
                    a.activeTexture.set(l.TEXTURE1),
                    x ? (x.texture.bind(S, l.CLAMP_TO_EDGE),
                    T = Math.pow(2, x.tileID.overscaledZ - g.tileID.overscaledZ),
                    E = [g.tileID.canonical.x * T % 1, g.tileID.canonical.y * T % 1]) : g.texture.bind(S, l.CLAMP_TO_EDGE);
                    const C = Po(v, E || [0, 0], T || 1, w, r, c instanceof jt ? c.perspectiveTransform : [0, 0]);
                    if (e.prepareDrawProgram(a, h, _),
                    c instanceof jt)
                        c.boundsBuffer && c.boundsSegments && h.draw(a, l.TRIANGLES, n, t.StencilMode.disabled, u, t.CullFaceMode.disabled, C, r.id, c.boundsBuffer, e.quadTriangleIndexBuffer, c.boundsSegments);
                    else {
                        const {tileBoundsBuffer: i, tileBoundsIndexBuffer: o, tileBoundsSegments: s} = e.getTileBoundsBuffers(g);
                        h.draw(a, l.TRIANGLES, n, y, u, t.CullFaceMode.disabled, C, r.id, i, o, s);
                    }
                }
                e.resetStencilClippingMasks();
            },
            background: function(e, i, r, o) {
                const n = r.paint.get("background-color")
                  , s = r.paint.get("background-opacity");
                if (0 === s)
                    return;
                const a = e.context
                  , l = a.gl
                  , c = e.transform
                  , h = c.tileSize
                  , u = r.paint.get("background-pattern");
                if (e.isPatternMissing(u))
                    return;
                const d = !u && 1 === n.a && 1 === s && e.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                if (e.renderPass !== d)
                    return;
                const f = t.StencilMode.disabled
                  , _ = e.depthModeForSublayer(0, "opaque" === d ? t.DepthMode.ReadWrite : t.DepthMode.ReadOnly)
                  , p = e.colorModeForRenderPass()
                  , m = e.useProgram(u ? "backgroundPattern" : "background");
                let g, v = o;
                v || (g = e.getBackgroundTiles(),
                v = Object.values(g).map((t => t.tileID))),
                u && (a.activeTexture.set(l.TEXTURE0),
                e.imageManager.bind(e.context));
                const y = r.getCrossfadeParameters();
                for (const d of v) {
                    const v = d.toUnwrapped()
                      , b = o ? d.projMatrix : e.transform.calculateProjMatrix(v);
                    e.prepareDrawTile();
                    const x = i ? i.getTile(d) : g ? g[d.key] : new t.Tile(d,h,c.zoom,e)
                      , w = u ? Fo(b, s, e, u, {
                        tileID: d,
                        tileSize: h
                    }, y) : Oo(b, s, n);
                    e.prepareDrawProgram(a, m, v);
                    const {tileBoundsBuffer: T, tileBoundsIndexBuffer: E, tileBoundsSegments: S} = e.getTileBoundsBuffers(x);
                    m.draw(a, l.TRIANGLES, _, f, p, t.CullFaceMode.disabled, w, r.id, T, E, S);
                }
            },
            sky: function(e, i, r) {
                const o = e.transform
                  , n = "mercator" === o.projection.name || "globe" === o.projection.name ? 1 : t.smoothstep(7, 8, o.zoom)
                  , s = r.paint.get("sky-opacity") * n;
                if (0 === s)
                    return;
                const a = e.context
                  , l = r.paint.get("sky-type")
                  , c = new t.DepthMode(a.gl.LEQUAL,t.DepthMode.ReadOnly,[0, 1])
                  , h = e.frameCounter / 1e3 % 1;
                "atmosphere" === l ? "offscreen" === e.renderPass ? r.needsSkyboxCapture(e) && (function(e, i, r, o) {
                    const n = e.context
                      , s = n.gl;
                    let a = i.skyboxFbo;
                    if (!a) {
                        a = i.skyboxFbo = n.createFramebuffer(32, 32, !1),
                        i.skyboxGeometry = new pn(n),
                        i.skyboxTexture = n.gl.createTexture(),
                        s.bindTexture(s.TEXTURE_CUBE_MAP, i.skyboxTexture),
                        s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE),
                        s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE),
                        s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_MIN_FILTER, s.LINEAR),
                        s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_MAG_FILTER, s.LINEAR);
                        for (let t = 0; t < 6; ++t)
                            s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, s.RGBA, 32, 32, 0, s.RGBA, s.UNSIGNED_BYTE, null);
                    }
                    n.bindFramebuffer.set(a.framebuffer),
                    n.viewport.set([0, 0, 32, 32]);
                    const l = i.getCenter(e, !0)
                      , c = e.useProgram("skyboxCapture")
                      , h = new Float64Array(16);
                    t.identity(h),
                    t.rotateY(h, h, .5 * -Math.PI),
                    mn(n, i, c, h, l, 0),
                    t.identity(h),
                    t.rotateY(h, h, .5 * Math.PI),
                    mn(n, i, c, h, l, 1),
                    t.identity(h),
                    t.rotateX(h, h, .5 * -Math.PI),
                    mn(n, i, c, h, l, 2),
                    t.identity(h),
                    t.rotateX(h, h, .5 * Math.PI),
                    mn(n, i, c, h, l, 3),
                    t.identity(h),
                    mn(n, i, c, h, l, 4),
                    t.identity(h),
                    t.rotateY(h, h, Math.PI),
                    mn(n, i, c, h, l, 5),
                    n.viewport.set([0, 0, e.width, e.height]);
                }(e, r),
                r.markSkyboxValid(e)) : "sky" === e.renderPass && function(e, i, r, o, n) {
                    const s = e.context
                      , a = s.gl
                      , l = e.transform
                      , c = e.useProgram("skybox");
                    s.activeTexture.set(a.TEXTURE0),
                    a.bindTexture(a.TEXTURE_CUBE_MAP, i.skyboxTexture);
                    const h = ( (t, e, i, r, o) => ({
                        u_matrix: t,
                        u_sun_direction: e,
                        u_cubemap: 0,
                        u_opacity: r,
                        u_temporal_offset: o
                    }))(l.skyboxMatrix, i.getCenter(e, !1), 0, o, n);
                    e.prepareDrawProgram(s, c),
                    c.draw(s, a.TRIANGLES, r, t.StencilMode.disabled, e.colorModeForRenderPass(), t.CullFaceMode.backCW, h, "skybox", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);
                }(e, r, c, s, h) : "gradient" === l && "sky" === e.renderPass && function(e, i, r, o, n) {
                    const s = e.context
                      , a = s.gl
                      , l = e.transform
                      , c = e.useProgram("skyboxGradient");
                    i.skyboxGeometry || (i.skyboxGeometry = new pn(s)),
                    s.activeTexture.set(a.TEXTURE0);
                    let h = i.colorRampTexture;
                    h || (h = i.colorRampTexture = new t.Texture(s,i.colorRamp,a.RGBA)),
                    h.bind(a.LINEAR, a.CLAMP_TO_EDGE);
                    const u = ( (e, i, r, o, n) => ({
                        u_matrix: e,
                        u_color_ramp: 0,
                        u_center_direction: i,
                        u_radius: t.degToRad(r),
                        u_opacity: o,
                        u_temporal_offset: n
                    }))(l.skyboxMatrix, i.getCenter(e, !1), i.paint.get("sky-gradient-radius"), o, n);
                    e.prepareDrawProgram(s, c),
                    c.draw(s, a.TRIANGLES, r, t.StencilMode.disabled, e.colorModeForRenderPass(), t.CullFaceMode.backCW, u, "skyboxGradient", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);
                }(e, r, c, s, h);
            },
            debug: function(t, e, i) {
                for (let r = 0; r < i.length; r++)
                    ln(t, e, i[r]);
            },
            custom: function(e, i, r, o, n, s, a) {
                const l = e.context
                  , c = r.implementation;
                if (e.transform.projection.unsupportedLayers && e.transform.projection.unsupportedLayers.includes("custom") && !a)
                    t.warnOnce("Custom layers are not yet supported with non-mercator projections. Use mercator to enable custom layers.");
                else if ("offscreen" === e.renderPass) {
                    const t = c.prerender;
                    t && (e.setCustomLayerDefaults(),
                    l.setColorMode(e.colorModeForRenderPass()),
                    t.call(c, l.gl, e.transform.customLayerMatrix()),
                    l.setDirty(),
                    e.setBaseState());
                } else if ("translucent" === e.renderPass) {
                    e.setCustomLayerDefaults(),
                    l.setColorMode(e.colorModeForRenderPass()),
                    l.setStencilMode(t.StencilMode.disabled);
                    const i = "3d" === c.renderingMode ? new t.DepthMode(e.context.gl.LEQUAL,t.DepthMode.ReadWrite,e.depthRangeFor3D) : e.depthModeForSublayer(0, t.DepthMode.ReadOnly);
                    l.setDepthMode(i),
                    c.render(l.gl, e.transform.customLayerMatrix()),
                    l.setDirty(),
                    e.setBaseState(),
                    l.bindFramebuffer.set(null);
                }
            },
            esymbol: function(e, i, r, o) {
                if ("translucent" !== e.renderPass)
                    return;
                const n = r.paint.get("esymbol-opacity")
                  , s = r.paint.get("esymbol-stroke-width")
                  , a = r.paint.get("esymbol-stroke-opacity")
                  , l = void 0 !== r.layout.get("esymbol-sort-key").constantOr(1);
                if (0 === n.constantOr(1) && (0 === s.constantOr(1) || 0 === a.constantOr(1)))
                    return;
                const c = e.context
                  , h = c.gl
                  , u = e.transform
                  , d = e.depthModeForSublayer(0, t.DepthMode.ReadOnly)
                  , f = t.StencilMode.disabled
                  , _ = e.colorModeForRenderPass()
                  , p = "globe" === u.projection.name
                  , m = [t.mercatorXfromLng(u.center.lng), t.mercatorYfromLat(u.center.lat)]
                  , g = [];
                (p || u.mercatorFromTransition) && function(e) {
                    const i = e._camera.getWorldToCamera(e.worldSize, 1)
                      , r = t.multiply([], i, e.globeMatrix);
                    t.invert(r, r);
                    const o = [0, 0, 0]
                      , n = [0, 1, 0, 0];
                    t.transformMat4$1(n, n, r),
                    o[0] = n[0],
                    o[1] = n[1],
                    o[2] = n[2],
                    t.normalize(o, o);
                }(u);
                for (let n = 0; n < o.length; n++) {
                    const s = o[n]
                      , a = i.getTile(s)
                      , c = a.getBucket(r);
                    if (!c || c.projection.name !== u.projection.name)
                        continue;
                    const h = c.programConfigurations.get(r.id)
                      , d = jo();
                    p && d.push("PROJECTION_GLOBE_VIEW");
                    const f = e.useProgram("eleSymbol", h, d)
                      , _ = c.layoutVertexBuffer
                      , v = c.globeExtVertexBuffer
                      , y = c.indexBuffer
                      , b = c.colorVertexBuffer
                      , x = Ji(s, c.getProjection(), u)
                      , w = u.calculatePixelsToTileUnitsMatrix(a)
                      , T = zi(x, a.tileID.canonical, !0, !0, u, c.getProjection(), w)
                      , E = Di(x, a.tileID.canonical, !0, !0, e.transform, c.getProjection(), w)
                      , S = e.translatePosMatrix(x, a, [0, 0], "map")
                      , C = T
                      , A = e.translatePosMatrix(E, a, [0, 0], "map", !0)
                      , M = c.getProjection().createInversionMatrix(u, s.canonical);
                    let I = 1;
                    I = Math.pow(2, e.transform.zoom - 18);
                    const z = {
                        programConfiguration: h,
                        program: f,
                        layoutVertexBuffer: _,
                        globeExtVertexBuffer: v,
                        indexBuffer: y,
                        uniformValues: No(e, s, a, M, m, 0, S, C, A, I),
                        tile: a,
                        colorVertexBuffer: b
                    };
                    if (l) {
                        const e = c.segments.get();
                        for (const i of e)
                            g.push({
                                segments: new t.SegmentVector([i]),
                                sortKey: i.sortKey,
                                state: z
                            });
                    } else
                        g.push({
                            segments: c.segments,
                            sortKey: 0,
                            state: z
                        });
                }
                l && g.sort(( (t, e) => t.sortKey - e.sortKey));
                const v = {
                    useDepthForOcclusion: !p
                };
                for (const i of g) {
                    const {programConfiguration: o, program: n, layoutVertexBuffer: s, globeExtVertexBuffer: a, indexBuffer: l, uniformValues: p, tile: m, colorVertexBuffer: g} = i.state
                      , y = i.segments;
                    e.terrain && e.terrain.setupElevationDraw(m, n, v),
                    e.prepareDrawProgram(c, n, m.tileID.toUnwrapped()),
                    n.draw(c, h.TRIANGLES, d, f, _, t.CullFaceMode.disabled, p, r.id, s, l, y, r.paint, u.zoom, o, [a, g]);
                }
            },
            eline: Jo
        };
        class wn {
            constructor(e, i) {
                this.context = new kt(e),
                this.transform = i,
                this._tileTextures = {},
                this.frameCopies = [],
                this.loadTimeStamps = [],
                this.setup(),
                this.numSublayers = t.SourceCache.maxUnderzooming + t.SourceCache.maxOverzooming + 1,
                this.depthEpsilon = 1 / Math.pow(2, 16),
                this.crossTileSymbolIndex = new Tr,
                this.deferredRenderGpuTimeQueries = [],
                this.gpuTimers = {},
                this.frameCounter = 0,
                this._backgroundTiles = {};
            }
            updateTerrain(t, e) {
                const i = !!t && !!t.terrain && this.transform.projection.supportsTerrain;
                if (!(i || this._terrain && this._terrain.enabled))
                    return;
                this._terrain || (this._terrain = new lo(this,t));
                const r = this._terrain;
                this.transform.elevation = i ? r : null,
                r.update(t, this.transform, e);
            }
            _updateFog(t) {
                const e = t.fog;
                if (!e || "globe" === this.transform.projection.name || e.getOpacity(this.transform.pitch) < 1 || e.properties.get("horizon-blend") < .03)
                    return void (this.transform.fogCullDistSq = null);
                const [i,r] = e.getFovAdjustedRange(this.transform._fov);
                if (i > r)
                    return void (this.transform.fogCullDistSq = null);
                const o = i + .78 * (r - i);
                this.transform.fogCullDistSq = o * o;
            }
            get terrain() {
                return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null
            }
            resize(e, i) {
                if (this.width = e * t.exported.devicePixelRatio,
                this.height = i * t.exported.devicePixelRatio,
                this.context.viewport.set([0, 0, this.width, this.height]),
                this.style)
                    for (const t of this.style.order)
                        this.style._layers[t].resize();
            }
            setup() {
                const e = this.context
                  , i = new t.StructArrayLayout2i4;
                i.emplaceBack(0, 0),
                i.emplaceBack(t.EXTENT, 0),
                i.emplaceBack(0, t.EXTENT),
                i.emplaceBack(t.EXTENT, t.EXTENT),
                this.tileExtentBuffer = e.createVertexBuffer(i, t.posAttributes.members),
                this.tileExtentSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
                const r = new t.StructArrayLayout2i4;
                r.emplaceBack(0, 0),
                r.emplaceBack(t.EXTENT, 0),
                r.emplaceBack(0, t.EXTENT),
                r.emplaceBack(t.EXTENT, t.EXTENT),
                this.debugBuffer = e.createVertexBuffer(r, t.posAttributes.members),
                this.debugSegments = t.SegmentVector.simpleSegment(0, 0, 4, 5);
                const o = new t.StructArrayLayout2i4;
                o.emplaceBack(-1, -1),
                o.emplaceBack(1, -1),
                o.emplaceBack(-1, 1),
                o.emplaceBack(1, 1),
                this.viewportBuffer = e.createVertexBuffer(o, t.posAttributes.members),
                this.viewportSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
                const n = new t.StructArrayLayout4i8;
                n.emplaceBack(0, 0, 0, 0),
                n.emplaceBack(t.EXTENT, 0, t.EXTENT, 0),
                n.emplaceBack(0, t.EXTENT, 0, t.EXTENT),
                n.emplaceBack(t.EXTENT, t.EXTENT, t.EXTENT, t.EXTENT),
                this.mercatorBoundsBuffer = e.createVertexBuffer(n, t.boundsAttributes.members),
                this.mercatorBoundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
                const s = new t.StructArrayLayout3ui6;
                s.emplaceBack(0, 1, 2),
                s.emplaceBack(2, 1, 3),
                this.quadTriangleIndexBuffer = e.createIndexBuffer(s);
                const a = new t.StructArrayLayout1ui2;
                for (const t of [0, 1, 3, 2, 0])
                    a.emplaceBack(t);
                this.debugIndexBuffer = e.createIndexBuffer(a),
                this.emptyTexture = new t.Texture(e,new t.RGBAImage({
                    width: 1,
                    height: 1
                },Uint8Array.of(0, 0, 0, 0)),e.gl.RGBA),
                this.identityMat = t.create();
                const l = this.context.gl;
                this.stencilClearMode = new t.StencilMode({
                    func: l.ALWAYS,
                    mask: 0
                },0,255,l.ZERO,l.ZERO,l.ZERO),
                this.loadTimeStamps.push(t.window.performance.now()),
                this.atmosphereBuffer = new vn(this.context);
            }
            getMercatorTileBoundsBuffers() {
                return {
                    tileBoundsBuffer: this.mercatorBoundsBuffer,
                    tileBoundsIndexBuffer: this.quadTriangleIndexBuffer,
                    tileBoundsSegments: this.mercatorBoundsSegments
                }
            }
            getTileBoundsBuffers(t) {
                return t._makeTileBoundsBuffers(this.context, this.transform.projection),
                t._tileBoundsBuffer ? {
                    tileBoundsBuffer: t._tileBoundsBuffer,
                    tileBoundsIndexBuffer: t._tileBoundsIndexBuffer,
                    tileBoundsSegments: t._tileBoundsSegments
                } : this.getMercatorTileBoundsBuffers()
            }
            clearStencil() {
                const e = this.context
                  , i = e.gl;
                this.nextStencilID = 1,
                this.currentStencilSource = void 0,
                this._tileClippingMaskIDs = {},
                this.useProgram("clippingMask").draw(e, i.TRIANGLES, t.DepthMode.disabled, this.stencilClearMode, t.ColorMode.disabled, t.CullFaceMode.disabled, ro(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
            }
            resetStencilClippingMasks() {
                this.terrain || (this.currentStencilSource = void 0,
                this._tileClippingMaskIDs = {});
            }
            _renderTileClippingMasks(e, i, r) {
                if (!i || this.currentStencilSource === i.id || !e.isTileClipped() || !r || 0 === r.length)
                    return;
                if (this._tileClippingMaskIDs && !this.terrain) {
                    let t = !1;
                    for (const e of r)
                        if (void 0 === this._tileClippingMaskIDs[e.key]) {
                            t = !0;
                            break
                        }
                    if (!t)
                        return
                }
                this.currentStencilSource = i.id;
                const o = this.context
                  , n = o.gl;
                this.nextStencilID + r.length > 256 && this.clearStencil(),
                o.setColorMode(t.ColorMode.disabled),
                o.setDepthMode(t.DepthMode.disabled);
                const s = this.useProgram("clippingMask");
                this._tileClippingMaskIDs = {};
                for (const e of r) {
                    const r = i.getTile(e)
                      , a = this._tileClippingMaskIDs[e.key] = this.nextStencilID++;
                    if ("Sg4326" == e.reference)
                        continue;
                    const {tileBoundsBuffer: l, tileBoundsIndexBuffer: c, tileBoundsSegments: h} = this.getTileBoundsBuffers(r);
                    s.draw(o, n.TRIANGLES, t.DepthMode.disabled, new t.StencilMode({
                        func: n.ALWAYS,
                        mask: 0
                    },a,255,n.KEEP,n.KEEP,n.REPLACE), t.ColorMode.disabled, t.CullFaceMode.disabled, ro(e.projMatrix), "$clipping", l, c, h);
                }
            }
            stencilModeFor3D() {
                this.currentStencilSource = void 0,
                this.nextStencilID + 1 > 256 && this.clearStencil();
                const e = this.nextStencilID++
                  , i = this.context.gl;
                return new t.StencilMode({
                    func: i.NOTEQUAL,
                    mask: 255
                },e,255,i.KEEP,i.KEEP,i.REPLACE)
            }
            stencilModeForClipping(e) {
                if (this.terrain)
                    return this.terrain.stencilModeForRTTOverlap(e);
                const i = this.context.gl;
                return "Sg4326" == e.reference ? t.StencilMode.disabled : new t.StencilMode({
                    func: i.EQUAL,
                    mask: 255
                },this._tileClippingMaskIDs[e.key],0,i.KEEP,i.KEEP,i.REPLACE)
            }
            stencilConfigForOverlap(e) {
                const i = this.context.gl
                  , r = e.sort(( (t, e) => e.overscaledZ - t.overscaledZ))
                  , o = r[r.length - 1].overscaledZ
                  , n = r[0].overscaledZ - o + 1;
                if (n > 1) {
                    this.currentStencilSource = void 0,
                    this.nextStencilID + n > 256 && this.clearStencil();
                    const e = {};
                    for (let r = 0; r < n; r++)
                        e[r + o] = new t.StencilMode({
                            func: i.GEQUAL,
                            mask: 255
                        },r + this.nextStencilID,255,i.KEEP,i.KEEP,i.REPLACE);
                    return this.nextStencilID += n,
                    [e, r]
                }
                return [{
                    [o]: t.StencilMode.disabled
                }, r]
            }
            colorModeForRenderPass() {
                const e = this.context.gl;
                if (this._showOverdrawInspector) {
                    const i = 1 / 8;
                    return new t.ColorMode([e.CONSTANT_COLOR, e.ONE],new t.Color(i,i,i,0),[!0, !0, !0, !0])
                }
                return "opaque" === this.renderPass ? t.ColorMode.unblended : t.ColorMode.alphaBlended
            }
            depthModeForSublayer(e, i, r) {
                if (!this.opaquePassEnabledForLayer())
                    return t.DepthMode.disabled;
                const o = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
                return new t.DepthMode(r || this.context.gl.LEQUAL,i,[o, o])
            }
            opaquePassEnabledForLayer() {
                return this.currentLayer < this.opaquePassCutoff
            }
            render(e, i) {
                this.style = e,
                this.options = i,
                this.lineAtlas = e.lineAtlas,
                this.imageManager = e.imageManager,
                this.glyphManager = e.glyphManager,
                this.symbolFadeChange = e.placement.symbolFadeChange(t.exported.now()),
                this.imageManager.beginFrame();
                const r = this.style.order
                  , o = this.style._sourceCaches;
                for (const t in o) {
                    const e = o[t];
                    e.used && e.prepare(this.context);
                }
                const n = {}
                  , s = {}
                  , a = {};
                for (const t in o) {
                    const e = o[t];
                    n[t] = e.getVisibleCoordinates(),
                    s[t] = n[t].slice().reverse(),
                    a[t] = e.getVisibleCoordinates(!0).reverse();
                }
                this.opaquePassCutoff = 1 / 0;
                for (let t = 0; t < r.length; t++)
                    if (this.style._layers[r[t]].is3D()) {
                        this.opaquePassCutoff = t;
                        break
                    }
                this.terrain && (this.terrain.updateTileBinding(a),
                this.opaquePassCutoff = 0),
                "globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new t.GlobeSharedBuffers(this.context)),
                this.renderPass = "offscreen";
                for (const t of r) {
                    const i = this.style._layers[t]
                      , r = e._getLayerSourceCache(i);
                    if (!i.hasOffscreenPass() || i.isHidden(this.transform.zoom))
                        continue;
                    const o = r ? s[r.id] : void 0;
                    ("custom" === i.type || i.isSky() || o && o.length) && this.renderLayer(this, r, i, o);
                }
                if (this.depthRangeFor3D = [0, 1 - (e.order.length + 2) * this.numSublayers * this.depthEpsilon],
                this.terrain && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && this.terrain.drawDepth(),
                this.context.bindFramebuffer.set(null),
                this.context.viewport.set([0, 0, this.width, this.height]),
                this.context.clear({
                    color: i.showOverdrawInspector ? t.Color.black : t.Color.transparent,
                    depth: 1
                }),
                this.clearStencil(),
                this._showOverdrawInspector = i.showOverdrawInspector,
                this.renderPass = "opaque",
                !this.terrain)
                    for (this.currentLayer = r.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                        const t = this.style._layers[r[this.currentLayer]]
                          , i = e._getLayerSourceCache(t);
                        if (t.isSky())
                            continue;
                        if (t.isHidden(this.transform.zoom))
                            continue;
                        const o = i ? s[i.id] : void 0;
                        this._renderTileClippingMasks(t, i, o),
                        this.renderLayer(this, i, t, o);
                    }
                if (this.style.fog && this.transform.projection.supportsFog && function(e, i) {
                    const r = e.context
                      , o = r.gl
                      , n = e.transform
                      , s = new t.DepthMode(o.LEQUAL,t.DepthMode.ReadOnly,[0, 1])
                      , a = e.useProgram("globeAtmosphere", null, "globe" === n.projection.name ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"])
                      , l = t.globeToMercatorTransition(n.zoom)
                      , c = i.properties.get("color").toArray01()
                      , h = i.properties.get("high-color").toArray01()
                      , u = i.properties.get("space-color").toArray01PremultipliedAlpha()
                      , d = t.identity$1([]);
                    t.rotateY$1(d, d, -t.degToRad(n._center.lng)),
                    t.rotateX$1(d, d, t.degToRad(n._center.lat)),
                    t.rotateZ$1(d, d, n.angle),
                    t.rotateX$1(d, d, -n._pitch);
                    const f = t.fromQuat(new Float32Array(16), d)
                      , _ = t.mapValue(i.properties.get("star-intensity"), 0, 1, 0, .25)
                      , p = 5e-4
                      , m = t.mapValue(i.properties.get("horizon-blend"), 0, 1, p, .25)
                      , g = t.globeUseCustomAntiAliasing(e, r, n) && m === p ? n.worldSize / (2 * Math.PI * 1.025) - 1 : n.globeRadius
                      , v = e.frameCounter / 1e3 % 1
                      , y = t.length(n.globeCenterInViewSpace)
                      , b = Math.sqrt(Math.pow(y, 2) - Math.pow(g, 2))
                      , x = Math.acos(b / y)
                      , w = ( (e, i, r, o, n, s, a, l, c, h, u, d, f, _) => ({
                        u_frustum_tl: e,
                        u_frustum_tr: i,
                        u_frustum_br: r,
                        u_frustum_bl: o,
                        u_horizon: n,
                        u_transition: s,
                        u_fadeout_range: a,
                        u_color: l,
                        u_high_color: c,
                        u_space_color: h,
                        u_star_intensity: u,
                        u_star_size: 5 * t.exported.devicePixelRatio,
                        u_star_density: 0,
                        u_temporal_offset: d,
                        u_horizon_angle: f,
                        u_rotation_matrix: _
                    }))(n.frustumCorners.TL, n.frustumCorners.TR, n.frustumCorners.BR, n.frustumCorners.BL, n.frustumCorners.horizon, l, m, c, h, u, _, v, x, f);
                    e.prepareDrawProgram(r, a);
                    const T = e.atmosphereBuffer;
                    T && a.draw(r, o.TRIANGLES, s, t.StencilMode.disabled, t.ColorMode.alphaBlended, t.CullFaceMode.backCW, w, "skybox", T.vertexBuffer, T.indexBuffer, T.segments);
                }(this, this.style.fog),
                this.renderPass = "sky",
                (t.globeToMercatorTransition(this.transform.zoom) > 0 || "globe" !== this.transform.projection.name) && this.transform.isHorizonVisible())
                    for (this.currentLayer = 0; this.currentLayer < r.length; this.currentLayer++) {
                        const t = this.style._layers[r[this.currentLayer]]
                          , i = e._getLayerSourceCache(t);
                        t.isSky() && this.renderLayer(this, i, t, i ? s[i.id] : void 0);
                    }
                for (this.renderPass = "translucent",
                this.currentLayer = 0; this.currentLayer < r.length; ) {
                    const t = this.style._layers[r[this.currentLayer]]
                      , i = e._getLayerSourceCache(t);
                    if (t.isSky()) {
                        ++this.currentLayer;
                        continue
                    }
                    if (this.terrain && this.style.isLayerDraped(t)) {
                        if (t.isHidden(this.transform.zoom)) {
                            ++this.currentLayer;
                            continue
                        }
                        this.currentLayer = this.terrain.renderBatch(this.currentLayer);
                        continue
                    }
                    const o = i ? ("symbol" === t.type ? a : s)[i.id] : void 0;
                    this._renderTileClippingMasks(t, i, i ? n[i.id] : void 0),
                    this.renderLayer(this, i, t, o),
                    ++this.currentLayer;
                }
                if (this.terrain && this.terrain.postRender(),
                this.options.showTileBoundaries || this.options.showQueryGeometry) {
                    let i = null;
                    t.values(this.style._layers).forEach((t => {
                        const r = e._getLayerSourceCache(t);
                        r && !t.isHidden(this.transform.zoom) && (!i || i.getSource().maxzoom < r.getSource().maxzoom) && (i = r);
                    }
                    )),
                    i && this.options.showTileBoundaries && xn.debug(this, i, i.getVisibleCoordinates());
                }
                this.options.showPadding && function(t) {
                    const e = t.transform.padding;
                    cn(t, t.transform.height - (e.top || 0), 3, rn),
                    cn(t, e.bottom || 0, 3, on),
                    hn(t, e.left || 0, 3, nn),
                    hn(t, t.transform.width - (e.right || 0), 3, sn);
                    const i = t.transform.centerPoint;
                    !function(t, e, i, r) {
                        un(t, e - 1, i - 10, 2, 20, r),
                        un(t, e - 10, i - 1, 20, 2, r);
                    }(t, i.x, t.transform.height - i.y, an);
                }(this),
                !this.WaterLayer && this._waterSetting && this._waterSetting.show && (this.WaterLayer = t.createStyleLayer(new bn(this._waterSetting)),
                this.WaterLayer.onAdd(this.style.map)),
                this._waterSetting && this._waterSetting.show && (this.WaterLayer.implementation.setOptions(this._waterSetting),
                this.renderLayer(this, "", this.WaterLayer, null, !0));
                let l = {
                    context: this.context,
                    width: this.width,
                    height: this.height,
                    logoSize: i.logoSize || ""
                };
                this.LogoLayer || (this.LogoLayer = t.createStyleLayer(new yn(l)),
                this.LogoLayer.onAdd({
                    painter: {
                        context: this.context
                    }
                })),
                this.LogoLayer.implementation.updateSize(l),
                this.renderLayer(this, "", this.LogoLayer, null, !0),
                this.context.setDefault(),
                this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER,
                this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(t.window.performance.now()),
                this.saveCanvasCopy());
            }
            renderLayer(t, e, i, r, o) {
                i.isHidden(this.transform.zoom) || ("background" === i.type || "sky" === i.type || "custom" === i.type || r && r.length) && (this.id = i.id,
                this.gpuTimingStart(i),
                t.transform.projection.unsupportedLayers && t.transform.projection.unsupportedLayers.includes(i.type) && !o || xn[i.type](t, e, i, r, this.style.placement.variableOffsets, this.options.isInitialLoad, o),
                this.gpuTimingEnd());
            }
            gpuTimingStart(t) {
                if (!this.options.gpuTiming)
                    return;
                const e = this.context.extTimerQuery;
                let i = this.gpuTimers[t.id];
                i || (i = this.gpuTimers[t.id] = {
                    calls: 0,
                    cpuTime: 0,
                    query: e.createQueryEXT()
                }),
                i.calls++,
                e.beginQueryEXT(e.TIME_ELAPSED_EXT, i.query);
            }
            gpuTimingDeferredRenderStart() {
                if (this.options.gpuTimingDeferredRender) {
                    const t = this.context.extTimerQuery
                      , e = t.createQueryEXT();
                    this.deferredRenderGpuTimeQueries.push(e),
                    t.beginQueryEXT(t.TIME_ELAPSED_EXT, e);
                }
            }
            gpuTimingDeferredRenderEnd() {
                if (!this.options.gpuTimingDeferredRender)
                    return;
                const t = this.context.extTimerQuery;
                t.endQueryEXT(t.TIME_ELAPSED_EXT);
            }
            gpuTimingEnd() {
                if (!this.options.gpuTiming)
                    return;
                const t = this.context.extTimerQuery;
                t.endQueryEXT(t.TIME_ELAPSED_EXT);
            }
            collectGpuTimers() {
                const t = this.gpuTimers;
                return this.gpuTimers = {},
                t
            }
            collectDeferredRenderGpuQueries() {
                const t = this.deferredRenderGpuTimeQueries;
                return this.deferredRenderGpuTimeQueries = [],
                t
            }
            queryGpuTimers(t) {
                const e = {};
                for (const i in t) {
                    const r = t[i]
                      , o = this.context.extTimerQuery
                      , n = o.getQueryObjectEXT(r.query, o.QUERY_RESULT_EXT) / 1e6;
                    o.deleteQueryEXT(r.query),
                    e[i] = n;
                }
                return e
            }
            queryGpuTimeDeferredRender(t) {
                if (!this.options.gpuTimingDeferredRender)
                    return 0;
                const e = this.context.extTimerQuery;
                let i = 0;
                for (const r of t)
                    i += e.getQueryObjectEXT(r, e.QUERY_RESULT_EXT) / 1e6,
                    e.deleteQueryEXT(r);
                return i
            }
            translatePosMatrix(e, i, r, o, n) {
                if (!r[0] && !r[1])
                    return e;
                const s = n ? "map" === o ? this.transform.angle : 0 : "viewport" === o ? -this.transform.angle : 0;
                if (s) {
                    const t = Math.sin(s)
                      , e = Math.cos(s);
                    r = [r[0] * e - r[1] * t, r[0] * t + r[1] * e];
                }
                const a = [n ? r[0] : V(i, r[0], this.transform.zoom), n ? r[1] : V(i, r[1], this.transform.zoom, "xy")[1], 0]
                  , l = new Float32Array(16);
                return t.translate(l, e, a),
                l
            }
            saveTileTexture(t) {
                const e = this._tileTextures[t.size[0]];
                e ? e.push(t) : this._tileTextures[t.size[0]] = [t];
            }
            getTileTexture(t) {
                const e = this._tileTextures[t];
                return e && e.length > 0 ? e.pop() : null
            }
            isPatternMissing(t) {
                if (!t)
                    return !1;
                if (!t.from || !t.to)
                    return !0;
                const e = this.imageManager.getPattern(t.from.toString())
                  , i = this.imageManager.getPattern(t.to.toString());
                return !e || !i
            }
            currentGlobalDefines() {
                const t = this.terrain && this.terrain.renderingToTexture
                  , e = this.style && this.style.fog
                  , i = [];
                return this.terrain && !this.terrain.renderingToTexture && i.push("TERRAIN"),
                e && !t && 0 !== e.getOpacity(this.transform.pitch) && i.push("FOG"),
                t && i.push("RENDER_TO_TEXTURE"),
                this._showOverdrawInspector && i.push("OVERDRAW_INSPECTOR"),
                i
            }
            useProgram(t, e, i) {
                this.cache = this.cache || {};
                const r = i || []
                  , o = this.currentGlobalDefines().concat(r)
                  , n = co.cacheKey(Gr[t], t, o, e);
                return this.cache[n] || (this.cache[n] = new co(this.context,t,Gr[t],e,Go[t],o)),
                this.cache[n]
            }
            setCustomLayerDefaults() {
                this.context.unbindVAO(),
                this.context.cullFace.setDefault(),
                this.context.frontFace.setDefault(),
                this.context.cullFaceSide.setDefault(),
                this.context.activeTexture.setDefault(),
                this.context.pixelStoreUnpack.setDefault(),
                this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                this.context.pixelStoreUnpackFlipY.setDefault();
            }
            setBaseState() {
                const t = this.context.gl;
                this.context.cullFace.set(!1),
                this.context.viewport.set([0, 0, this.width, this.height]),
                this.context.blendEquation.set(t.FUNC_ADD);
            }
            initDebugOverlayCanvas() {
                null == this.debugOverlayCanvas && (this.debugOverlayCanvas = t.window.document.createElement("canvas"),
                this.debugOverlayCanvas.width = 512,
                this.debugOverlayCanvas.height = 512,
                this.debugOverlayTexture = new t.Texture(this.context,this.debugOverlayCanvas,this.context.gl.RGBA));
            }
            destroy() {
                this.LogoLayer.implementation.onRemove(),
                this._terrain && this._terrain.destroy(),
                this.globeSharedBuffers && this.globeSharedBuffers.destroy(),
                this.emptyTexture.destroy(),
                this.debugOverlayTexture && this.debugOverlayTexture.destroy(),
                this.atmosphereBuffer && this.atmosphereBuffer.destroy();
            }
            prepareDrawTile() {
                this.terrain && this.terrain.prepareDrawTile();
            }
            prepareDrawProgram(e, i, r) {
                if (this.terrain && this.terrain.renderingToTexture)
                    return;
                const o = this.style.fog;
                if (o) {
                    const n = o.getOpacity(this.transform.pitch)
                      , s = ( (e, i, r, o, n, s, a, l, c, h, u) => {
                        const d = e.transform
                          , f = i.properties.get("color").toArray01();
                        f[3] = o;
                        const _ = e.frameCounter / 1e3 % 1;
                        return {
                            u_fog_matrix: r ? d.calculateFogTileMatrix(r) : e.identityMat,
                            u_fog_range: i.getFovAdjustedRange(d._fov),
                            u_fog_color: f,
                            u_fog_horizon_blend: i.properties.get("horizon-blend"),
                            u_fog_temporal_offset: _,
                            u_frustum_tl: n,
                            u_frustum_tr: s,
                            u_frustum_br: a,
                            u_frustum_bl: l,
                            u_globe_pos: c,
                            u_globe_radius: h,
                            u_viewport: u,
                            u_globe_transition: t.globeToMercatorTransition(d.zoom),
                            u_is_globe: +("globe" === d.projection.name)
                        }
                    }
                    )(this, o, r, n, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * t.exported.devicePixelRatio, this.transform.height * t.exported.devicePixelRatio]);
                    i.setFogUniformValues(e, s);
                }
            }
            setTileLoadedFlag(t) {
                this.tileLoaded = t;
            }
            saveCanvasCopy() {
                this.frameCopies.push(this.canvasCopy()),
                this.tileLoaded = !1;
            }
            canvasCopy() {
                const t = this.context.gl
                  , e = t.createTexture();
                return t.bindTexture(t.TEXTURE_2D, e),
                t.copyTexImage2D(t.TEXTURE_2D, 0, t.RGBA, 0, 0, t.drawingBufferWidth, t.drawingBufferHeight, 0),
                e
            }
            getCanvasCopiesAndTimestamps() {
                return {
                    canvasCopies: this.frameCopies,
                    timeStamps: this.loadTimeStamps
                }
            }
            averageElevationNeedsEasing() {
                if (!this.transform._elevation)
                    return !1;
                const t = this.style && this.style.fog;
                return !!t && 0 !== t.getOpacity(this.transform.pitch)
            }
            getBackgroundTiles() {
                const e = this._backgroundTiles
                  , i = this._backgroundTiles = {}
                  , r = this.transform.coveringTiles({
                    tileSize: 512
                });
                for (const o of r)
                    i[o.key] = e[o.key] || new t.Tile(o,512,this.transform.tileZoom,this);
                return i
            }
            clearBackgroundTiles() {
                this._backgroundTiles = {};
            }
        }
        class Tn {
            constructor(t=0, e=0, i=0, r=0) {
                if (isNaN(t) || t < 0 || isNaN(e) || e < 0 || isNaN(i) || i < 0 || isNaN(r) || r < 0)
                    throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
                this.top = t,
                this.bottom = e,
                this.left = i,
                this.right = r;
            }
            interpolate(e, i, r) {
                return null != i.top && null != e.top && (this.top = t.number(e.top, i.top, r)),
                null != i.bottom && null != e.bottom && (this.bottom = t.number(e.bottom, i.bottom, r)),
                null != i.left && null != e.left && (this.left = t.number(e.left, i.left, r)),
                null != i.right && null != e.right && (this.right = t.number(e.right, i.right, r)),
                this
            }
            getCenter(e, i) {
                const r = t.clamp((this.left + e - this.right) / 2, 0, e)
                  , o = t.clamp((this.top + i - this.bottom) / 2, 0, i);
                return new t.pointGeometry(r,o)
            }
            equals(t) {
                return this.top === t.top && this.bottom === t.bottom && this.left === t.left && this.right === t.right
            }
            clone() {
                return new Tn(this.top,this.bottom,this.left,this.right)
            }
            toJSON() {
                return {
                    top: this.top,
                    bottom: this.bottom,
                    left: this.left,
                    right: this.right
                }
            }
        }
        function En(e, i) {
            const r = t.getColumn(e, 3);
            t.fromQuat(e, i),
            t.setColumn(e, 3, r);
        }
        function Sn(e, i) {
            const r = t.identity$1([]);
            return t.rotateZ$1(r, r, -i),
            t.rotateX$1(r, r, -e),
            r
        }
        function Cn(e, i) {
            const r = [e[0], e[1], 0]
              , o = [i[0], i[1], 0];
            if (t.length(r) >= 1e-15) {
                const e = t.normalize([], r);
                t.scale$2(o, e, t.dot(o, e)),
                i[0] = o[0],
                i[1] = o[1];
            }
            const n = t.cross([], i, e);
            if (t.len(n) < 1e-15)
                return null;
            const s = Math.atan2(-n[1], n[0]);
            return Sn(Math.atan2(Math.sqrt(e[0] * e[0] + e[1] * e[1]), -e[2]), s)
        }
        class An {
            constructor(t, e) {
                this.position = t,
                this.orientation = e;
            }
            get position() {
                return this._position
            }
            set position(e) {
                if (e) {
                    const i = e instanceof t.MercatorCoordinate ? e : new t.MercatorCoordinate(e[0],e[1],e[2]);
                    this._renderWorldCopies && (i.x = t.wrap(i.x, 0, 1)),
                    this._position = i;
                } else
                    this._position = null;
            }
            lookAtPoint(e, i) {
                if (this.orientation = null,
                !this.position)
                    return;
                const r = this._elevation ? this._elevation.getAtPointOrZero(t.MercatorCoordinate.fromLngLat(e)) : 0
                  , o = this.position
                  , n = t.MercatorCoordinate.fromLngLat(e, r)
                  , s = [n.x - o.x, n.y - o.y, n.z - o.z];
                i || (i = [0, 0, 1]),
                i[2] = Math.abs(i[2]),
                this.orientation = Cn(s, i);
            }
            setPitchBearing(e, i) {
                this.orientation = Sn(t.degToRad(e), t.degToRad(-i));
            }
        }
        class Mn {
            constructor(e, i) {
                this._transform = t.identity([]),
                this.orientation = i,
                this.position = e;
            }
            get mercatorPosition() {
                const e = this.position;
                return new t.MercatorCoordinate(e[0],e[1],e[2])
            }
            get position() {
                const e = t.getColumn(this._transform, 3);
                return [e[0], e[1], e[2]]
            }
            set position(e) {
                var i;
                e && t.setColumn(this._transform, 3, [(i = e)[0], i[1], i[2], 1]);
            }
            get orientation() {
                return this._orientation
            }
            set orientation(e) {
                this._orientation = e || t.identity$1([]),
                e && En(this._transform, this._orientation);
            }
            getPitchBearing() {
                const t = this.forward()
                  , e = this.right();
                return {
                    bearing: Math.atan2(-e[1], e[0]),
                    pitch: Math.atan2(Math.sqrt(t[0] * t[0] + t[1] * t[1]), -t[2])
                }
            }
            setPitchBearing(t, e) {
                this._orientation = Sn(t, e),
                En(this._transform, this._orientation);
            }
            forward() {
                const e = t.getColumn(this._transform, 2);
                return [-e[0], -e[1], -e[2]]
            }
            up() {
                const e = t.getColumn(this._transform, 1);
                return [-e[0], -e[1], -e[2]]
            }
            right() {
                const e = t.getColumn(this._transform, 0);
                return [e[0], e[1], e[2]]
            }
            getCameraToWorld(e, i) {
                const r = new Float64Array(16);
                return t.invert(r, this.getWorldToCamera(e, i)),
                r
            }
            getWorldToCameraPosition(e, i, r) {
                const o = this.position;
                t.scale$2(o, o, -e);
                const n = new Float64Array(16);
                return t.fromScaling(n, [r, r, r]),
                t.translate(n, n, o),
                n[10] *= i,
                n
            }
            getWorldToCamera(e, i) {
                const r = new Float64Array(16)
                  , o = new Float64Array(4)
                  , n = this.position;
                return t.conjugate(o, this._orientation),
                t.scale$2(n, n, -e),
                t.fromQuat(r, o),
                t.translate(r, r, n),
                r[1] *= -1,
                r[5] *= -1,
                r[9] *= -1,
                r[13] *= -1,
                r[8] *= i,
                r[9] *= i,
                r[10] *= i,
                r[11] *= i,
                r
            }
            getCameraToClipPerspective(e, i, r, o) {
                const n = new Float64Array(16);
                return t.perspective(n, e, i, r, o),
                n
            }
            getDistanceToElevation(e) {
                const i = 0 === e ? 0 : t.mercatorZfromAltitude(e, this.position[1])
                  , r = this.forward();
                return (i - this.position[2]) / r[2]
            }
            clone() {
                return new Mn([...this.position],[...this.orientation])
            }
        }
        function In(e, i) {
            const r = Pn(e.projection, e.zoom, e.width, e.height)
              , o = function(e, i, r, o, n) {
                const s = new t.LngLat(r.lng - 180 * Dn,r.lat)
                  , a = new t.LngLat(r.lng + 180 * Dn,r.lat)
                  , l = e.project(s.lng, s.lat)
                  , c = e.project(a.lng, a.lat)
                  , h = -Math.atan2(c.y - l.y, c.x - l.x)
                  , u = t.MercatorCoordinate.fromLngLat(r);
                u.y = t.clamp(u.y, -.999975, .999975);
                const d = u.toLngLat()
                  , f = e.project(d.lng, d.lat)
                  , _ = t.MercatorCoordinate.fromLngLat(d);
                _.x += Dn;
                const p = _.toLngLat()
                  , m = e.project(p.lng, p.lat)
                  , g = Ln(m.x - f.x, m.y - f.y, h)
                  , v = t.MercatorCoordinate.fromLngLat(d);
                v.y += Dn;
                const y = v.toLngLat()
                  , b = e.project(y.lng, y.lat)
                  , x = Ln(b.x - f.x, b.y - f.y, h)
                  , w = Math.abs(g.x) / Math.abs(x.y)
                  , T = t.identity([]);
                t.rotateZ(T, T, -h * (1 - (n ? 0 : o)));
                const E = t.identity([]);
                return t.scale(E, E, [1, 1 - (1 - w) * o, 1]),
                E[4] = -x.x / x.y * o,
                t.rotateZ(E, E, h),
                t.multiply(E, T, E),
                E
            }(e.projection, 0, e.center, r, i)
              , n = zn(e);
            return t.scale(o, o, [n, n, 1]),
            o
        }
        function zn(e) {
            const i = e.projection
              , r = Pn(e.projection, e.zoom, e.width, e.height)
              , o = Bn(i, e.center)
              , n = Bn(i, t.LngLat.convert(i.center));
            return Math.pow(2, o * r + (1 - r) * n)
        }
        function Pn(e, i, r, o, n=1 / 0) {
            const s = e.range;
            if (!s)
                return 0;
            const a = Math.min(n, Math.max(r, o))
              , l = Math.log(a / 1024) / Math.LN2;
            return t.smoothstep(s[0] + l, s[1] + l, i)
        }
        const Dn = 1 / 4e4;
        function Bn(e, i) {
            const r = t.clamp(i.lat, -t.MAX_MERCATOR_LATITUDE, t.MAX_MERCATOR_LATITUDE)
              , o = new t.LngLat(i.lng - 180 * Dn,r)
              , n = new t.LngLat(i.lng + 180 * Dn,r)
              , s = e.project(o.lng, r)
              , a = e.project(n.lng, r)
              , l = t.MercatorCoordinate.fromLngLat(o)
              , c = t.MercatorCoordinate.fromLngLat(n)
              , h = a.x - s.x
              , u = a.y - s.y
              , d = c.x - l.x
              , f = c.y - l.y
              , _ = Math.sqrt((d * d + f * f) / (h * h + u * u));
            return Math.log(_) / Math.LN2
        }
        function Ln(t, e, i) {
            const r = Math.cos(i)
              , o = Math.sin(i);
            return {
                x: t * r - e * o,
                y: t * o + e * r
            }
        }
        class Rn {
            constructor(e, i, r, o, n, s, a) {
                this.tileSize = 512,
                this._renderWorldCopies = void 0 === n || n,
                this._minZoom = e || 0,
                this._maxZoom = i || 22,
                this._minPitch = null == r ? 0 : r,
                this._maxPitch = null == o ? 60 : o,
                this.setProjection(s),
                this.setMaxBounds(a),
                this.width = 0,
                this.height = 0,
                this._center = new t.LngLat(0,0),
                this.zoom = 0,
                this.angle = 0,
                this._fov = .6435011087932844,
                this._pitch = 0,
                this._nearZ = 0,
                this._farZ = 0,
                this._unmodified = !0,
                this._edgeInsets = new Tn,
                this._projMatrixCache = {},
                this._alignedProjMatrixCache = {},
                this._fogTileMatrixCache = {},
                this._distanceTileDataCache = {},
                this._camera = new Mn,
                this._centerAltitude = 0,
                this._averageElevation = 0,
                this.cameraElevationReference = "ground",
                this._pixelsPerMercatorPixel = 1,
                this.globeRadius = 0,
                this.globeCenterInViewSpace = [0, 0, 0],
                this._horizonShift = .2;
            }
            clone() {
                const t = new Rn(this._minZoom,this._maxZoom,this._minPitch,this.maxPitch,this._renderWorldCopies,this.getProjection());
                return t._elevation = this._elevation,
                t._centerAltitude = this._centerAltitude,
                t._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration,
                t.tileSize = this.tileSize,
                t.width = this.width,
                t.height = this.height,
                t.cameraElevationReference = this.cameraElevationReference,
                t._center = this._center,
                t._setZoom(this.zoom),
                t._seaLevelZoom = this._seaLevelZoom,
                t.angle = this.angle,
                t._fov = this._fov,
                t._pitch = this._pitch,
                t._nearZ = this._nearZ,
                t._farZ = this._farZ,
                t._averageElevation = this._averageElevation,
                t._unmodified = this._unmodified,
                t._edgeInsets = this._edgeInsets.clone(),
                t._camera = this._camera.clone(),
                t._calcMatrices(),
                t.freezeTileCoverage = this.freezeTileCoverage,
                t.frustumCorners = this.frustumCorners,
                t
            }
            get elevation() {
                return this._elevation
            }
            set elevation(t) {
                this._elevation !== t && (this._elevation = t,
                this._updateCameraOnTerrain(),
                this._calcMatrices());
            }
            updateElevation(t) {
                const e = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
                (null == this._seaLevelZoom || e) && this._updateCameraOnTerrain(),
                (t || e) && this._constrainCameraAltitude(),
                this._calcMatrices();
            }
            getProjection() {
                return t.pick(this.projection, ["name", "center", "parallels"])
            }
            setProjection(e) {
                this.projectionOptions = e || {
                    name: "mercator"
                };
                const i = this.projection ? this.getProjection() : void 0;
                this.projection = t.getProjection(this.projectionOptions);
                const r = !c(i, this.getProjection());
                return r && this._calcMatrices(),
                this.mercatorFromTransition = !1,
                r
            }
            setMercatorFromTransition() {
                const e = this.projection.name;
                this.mercatorFromTransition = !0,
                this.projectionOptions = {
                    name: "mercator"
                },
                this.projection = t.getProjection({
                    name: "mercator"
                });
                const i = e !== this.projection.name;
                return i && this._calcMatrices(),
                i
            }
            get minZoom() {
                return this._minZoom
            }
            set minZoom(t) {
                this._minZoom !== t && (this._minZoom = t,
                this.zoom = Math.max(this.zoom, t));
            }
            get maxZoom() {
                return this._maxZoom
            }
            set maxZoom(t) {
                this._maxZoom !== t && (this._maxZoom = t,
                this.zoom = Math.min(this.zoom, t));
            }
            get minPitch() {
                return this._minPitch
            }
            set minPitch(t) {
                this._minPitch !== t && (this._minPitch = t,
                this.pitch = Math.max(this.pitch, t));
            }
            get maxPitch() {
                return this._maxPitch
            }
            set maxPitch(t) {
                this._maxPitch !== t && (this._maxPitch = t,
                this.pitch = Math.min(this.pitch, t));
            }
            get renderWorldCopies() {
                return this._renderWorldCopies && !0 === this.projection.supportsWorldCopies
            }
            set renderWorldCopies(t) {
                void 0 === t ? t = !0 : null === t && (t = !1),
                this._renderWorldCopies = t;
            }
            get worldSize() {
                return this.tileSize * this.scale
            }
            get cameraWorldSize() {
                const t = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
                return this._worldSizeFromZoom(this._zoomFromMercatorZ(t))
            }
            get pixelsPerMeter() {
                return this.projection.pixelsPerMeter(this.center.lat, this.worldSize)
            }
            get cameraPixelsPerMeter() {
                return t.mercatorZfromAltitude(this.center.lat, this.cameraWorldSize)
            }
            get centerOffset() {
                return this.centerPoint._sub(this.size._div(2))
            }
            get size() {
                return new t.pointGeometry(this.width,this.height)
            }
            get bearing() {
                return t.wrap(this.rotation, -180, 180)
            }
            set bearing(t) {
                this.rotation = t;
            }
            get rotation() {
                return -this.angle / Math.PI * 180
            }
            set rotation(e) {
                const i = -e * Math.PI / 180;
                var r;
                this.angle !== i && (this._unmodified = !1,
                this.angle = i,
                this._calcMatrices(),
                this.rotationMatrix = (r = new t.ARRAY_TYPE(4),
                t.ARRAY_TYPE != Float32Array && (r[1] = 0,
                r[2] = 0),
                r[0] = 1,
                r[3] = 1,
                r),
                function(t, e, i) {
                    var r = e[0]
                      , o = e[1]
                      , n = e[2]
                      , s = e[3]
                      , a = Math.sin(i)
                      , l = Math.cos(i);
                    t[0] = r * l + n * a,
                    t[1] = o * l + s * a,
                    t[2] = r * -a + n * l,
                    t[3] = o * -a + s * l;
                }(this.rotationMatrix, this.rotationMatrix, this.angle));
            }
            get pitch() {
                return this._pitch / Math.PI * 180
            }
            set pitch(e) {
                const i = t.clamp(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
                this._pitch !== i && (this._unmodified = !1,
                this._pitch = i,
                this._calcMatrices());
            }
            get fov() {
                return this._fov / Math.PI * 180
            }
            set fov(t) {
                t = Math.max(.01, Math.min(60, t)),
                this._fov !== t && (this._unmodified = !1,
                this._fov = t / 180 * Math.PI,
                this._calcMatrices());
            }
            get averageElevation() {
                return this._averageElevation
            }
            set averageElevation(t) {
                this._averageElevation = t,
                this._calcFogMatrices(),
                this._distanceTileDataCache = {};
            }
            get zoom() {
                return this._zoom
            }
            set zoom(t) {
                const e = Math.min(Math.max(t, this.minZoom), this.maxZoom);
                this._zoom !== e && (this._unmodified = !1,
                this._setZoom(e),
                this._updateSeaLevelZoom(),
                this._constrain(),
                this._calcMatrices());
            }
            _setZoom(t) {
                this._zoom = t,
                this.scale = this.zoomScale(t),
                this.tileZoom = Math.floor(t),
                this.zoomFraction = t - this.tileZoom;
            }
            _updateCameraOnTerrain() {
                if (!this._elevation || !this._elevation.isDataAvailableAtPoint(this.locationCoordinate(this.center)))
                    return this._centerAltitude = 0,
                    this._seaLevelZoom = null,
                    void (this._centerAltitudeValidForExaggeration = void 0);
                const t = this._elevation;
                this._centerAltitude = t.getAtPointOrZero(this.locationCoordinate(this.center)),
                this._centerAltitudeValidForExaggeration = t.exaggeration(),
                this._updateSeaLevelZoom();
            }
            _updateSeaLevelZoom() {
                void 0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
            }
            sampleAverageElevation() {
                if (!this._elevation)
                    return 0;
                const e = this._elevation
                  , i = [[.5, .2], [.3, .5], [.5, .5], [.7, .5], [.5, .8]]
                  , r = this.horizonLineFromTop();
                let o = 0
                  , n = 0;
                for (let s = 0; s < i.length; s++) {
                    const a = new t.pointGeometry(i[s][0] * this.width,r + i[s][1] * (this.height - r))
                      , l = e.pointCoordinate(a);
                    if (!l)
                        continue;
                    const c = 1 / Math.hypot(l[0] - this._camera.position[0], l[1] - this._camera.position[1]);
                    o += l[3] * c,
                    n += c;
                }
                return 0 === n ? NaN : o / n
            }
            get center() {
                return this._center
            }
            set center(t) {
                t.lat === this._center.lat && t.lng === this._center.lng || (this._unmodified = !1,
                this._center = t,
                this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()),
                this._constrain(),
                this._calcMatrices());
            }
            _updateZoomFromElevation() {
                if (null == this._seaLevelZoom || !this._elevation)
                    return;
                const t = this._seaLevelZoom
                  , e = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center))
                  , i = this.pixelsPerMeter / this.worldSize * e
                  , r = this._mercatorZfromZoom(t)
                  , o = this._mercatorZfromZoom(this._maxZoom)
                  , n = Math.max(r - i, o);
                this._setZoom(this._zoomFromMercatorZ(n));
            }
            get padding() {
                return this._edgeInsets.toJSON()
            }
            set padding(t) {
                this._edgeInsets.equals(t) || (this._unmodified = !1,
                this._edgeInsets.interpolate(this._edgeInsets, t, 1),
                this._calcMatrices());
            }
            computeZoomRelativeTo(e) {
                const i = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, e.toAltitude()));
                let r;
                r = e.z < this._camera.position[2] ? [i.x, i.y, i.z] : [e.x, e.y, e.z];
                const o = t.length(t.sub([], this._camera.position, r));
                return t.clamp(this._zoomFromMercatorZ(o), this._minZoom, this._maxZoom)
            }
            setFreeCameraOptions(e) {
                if (!this.height)
                    return;
                if (!e.position && !e.orientation)
                    return;
                this._updateCameraState();
                let i = !1;
                if (e.orientation && !t.exactEquals(e.orientation, this._camera.orientation) && (i = this._setCameraOrientation(e.orientation)),
                e.position) {
                    const r = [e.position.x, e.position.y, e.position.z];
                    t.exactEquals$1(r, this._camera.position) || (this._setCameraPosition(r),
                    i = !0);
                }
                i && (this._updateStateFromCamera(),
                this.recenterOnTerrain());
            }
            getFreeCameraOptions() {
                this._updateCameraState();
                const e = this._camera.position
                  , i = new An;
                return i.position = new t.MercatorCoordinate(e[0],e[1],e[2]),
                i.orientation = this._camera.orientation,
                i._elevation = this.elevation,
                i._renderWorldCopies = this.renderWorldCopies,
                i
            }
            _setCameraOrientation(e) {
                if (!t.length$1(e))
                    return !1;
                t.normalize$1(e, e);
                const i = t.transformQuat([], [0, 0, -1], e)
                  , r = t.transformQuat([], [0, -1, 0], e);
                if (r[2] < 0)
                    return !1;
                const o = Cn(i, r);
                return !!o && (this._camera.orientation = o,
                !0)
            }
            _setCameraPosition(e) {
                const i = this.zoomScale(this.minZoom) * this.tileSize
                  , r = this.zoomScale(this.maxZoom) * this.tileSize
                  , o = this.cameraToCenterDistance;
                e[2] = t.clamp(e[2], o / r, o / i),
                this._camera.position = e;
            }
            get centerPoint() {
                return this._edgeInsets.getCenter(this.width, this.height)
            }
            get fovAboveCenter() {
                return this._fov * (.5 + this.centerOffset.y / this.height)
            }
            isPaddingEqual(t) {
                return this._edgeInsets.equals(t)
            }
            interpolatePadding(t, e, i) {
                this._unmodified = !1,
                this._edgeInsets.interpolate(t, e, i),
                this._constrain(),
                this._calcMatrices();
            }
            coveringZoomLevel(t) {
                const e = (t.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t.tileSize));
                return Math.max(0, e)
            }
            getVisibleUnwrappedCoordinates(e) {
                const i = [new t.UnwrappedTileID(0,e)];
                if (this.renderWorldCopies) {
                    const r = this.pointCoordinate(new t.pointGeometry(0,0))
                      , o = this.pointCoordinate(new t.pointGeometry(this.width,0))
                      , n = this.pointCoordinate(new t.pointGeometry(this.width,this.height))
                      , s = this.pointCoordinate(new t.pointGeometry(0,this.height))
                      , a = Math.floor(Math.min(r.x, o.x, n.x, s.x))
                      , l = Math.floor(Math.max(r.x, o.x, n.x, s.x))
                      , c = 1;
                    for (let r = a - c; r <= l + c; r++)
                        0 !== r && i.push(new t.UnwrappedTileID(r,e));
                }
                return i
            }
            coveringTiles(e) {
                let i = this.coveringZoomLevel(e);
                const r = i
                  , o = this.elevation && !e.isTerrainDEM
                  , n = "mercator" === this.projection.name;
                if (void 0 !== e.minzoom && i < e.minzoom)
                    return [];
                void 0 !== e.maxzoom && i > e.maxzoom && (i = e.maxzoom);
                const s = this.locationCoordinate(this.center)
                  , a = this.center.lat
                  , l = 1 << i
                  , c = [l * s.x, l * s.y, 0]
                  , h = "globe" === this.projection.name
                  , u = !h
                  , d = t.Frustum.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i, u)
                  , f = h ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint())
                  , _ = l * t.mercatorZfromAltitude(1, this.center.lat)
                  , p = this._camera.position[2] / t.mercatorZfromAltitude(1, this.center.lat)
                  , m = [l * f.x, l * f.y, p * (u ? 1 : _)]
                  , g = this.cameraToCenterDistance / e.tileSize * (e.roundZoom ? 1 : .502)
                  , v = this.pitch <= 60 && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace ? i : 0
                  , y = e.isTerrainDEM && this._elevation ? 1e4 * this._elevation.exaggeration() : this._centerAltitude
                  , b = e.isTerrainDEM ? -y : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0
                  , x = this.projection.isReprojectedInTileSpace ? zn(this) : 1
                  , w = e => {
                    const i = 1 / 4e4
                      , r = new t.MercatorCoordinate(e.x + i,e.y,e.z)
                      , o = new t.MercatorCoordinate(e.x,e.y + i,e.z)
                      , n = e.toLngLat()
                      , s = r.toLngLat()
                      , a = o.toLngLat()
                      , l = this.locationCoordinate(n)
                      , c = this.locationCoordinate(s)
                      , h = this.locationCoordinate(a)
                      , u = Math.hypot(c.x - l.x, c.y - l.y)
                      , d = Math.hypot(h.x - l.x, h.y - l.y);
                    return Math.sqrt(u * d) * x / i
                }
                  , T = (e, i, r) => {
                    const o = y
                      , n = b;
                    return {
                        aabb: t.tileAABB(this, l, 0, 0, 0, e, n, o, this.projection),
                        zoom: 0,
                        x: 0,
                        y: 0,
                        minZ: n,
                        maxZ: o,
                        wrap: e,
                        fullyVisible: !1,
                        targZ: i,
                        zoomRange: r,
                        _tileY: 0,
                        _tileH: 1
                    }
                }
                  , E = [];
                let S = [];
                const C = i
                  , A = e.reparseOverscaled ? r : i
                  , M = t => t * t
                  , I = M((p - this._centerAltitude) * _)
                  , z = t => {
                    if (!this._elevation || !t.tileID || !n)
                        return;
                    const e = this._elevation.getMinMaxForTile(t.tileID)
                      , i = t.aabb;
                    e ? (i.min[2] = e.min,
                    i.max[2] = e.max,
                    i.center[2] = (i.min[2] + i.max[2]) / 2) : (t.shouldSplit = P(t),
                    t.shouldSplit || (i.min[2] = i.max[2] = i.center[2] = this._centerAltitude));
                }
                  , P = e => {
                    if (e.zoom < v)
                        return !0;
                    if (e.zoom === C)
                        return !1;
                    if (null != e.shouldSplit)
                        return e.shouldSplit;
                    const i = e.aabb.distanceX(m)
                      , n = e.aabb.distanceY(m);
                    let s = I
                      , l = 1;
                    if (h) {
                        s = M(e.aabb.distanceZ(m));
                        const i = Math.pow(2, e.zoom)
                          , r = t.latFromMercatorY((e._tileY + e._tileH) / i)
                          , o = t.latFromMercatorY(e._tileY / i)
                          , n = Math.min(Math.max(a, r), o)
                          , c = t.circumferenceAtLatitude(n) / t.circumferenceAtLatitude(a);
                        if (l = n === a ? 1 / Math.max(1, this._mercatorScaleRatio - .3) : Math.min(1, c / this._mercatorScaleRatio),
                        this.zoom <= t.GLOBE_ZOOM_THRESHOLD_MIN && e.zoom === C - 1 && c >= .9)
                            return !0
                    } else if (o && (s = M(e.aabb.distanceZ(m) * _)),
                    this.projection.isReprojectedInTileSpace && r <= 5) {
                        const i = Math.pow(2, e.zoom)
                          , r = w(new t.MercatorCoordinate((e.x + .5) / i,(e._tileY + e._tileH / 2) / i));
                        l = r > .85 ? 1 : r;
                    }
                    const c = i * i + n * n + s;
                    return c < M((1 << C - e.zoom) * g * l * ( (t, e) => {
                        if (e * M(.707) < t)
                            return 1;
                        const i = Math.sqrt(e / t);
                        return i / (1.4144271570014144 + (Math.pow(1.1, i - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1)
                    }
                    )(Math.max(s, I), c))
                }
                ;
                let D = null
                  , B = e.zoomRule
                  , L = null
                  , R = [i]
                  , k = [];
                const O = "Sg4326" == e.reference;
                if (O && (D = e.reference,
                L = e.sourceID),
                B) {
                    R = [];
                    let t = String(this.tileZoom);
                    k = B.map((t => Object.values(t))) || [];
                    for (let e = 0, i = B.length; e < i; e++) {
                        var F = B[e]
                          , U = Object.keys(F);
                        for (let e = 0, i = U.length; e < i; e++)
                            if (U[e].split(",").indexOf(t) >= 0) {
                                var N = F[U[e]];
                                R.indexOf(N) < 0 && R.push(Number(N));
                                break
                            }
                    }
                }
                const j = R.length;
                if (this.renderWorldCopies)
                    for (let t = 1; t <= 3; t++)
                        for (let e = 0; e < j; e++)
                            E.push(T(-t, R[e], k[e])),
                            E.push(T(t, R[e], k[e]));
                for (let t = 0; t < j; t++)
                    E.push(T(0, R[t], k[t]));
                for (; E.length > 0; ) {
                    const r = E.pop()
                      , a = r.x
                      , u = r.y;
                    let f = r.fullyVisible;
                    if (!f) {
                        const t = r.aabb.intersects(d);
                        if (0 === t)
                            continue;
                        f = 2 === t;
                    }
                    let _ = r.zoom === C || !P(r);
                    if (r.targZ && r.zoomRange && (_ = r.zoom === r.targZ || !P(r) && r.zoomRange.indexOf(r.zoom) >= 0),
                    _) {
                        const o = r.zoom === C ? A : r.zoom;
                        if (e.minzoom && e.minzoom > o)
                            continue;
                        let n = c[0] - (.5 + a + (r.wrap << r.zoom)) * (1 << i - r.zoom)
                          , l = c[1] - .5 - u
                          , h = u
                          , d = 1;
                        if (O) {
                            let e = Math.pow(2, r.zoom)
                              , i = [e * s.x, e * s.y, 0]
                              , o = t.MercatorTileY(a, u, r.zoom, "all");
                            n = i[0] - (.5 + a + (r.wrap << r.zoom)),
                            l = i[1] - o.top - o.height / 2,
                            h = o.top,
                            d = o.height;
                        }
                        const f = r.tileID ? r.tileID : new t.OverscaledTileID(o,r.wrap,r.zoom,a,u,{
                            reference: D,
                            sourceID: L,
                            zoomRule: F,
                            _tileY: h,
                            _tileH: d,
                            _mapZoom: A
                        });
                        S.push({
                            tileID: f,
                            distanceSq: n * n + l * l
                        });
                    } else
                        for (let e = 0; e < 4; e++) {
                            const i = (a << 1) + e % 2
                              , s = (u << 1) + (e >> 1);
                            let c, d = s, _ = 1;
                            if (O) {
                                let e = t.MercatorTileY(i, s, r.zoom + 1, "all");
                                d = e.top,
                                _ = e.height,
                                c = t.tileAABB(this, l, r.zoom + 1, i, s, r.wrap, r.minZ, r.maxZ, this.projection, D, L, d, _);
                            } else
                                c = n ? r.aabb.quadrant(e) : t.tileAABB(this, l, r.zoom + 1, i, s, r.wrap, r.minZ, r.maxZ, this.projection);
                            const p = {
                                aabb: c,
                                zoom: r.zoom + 1,
                                x: i,
                                y: s,
                                wrap: r.wrap,
                                fullyVisible: f,
                                tileID: void 0,
                                shouldSplit: void 0,
                                minZ: r.minZ,
                                maxZ: r.maxZ,
                                targZ: r.targZ,
                                zoomRange: r.zoomRange,
                                _tileY: d,
                                _tileH: _
                            };
                            o && !h && (p.tileID = new t.OverscaledTileID(r.zoom + 1 === C ? A : r.zoom + 1,r.wrap,r.zoom + 1,i,s,{
                                reference: D,
                                sourceID: L,
                                zoomRule: F,
                                _tileY: d,
                                _tileH: _,
                                _mapZoom: A
                            }),
                            z(p)),
                            E.push(p);
                        }
                }
                if (this.fogCullDistSq) {
                    const i = this.fogCullDistSq
                      , r = this.horizonLineFromTop();
                    S = S.filter((o => {
                        const n = [0, 0, 0, 1]
                          , s = [t.EXTENT, t.EXTENT, 0, 1]
                          , a = this.calculateFogTileMatrix(o.tileID.toUnwrapped());
                        t.transformMat4$1(n, n, a),
                        t.transformMat4$1(s, s, a);
                        const l = t.getAABBPointSquareDist(n, s);
                        if (0 === l)
                            return !0;
                        let c = !1;
                        const h = this._elevation;
                        if (h && l > i && 0 !== r) {
                            const i = this.calculateProjMatrix(o.tileID.toUnwrapped());
                            let n;
                            e.isTerrainDEM || (n = h.getMinMaxForTile(o.tileID)),
                            n || (n = {
                                min: b,
                                max: y
                            });
                            const s = t.furthestTileCorner(this.rotation)
                              , a = [s[0] * t.EXTENT, s[1] * t.EXTENT, n.max];
                            t.transformMat4(a, a, i),
                            c = (1 - a[1]) * this.height * .5 < r;
                        }
                        return l < i || c
                    }
                    ));
                }
                return S.sort(( (t, e) => t.distanceSq - e.distanceSq)).map((t => t.tileID))
            }
            resize(t, e) {
                this.width = t,
                this.height = e,
                this.pixelsToGLUnits = [2 / t, -2 / e],
                this._constrain(),
                this._calcMatrices();
            }
            get unmodified() {
                return this._unmodified
            }
            zoomScale(t) {
                return Math.pow(2, t)
            }
            scaleZoom(t) {
                return Math.log(t) / Math.LN2
            }
            project(e) {
                const i = t.clamp(e.lat, -t.MAX_MERCATOR_LATITUDE, t.MAX_MERCATOR_LATITUDE)
                  , r = this.projection.project(e.lng, i);
                return new t.pointGeometry(r.x * this.worldSize,r.y * this.worldSize)
            }
            unproject(t) {
                return this.projection.unproject(t.x / this.worldSize, t.y / this.worldSize)
            }
            get point() {
                return this.project(this.center)
            }
            setLocationAtPoint(e, i) {
                let r, o;
                const n = this.centerPoint;
                if ("globe" === this.projection.name) {
                    const t = this.worldSize;
                    r = (i.x - n.x) / t,
                    o = (i.y - n.y) / t;
                } else {
                    const t = this.pointCoordinate(i)
                      , e = this.pointCoordinate(n);
                    r = t.x - e.x,
                    o = t.y - e.y;
                }
                const s = this.locationCoordinate(e);
                this.setLocation(new t.MercatorCoordinate(s.x - r,s.y - o));
            }
            setLocation(t) {
                this.center = this.coordinateLocation(t),
                this.projection.wrap && (this.center = this.center.wrap());
            }
            locationPoint(t) {
                return this.projection.locationPoint(this, t)
            }
            locationPoint3D(t) {
                return this.projection.locationPoint(this, t, !0)
            }
            pointLocation(t) {
                return this.coordinateLocation(this.pointCoordinate(t))
            }
            pointLocation3D(t) {
                return this.coordinateLocation(this.pointCoordinate3D(t))
            }
            locationCoordinate(e, i) {
                const r = i ? t.mercatorZfromAltitude(i, e.lat) : void 0
                  , o = this.projection.project(e.lng, e.lat);
                return new t.MercatorCoordinate(o.x,o.y,r)
            }
            coordinateLocation(t) {
                return this.projection.unproject(t.x, t.y)
            }
            pointRayIntersection(e, i) {
                const r = null != i ? i : this._centerAltitude
                  , o = [e.x, e.y, 0, 1]
                  , n = [e.x, e.y, 1, 1];
                t.transformMat4$1(o, o, this.pixelMatrixInverse),
                t.transformMat4$1(n, n, this.pixelMatrixInverse);
                const s = n[3];
                t.scale$1(o, o, 1 / o[3]),
                t.scale$1(n, n, 1 / s);
                const a = o[2]
                  , l = n[2];
                return {
                    p0: o,
                    p1: n,
                    t: a === l ? 0 : (r - a) / (l - a)
                }
            }
            screenPointToMercatorRay(e) {
                const i = [e.x, e.y, 0, 1]
                  , r = [e.x, e.y, 1, 1];
                return t.transformMat4$1(i, i, this.pixelMatrixInverse),
                t.transformMat4$1(r, r, this.pixelMatrixInverse),
                t.scale$1(i, i, 1 / i[3]),
                t.scale$1(r, r, 1 / r[3]),
                i[2] = t.mercatorZfromAltitude(i[2], this._center.lat) * this.worldSize,
                r[2] = t.mercatorZfromAltitude(r[2], this._center.lat) * this.worldSize,
                t.scale$1(i, i, 1 / this.worldSize),
                t.scale$1(r, r, 1 / this.worldSize),
                new t.Ray([i[0], i[1], i[2]],t.normalize([], t.sub([], r, i)))
            }
            rayIntersectionCoordinate(e) {
                const {p0: i, p1: r, t: o} = e
                  , n = t.mercatorZfromAltitude(i[2], this._center.lat)
                  , s = t.mercatorZfromAltitude(r[2], this._center.lat);
                return new t.MercatorCoordinate(t.number(i[0], r[0], o) / this.worldSize,t.number(i[1], r[1], o) / this.worldSize,t.number(n, s, o))
            }
            pointCoordinate(t, e=this._centerAltitude) {
                return this.projection.pointCoordinate(this, t.x, t.y, e)
            }
            pointCoordinate3D(e) {
                if (!this.elevation)
                    return this.pointCoordinate(e);
                let i = this.projection.pointCoordinate3D(this, e.x, e.y);
                if (i)
                    return new t.MercatorCoordinate(i[0],i[1],i[2]);
                let r = 0
                  , o = this.horizonLineFromTop();
                if (e.y > o)
                    return this.pointCoordinate(e);
                const n = .02 * o
                  , s = e.clone();
                for (let e = 0; e < 10 && o - r > n; e++) {
                    s.y = t.number(r, o, .66);
                    const e = this.projection.pointCoordinate3D(this, s.x, s.y);
                    e ? (o = s.y,
                    i = e) : r = s.y;
                }
                return i ? new t.MercatorCoordinate(i[0],i[1],i[2]) : this.pointCoordinate(e)
            }
            isPointAboveHorizon(t) {
                return this.projection.isPointAboveHorizon(this, t)
            }
            _coordinatePoint(e, i) {
                const r = i && this.elevation ? this.elevation.getAtPointOrZero(e, this._centerAltitude) : this._centerAltitude
                  , o = [e.x * this.worldSize, e.y * this.worldSize, r + e.toAltitude(), 1];
                return t.transformMat4$1(o, o, this.pixelMatrix),
                o[3] > 0 ? new t.pointGeometry(o[0] / o[3],o[1] / o[3]) : new t.pointGeometry(Number.MAX_VALUE,Number.MAX_VALUE)
            }
            _getBounds(e, i) {
                const r = new t.pointGeometry(this._edgeInsets.left,this._edgeInsets.top)
                  , o = new t.pointGeometry(this.width - this._edgeInsets.right,this._edgeInsets.top)
                  , n = new t.pointGeometry(this.width - this._edgeInsets.right,this.height - this._edgeInsets.bottom)
                  , s = new t.pointGeometry(this._edgeInsets.left,this.height - this._edgeInsets.bottom);
                let a = this.pointCoordinate(r, e)
                  , l = this.pointCoordinate(o, e);
                const c = this.pointCoordinate(n, i)
                  , h = this.pointCoordinate(s, i)
                  , u = (t, e) => (e.y - t.y) / (e.x - t.x);
                return a.y > 1 && l.y >= 0 ? a = new t.MercatorCoordinate((1 - h.y) / u(h, a) + h.x,1) : a.y < 0 && l.y <= 1 && (a = new t.MercatorCoordinate(-h.y / u(h, a) + h.x,0)),
                l.y > 1 && a.y >= 0 ? l = new t.MercatorCoordinate((1 - c.y) / u(c, l) + c.x,1) : l.y < 0 && a.y <= 1 && (l = new t.MercatorCoordinate(-c.y / u(c, l) + c.x,0)),
                (new t.LngLatBounds).extend(this.coordinateLocation(a)).extend(this.coordinateLocation(l)).extend(this.coordinateLocation(h)).extend(this.coordinateLocation(c))
            }
            _getBounds3D() {
                const t = this.elevation;
                if (!t.visibleDemTiles.length || t.isUsingMockSource())
                    return this._getBounds(0, 0);
                const e = t.visibleDemTiles.reduce(( (t, e) => {
                    if (e.dem) {
                        const i = e.dem.tree;
                        t.min = Math.min(t.min, i.minimums[0]),
                        t.max = Math.max(t.max, i.maximums[0]);
                    }
                    return t
                }
                ), {
                    min: Number.MAX_VALUE,
                    max: 0
                });
                return this._getBounds(e.min * t.exaggeration(), e.max * t.exaggeration())
            }
            getBounds() {
                return this._terrainEnabled() ? this._getBounds3D() : this._getBounds(0, 0)
            }
            horizonLineFromTop(t=!0) {
                const e = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, .1)) + this.centerOffset.y
                  , i = this.height / 2 - e * (1 - this._horizonShift);
                return t ? Math.max(0, i) : i
            }
            getMaxBounds() {
                return this.maxBounds
            }
            setMaxBounds(e) {
                this.maxBounds = e,
                this.minLat = -t.MAX_MERCATOR_LATITUDE,
                this.maxLat = t.MAX_MERCATOR_LATITUDE,
                this.minLng = -180,
                this.maxLng = 180,
                e && (this.minLat = e.getSouth(),
                this.maxLat = e.getNorth(),
                this.minLng = e.getWest(),
                this.maxLng = e.getEast(),
                this.maxLng < this.minLng && (this.maxLng += 360)),
                this.worldMinX = t.mercatorXfromLng(this.minLng) * this.tileSize,
                this.worldMaxX = t.mercatorXfromLng(this.maxLng) * this.tileSize,
                this.worldMinY = t.mercatorYfromLat(this.maxLat) * this.tileSize,
                this.worldMaxY = t.mercatorYfromLat(this.minLat) * this.tileSize,
                this._constrain();
            }
            calculatePosMatrix(t, e) {
                return this.projection.createTileMatrix(this, e, t)
            }
            calculateDistanceTileData(e) {
                const i = e.key
                  , r = this._distanceTileDataCache;
                if (r[i])
                    return r[i];
                const o = e.canonical
                  , n = 1 / this.height
                  , s = this.cameraWorldSize / this.zoomScale(o.z)
                  , a = (o.x + Math.pow(2, o.z) * e.wrap) * s
                  , l = o._tileY * s
                  , c = this.point
                  , h = this.angle
                  , u = Math.sin(-h)
                  , d = -Math.cos(-h);
                return r[i] = {
                    bearing: [u, d],
                    center: [(c.x - a) * n, (c.y - l) * n],
                    scale: s / t.EXTENT * n
                },
                r[i]
            }
            calculateFogTileMatrix(e) {
                const i = e.key
                  , r = this._fogTileMatrixCache;
                if (r[i])
                    return r[i];
                const o = this.projection.createTileMatrix(this, this.cameraWorldSize, e);
                return t.multiply(o, this.worldToFogMatrix, o),
                r[i] = new Float32Array(o),
                r[i]
            }
            calculateProjMatrix(e, i=!1) {
                const r = e.key
                  , o = i ? this._alignedProjMatrixCache : this._projMatrixCache;
                if (o[r])
                    return o[r];
                const n = this.calculatePosMatrix(e, this.worldSize);
                return t.multiply(n, this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : i ? this.alignedProjMatrix : this.projMatrix, n),
                o[r] = new Float32Array(n),
                o[r]
            }
            calculatePixelsToTileUnitsMatrix(e) {
                const i = e.tileID.key
                  , r = this._pixelsToTileUnitsCache;
                if (r[i])
                    return r[i];
                const o = function(e, i) {
                    const {scale: r} = e.tileTransform
                      , o = r * t.EXTENT / (e.tileSize * Math.pow(2, i.zoom - e.tileID.overscaledZ + e.tileID.canonical.z))
                      , n = "Sg4326" == e.tileID.reference;
                    return s = new Float32Array(4),
                    c = (a = i.inverseAdjustmentMatrix)[1],
                    h = a[2],
                    u = a[3],
                    f = (l = n ? [o, o / e.tileID._tileH] : [o, o])[1],
                    s[0] = a[0] * (d = l[0]),
                    s[1] = c * d,
                    s[2] = h * f,
                    s[3] = u * f,
                    s;
                    var s, a, l, c, h, u, d, f;
                }(e, this);
                return r[i] = o,
                r[i]
            }
            customLayerMatrix() {
                return this.mercatorMatrix.slice()
            }
            recenterOnTerrain() {
                if (!this._elevation || "globe" === this.projection.name)
                    return;
                const e = this._elevation;
                this._updateCameraState();
                const i = t.mercatorZfromAltitude(1, this._center.lat) * this.worldSize
                  , r = this._computeCameraPosition(i)
                  , o = this._camera.forward()
                  , n = t.mercatorZfromAltitude(1, this._center.lat);
                r[2] /= n,
                o[2] /= n,
                t.normalize(o, o);
                const s = e.raycast(r, o, e.exaggeration());
                if (s) {
                    const e = t.scaleAndAdd([], r, o, s)
                      , i = new t.MercatorCoordinate(e[0],e[1],t.mercatorZfromAltitude(e[2], t.latFromMercatorY(e[1])))
                      , a = (i.z + t.length([i.x - r[0], i.y - r[1], i.z - r[2] * n])) * this._pixelsPerMercatorPixel;
                    this._seaLevelZoom = this._zoomFromMercatorZ(a),
                    this._centerAltitude = i.toAltitude(),
                    this._center = this.coordinateLocation(i),
                    this._updateZoomFromElevation(),
                    this._constrain(),
                    this._calcMatrices();
                }
            }
            _constrainCameraAltitude() {
                if (!this._elevation)
                    return;
                const e = this._elevation;
                this._updateCameraState();
                const i = t.mercatorZfromAltitude(1, this._center.lat) * this.worldSize
                  , r = this._computeCameraPosition(i)
                  , o = e.getAtPointOrZero(new t.MercatorCoordinate(...r))
                  , n = this._minimumHeightOverTerrain() * Math.cos(t.degToRad(this._maxPitch))
                  , s = this._camera.position[2] - this.pixelsPerMeter / this.worldSize * o;
                if (s < n) {
                    const e = this.locationCoordinate(this._center, this._centerAltitude)
                      , i = [e.x - r[0], e.y - r[1], e.z - r[2]]
                      , o = t.length(i);
                    i[2] -= (n - s) / this._pixelsPerMercatorPixel;
                    const a = t.length(i);
                    if (0 === a)
                        return;
                    t.scale$2(i, i, o / a * this._pixelsPerMercatorPixel),
                    this._camera.position = [e.x - i[0], e.y - i[1], e.z * this._pixelsPerMercatorPixel - i[2]],
                    this._camera.orientation = Cn(i, this._camera.up()),
                    this._updateStateFromCamera();
                }
            }
            _constrain() {
                if (!this.center || !this.width || !this.height || this._constraining)
                    return;
                this._constraining = !0;
                const e = "globe" === this.projection.name || this.mercatorFromTransition;
                if (this.projection.isReprojectedInTileSpace || e) {
                    const i = this.center;
                    return i.lat = t.clamp(i.lat, this.minLat, this.maxLat),
                    (this.maxBounds || !this.renderWorldCopies && !e) && (i.lng = t.clamp(i.lng, this.minLng, this.maxLng)),
                    this.center = i,
                    void (this._constraining = !1)
                }
                const i = this._unmodified
                  , {x: r, y: o} = this.point;
                let n = 0
                  , s = r
                  , a = o;
                const l = this.width / 2
                  , c = this.height / 2
                  , h = this.worldMinY * this.scale
                  , u = this.worldMaxY * this.scale;
                if (o - c < h && (a = h + c),
                o + c > u && (a = u - c),
                u - h < this.height && (n = Math.max(n, this.height / (u - h)),
                a = (u + h) / 2),
                this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
                    const t = this.worldMinX * this.scale
                      , e = this.worldMaxX * this.scale
                      , i = this.worldSize / 2 - (t + e) / 2;
                    s = (r + i + this.worldSize) % this.worldSize - i,
                    s - l < t && (s = t + l),
                    s + l > e && (s = e - l),
                    e - t < this.width && (n = Math.max(n, this.width / (e - t)),
                    s = (e + t) / 2);
                }
                s === r && a === o || (this.center = this.unproject(new t.pointGeometry(s,a))),
                n && (this.zoom += this.scaleZoom(n)),
                this._constrainCameraAltitude(),
                this._unmodified = i,
                this._constraining = !1;
            }
            _minZoomForBounds() {
                let t = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
                return this.maxBounds && (t = Math.max(t, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))),
                t
            }
            _maxCameraBoundsDistance() {
                return this._mercatorZfromZoom(this._minZoomForBounds())
            }
            _calcMatrices() {
                if (!this.height)
                    return;
                const e = this.centerOffset
                  , i = this.pixelsPerMeter;
                "globe" === this.projection.name && (this._mercatorScaleRatio = t.mercatorZfromAltitude(1, this.center.lat) / t.mercatorZfromAltitude(1, t.GLOBE_SCALE_MATCH_LATITUDE));
                const r = Pn(this.projection, this.zoom, this.width, this.height, 1024);
                this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, r),
                this.cameraToCenterDistance = .5 / Math.tan(.5 * this._fov) * this.height * this._pixelsPerMercatorPixel,
                this._updateCameraState(),
                this._farZ = this.projection.farthestPixelDistance(this),
                this._nearZ = this.height / 50;
                const o = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? i : 1)
                  , n = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
                n[8] = 2 * -e.x / this.width,
                n[9] = 2 * e.y / this.height;
                let s = t.mul([], n, o);
                if (this.projection.isReprojectedInTileSpace) {
                    const e = this.locationCoordinate(this.center)
                      , i = t.identity([]);
                    t.translate(i, i, [e.x * this.worldSize, e.y * this.worldSize, 0]),
                    t.multiply(i, i, In(this)),
                    t.translate(i, i, [-e.x * this.worldSize, -e.y * this.worldSize, 0]),
                    t.multiply(s, s, i),
                    this.inverseAdjustmentMatrix = function(t) {
                        const e = In(t, !0);
                        return A([], [e[0], e[1], e[4], e[5]])
                    }(this);
                } else
                    this.inverseAdjustmentMatrix = [1, 0, 0, 1];
                this.mercatorMatrix = t.scale([], s, [this.worldSize, this.worldSize, this.worldSize / i, 1]),
                this.projMatrix = s,
                this.invProjMatrix = t.invert(new Float64Array(16), this.projMatrix);
                const a = t.invert([], n);
                this.frustumCorners = t.FrustumCorners.fromInvProjectionMatrix(a, this.horizonLineFromTop(), this.height);
                const l = new Float32Array(16);
                t.identity(l),
                t.scale(l, l, [1, -1, 1]),
                t.rotateX(l, l, this._pitch),
                t.rotateZ(l, l, this.angle);
                const c = t.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ)
                  , h = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
                c[8] = 2 * -e.x / this.width,
                c[9] = 2 * (e.y + h) / this.height,
                this.skyboxMatrix = t.multiply(l, c, l);
                const u = this.point
                  , d = u.x
                  , f = u.y
                  , _ = this.width % 2 / 2
                  , p = this.height % 2 / 2
                  , m = Math.cos(this.angle)
                  , g = Math.sin(this.angle)
                  , v = d - Math.round(d) + m * _ + g * p
                  , y = f - Math.round(f) + m * p + g * _
                  , b = new Float64Array(s);
                if (t.translate(b, b, [v > .5 ? v - 1 : v, y > .5 ? y - 1 : y, 0]),
                this.alignedProjMatrix = b,
                s = t.create(),
                t.scale(s, s, [this.width / 2, -this.height / 2, 1]),
                t.translate(s, s, [1, -1, 0]),
                this.labelPlaneMatrix = s,
                s = t.create(),
                t.scale(s, s, [1, -1, 1]),
                t.translate(s, s, [-1, -1, 0]),
                t.scale(s, s, [2 / this.width, 2 / this.height, 1]),
                this.glCoordMatrix = s,
                this.pixelMatrix = t.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix),
                this._calcFogMatrices(),
                this._distanceTileDataCache = {},
                s = t.invert(new Float64Array(16), this.pixelMatrix),
                !s)
                    throw new Error("failed to invert matrix");
                if (this.pixelMatrixInverse = s,
                "globe" === this.projection.name || this.mercatorFromTransition) {
                    this.globeMatrix = t.calculateGlobeMatrix(this);
                    const e = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
                    this.globeCenterInViewSpace = t.transformMat4(e, e, o),
                    this.globeRadius = this.worldSize / 2 / Math.PI - 1;
                } else
                    this.globeMatrix = s;
                this._projMatrixCache = {},
                this._alignedProjMatrixCache = {},
                this._pixelsToTileUnitsCache = {};
            }
            _calcFogMatrices() {
                this._fogTileMatrixCache = {};
                const e = this.cameraWorldSize
                  , i = this.cameraPixelsPerMeter
                  , r = this._camera.position
                  , o = 1 / this.height / this._pixelsPerMercatorPixel
                  , n = [e, e, i];
                t.scale$2(n, n, o),
                t.scale$2(r, r, -1),
                t.multiply$2(r, r, n);
                const s = t.create();
                t.translate(s, s, r),
                t.scale(s, s, n),
                this.mercatorFogMatrix = s,
                this.worldToFogMatrix = this._camera.getWorldToCameraPosition(e, i, o);
            }
            _computeCameraPosition(t) {
                const e = (t = t || this.pixelsPerMeter) / this.pixelsPerMeter
                  , i = this._camera.forward()
                  , r = this.point
                  , o = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * e - t / this.worldSize * this._centerAltitude;
                return [r.x / this.worldSize - i[0] * o, r.y / this.worldSize - i[1] * o, t / this.worldSize * this._centerAltitude - i[2] * o]
            }
            _updateCameraState() {
                this.height && (this._camera.setPitchBearing(this._pitch, this.angle),
                this._camera.position = this._computeCameraPosition());
            }
            _translateCameraConstrained(e) {
                const i = this._maxCameraBoundsDistance() * Math.cos(this._pitch)
                  , r = this._camera.position[2]
                  , o = e[2];
                let n = 1;
                this.projection.wrap && (this.center = this.center.wrap()),
                o > 0 && (n = Math.min((i - r) / o, 1)),
                this._camera.position = t.scaleAndAdd([], this._camera.position, e, n),
                this._updateStateFromCamera();
            }
            _updateStateFromCamera() {
                const e = this._camera.position
                  , i = this._camera.forward()
                  , {pitch: r, bearing: o} = this._camera.getPitchBearing()
                  , n = t.mercatorZfromAltitude(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel
                  , s = this._mercatorZfromZoom(this._maxZoom) * Math.cos(t.degToRad(this._maxPitch))
                  , a = Math.max((e[2] - n) / Math.cos(r), s)
                  , l = this._zoomFromMercatorZ(a);
                t.scaleAndAdd(e, e, i, a),
                this._pitch = t.clamp(r, t.degToRad(this.minPitch), t.degToRad(this.maxPitch)),
                this.angle = t.wrap(o, -Math.PI, Math.PI),
                this._setZoom(t.clamp(l, this._minZoom, this._maxZoom)),
                this._updateSeaLevelZoom(),
                this._center = this.coordinateLocation(new t.MercatorCoordinate(e[0],e[1],e[2])),
                this._unmodified = !1,
                this._constrain(),
                this._calcMatrices();
            }
            _worldSizeFromZoom(t) {
                return Math.pow(2, t) * this.tileSize
            }
            _mercatorZfromZoom(t) {
                return this.cameraToCenterDistance / this._worldSizeFromZoom(t)
            }
            _minimumHeightOverTerrain() {
                const t = Math.min((null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom) + 2, this._maxZoom);
                return this._mercatorZfromZoom(t)
            }
            _zoomFromMercatorZ(t) {
                return this.scaleZoom(this.cameraToCenterDistance / (t * this.tileSize))
            }
            _terrainEnabled() {
                return !(!this._elevation || !this.projection.supportsTerrain && (t.warnOnce("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."),
                1))
            }
            anyCornerOffEdge(e, i) {
                const r = Math.min(e.x, i.x)
                  , o = Math.max(e.x, i.x)
                  , n = Math.min(e.y, i.y)
                  , s = Math.max(e.y, i.y);
                if (n < this.horizonLineFromTop(!1))
                    return !0;
                if ("mercator" !== this.projection.name)
                    return !1;
                const a = [new t.pointGeometry(r,n), new t.pointGeometry(o,s), new t.pointGeometry(r,s), new t.pointGeometry(o,n)]
                  , l = this.renderWorldCopies ? -3 : 0
                  , c = this.renderWorldCopies ? 4 : 1;
                for (const t of a) {
                    const e = this.pointRayIntersection(t);
                    if (e.t < 0)
                        return !0;
                    const i = this.rayIntersectionCoordinate(e);
                    if (i.x < l || i.y < 0 || i.x > c || i.y > 1)
                        return !0
                }
                return !1
            }
            isHorizonVisible() {
                return this.pitch + t.radToDeg(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new t.pointGeometry(0,0), new t.pointGeometry(this.width,this.height))
            }
            zoomDeltaToMovement(e, i) {
                const r = t.length(t.sub([], this._camera.position, e))
                  , o = this._zoomFromMercatorZ(r) + i;
                return r - this._mercatorZfromZoom(o)
            }
            getCameraPoint() {
                if ("globe" === this.projection.name) {
                    const e = function(e, i) {
                        const r = [e[0], e[1], e[2], 1];
                        t.transformMat4$1(r, r, i);
                        const o = Math.max(r[3], 1e-6);
                        return [r[0] / o, r[1] / o, r[2] / o, o]
                    }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
                    return new t.pointGeometry(e[0],e[1])
                }
                {
                    const e = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
                    return this.centerPoint.add(new t.pointGeometry(0,e))
                }
            }
            getCameraToCenterDistance(t) {
                const e = Pn(t, this.zoom, this.width, this.height, 1024)
                  , i = t.pixelSpaceConversion(this.center.lat, this.worldSize, e);
                return .5 / Math.tan(.5 * this._fov) * this.height * i
            }
        }
        function kn(t, e) {
            let i = !1
              , r = null;
            const o = () => {
                r = null,
                i && (t(),
                r = setTimeout(o, e),
                i = !1);
            }
            ;
            return () => (i = !0,
            r || o(),
            r)
        }
        class On {
            constructor(e) {
                this._hashName = e && encodeURIComponent(e),
                t.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this),
                this._updateHash = kn(this._updateHashUnthrottled.bind(this), 300);
            }
            addTo(e) {
                return this._map = e,
                t.window.addEventListener("hashchange", this._onHashChange, !1),
                e.on("moveend", this._updateHash),
                this
            }
            remove() {
                return this._map ? (this._map.off("moveend", this._updateHash),
                t.window.removeEventListener("hashchange", this._onHashChange, !1),
                clearTimeout(this._updateHash()),
                this._map = void 0,
                this) : this
            }
            getHashString() {
                const e = this._map;
                if (!e)
                    return "";
                const i = Fn(e);
                if (this._hashName) {
                    const e = this._hashName;
                    let r = !1;
                    const o = t.window.location.hash.slice(1).split("&").map((t => {
                        const o = t.split("=")[0];
                        return o === e ? (r = !0,
                        `${o}=${i}`) : t
                    }
                    )).filter((t => t));
                    return r || o.push(`${e}=${i}`),
                    `#${o.join("&")}`
                }
                return `#${i}`
            }
            _getCurrentHash() {
                const e = t.window.location.hash.replace("#", "");
                if (this._hashName) {
                    let t;
                    return e.split("&").map((t => t.split("="))).forEach((e => {
                        e[0] === this._hashName && (t = e);
                    }
                    )),
                    (t && t[1] || "").split("/")
                }
                return e.split("/")
            }
            _onHashChange() {
                const t = this._map;
                if (!t)
                    return !1;
                const e = this._getCurrentHash();
                if (e.length >= 3 && !e.some((t => isNaN(t)))) {
                    const i = t.dragRotate.isEnabled() && t.touchZoomRotate.isEnabled() ? +(e[3] || 0) : t.getBearing();
                    return t.jumpTo({
                        center: [+e[2], +e[1]],
                        zoom: +e[0],
                        bearing: i,
                        pitch: +(e[4] || 0)
                    }),
                    !0
                }
                return !1
            }
            _updateHashUnthrottled() {
                const e = t.window.location.href.replace(/(#.+)?$/, this.getHashString());
                t.window.history.replaceState(t.window.history.state, null, e);
            }
        }
        function Fn(t, e) {
            const i = t.getCenter()
              , r = Math.round(100 * t.getZoom()) / 100
              , o = Math.ceil((r * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10)
              , n = Math.pow(10, o)
              , s = Math.round(i.lng * n) / n
              , a = Math.round(i.lat * n) / n
              , l = t.getBearing()
              , c = t.getPitch();
            let h = e ? `/${s}/${a}/${r}` : `${r}/${a}/${s}`;
            return (l || c) && (h += "/" + Math.round(10 * l) / 10),
            c && (h += `/${Math.round(c)}`),
            h
        }
        const Un = {
            linearity: .3,
            easing: t.bezier(0, 0, .3, 1)
        }
          , Nn = t.extend({
            deceleration: 2500,
            maxSpeed: 1400
        }, Un)
          , jn = t.extend({
            deceleration: 20,
            maxSpeed: 1400
        }, Un)
          , Gn = t.extend({
            deceleration: 1e3,
            maxSpeed: 360
        }, Un)
          , Vn = t.extend({
            deceleration: 1e3,
            maxSpeed: 90
        }, Un);
        class Zn {
            constructor(t) {
                this._map = t,
                this.clear();
            }
            clear() {
                this._inertiaBuffer = [];
            }
            record(e) {
                this._drainInertiaBuffer(),
                this._inertiaBuffer.push({
                    time: t.exported.now(),
                    settings: e
                });
            }
            _drainInertiaBuffer() {
                const e = this._inertiaBuffer
                  , i = t.exported.now();
                for (; e.length > 0 && i - e[0].time > 160; )
                    e.shift();
            }
            _onMoveEnd(e) {
                if (this._drainInertiaBuffer(),
                this._inertiaBuffer.length < 2)
                    return;
                const i = {
                    zoom: 0,
                    bearing: 0,
                    pitch: 0,
                    pan: new t.pointGeometry(0,0),
                    pinchAround: void 0,
                    around: void 0
                };
                for (const {settings: t} of this._inertiaBuffer)
                    i.zoom += t.zoomDelta || 0,
                    i.bearing += t.bearingDelta || 0,
                    i.pitch += t.pitchDelta || 0,
                    t.panDelta && i.pan._add(t.panDelta),
                    t.around && (i.around = t.around),
                    t.pinchAround && (i.pinchAround = t.pinchAround);
                const r = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time
                  , o = {};
                if (i.pan.mag()) {
                    const n = qn(i.pan.mag(), r, t.extend({}, Nn, e || {}));
                    o.offset = i.pan.mult(n.amount / i.pan.mag()),
                    o.center = this._map.transform.center,
                    Wn(o, n);
                }
                if (i.zoom) {
                    const t = qn(i.zoom, r, jn);
                    o.zoom = this._map.transform.zoom + t.amount,
                    Wn(o, t);
                }
                if (i.bearing) {
                    const e = qn(i.bearing, r, Gn);
                    o.bearing = this._map.transform.bearing + t.clamp(e.amount, -179, 179),
                    Wn(o, e);
                }
                if (i.pitch) {
                    const t = qn(i.pitch, r, Vn);
                    o.pitch = this._map.transform.pitch + t.amount,
                    Wn(o, t);
                }
                if (o.zoom || o.bearing) {
                    const t = void 0 === i.pinchAround ? i.around : i.pinchAround;
                    o.around = t ? this._map.unproject(t) : this._map.getCenter();
                }
                return this.clear(),
                o.noMoveStart = !0,
                o
            }
        }
        function Wn(t, e) {
            (!t.duration || t.duration < e.duration) && (t.duration = e.duration,
            t.easing = e.easing);
        }
        function qn(e, i, r) {
            const {maxSpeed: o, linearity: n, deceleration: s} = r
              , a = t.clamp(e * n / (i / 1e3), -o, o)
              , l = Math.abs(a) / (s * n);
            return {
                easing: r.easing,
                duration: 1e3 * l,
                amount: a * (l / 2)
            }
        }
        class Hn extends t.Event {
            preventDefault() {
                this._defaultPrevented = !0;
            }
            get defaultPrevented() {
                return this._defaultPrevented
            }
            constructor(e, i, r, o={}) {
                const n = T(i.getCanvasContainer(), r)
                  , s = i.unproject(n);
                super(e, t.extend({
                    point: n,
                    lngLat: s,
                    originalEvent: r
                }, o)),
                this._defaultPrevented = !1,
                this.target = i;
            }
        }
        class Xn extends t.Event {
            preventDefault() {
                this._defaultPrevented = !0;
            }
            get defaultPrevented() {
                return this._defaultPrevented
            }
            constructor(e, i, r) {
                const o = "touchend" === e ? r.changedTouches : r.touches
                  , n = E(i.getCanvasContainer(), o)
                  , s = n.map((t => i.unproject(t)))
                  , a = n.reduce(( (t, e, i, r) => t.add(e.div(r.length))), new t.pointGeometry(0,0));
                super(e, {
                    points: n,
                    point: a,
                    lngLats: s,
                    lngLat: i.unproject(a),
                    originalEvent: r
                }),
                this._defaultPrevented = !1;
            }
        }
        class Yn extends t.Event {
            preventDefault() {
                this._defaultPrevented = !0;
            }
            get defaultPrevented() {
                return this._defaultPrevented
            }
            constructor(t, e, i) {
                super(t, {
                    originalEvent: i
                }),
                this._defaultPrevented = !1;
            }
        }
        class Kn {
            constructor(t, e) {
                this._map = t,
                this._clickTolerance = e.clickTolerance;
            }
            reset() {
                this._mousedownPos = void 0;
            }
            wheel(t) {
                return this._firePreventable(new Yn(t.type,this._map,t))
            }
            mousedown(t, e) {
                return this._mousedownPos = e,
                this._firePreventable(new Hn(t.type,this._map,t))
            }
            mouseup(t) {
                this._map.fire(new Hn(t.type,this._map,t));
            }
            preclick(e) {
                const i = t.extend({}, e);
                i.type = "preclick",
                this._map.fire(new Hn(i.type,this._map,i));
            }
            click(t, e) {
                this._mousedownPos && this._mousedownPos.dist(e) >= this._clickTolerance || (this.preclick(t),
                this._map.fire(new Hn(t.type,this._map,t)));
            }
            dblclick(t) {
                return this._firePreventable(new Hn(t.type,this._map,t))
            }
            mouseover(t) {
                this._map.fire(new Hn(t.type,this._map,t));
            }
            mouseout(t) {
                this._map.fire(new Hn(t.type,this._map,t));
            }
            touchstart(t) {
                return this._firePreventable(new Xn(t.type,this._map,t))
            }
            touchmove(t) {
                this._map.fire(new Xn(t.type,this._map,t));
            }
            touchend(t) {
                this._map.fire(new Xn(t.type,this._map,t));
            }
            touchcancel(t) {
                this._map.fire(new Xn(t.type,this._map,t));
            }
            _firePreventable(t) {
                if (this._map.fire(t),
                t.defaultPrevented)
                    return {}
            }
            isEnabled() {
                return !0
            }
            isActive() {
                return !1
            }
            enable() {}
            disable() {}
        }
        class Jn {
            constructor(t) {
                this._map = t;
            }
            reset() {
                this._delayContextMenu = !1,
                this._contextMenuEvent = void 0;
            }
            mousemove(t) {
                this._map.fire(new Hn(t.type,this._map,t));
            }
            mousedown() {
                this._delayContextMenu = !0;
            }
            mouseup() {
                this._delayContextMenu = !1,
                this._contextMenuEvent && (this._map.fire(new Hn("contextmenu",this._map,this._contextMenuEvent)),
                delete this._contextMenuEvent);
            }
            contextmenu(t) {
                this._delayContextMenu ? this._contextMenuEvent = t : this._map.fire(new Hn(t.type,this._map,t)),
                this._map.listens("contextmenu") && t.preventDefault();
            }
            isEnabled() {
                return !0
            }
            isActive() {
                return !1
            }
            enable() {}
            disable() {}
        }
        class $n {
            constructor(t, e) {
                this._map = t,
                this._el = t.getCanvasContainer(),
                this._container = t.getContainer(),
                this._clickTolerance = e.clickTolerance || 1;
            }
            isEnabled() {
                return !!this._enabled
            }
            isActive() {
                return !!this._active
            }
            enable() {
                this.isEnabled() || (this._enabled = !0);
            }
            disable() {
                this.isEnabled() && (this._enabled = !1);
            }
            mousedown(t, e) {
                this.isEnabled() && t.shiftKey && 0 === t.button && (y(),
                this._startPos = this._lastPos = e,
                this._active = !0);
            }
            mousemoveWindow(t, e) {
                if (!this._active)
                    return;
                const i = e;
                if (this._lastPos.equals(i) || !this._box && i.dist(this._startPos) < this._clickTolerance)
                    return;
                const r = this._startPos;
                this._lastPos = i,
                this._box || (this._box = _("div", "sgmap-boxzoom", this._container),
                this._container.classList.add("sgmap-crosshair"),
                this._fireEvent("boxzoomstart", t));
                const o = Math.min(r.x, i.x)
                  , n = Math.max(r.x, i.x)
                  , s = Math.min(r.y, i.y)
                  , a = Math.max(r.y, i.y);
                this._map._requestDomTask(( () => {
                    this._box && (this._box.style.transform = `translate(${o}px,${s}px)`,
                    this._box.style.width = n - o + "px",
                    this._box.style.height = a - s + "px");
                }
                ));
            }
            mouseupWindow(e, i) {
                if (!this._active)
                    return;
                if (0 !== e.button)
                    return;
                const r = this._startPos
                  , o = i;
                if (this.reset(),
                w(),
                r.x !== o.x || r.y !== o.y)
                    return this._map.fire(new t.Event("boxzoomend",{
                        originalEvent: e
                    })),
                    {
                        cameraAnimation: t => t.fitScreenCoordinates(r, o, this._map.getBearing(), {
                            linear: !1
                        })
                    };
                this._fireEvent("boxzoomcancel", e);
            }
            keydown(t) {
                this._active && 27 === t.keyCode && (this.reset(),
                this._fireEvent("boxzoomcancel", t));
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1,
                this._container.classList.remove("sgmap-crosshair"),
                this._box && (this._box.remove(),
                this._box = null),
                b(),
                delete this._startPos,
                delete this._lastPos;
            }
            _fireEvent(e, i) {
                return this._map.fire(new t.Event(e,{
                    originalEvent: i
                }))
            }
        }
        function Qn(t, e) {
            const i = {};
            for (let r = 0; r < t.length; r++)
                i[t[r].identifier] = e[r];
            return i
        }
        class ts {
            constructor(t) {
                this.reset(),
                this.numTouches = t.numTouches;
            }
            reset() {
                this.centroid = void 0,
                this.startTime = 0,
                this.touches = {},
                this.aborted = !1;
            }
            touchstart(e, i, r) {
                (this.centroid || r.length > this.numTouches) && (this.aborted = !0),
                this.aborted || (0 === this.startTime && (this.startTime = e.timeStamp),
                r.length === this.numTouches && (this.centroid = function(e) {
                    const i = new t.pointGeometry(0,0);
                    for (const t of e)
                        i._add(t);
                    return i.div(e.length)
                }(i),
                this.touches = Qn(r, i)));
            }
            touchmove(t, e, i) {
                if (this.aborted || !this.centroid)
                    return;
                const r = Qn(i, e);
                for (const t in this.touches) {
                    const e = this.touches[t]
                      , i = r[t];
                    (!i || i.dist(e) > 30) && (this.aborted = !0);
                }
            }
            touchend(t, e, i) {
                if ((!this.centroid || t.timeStamp - this.startTime > 500) && (this.aborted = !0),
                0 === i.length) {
                    const t = !this.aborted && this.centroid;
                    if (this.reset(),
                    t)
                        return t
                }
            }
        }
        class es {
            constructor(t) {
                this.singleTap = new ts(t),
                this.numTaps = t.numTaps,
                this.reset();
            }
            reset() {
                this.lastTime = 1 / 0,
                this.lastTap = void 0,
                this.count = 0,
                this.singleTap.reset();
            }
            touchstart(t, e, i) {
                this.singleTap.touchstart(t, e, i);
            }
            touchmove(t, e, i) {
                this.singleTap.touchmove(t, e, i);
            }
            touchend(t, e, i) {
                const r = this.singleTap.touchend(t, e, i);
                if (r) {
                    const e = t.timeStamp - this.lastTime < 500
                      , i = !this.lastTap || this.lastTap.dist(r) < 30;
                    if (e && i || this.reset(),
                    this.count++,
                    this.lastTime = t.timeStamp,
                    this.lastTap = r,
                    this.count === this.numTaps)
                        return this.reset(),
                        r
                }
            }
        }
        class is {
            constructor() {
                this._zoomIn = new es({
                    numTouches: 1,
                    numTaps: 2
                }),
                this._zoomOut = new es({
                    numTouches: 2,
                    numTaps: 1
                }),
                this.reset();
            }
            reset() {
                this._active = !1,
                this._zoomIn.reset(),
                this._zoomOut.reset();
            }
            touchstart(t, e, i) {
                this._zoomIn.touchstart(t, e, i),
                this._zoomOut.touchstart(t, e, i);
            }
            touchmove(t, e, i) {
                this._zoomIn.touchmove(t, e, i),
                this._zoomOut.touchmove(t, e, i);
            }
            touchend(t, e, i) {
                const r = this._zoomIn.touchend(t, e, i)
                  , o = this._zoomOut.touchend(t, e, i);
                return r ? (this._active = !0,
                t.preventDefault(),
                setTimeout(( () => this.reset()), 0),
                {
                    cameraAnimation: e => e.easeTo({
                        duration: 300,
                        zoom: e.getZoom() + 1,
                        around: e.unproject(r)
                    }, {
                        originalEvent: t
                    })
                }) : o ? (this._active = !0,
                t.preventDefault(),
                setTimeout(( () => this.reset()), 0),
                {
                    cameraAnimation: e => e.easeTo({
                        duration: 300,
                        zoom: e.getZoom() - 1,
                        around: e.unproject(o)
                    }, {
                        originalEvent: t
                    })
                }) : void 0
            }
            touchcancel() {
                this.reset();
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1,
                this.reset();
            }
            isEnabled() {
                return this._enabled
            }
            isActive() {
                return this._active
            }
        }
        const rs = {
            0: 1,
            2: 2
        };
        class os {
            constructor(t) {
                this.reset(),
                this._clickTolerance = t.clickTolerance || 1;
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1,
                this._moved = !1,
                this._lastPoint = void 0,
                this._eventButton = void 0;
            }
            _correctButton(t, e) {
                return !1
            }
            _move(t, e) {
                return {}
            }
            mousedown(t, e) {
                if (this._lastPoint)
                    return;
                const i = S(t);
                this._correctButton(t, i) && (this._lastPoint = e,
                this._eventButton = i);
            }
            mousemoveWindow(t, e) {
                const i = this._lastPoint;
                if (i)
                    if (t.preventDefault(),
                    null != this._eventButton && function(t, e) {
                        const i = rs[e];
                        return void 0 === t.buttons || (t.buttons & i) !== i
                    }(t, this._eventButton))
                        this.reset();
                    else if (this._moved || !(e.dist(i) < this._clickTolerance))
                        return this._moved = !0,
                        this._lastPoint = e,
                        this._move(i, e)
            }
            mouseupWindow(t) {
                this._lastPoint && S(t) === this._eventButton && (this._moved && w(),
                this.reset());
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1,
                this.reset();
            }
            isEnabled() {
                return this._enabled
            }
            isActive() {
                return this._active
            }
        }
        class ns extends os {
            mousedown(t, e) {
                super.mousedown(t, e),
                this._lastPoint && (this._active = !0);
            }
            _correctButton(t, e) {
                return 0 === e && !t.ctrlKey
            }
            _move(t, e) {
                return {
                    around: e,
                    panDelta: e.sub(t)
                }
            }
        }
        class ss extends os {
            _correctButton(t, e) {
                return 0 === e && t.ctrlKey || 2 === e
            }
            _move(t, e) {
                const i = .8 * (e.x - t.x);
                if (i)
                    return this._active = !0,
                    {
                        bearingDelta: i
                    }
            }
            contextmenu(t) {
                t.preventDefault();
            }
        }
        class as extends os {
            _correctButton(t, e) {
                return 0 === e && t.ctrlKey || 2 === e
            }
            _move(t, e) {
                const i = -.5 * (e.y - t.y);
                if (i)
                    return this._active = !0,
                    {
                        pitchDelta: i
                    }
            }
            contextmenu(t) {
                t.preventDefault();
            }
        }
        class ls {
            constructor(e, i) {
                this._map = e,
                this._el = e.getCanvasContainer(),
                this._minTouches = 1,
                this._clickTolerance = i.clickTolerance || 1,
                this.reset(),
                t.bindAll(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this);
            }
            reset() {
                this._active = !1,
                this._touches = {},
                this._sum = new t.pointGeometry(0,0);
            }
            touchstart(t, e, i) {
                return this._calculateTransform(t, e, i)
            }
            touchmove(e, i, r) {
                if (this._active && !(r.length < this._minTouches)) {
                    if (this._map._cooperativeGestures && !this._map.isMoving()) {
                        if (1 === r.length && !t.isFullscreen())
                            return void this._showTouchPanBlockerAlert();
                        "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden",
                        clearTimeout(this._alertTimer));
                    }
                    return e.cancelable && e.preventDefault(),
                    this._calculateTransform(e, i, r)
                }
            }
            touchend(t, e, i) {
                this._calculateTransform(t, e, i),
                this._active && i.length < this._minTouches && this.reset();
            }
            touchcancel() {
                this.reset();
            }
            _calculateTransform(e, i, r) {
                r.length > 0 && (this._active = !0);
                const o = Qn(r, i)
                  , n = new t.pointGeometry(0,0)
                  , s = new t.pointGeometry(0,0);
                let a = 0;
                for (const t in o) {
                    const e = o[t]
                      , i = this._touches[t];
                    i && (n._add(e),
                    s._add(e.sub(i)),
                    a++,
                    o[t] = e);
                }
                if (this._touches = o,
                a < this._minTouches || !s.mag())
                    return;
                const l = s.div(a);
                return this._sum._add(l),
                this._sum.mag() < this._clickTolerance ? void 0 : {
                    around: n.div(a),
                    panDelta: l
                }
            }
            enable() {
                this._enabled = !0,
                this._map._cooperativeGestures && (this._addTouchPanBlocker(),
                this._el.classList.add("sgmap-touch-pan-blocker-override", "sgmap-scrollable-page"));
            }
            disable() {
                this._enabled = !1,
                this._map._cooperativeGestures && (clearTimeout(this._alertTimer),
                this._alertContainer.remove(),
                this._el.classList.remove("sgmap-touch-pan-blocker-override", "sgmap-scrollable-page")),
                this.reset();
            }
            isEnabled() {
                return !!this._enabled
            }
            isActive() {
                return !!this._active
            }
            _addTouchPanBlocker() {
                this._map && !this._alertContainer && (this._alertContainer = _("div", "sgmap-touch-pan-blocker", this._map._container),
                this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"),
                this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);
            }
            _showTouchPanBlockerAlert() {
                this._alertContainer.style.visibility = "visible",
                this._alertContainer.classList.add("sgmap-touch-pan-blocker-show"),
                this._alertContainer.setAttribute("role", "alert"),
                clearTimeout(this._alertTimer),
                this._alertTimer = setTimeout(( () => {
                    this._alertContainer.classList.remove("sgmap-touch-pan-blocker-show"),
                    this._alertContainer.setAttribute("role", "null");
                }
                ), 500);
            }
        }
        class cs {
            constructor() {
                this.reset();
            }
            reset() {
                this._active = !1,
                this._firstTwoTouches = void 0;
            }
            _start(t) {}
            _move(t, e, i) {
                return {}
            }
            touchstart(t, e, i) {
                this._firstTwoTouches || i.length < 2 || (this._firstTwoTouches = [i[0].identifier, i[1].identifier],
                this._start([e[0], e[1]]));
            }
            touchmove(t, e, i) {
                const r = this._firstTwoTouches;
                if (!r)
                    return;
                t.preventDefault();
                const [o,n] = r
                  , s = hs(i, e, o)
                  , a = hs(i, e, n);
                if (!s || !a)
                    return;
                const l = this._aroundCenter ? null : s.add(a).div(2);
                return this._move([s, a], l, t)
            }
            touchend(t, e, i) {
                if (!this._firstTwoTouches)
                    return;
                const [r,o] = this._firstTwoTouches
                  , n = hs(i, e, r)
                  , s = hs(i, e, o);
                n && s || (this._active && w(),
                this.reset());
            }
            touchcancel() {
                this.reset();
            }
            enable(t) {
                this._enabled = !0,
                this._aroundCenter = !!t && "center" === t.around;
            }
            disable() {
                this._enabled = !1,
                this.reset();
            }
            isEnabled() {
                return this._enabled
            }
            isActive() {
                return this._active
            }
        }
        function hs(t, e, i) {
            for (let r = 0; r < t.length; r++)
                if (t[r].identifier === i)
                    return e[r]
        }
        function us(t, e) {
            return Math.log(t / e) / Math.LN2
        }
        class ds extends cs {
            reset() {
                super.reset(),
                this._distance = 0,
                this._startDistance = 0;
            }
            _start(t) {
                this._startDistance = this._distance = t[0].dist(t[1]);
            }
            _move(t, e) {
                const i = this._distance;
                if (this._distance = t[0].dist(t[1]),
                this._active || !(Math.abs(us(this._distance, this._startDistance)) < .1))
                    return this._active = !0,
                    {
                        zoomDelta: us(this._distance, i),
                        pinchAround: e
                    }
            }
        }
        function fs(t, e) {
            return 180 * t.angleWith(e) / Math.PI
        }
        class _s extends cs {
            reset() {
                super.reset(),
                this._minDiameter = 0,
                this._startVector = void 0,
                this._vector = void 0;
            }
            _start(t) {
                this._startVector = this._vector = t[0].sub(t[1]),
                this._minDiameter = t[0].dist(t[1]);
            }
            _move(t, e) {
                const i = this._vector;
                if (this._vector = t[0].sub(t[1]),
                this._active || !this._isBelowThreshold(this._vector))
                    return this._active = !0,
                    {
                        bearingDelta: fs(this._vector, i),
                        pinchAround: e
                    }
            }
            _isBelowThreshold(t) {
                this._minDiameter = Math.min(this._minDiameter, t.mag());
                const e = 25 / (Math.PI * this._minDiameter) * 360
                  , i = fs(t, this._startVector);
                return Math.abs(i) < e
            }
        }
        function ps(t) {
            return Math.abs(t.y) > Math.abs(t.x)
        }
        class ms extends cs {
            constructor(t) {
                super(),
                this._map = t;
            }
            reset() {
                super.reset(),
                this._valid = void 0,
                this._firstMove = void 0,
                this._lastPoints = void 0;
            }
            _start(t) {
                this._lastPoints = t,
                ps(t[0].sub(t[1])) && (this._valid = !1);
            }
            _move(t, e, i) {
                const r = this._lastPoints;
                if (!r)
                    return;
                const o = t[0].sub(r[0])
                  , n = t[1].sub(r[1]);
                return this._map._cooperativeGestures && i.touches.length < 3 || (this._valid = this.gestureBeginsVertically(o, n, i.timeStamp),
                !this._valid) ? void 0 : (this._lastPoints = t,
                this._active = !0,
                {
                    pitchDelta: (o.y + n.y) / 2 * -.5
                })
            }
            gestureBeginsVertically(t, e, i) {
                if (void 0 !== this._valid)
                    return this._valid;
                const r = t.mag() >= 2
                  , o = e.mag() >= 2;
                if (!r && !o)
                    return;
                if (!r || !o)
                    return null == this._firstMove && (this._firstMove = i),
                    i - this._firstMove < 100 && void 0;
                const n = t.y > 0 == e.y > 0;
                return ps(t) && ps(e) && n
            }
        }
        const gs = {
            panStep: 100,
            bearingStep: 15,
            pitchStep: 10
        };
        class vs {
            constructor() {
                const t = gs;
                this._panStep = t.panStep,
                this._bearingStep = t.bearingStep,
                this._pitchStep = t.pitchStep,
                this._rotationDisabled = !1;
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1;
            }
            keydown(t) {
                if (t.altKey || t.ctrlKey || t.metaKey)
                    return;
                let e = 0
                  , i = 0
                  , r = 0
                  , o = 0
                  , n = 0;
                switch (t.keyCode) {
                case 61:
                case 107:
                case 171:
                case 187:
                    e = 1;
                    break;
                case 189:
                case 109:
                case 173:
                    e = -1;
                    break;
                case 37:
                    t.shiftKey ? i = -1 : (t.preventDefault(),
                    o = -1);
                    break;
                case 39:
                    t.shiftKey ? i = 1 : (t.preventDefault(),
                    o = 1);
                    break;
                case 38:
                    t.shiftKey ? r = 1 : (t.preventDefault(),
                    n = -1);
                    break;
                case 40:
                    t.shiftKey ? r = -1 : (t.preventDefault(),
                    n = 1);
                    break;
                default:
                    return
                }
                return this._rotationDisabled && (i = 0,
                r = 0),
                {
                    cameraAnimation: s => {
                        const a = s.getZoom();
                        s.easeTo({
                            duration: 300,
                            easeId: "keyboardHandler",
                            easing: ys,
                            zoom: e ? Math.round(a) + e * (t.shiftKey ? 2 : 1) : a,
                            bearing: s.getBearing() + i * this._bearingStep,
                            pitch: s.getPitch() + r * this._pitchStep,
                            offset: [-o * this._panStep, -n * this._panStep],
                            center: s.getCenter()
                        }, {
                            originalEvent: t
                        });
                    }
                }
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1,
                this.reset();
            }
            isEnabled() {
                return this._enabled
            }
            isActive() {
                return this._active
            }
            disableRotation() {
                this._rotationDisabled = !0;
            }
            enableRotation() {
                this._rotationDisabled = !1;
            }
        }
        function ys(t) {
            return t * (2 - t)
        }
        const bs = 4.000244140625;
        class xs {
            constructor(e, i) {
                this._map = e,
                this._el = e.getCanvasContainer(),
                this._handler = i,
                this._delta = 0,
                this._defaultZoomRate = .01,
                this._wheelZoomRate = .0022222222222222222,
                t.bindAll(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this);
            }
            setZoomRate(t) {
                this._defaultZoomRate = t;
            }
            setWheelZoomRate(t) {
                this._wheelZoomRate = t;
            }
            isEnabled() {
                return !!this._enabled
            }
            isActive() {
                return this._active || void 0 !== this._finishTimeout
            }
            isZooming() {
                return !!this._zooming
            }
            enable(t) {
                this.isEnabled() || (this._enabled = !0,
                this._aroundCenter = !!t && "center" === t.around,
                this._map._cooperativeGestures && this._addScrollZoomBlocker());
            }
            disable() {
                this.isEnabled() && (this._enabled = !1,
                this._map._cooperativeGestures && (clearTimeout(this._alertTimer),
                this._alertContainer.remove()));
            }
            wheel(e) {
                if (!this.isEnabled())
                    return;
                if (this._map._cooperativeGestures) {
                    if (!(e.ctrlKey || e.metaKey || this.isZooming() || t.isFullscreen()))
                        return void this._showBlockerAlert();
                    "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden",
                    clearTimeout(this._alertTimer));
                }
                let i = e.deltaMode === t.window.WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
                const r = t.exported.now()
                  , o = r - (this._lastWheelEventTime || 0);
                this._lastWheelEventTime = r,
                0 !== i && i % bs == 0 ? this._type = "wheel" : 0 !== i && Math.abs(i) < 4 ? this._type = "trackpad" : o > 400 ? (this._type = null,
                this._lastValue = i,
                this._timeout && clearTimeout(this._timeout),
                this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(o * i) < 200 ? "trackpad" : "wheel",
                this._timeout && (clearTimeout(this._timeout),
                this._timeout = null,
                i += this._lastValue)),
                e.shiftKey && i && (i /= 4),
                this._type && (this._lastWheelEvent = e,
                this._delta -= i,
                this._active || this._start(e)),
                e.preventDefault();
            }
            _onTimeout(t) {
                this._type = "wheel",
                this._delta -= this._lastValue,
                this._active || this._start(t);
            }
            _start(t) {
                if (!this._delta)
                    return;
                this._frameId && (this._frameId = null),
                this._active = !0,
                this.isZooming() || (this._zooming = !0),
                this._finishTimeout && (clearTimeout(this._finishTimeout),
                delete this._finishTimeout);
                const e = T(this._el, t);
                this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : e,
                this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint),
                this._targetZoom = void 0,
                this._frameId || (this._frameId = !0,
                this._handler._triggerRenderFrame());
            }
            renderFrame() {
                if (!this._frameId)
                    return;
                if (this._frameId = null,
                !this.isActive())
                    return;
                const e = this._map.transform;
                "wheel" === this._type && e.projection.wrap && (e._center.lng >= 180 || e._center.lng <= -180) && (this._prevEase = null,
                this._easing = null,
                this._lastWheelEvent = null,
                this._lastWheelEventTime = 0);
                const i = () => {
                    let t = this._map.transform.pointCoordinate3D(this._aroundPoint);
                    return e._terrainEnabled() && this._aroundCoord ? e.computeZoomRelativeTo(t) : e.zoom
                }
                ;
                if (0 !== this._delta) {
                    const t = "wheel" === this._type && Math.abs(this._delta) > bs ? this._wheelZoomRate : this._defaultZoomRate;
                    let r = 2 / (1 + Math.exp(-Math.abs(this._delta * t)));
                    this._delta < 0 && 0 !== r && (r = 1 / r);
                    const o = i()
                      , n = Math.pow(2, o)
                      , s = "number" == typeof this._targetZoom ? e.zoomScale(this._targetZoom) : n;
                    this._targetZoom = Math.min(e.maxZoom, Math.max(e.minZoom, e.scaleZoom(s * r))),
                    "wheel" === this._type && (this._startZoom = o,
                    this._easing = this._smoothOutEasing(200)),
                    this._delta = 0;
                }
                const r = "number" == typeof this._targetZoom ? this._targetZoom : i()
                  , o = this._startZoom
                  , n = this._easing;
                let s, a = !1;
                if ("wheel" === this._type && o && n) {
                    const e = Math.min((t.exported.now() - this._lastWheelEventTime) / 200, 1)
                      , i = n(e);
                    s = t.number(o, r, i),
                    e < 1 ? this._frameId || (this._frameId = !0) : a = !0;
                } else
                    s = r,
                    a = !0;
                return this._active = !0,
                a && (this._active = !1,
                clearTimeout(this._finishTimeout),
                this._finishTimeout = setTimeout(( () => {
                    this._zooming = !1,
                    this._handler._triggerRenderFrame(),
                    clearTimeout(this._finishTimeout),
                    delete this._targetZoom,
                    delete this._finishTimeout;
                }
                ), 200)),
                {
                    noInertia: !0,
                    needsRenderFrame: !a,
                    zoomDelta: s - i(),
                    around: this._aroundPoint,
                    aroundCoord: this._aroundCoord,
                    originalEvent: this._lastWheelEvent
                }
            }
            _smoothOutEasing(e) {
                let i = t.ease;
                if (this._prevEase) {
                    const e = this._prevEase
                      , r = (t.exported.now() - e.start) / e.duration
                      , o = e.easing(r + .01) - e.easing(r)
                      , n = .27 / Math.sqrt(o * o + 1e-4) * .01
                      , s = Math.sqrt(.0729 - n * n);
                    i = t.bezier(n, s, .25, 1);
                }
                return this._prevEase = {
                    start: t.exported.now(),
                    duration: e,
                    easing: i
                },
                i
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1;
            }
            _addScrollZoomBlocker() {
                this._map && !this._alertContainer && (this._alertContainer = _("div", "sgmap-scroll-zoom-blocker", this._map._container),
                this._alertContainer.textContent = /(Mac|iPad)/i.test(t.window.navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"),
                this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);
            }
            _showBlockerAlert() {
                this._alertContainer.style.visibility = "visible",
                this._alertContainer.classList.add("sgmap-scroll-zoom-blocker-show"),
                this._alertContainer.setAttribute("role", "alert"),
                clearTimeout(this._alertTimer),
                this._alertTimer = setTimeout(( () => {
                    this._alertContainer.classList.remove("sgmap-scroll-zoom-blocker-show"),
                    this._alertContainer.setAttribute("role", "null");
                }
                ), 200);
            }
        }
        class ws {
            constructor(t, e) {
                this._clickZoom = t,
                this._tapZoom = e;
            }
            enable() {
                this._clickZoom.enable(),
                this._tapZoom.enable();
            }
            disable() {
                this._clickZoom.disable(),
                this._tapZoom.disable();
            }
            isEnabled() {
                return this._clickZoom.isEnabled() && this._tapZoom.isEnabled()
            }
            isActive() {
                return this._clickZoom.isActive() || this._tapZoom.isActive()
            }
        }
        class Ts {
            constructor() {
                this.reset();
            }
            reset() {
                this._active = !1;
            }
            blur() {
                this.reset();
            }
            dblclick(t, e) {
                return t.preventDefault(),
                {
                    cameraAnimation: i => {
                        i.easeTo({
                            duration: 300,
                            zoom: i.getZoom() + (t.shiftKey ? -1 : 1),
                            around: i.unproject(e)
                        }, {
                            originalEvent: t
                        });
                    }
                }
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1,
                this.reset();
            }
            isEnabled() {
                return this._enabled
            }
            isActive() {
                return this._active
            }
        }
        class Es {
            constructor() {
                this._tap = new es({
                    numTouches: 1,
                    numTaps: 1
                }),
                this.reset();
            }
            reset() {
                this._active = !1,
                this._swipePoint = void 0,
                this._swipeTouch = 0,
                this._tapTime = 0,
                this._tap.reset();
            }
            touchstart(t, e, i) {
                this._swipePoint || (this._tapTime && t.timeStamp - this._tapTime > 500 && this.reset(),
                this._tapTime ? i.length > 0 && (this._swipePoint = e[0],
                this._swipeTouch = i[0].identifier) : this._tap.touchstart(t, e, i));
            }
            touchmove(t, e, i) {
                if (this._tapTime) {
                    if (this._swipePoint) {
                        if (i[0].identifier !== this._swipeTouch)
                            return;
                        const r = e[0]
                          , o = r.y - this._swipePoint.y;
                        return this._swipePoint = r,
                        t.preventDefault(),
                        this._active = !0,
                        {
                            zoomDelta: o / 128
                        }
                    }
                } else
                    this._tap.touchmove(t, e, i);
            }
            touchend(t, e, i) {
                this._tapTime ? this._swipePoint && 0 === i.length && this.reset() : this._tap.touchend(t, e, i) && (this._tapTime = t.timeStamp);
            }
            touchcancel() {
                this.reset();
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1,
                this.reset();
            }
            isEnabled() {
                return this._enabled
            }
            isActive() {
                return this._active
            }
        }
        class Ss {
            constructor(t, e, i) {
                this._el = t,
                this._mousePan = e,
                this._touchPan = i;
            }
            enable(t) {
                this._inertiaOptions = t || {},
                this._mousePan.enable(),
                this._touchPan.enable(),
                this._el.classList.add("sgmap-touch-drag-pan");
            }
            disable() {
                this._mousePan.disable(),
                this._touchPan.disable(),
                this._el.classList.remove("sgmap-touch-drag-pan");
            }
            isEnabled() {
                return this._mousePan.isEnabled() && this._touchPan.isEnabled()
            }
            isActive() {
                return this._mousePan.isActive() || this._touchPan.isActive()
            }
        }
        class Cs {
            constructor(t, e, i) {
                this._pitchWithRotate = t.pitchWithRotate,
                this._mouseRotate = e,
                this._mousePitch = i;
            }
            enable() {
                this._mouseRotate.enable(),
                this._pitchWithRotate && this._mousePitch.enable();
            }
            disable() {
                this._mouseRotate.disable(),
                this._mousePitch.disable();
            }
            isEnabled() {
                return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled())
            }
            isActive() {
                return this._mouseRotate.isActive() || this._mousePitch.isActive()
            }
        }
        class As {
            constructor(t, e, i, r) {
                this._el = t,
                this._touchZoom = e,
                this._touchRotate = i,
                this._tapDragZoom = r,
                this._rotationDisabled = !1,
                this._enabled = !0;
            }
            enable(t) {
                this._touchZoom.enable(t),
                this._rotationDisabled || this._touchRotate.enable(t),
                this._tapDragZoom.enable(),
                this._el.classList.add("sgmap-touch-zoom-rotate");
            }
            disable() {
                this._touchZoom.disable(),
                this._touchRotate.disable(),
                this._tapDragZoom.disable(),
                this._el.classList.remove("sgmap-touch-zoom-rotate");
            }
            isEnabled() {
                return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled()
            }
            isActive() {
                return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive()
            }
            disableRotation() {
                this._rotationDisabled = !0,
                this._touchRotate.disable();
            }
            enableRotation() {
                this._rotationDisabled = !1,
                this._touchZoom.isEnabled() && this._touchRotate.enable();
            }
        }
        const Ms = t => t.zoom || t.drag || t.pitch || t.rotate;
        class Is extends t.Event {
        }
        class zs {
            constructor() {
                this.constants = [1, 1, .01],
                this.radius = 0;
            }
            setup(e, i) {
                const r = t.sub([], i, e);
                this.radius = t.length(r[2] < 0 ? t.div([], r, this.constants) : [r[0], r[1], 0]);
            }
            projectRay(e) {
                t.div(e, e, this.constants),
                t.normalize(e, e),
                t.mul$1(e, e, this.constants);
                const i = t.scale$2([], e, this.radius);
                if (i[2] > 0) {
                    const e = t.scale$2([], [0, 0, 1], t.dot(i, [0, 0, 1]))
                      , r = t.scale$2([], t.normalize([], [i[0], i[1], 0]), this.radius)
                      , o = t.add([], i, t.scale$2([], t.sub([], t.add([], r, e), i), 2));
                    i[0] = o[0],
                    i[1] = o[1];
                }
                return i
            }
        }
        function Ps(t) {
            return t.panDelta && t.panDelta.mag() || t.zoomDelta || t.bearingDelta || t.pitchDelta
        }
        class Ds {
            constructor(e, i) {
                this._map = e,
                this._el = this._map.getCanvasContainer(),
                this._handlers = [],
                this._handlersById = {},
                this._changes = [],
                this._inertia = new Zn(e),
                this._bearingSnap = i.bearingSnap,
                this._previousActiveHandlers = {},
                this._trackingEllipsoid = new zs,
                this._dragOrigin = null,
                this._eventsInProgress = {},
                this._addDefaultHandlers(i),
                t.bindAll(["handleEvent", "handleWindowEvent"], this);
                const r = this._el;
                this._listeners = [[r, "touchstart", {
                    passive: !0
                }], [r, "touchmove", {
                    passive: !1
                }], [r, "touchend", void 0], [r, "touchcancel", void 0], [r, "mousedown", void 0], [r, "mousemove", void 0], [r, "mouseup", void 0], [t.window.document, "mousemove", {
                    capture: !0
                }], [t.window.document, "mouseup", void 0], [r, "mouseover", void 0], [r, "mouseout", void 0], [r, "dblclick", void 0], [r, "click", void 0], [r, "keydown", {
                    capture: !1
                }], [r, "keyup", void 0], [r, "wheel", {
                    passive: !1
                }], [r, "contextmenu", void 0], [t.window, "blur", void 0]];
                for (const [e,i,r] of this._listeners)
                    e.addEventListener(i, e === t.window.document ? this.handleWindowEvent : this.handleEvent, r);
            }
            destroy() {
                for (const [e,i,r] of this._listeners)
                    e.removeEventListener(i, e === t.window.document ? this.handleWindowEvent : this.handleEvent, r);
            }
            _addDefaultHandlers(t) {
                const e = this._map
                  , i = e.getCanvasContainer();
                this._add("mapEvent", new Kn(e,t));
                const r = e.boxZoom = new $n(e,t);
                this._add("boxZoom", r);
                const o = new is
                  , n = new Ts;
                e.doubleClickZoom = new ws(n,o),
                this._add("tapZoom", o),
                this._add("clickZoom", n);
                const s = new Es;
                this._add("tapDragZoom", s);
                const a = e.touchPitch = new ms(e);
                this._add("touchPitch", a);
                const l = new ss(t)
                  , c = new as(t);
                e.dragRotate = new Cs(t,l,c),
                this._add("mouseRotate", l, ["mousePitch"]),
                this._add("mousePitch", c, ["mouseRotate"]);
                const h = new ns(t)
                  , u = new ls(e,t);
                e.dragPan = new Ss(i,h,u),
                this._add("mousePan", h),
                this._add("touchPan", u, ["touchZoom", "touchRotate"]);
                const d = new _s
                  , f = new ds;
                e.touchZoomRotate = new As(i,f,d,s),
                this._add("touchRotate", d, ["touchPan", "touchZoom"]),
                this._add("touchZoom", f, ["touchPan", "touchRotate"]),
                this._add("blockableMapEvent", new Jn(e));
                const _ = e.scrollZoom = new xs(e,this);
                this._add("scrollZoom", _, ["mousePan"]);
                const p = e.keyboard = new vs;
                this._add("keyboard", p);
                for (const i of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"])
                    t.interactive && t[i] && e[i].enable(t[i]);
            }
            _add(t, e, i) {
                this._handlers.push({
                    handlerName: t,
                    handler: e,
                    allowed: i
                }),
                this._handlersById[t] = e;
            }
            stop(t) {
                if (!this._updatingCamera) {
                    for (const {handler: t} of this._handlers)
                        t.reset();
                    this._inertia.clear(),
                    this._fireEvents({}, {}, t),
                    this._changes = [];
                }
            }
            isActive() {
                for (const {handler: t} of this._handlers)
                    if (t.isActive())
                        return !0;
                return !1
            }
            isZooming() {
                return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming()
            }
            isRotating() {
                return !!this._eventsInProgress.rotate
            }
            isMoving() {
                return !!Ms(this._eventsInProgress) || this.isZooming()
            }
            _blockedByActive(t, e, i) {
                for (const r in t)
                    if (r !== i && (!e || e.indexOf(r) < 0))
                        return !0;
                return !1
            }
            handleWindowEvent(t) {
                this.handleEvent(t, `${t.type}Window`);
            }
            _getMapTouches(t) {
                const e = [];
                for (const i of t)
                    this._el.contains(i.target) && e.push(i);
                return e
            }
            handleEvent(t, e) {
                this._updatingCamera = !0;
                const i = "renderFrame" === t.type
                  , r = i ? void 0 : t
                  , o = {
                    needsRenderFrame: !1
                }
                  , n = {}
                  , s = {}
                  , a = t.touches ? this._getMapTouches(t.touches) : void 0
                  , l = a ? E(this._el, a) : i ? void 0 : T(this._el, t);
                for (const {handlerName: i, handler: c, allowed: h} of this._handlers) {
                    if (!c.isEnabled())
                        continue;
                    let u;
                    this._blockedByActive(s, h, i) ? c.reset() : c[e || t.type] && (u = c[e || t.type](t, l, a),
                    this.mergeHandlerResult(o, n, u, i, r),
                    u && u.needsRenderFrame && this._triggerRenderFrame()),
                    (u || c.isActive()) && (s[i] = c);
                }
                const c = {};
                for (const t in this._previousActiveHandlers)
                    s[t] || (c[t] = r);
                this._previousActiveHandlers = s,
                (Object.keys(c).length || Ps(o)) && (this._changes.push([o, n, c]),
                this._triggerRenderFrame()),
                (Object.keys(s).length || Ps(o)) && this._map._stop(!0),
                this._updatingCamera = !1;
                const {cameraAnimation: h} = o;
                h && (this._inertia.clear(),
                this._fireEvents({}, {}, !0),
                this._changes = [],
                h(this._map));
            }
            mergeHandlerResult(e, i, r, o, n) {
                if (!r)
                    return;
                t.extend(e, r);
                const s = {
                    handlerName: o,
                    originalEvent: r.originalEvent || n
                };
                void 0 !== r.zoomDelta && (i.zoom = s),
                void 0 !== r.panDelta && (i.drag = s),
                void 0 !== r.pitchDelta && (i.pitch = s),
                void 0 !== r.bearingDelta && (i.rotate = s);
            }
            _applyChanges() {
                const e = {}
                  , i = {}
                  , r = {};
                for (const [o,n,s] of this._changes)
                    o.panDelta && (e.panDelta = (e.panDelta || new t.pointGeometry(0,0))._add(o.panDelta)),
                    o.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + o.zoomDelta),
                    o.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + o.bearingDelta),
                    o.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + o.pitchDelta),
                    void 0 !== o.around && (e.around = o.around),
                    void 0 !== o.aroundCoord && (e.aroundCoord = o.aroundCoord),
                    void 0 !== o.pinchAround && (e.pinchAround = o.pinchAround),
                    o.noInertia && (e.noInertia = o.noInertia),
                    t.extend(i, n),
                    t.extend(r, s);
                this._updateMapTransform(e, i, r),
                this._changes = [];
            }
            _updateMapTransform(e, i, r) {
                const o = this._map
                  , n = o.transform
                  , s = t => [t.x, t.y, t.z];
                if ((t => {
                    const e = this._eventsInProgress.drag;
                    return e && !this._handlersById[e.handlerName].isActive()
                }
                )() && !Ps(e)) {
                    const t = n.zoom;
                    n.cameraElevationReference = "sea",
                    n.recenterOnTerrain(),
                    n.cameraElevationReference = "ground",
                    t !== n.zoom && this._map._update(!0);
                }
                if (!Ps(e))
                    return void this._fireEvents(i, r, !0);
                let {panDelta: a, zoomDelta: l, bearingDelta: c, pitchDelta: h, around: u, aroundCoord: d, pinchAround: f} = e;
                void 0 !== f && (u = f),
                (t => i.drag && !this._eventsInProgress.drag)() && u && (this._dragOrigin = s(n.pointCoordinate3D(u)),
                this._trackingEllipsoid.setup(n._camera.position, this._dragOrigin)),
                n.cameraElevationReference = "sea",
                o._stop(!0),
                u = u || o.transform.centerPoint,
                c && (n.bearing += c),
                h && (n.pitch += h),
                n._updateCameraState();
                const _ = [0, 0, 0];
                if (a)
                    if ("mercator" === n.projection.name) {
                        const t = this._trackingEllipsoid.projectRay(n.screenPointToMercatorRay(u).dir)
                          , e = this._trackingEllipsoid.projectRay(n.screenPointToMercatorRay(u.sub(a)).dir);
                        _[0] = e[0] - t[0],
                        _[1] = e[1] - t[1];
                    } else {
                        const e = n.pointCoordinate(u);
                        if ("globe" === n.projection.name) {
                            a = a.rotate(-n.angle);
                            const i = n._pixelsPerMercatorPixel / n.worldSize;
                            _[0] = -a.x * t.mercatorScale(t.latFromMercatorY(e.y)) * i,
                            _[1] = -a.y * t.mercatorScale(n.center.lat) * i;
                        } else {
                            const t = n.pointCoordinate(u.sub(a));
                            e && t && (_[0] = t.x - e.x,
                            _[1] = t.y - e.y);
                        }
                    }
                const p = n.zoom
                  , m = [0, 0, 0];
                if (l) {
                    const e = s(d || n.pointCoordinate3D(u))
                      , i = {
                        dir: t.normalize([], t.sub([], e, n._camera.position))
                    };
                    if (i.dir[2] < 0) {
                        const r = n.zoomDeltaToMovement(e, l);
                        t.scale$2(m, i.dir, r);
                    }
                }
                const g = t.add(_, _, m);
                n._translateCameraConstrained(g),
                l && Math.abs(n.zoom - p) > 1e-4 && n.recenterOnTerrain(),
                n.cameraElevationReference = "ground",
                this._map._update(),
                e.noInertia || this._inertia.record(e),
                this._fireEvents(i, r, !0);
            }
            _fireEvents(e, i, r) {
                const o = Ms(this._eventsInProgress)
                  , n = Ms(e)
                  , s = {};
                for (const t in e) {
                    const {originalEvent: i} = e[t];
                    this._eventsInProgress[t] || (s[`${t}start`] = i),
                    this._eventsInProgress[t] = e[t];
                }
                !o && n && this._fireEvent("movestart", n.originalEvent);
                for (const t in s)
                    this._fireEvent(t, s[t]);
                n && this._fireEvent("move", n.originalEvent);
                for (const t in e) {
                    const {originalEvent: i} = e[t];
                    this._fireEvent(t, i);
                }
                const a = {};
                let l;
                for (const t in this._eventsInProgress) {
                    const {handlerName: e, originalEvent: r} = this._eventsInProgress[t];
                    this._handlersById[e].isActive() || (delete this._eventsInProgress[t],
                    l = i[e] || r,
                    a[`${t}end`] = l);
                }
                for (const t in a)
                    this._fireEvent(t, a[t]);
                const c = Ms(this._eventsInProgress);
                if (r && (o || n) && !c) {
                    this._updatingCamera = !0;
                    const e = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions)
                      , i = t => 0 !== t && -this._bearingSnap < t && t < this._bearingSnap;
                    e ? (i(e.bearing || this._map.getBearing()) && (e.bearing = 0),
                    this._map.easeTo(e, {
                        originalEvent: l
                    })) : (this._map.fire(new t.Event("moveend",{
                        originalEvent: l
                    })),
                    i(this._map.getBearing()) && this._map.resetNorth()),
                    this._updatingCamera = !1;
                }
            }
            _fireEvent(e, i) {
                this._map.fire(new t.Event(e,i ? {
                    originalEvent: i
                } : {}));
            }
            _requestFrame() {
                return this._map.triggerRepaint(),
                this._map._renderTaskQueue.add((t => {
                    this._frameId = void 0,
                    this.handleEvent(new Is("renderFrame",{
                        timeStamp: t
                    })),
                    this._applyChanges();
                }
                ))
            }
            _triggerRenderFrame() {
                void 0 === this._frameId && (this._frameId = this._requestFrame());
            }
        }
        const Bs = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
        class Ls extends t.Evented {
            constructor(e, i) {
                super(),
                this._moving = !1,
                this._zooming = !1,
                this.transform = e,
                this._bearingSnap = i.bearingSnap,
                t.bindAll(["_renderFrameCallback"], this);
            }
            getCenter() {
                return new t.LngLat(this.transform.center.lng,this.transform.center.lat)
            }
            setCenter(t, e) {
                return this.jumpTo({
                    center: t
                }, e)
            }
            panBy(e, i, r) {
                return e = t.pointGeometry.convert(e).mult(-1),
                this.panTo(this.transform.center, t.extend({
                    offset: e
                }, i), r)
            }
            panTo(e, i, r) {
                return this.easeTo(t.extend({
                    center: e
                }, i), r)
            }
            getZoom() {
                return this.transform.zoom
            }
            setZoom(t, e) {
                return this.jumpTo({
                    zoom: t
                }, e),
                this
            }
            zoomTo(e, i, r) {
                return this.easeTo(t.extend({
                    zoom: e
                }, i), r)
            }
            zoomIn(t, e) {
                return this.zoomTo(this.getZoom() + 1, t, e),
                this
            }
            zoomOut(t, e) {
                return this.zoomTo(this.getZoom() - 1, t, e),
                this
            }
            getBearing() {
                return this.transform.bearing
            }
            setBearing(t, e) {
                return this.jumpTo({
                    bearing: t
                }, e),
                this
            }
            getPadding() {
                return this.transform.padding
            }
            setPadding(t, e) {
                return this.jumpTo({
                    padding: t
                }, e),
                this
            }
            rotateTo(e, i, r) {
                return this.easeTo(t.extend({
                    bearing: e
                }, i), r)
            }
            resetNorth(e, i) {
                return this.rotateTo(0, t.extend({
                    duration: 1e3
                }, e), i),
                this
            }
            resetNorthPitch(e, i) {
                return this.easeTo(t.extend({
                    bearing: 0,
                    pitch: 0,
                    duration: 1e3
                }, e), i),
                this
            }
            snapToNorth(t, e) {
                return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t, e) : this
            }
            getPitch() {
                return this.transform.pitch
            }
            setPitch(t, e) {
                return this.jumpTo({
                    pitch: t
                }, e),
                this
            }
            cameraForBounds(e, i) {
                "globe" === this.transform.projection.name && t.warnOnce('Globe projection does not support cameraForBounds API, this API may behave unexpectedly."'),
                e = t.LngLatBounds.convert(e);
                const r = i && i.bearing || 0;
                return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), r, i)
            }
            _extendCameraOptions(e) {
                const i = {
                    top: 0,
                    bottom: 0,
                    right: 0,
                    left: 0
                };
                if ("number" == typeof (e = t.extend({
                    padding: i,
                    offset: [0, 0],
                    maxZoom: this.transform.maxZoom
                }, e)).padding) {
                    const t = e.padding;
                    e.padding = {
                        top: t,
                        bottom: t,
                        right: t,
                        left: t
                    };
                }
                return e.padding = t.extend(i, e.padding),
                e
            }
            _cameraForBoxAndBearing(e, i, r, o) {
                const n = this._extendCameraOptions(o)
                  , s = this.transform
                  , a = s.padding
                  , l = s.project(t.LngLat.convert(e))
                  , c = s.project(t.LngLat.convert(i))
                  , h = new t.pointGeometry(l.x,c.y)
                  , u = new t.pointGeometry(c.x,l.y)
                  , d = -t.degToRad(r)
                  , f = l.rotate(d)
                  , _ = c.rotate(d)
                  , p = h.rotate(d)
                  , m = u.rotate(d)
                  , g = new t.pointGeometry(Math.max(f.x, _.x, p.x, m.x),Math.max(f.y, _.y, p.y, m.y))
                  , v = new t.pointGeometry(Math.min(f.x, _.x, p.x, m.x),Math.min(f.y, _.y, p.y, m.y))
                  , y = g.sub(v)
                  , b = (s.width - ((a.left || 0) + (a.right || 0) + n.padding.left + n.padding.right)) / y.x
                  , x = (s.height - ((a.top || 0) + (a.bottom || 0) + n.padding.top + n.padding.bottom)) / y.y;
                if (x < 0 || b < 0)
                    return void t.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
                const w = Math.min(s.scaleZoom(s.scale * Math.min(b, x)), n.maxZoom)
                  , T = "number" == typeof n.offset.x && "number" == typeof n.offset.y ? new t.pointGeometry(n.offset.x,n.offset.y) : t.pointGeometry.convert(n.offset)
                  , E = new t.pointGeometry((n.padding.left - n.padding.right) / 2,(n.padding.top - n.padding.bottom) / 2).rotate(r * Math.PI / 180)
                  , S = T.add(E).mult(s.scale / s.zoomScale(w));
                return {
                    center: s.unproject(l.add(c).div(2).sub(S)),
                    zoom: w,
                    bearing: r
                }
            }
            _cameraForBox(e, i, r, o, n) {
                const s = this._extendCameraOptions(n);
                r = r || 0,
                o = o || 0,
                e = t.LngLat.convert(e),
                i = t.LngLat.convert(i);
                const a = this.transform.clone();
                a.padding = s.padding;
                const l = this.getFreeCameraOptions()
                  , c = new t.LngLat(.5 * (e.lng + i.lng),.5 * (e.lat + i.lat))
                  , h = .5 * (r + o);
                if (a._camera.position[2] < t.mercatorZfromAltitude(h, c.lat))
                    return void t.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
                l.lookAtPoint(c),
                a.setFreeCameraOptions(l);
                const u = t.MercatorCoordinate.fromLngLat(e)
                  , d = t.MercatorCoordinate.fromLngLat(i)
                  , f = a.pointRayIntersection(a.centerPoint, h)
                  , _ = [(p = a.rayIntersectionCoordinate(f)).x, p.y, p.z];
                var p;
                const m = a.screenPointToMercatorRay(a.centerPoint)
                  , g = "globe" !== a.projection.name;
                let v, y = 0;
                do {
                    const e = Math.floor(a.zoom)
                      , i = 1 << e
                      , n = Math.min(i * u.x, i * d.x)
                      , s = Math.min(i * u.y, i * d.y)
                      , l = Math.max(i * u.x, i * d.x)
                      , c = Math.max(i * u.y, i * d.y)
                      , h = new t.Aabb([n, s, r],[l, c, o])
                      , f = t.Frustum.fromInvProjectionMatrix(a.invProjMatrix, a.worldSize, e, g);
                    if (2 !== h.intersects(f)) {
                        v && (a._camera.position = t.scaleAndAdd([], a._camera.position, m.dir, -v),
                        a._updateStateFromCamera());
                        break
                    }
                    const p = t.sub([], a._camera.position, _);
                    v = .5 * t.length(p),
                    a._camera.position = t.scaleAndAdd([], a._camera.position, m.dir, v);
                    try {
                        a._updateStateFromCamera();
                    } catch (e) {
                        return void t.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.")
                    }
                } while (++y < 10);
                return {
                    center: a.center,
                    zoom: a.zoom,
                    bearing: a.bearing,
                    pitch: a.pitch
                }
            }
            fitBounds(e, i, r) {
                return "globe" === this.transform.projection.name && t.warnOnce("Globe projection does not support fitBounds API, this API may behave unexpectedly."),
                this._fitInternal(this.cameraForBounds(e, i), i, r)
            }
            _raycastElevationBox(e, i) {
                const r = this.transform.elevation;
                if (!r)
                    return;
                const o = new t.pointGeometry(e.x,i.y)
                  , n = new t.pointGeometry(i.x,e.y)
                  , s = r.pointCoordinate(e);
                if (!s)
                    return;
                const a = r.pointCoordinate(i);
                if (!a)
                    return;
                const l = r.pointCoordinate(o);
                if (!l)
                    return;
                const c = r.pointCoordinate(n);
                if (!c)
                    return;
                const h = new t.MercatorCoordinate(s[0],s[1]).toLngLat()
                  , u = new t.MercatorCoordinate(a[0],a[1]).toLngLat()
                  , d = new t.MercatorCoordinate(l[0],l[1]).toLngLat()
                  , f = new t.MercatorCoordinate(c[0],c[1]).toLngLat()
                  , _ = Math.min(h.lng, Math.min(u.lng, Math.min(d.lng, f.lng)))
                  , p = Math.min(h.lat, Math.min(u.lat, Math.min(d.lat, f.lat)))
                  , m = Math.max(h.lng, Math.max(u.lng, Math.max(d.lng, f.lng)))
                  , g = Math.max(h.lat, Math.max(u.lat, Math.max(d.lat, f.lat)))
                  , v = Math.min(s[3], Math.min(a[3], Math.min(l[3], c[3])))
                  , y = Math.max(s[3], Math.max(a[3], Math.max(l[3], c[3])));
                return {
                    minLngLat: new t.LngLat(_,p),
                    maxLngLat: new t.LngLat(m,g),
                    minAltitude: v,
                    maxAltitude: y
                }
            }
            fitScreenCoordinates(e, i, r, o, n) {
                let s, a, l, c;
                "globe" === this.transform.projection.name && t.warnOnce("Globe projection does not support fitScreenCoordinates API, this API may behave unexpectedly.");
                const h = t.pointGeometry.convert(e)
                  , u = t.pointGeometry.convert(i)
                  , d = this._raycastElevationBox(h, u);
                if (d)
                    s = d.minLngLat,
                    a = d.maxLngLat,
                    l = d.minAltitude,
                    c = d.maxAltitude;
                else {
                    if (this.transform.anyCornerOffEdge(h, u))
                        return this;
                    s = this.transform.pointLocation(h),
                    a = this.transform.pointLocation(u);
                }
                return this._fitInternal(0 === this.transform.pitch ? this._cameraForBoxAndBearing(this.transform.pointLocation(t.pointGeometry.convert(e)), this.transform.pointLocation(t.pointGeometry.convert(i)), r, o) : this._cameraForBox(s, a, l, c, o), o, n)
            }
            _fitInternal(e, i, r) {
                return e ? (delete (i = t.extend(e, i)).padding,
                i.linear ? this.easeTo(i, r) : this.flyTo(i, r)) : this
            }
            jumpTo(e, i) {
                this.stop();
                const r = e.preloadOnly ? this.transform.clone() : this.transform;
                let o = !1
                  , n = !1
                  , s = !1;
                return "zoom"in e && r.zoom !== +e.zoom && (o = !0,
                r.zoom = +e.zoom),
                void 0 !== e.center && (r.center = t.LngLat.convert(e.center)),
                "bearing"in e && r.bearing !== +e.bearing && (n = !0,
                r.bearing = +e.bearing),
                "pitch"in e && r.pitch !== +e.pitch && (s = !0,
                r.pitch = +e.pitch),
                null == e.padding || r.isPaddingEqual(e.padding) || (r.padding = e.padding),
                e.preloadOnly ? (this._preloadTiles(r),
                this) : (this.fire(new t.Event("movestart",i)).fire(new t.Event("move",i)),
                o && this.fire(new t.Event("zoomstart",i)).fire(new t.Event("zoom",i)).fire(new t.Event("zoomend",i)),
                n && this.fire(new t.Event("rotatestart",i)).fire(new t.Event("rotate",i)).fire(new t.Event("rotateend",i)),
                s && this.fire(new t.Event("pitchstart",i)).fire(new t.Event("pitch",i)).fire(new t.Event("pitchend",i)),
                this.fire(new t.Event("moveend",i)))
            }
            getFreeCameraOptions() {
                return this.transform.projection.supportsFreeCamera || t.warnOnce(Bs),
                this.transform.getFreeCameraOptions()
            }
            setFreeCameraOptions(e, i) {
                const r = this.transform;
                if (!r.projection.supportsFreeCamera)
                    return t.warnOnce(Bs),
                    this;
                this.stop();
                const o = r.zoom
                  , n = r.pitch
                  , s = r.bearing;
                r.setFreeCameraOptions(e);
                const a = o !== r.zoom
                  , l = n !== r.pitch
                  , c = s !== r.bearing;
                return this.fire(new t.Event("movestart",i)).fire(new t.Event("move",i)),
                a && this.fire(new t.Event("zoomstart",i)).fire(new t.Event("zoom",i)).fire(new t.Event("zoomend",i)),
                c && this.fire(new t.Event("rotatestart",i)).fire(new t.Event("rotate",i)).fire(new t.Event("rotateend",i)),
                l && this.fire(new t.Event("pitchstart",i)).fire(new t.Event("pitch",i)).fire(new t.Event("pitchend",i)),
                this.fire(new t.Event("moveend",i)),
                this
            }
            easeTo(e, i) {
                this._stop(!1, e.easeId),
                (!1 === (e = t.extend({
                    offset: [0, 0],
                    duration: 500,
                    easing: t.ease
                }, e)).animate || !e.essential && t.exported.prefersReducedMotion) && (e.duration = 0);
                const r = this.transform
                  , o = this.getZoom()
                  , n = this.getBearing()
                  , s = this.getPitch()
                  , a = this.getPadding()
                  , l = "zoom"in e ? +e.zoom : o
                  , c = "bearing"in e ? this._normalizeBearing(e.bearing, n) : n
                  , h = "pitch"in e ? +e.pitch : s
                  , u = "padding"in e ? e.padding : r.padding
                  , d = t.pointGeometry.convert(e.offset);
                let f, _, p;
                if ("globe" === r.projection.name) {
                    const i = t.MercatorCoordinate.fromLngLat(r.center)
                      , o = d.rotate(-r.angle);
                    i.x += o.x / r.worldSize,
                    i.y += o.y / r.worldSize;
                    const n = i.toLngLat()
                      , s = t.LngLat.convert(e.center || n);
                    this._normalizeCenter(s),
                    f = r.centerPoint.add(o),
                    _ = new t.pointGeometry(i.x,i.y).mult(r.worldSize),
                    p = new t.pointGeometry(t.mercatorXfromLng(s.lng),t.mercatorYfromLat(s.lat)).mult(r.worldSize).sub(_);
                } else {
                    f = r.centerPoint.add(d);
                    const i = r.pointLocation(f)
                      , o = t.LngLat.convert(e.center || i);
                    this._normalizeCenter(o),
                    _ = r.project(i),
                    p = r.project(o).sub(_);
                }
                const m = r.zoomScale(l - o);
                let g, v;
                e.around && (g = t.LngLat.convert(e.around),
                v = r.locationPoint(g));
                const y = this._zooming || l !== o
                  , b = this._rotating || n !== c
                  , x = this._pitching || h !== s
                  , w = !r.isPaddingEqual(u)
                  , T = r => T => {
                    if (y && (r.zoom = t.number(o, l, T)),
                    b && (r.bearing = t.number(n, c, T)),
                    x && (r.pitch = t.number(s, h, T)),
                    w && (r.interpolatePadding(a, u, T),
                    f = r.centerPoint.add(d)),
                    g)
                        r.setLocationAtPoint(g, v);
                    else {
                        const t = r.zoomScale(r.zoom - o)
                          , e = l > o ? Math.min(2, m) : Math.max(.5, m)
                          , i = Math.pow(e, 1 - T)
                          , n = r.unproject(_.add(p.mult(T * i)).mult(t));
                        r.setLocationAtPoint(r.renderWorldCopies ? n.wrap() : n, f);
                    }
                    return e.preloadOnly || this._fireMoveEvents(i),
                    r
                }
                ;
                if (e.preloadOnly) {
                    const t = this._emulate(T, e.duration, r);
                    return this._preloadTiles(t),
                    this
                }
                const E = {
                    moving: this._moving,
                    zooming: this._zooming,
                    rotating: this._rotating,
                    pitching: this._pitching
                };
                return this._zooming = y,
                this._rotating = b,
                this._pitching = x,
                this._padding = w,
                this._easeId = e.easeId,
                this._prepareEase(i, e.noMoveStart, E),
                this._ease(T(r), (t => {
                    r.recenterOnTerrain(),
                    this._afterEase(i, t);
                }
                ), e),
                this
            }
            _prepareEase(e, i, r={}) {
                this._moving = !0,
                this.transform.cameraElevationReference = "sea",
                i || r.moving || this.fire(new t.Event("movestart",e)),
                this._zooming && !r.zooming && this.fire(new t.Event("zoomstart",e)),
                this._rotating && !r.rotating && this.fire(new t.Event("rotatestart",e)),
                this._pitching && !r.pitching && this.fire(new t.Event("pitchstart",e));
            }
            _fireMoveEvents(e) {
                this.fire(new t.Event("move",e)),
                this._zooming && this.fire(new t.Event("zoom",e)),
                this._rotating && this.fire(new t.Event("rotate",e)),
                this._pitching && this.fire(new t.Event("pitch",e));
            }
            _afterEase(e, i) {
                if (this._easeId && i && this._easeId === i)
                    return;
                this._easeId = void 0,
                this.transform.cameraElevationReference = "ground";
                const r = this._zooming
                  , o = this._rotating
                  , n = this._pitching;
                this._moving = !1,
                this._zooming = !1,
                this._rotating = !1,
                this._pitching = !1,
                this._padding = !1,
                r && this.fire(new t.Event("zoomend",e)),
                o && this.fire(new t.Event("rotateend",e)),
                n && this.fire(new t.Event("pitchend",e)),
                this.fire(new t.Event("moveend",e));
            }
            flyTo(e, i) {
                if (!e.essential && t.exported.prefersReducedMotion) {
                    const r = t.pick(e, ["center", "zoom", "bearing", "pitch", "around"]);
                    return this.jumpTo(r, i)
                }
                this.stop(),
                e = t.extend({
                    offset: [0, 0],
                    speed: 1.2,
                    curve: 1.42,
                    easing: t.ease
                }, e);
                const r = this.transform
                  , o = this.getZoom()
                  , n = this.getBearing()
                  , s = this.getPitch()
                  , a = this.getPadding()
                  , l = "zoom"in e ? t.clamp(+e.zoom, r.minZoom, r.maxZoom) : o
                  , c = "bearing"in e ? this._normalizeBearing(e.bearing, n) : n
                  , h = "pitch"in e ? +e.pitch : s
                  , u = "padding"in e ? e.padding : r.padding
                  , d = r.zoomScale(l - o)
                  , f = t.pointGeometry.convert(e.offset);
                let _ = r.centerPoint.add(f);
                const p = r.pointLocation(_)
                  , m = t.LngLat.convert(e.center || p);
                this._normalizeCenter(m);
                const g = r.project(p)
                  , v = r.project(m).sub(g);
                let y = e.curve;
                const b = Math.max(r.width, r.height)
                  , x = b / d
                  , w = v.mag();
                if ("minZoom"in e) {
                    const i = t.clamp(Math.min(e.minZoom, o, l), r.minZoom, r.maxZoom)
                      , n = b / r.zoomScale(i - o);
                    y = Math.sqrt(n / w * 2);
                }
                const T = y * y;
                function E(t) {
                    const e = (x * x - b * b + (t ? -1 : 1) * T * T * w * w) / (2 * (t ? x : b) * T * w);
                    return Math.log(Math.sqrt(e * e + 1) - e)
                }
                function S(t) {
                    return (Math.exp(t) - Math.exp(-t)) / 2
                }
                function C(t) {
                    return (Math.exp(t) + Math.exp(-t)) / 2
                }
                const A = E(0);
                let M = function(t) {
                    return C(A) / C(A + y * t)
                }
                  , I = function(t) {
                    return b * ((C(A) * (S(e = A + y * t) / C(e)) - S(A)) / T) / w;
                    var e;
                }
                  , z = (E(1) - A) / y;
                if (Math.abs(w) < 1e-6 || !isFinite(z)) {
                    if (Math.abs(b - x) < 1e-6)
                        return this.easeTo(e, i);
                    const t = x < b ? -1 : 1;
                    z = Math.abs(Math.log(x / b)) / y,
                    I = function() {
                        return 0
                    }
                    ,
                    M = function(e) {
                        return Math.exp(t * y * e)
                    }
                    ;
                }
                e.duration = "duration"in e ? +e.duration : 1e3 * z / ("screenSpeed"in e ? +e.screenSpeed / y : +e.speed),
                e.maxDuration && e.duration > e.maxDuration && (e.duration = 0);
                const P = n !== c
                  , D = h !== s
                  , B = !r.isPaddingEqual(u)
                  , L = r => d => {
                    const p = d * z
                      , y = 1 / M(p);
                    r.zoom = 1 === d ? l : o + r.scaleZoom(y),
                    P && (r.bearing = t.number(n, c, d)),
                    D && (r.pitch = t.number(s, h, d)),
                    B && (r.interpolatePadding(a, u, d),
                    _ = r.centerPoint.add(f));
                    const b = 1 === d ? m : r.unproject(g.add(v.mult(I(p))).mult(y));
                    return r.setLocationAtPoint(r.renderWorldCopies ? b.wrap() : b, _),
                    r._updateCameraOnTerrain(),
                    e.preloadOnly || this._fireMoveEvents(i),
                    r
                }
                ;
                if (e.preloadOnly) {
                    const t = this._emulate(L, e.duration, r);
                    return this._preloadTiles(t),
                    this
                }
                return this._zooming = !0,
                this._rotating = P,
                this._pitching = D,
                this._padding = B,
                this._prepareEase(i, !1),
                this._ease(L(r), ( () => this._afterEase(i)), e),
                this
            }
            isEasing() {
                return !!this._easeFrameId
            }
            stop() {
                return this._stop()
            }
            _stop(t, e) {
                if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId),
                this._easeFrameId = void 0,
                this._onEaseFrame = void 0),
                this._onEaseEnd) {
                    const t = this._onEaseEnd;
                    this._onEaseEnd = void 0,
                    t.call(this, e);
                }
                if (!t) {
                    const t = this.handlers;
                    t && t.stop(!1);
                }
                return this
            }
            _ease(e, i, r) {
                !1 === r.animate || 0 === r.duration ? (e(1),
                i()) : (this._easeStart = t.exported.now(),
                this._easeOptions = r,
                this._onEaseFrame = e,
                this._onEaseEnd = i,
                this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
            }
            _renderFrameCallback() {
                const e = Math.min((t.exported.now() - this._easeStart) / this._easeOptions.duration, 1)
                  , i = this._onEaseFrame;
                i && i(this._easeOptions.easing(e)),
                e < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }
            _normalizeBearing(e, i) {
                e = t.wrap(e, -180, 180);
                const r = Math.abs(e - i);
                return Math.abs(e - 360 - i) < r && (e -= 360),
                Math.abs(e + 360 - i) < r && (e += 360),
                e
            }
            _normalizeCenter(t) {
                const e = this.transform;
                if (!e.renderWorldCopies || e.maxBounds)
                    return;
                const i = t.lng - e.center.lng;
                t.lng += i > 180 ? -360 : i < -180 ? 360 : 0;
            }
            _emulate(t, e, i) {
                const r = Math.ceil(15 * e / 1e3)
                  , o = []
                  , n = t(i.clone());
                for (let t = 0; t <= r; t++) {
                    const e = n(t / r);
                    o.push(e.clone());
                }
                return o
            }
        }
        class Rs {
            constructor(e={}) {
                this.options = e,
                t.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
            }
            getDefaultPosition() {
                return "bottom-right"
            }
            onAdd(t) {
                const e = this.options && this.options.compact;
                return this._map = t,
                this._container = _("div", "sgmap-ctrl sgmap-ctrl-attrib"),
                this._compactButton = _("button", "sgmap-ctrl-attrib-button", this._container),
                _("span", "sgmap-ctrl-icon", this._compactButton).setAttribute("aria-hidden", "true"),
                this._compactButton.type = "button",
                this._compactButton.addEventListener("click", this._toggleAttribution),
                this._setElementTitle(this._compactButton, "ToggleAttribution"),
                this._innerContainer = _("div", "sgmap-ctrl-attrib-inner", this._container),
                this._innerContainer.setAttribute("role", "list"),
                e && this._container.classList.add("sgmap-compact"),
                this._updateAttributions(),
                this._updateEditLink(),
                this._map.on("styledata", this._updateData),
                this._map.on("sourcedata", this._updateData),
                this._map.on("moveend", this._updateEditLink),
                void 0 === e && (this._map.on("resize", this._updateCompact),
                this._updateCompact()),
                this._container
            }
            onRemove() {
                this._container.remove(),
                this._map.off("styledata", this._updateData),
                this._map.off("sourcedata", this._updateData),
                this._map.off("moveend", this._updateEditLink),
                this._map.off("resize", this._updateCompact),
                this._map = void 0,
                this._attribHTML = void 0;
            }
            _setElementTitle(t, e) {
                const i = this._map._getUIString(`AttributionControl.${e}`);
                t.setAttribute("aria-label", i),
                t.removeAttribute("title"),
                t.firstElementChild && t.firstElementChild.setAttribute("title", i);
            }
            _toggleAttribution() {
                this._container.classList.contains("sgmap-compact-show") ? (this._container.classList.remove("sgmap-compact-show"),
                this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("sgmap-compact-show"),
                this._compactButton.setAttribute("aria-expanded", "true"));
            }
            _updateEditLink() {
                let e = this._editLink;
                e || (e = this._editLink = this._container.querySelector(".sgmap-improve-map"));
                const i = [{
                    key: "owner",
                    value: this.styleOwner
                }, {
                    key: "id",
                    value: this.styleId
                }, {
                    key: "access_token",
                    value: this._map._requestManager._customAccessToken || t.config.ACCESS_TOKEN
                }];
                if (e) {
                    const r = i.reduce(( (t, e, r) => (e.value && (t += `${e.key}=${e.value}${r < i.length - 1 ? "&" : ""}`),
                    t)), "?");
                    e.href = `${t.config.FEEDBACK_URL}/${r}#${Fn(this._map, !0)}`,
                    e.rel = "noopener nofollow",
                    this._setElementTitle(e, "MapFeedback");
                }
            }
            _updateData(t) {
                !t || "metadata" !== t.sourceDataType && "visibility" !== t.sourceDataType && "style" !== t.dataType || (this._updateAttributions(),
                this._updateEditLink());
            }
            _updateAttributions() {
                if (!this._map.style)
                    return;
                let t = [];
                if (this._map.style.stylesheet) {
                    const t = this._map.style.stylesheet;
                    this.styleOwner = t.owner,
                    this.styleId = t.id;
                }
                const e = this._map.style._sourceCaches;
                for (const i in e) {
                    const r = e[i];
                    if (r.used) {
                        const e = r.getSource();
                        e.attribution && t.indexOf(e.attribution) < 0 && t.push(e.attribution);
                    }
                }
                t.sort(( (t, e) => t.length - e.length)),
                t = t.filter(( (e, i) => {
                    for (let r = i + 1; r < t.length; r++)
                        if (t[r].indexOf(e) >= 0)
                            return !1;
                    return !0
                }
                )),
                this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t = [...this.options.customAttribution, ...t] : t.unshift(this.options.customAttribution));
                const i = t.join(" | ");
                i !== this._attribHTML && (this._attribHTML = i,
                t.length ? (this._innerContainer.innerHTML = i,
                this._container.classList.remove("sgmap-attrib-empty")) : this._container.classList.add("sgmap-attrib-empty"),
                this._editLink = null);
            }
            _updateCompact() {
                this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("sgmap-compact") : this._container.classList.remove("sgmap-compact", "sgmap-compact-show");
            }
        }
        /*!
 * UAParser.js v0.7.21
 * Lightweight JavaScript-based User-Agent string parser
 * https://github.com/faisalman/ua-parser-js
 *
 * Copyright © 2012-2019 Faisal Salman <f@faisalman.com>
 * Licensed under MIT License
 */
        var ks = t.createCommonjsModule((function(t, e) {
            !function(i, r) {
                var o = "function"
                  , n = "object"
                  , s = "model"
                  , a = "name"
                  , l = "type"
                  , c = "vendor"
                  , h = "version"
                  , u = "architecture"
                  , d = "console"
                  , f = "mobile"
                  , _ = "tablet"
                  , p = "smarttv"
                  , m = "wearable"
                  , g = {
                    extend: function(t, e) {
                        var i = {};
                        for (var r in t)
                            i[r] = e[r] && e[r].length % 2 == 0 ? e[r].concat(t[r]) : t[r];
                        return i
                    },
                    has: function(t, e) {
                        return "string" == typeof t && -1 !== e.toLowerCase().indexOf(t.toLowerCase())
                    },
                    lowerize: function(t) {
                        return t.toLowerCase()
                    },
                    major: function(t) {
                        return "string" == typeof t ? t.replace(/[^\d\.]/g, "").split(".")[0] : r
                    },
                    trim: function(t) {
                        return t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
                    }
                }
                  , v = {
                    rgx: function(t, e) {
                        for (var i, s, a, l, c, h, u = 0; u < e.length && !c; ) {
                            var d = e[u]
                              , f = e[u + 1];
                            for (i = s = 0; i < d.length && !c; )
                                if (c = d[i++].exec(t))
                                    for (a = 0; a < f.length; a++)
                                        h = c[++s],
                                        typeof (l = f[a]) === n && l.length > 0 ? 2 == l.length ? this[l[0]] = typeof l[1] == o ? l[1].call(this, h) : l[1] : 3 == l.length ? this[l[0]] = typeof l[1] !== o || l[1].exec && l[1].test ? h ? h.replace(l[1], l[2]) : r : h ? l[1].call(this, h, l[2]) : r : 4 == l.length && (this[l[0]] = h ? l[3].call(this, h.replace(l[1], l[2])) : r) : this[l] = h || r;
                            u += 2;
                        }
                    },
                    str: function(t, e) {
                        for (var i in e)
                            if (typeof e[i] === n && e[i].length > 0) {
                                for (var o = 0; o < e[i].length; o++)
                                    if (g.has(e[i][o], t))
                                        return "?" === i ? r : i
                            } else if (g.has(e[i], t))
                                return "?" === i ? r : i;
                        return t
                    }
                }
                  , y = {
                    browser: {
                        oldsafari: {
                            version: {
                                "1.0": "/8",
                                1.2: "/1",
                                1.3: "/3",
                                "2.0": "/412",
                                "2.0.2": "/416",
                                "2.0.3": "/417",
                                "2.0.4": "/419",
                                "?": "/"
                            }
                        }
                    },
                    device: {
                        amazon: {
                            model: {
                                "Fire Phone": ["SD", "KF"]
                            }
                        },
                        sprint: {
                            model: {
                                "Evo Shift 4G": "7373KT"
                            },
                            vendor: {
                                HTC: "APA",
                                Sprint: "Sprint"
                            }
                        }
                    },
                    os: {
                        windows: {
                            version: {
                                ME: "4.90",
                                "NT 3.11": "NT3.51",
                                "NT 4.0": "NT4.0",
                                2e3: "NT 5.0",
                                XP: ["NT 5.1", "NT 5.2"],
                                Vista: "NT 6.0",
                                7: "NT 6.1",
                                8: "NT 6.2",
                                8.1: "NT 6.3",
                                10: ["NT 6.4", "NT 10.0"],
                                RT: "ARM"
                            }
                        }
                    }
                }
                  , b = {
                    browser: [[/(opera\smini)\/([\w\.-]+)/i, /(opera\s[mobiletab]+).+version\/([\w\.-]+)/i, /(opera).+version\/([\w\.]+)/i, /(opera)[\/\s]+([\w\.]+)/i], [a, h], [/(opios)[\/\s]+([\w\.]+)/i], [[a, "Opera Mini"], h], [/\s(opr)\/([\w\.]+)/i], [[a, "Opera"], h], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]*)/i, /(avant\s|iemobile|slim)(?:browser)?[\/\s]?([\w\.]*)/i, /(bidubrowser|baidubrowser)[\/\s]?([\w\.]+)/i, /(?:ms|\()(ie)\s([\w\.]+)/i, /(rekonq)\/([\w\.]*)/i, /(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon)\/([\w\.-]+)/i], [a, h], [/(konqueror)\/([\w\.]+)/i], [[a, "Konqueror"], h], [/(trident).+rv[:\s]([\w\.]+).+like\sgecko/i], [[a, "IE"], h], [/(edge|edgios|edga|edg)\/((\d+)?[\w\.]+)/i], [[a, "Edge"], h], [/(yabrowser)\/([\w\.]+)/i], [[a, "Yandex"], h], [/(Avast)\/([\w\.]+)/i], [[a, "Avast Secure Browser"], h], [/(AVG)\/([\w\.]+)/i], [[a, "AVG Secure Browser"], h], [/(puffin)\/([\w\.]+)/i], [[a, "Puffin"], h], [/(focus)\/([\w\.]+)/i], [[a, "Firefox Focus"], h], [/(opt)\/([\w\.]+)/i], [[a, "Opera Touch"], h], [/((?:[\s\/])uc?\s?browser|(?:juc.+)ucweb)[\/\s]?([\w\.]+)/i], [[a, "UCBrowser"], h], [/(comodo_dragon)\/([\w\.]+)/i], [[a, /_/g, " "], h], [/(windowswechat qbcore)\/([\w\.]+)/i], [[a, "WeChat(Win) Desktop"], h], [/(micromessenger)\/([\w\.]+)/i], [[a, "WeChat"], h], [/(brave)\/([\w\.]+)/i], [[a, "Brave"], h], [/(qqbrowserlite)\/([\w\.]+)/i], [a, h], [/(QQ)\/([\d\.]+)/i], [a, h], [/m?(qqbrowser)[\/\s]?([\w\.]+)/i], [a, h], [/(baiduboxapp)[\/\s]?([\w\.]+)/i], [a, h], [/(2345Explorer)[\/\s]?([\w\.]+)/i], [a, h], [/(MetaSr)[\/\s]?([\w\.]+)/i], [a], [/(LBBROWSER)/i], [a], [/xiaomi\/miuibrowser\/([\w\.]+)/i], [h, [a, "MIUI Browser"]], [/;fbav\/([\w\.]+);/i], [h, [a, "Facebook"]], [/safari\s(line)\/([\w\.]+)/i, /android.+(line)\/([\w\.]+)\/iab/i], [a, h], [/headlesschrome(?:\/([\w\.]+)|\s)/i], [h, [a, "Chrome Headless"]], [/\swv\).+(chrome)\/([\w\.]+)/i], [[a, /(.+)/, "$1 WebView"], h], [/((?:oculus|samsung)browser)\/([\w\.]+)/i], [[a, /(.+(?:g|us))(.+)/, "$1 $2"], h], [/android.+version\/([\w\.]+)\s+(?:mobile\s?safari|safari)*/i], [h, [a, "Android Browser"]], [/(sailfishbrowser)\/([\w\.]+)/i], [[a, "Sailfish Browser"], h], [/(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i], [a, h], [/(dolfin)\/([\w\.]+)/i], [[a, "Dolphin"], h], [/(qihu|qhbrowser|qihoobrowser|360browser)/i], [[a, "360 Browser"]], [/((?:android.+)crmo|crios)\/([\w\.]+)/i], [[a, "Chrome"], h], [/(coast)\/([\w\.]+)/i], [[a, "Opera Coast"], h], [/fxios\/([\w\.-]+)/i], [h, [a, "Firefox"]], [/version\/([\w\.]+).+?mobile\/\w+\s(safari)/i], [h, [a, "Mobile Safari"]], [/version\/([\w\.]+).+?(mobile\s?safari|safari)/i], [h, a], [/webkit.+?(gsa)\/([\w\.]+).+?(mobile\s?safari|safari)(\/[\w\.]+)/i], [[a, "GSA"], h], [/webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i], [a, [h, v.str, y.browser.oldsafari.version]], [/(webkit|khtml)\/([\w\.]+)/i], [a, h], [/(navigator|netscape)\/([\w\.-]+)/i], [[a, "Netscape"], h], [/(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i, /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([\w\.-]+)$/i, /(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i, /(links)\s\(([\w\.]+)/i, /(gobrowser)\/?([\w\.]*)/i, /(ice\s?browser)\/v?([\w\._]+)/i, /(mosaic)[\/\s]([\w\.]+)/i], [a, h]],
                    cpu: [[/(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\)]/i], [[u, "amd64"]], [/(ia32(?=;))/i], [[u, g.lowerize]], [/((?:i[346]|x)86)[;\)]/i], [[u, "ia32"]], [/windows\s(ce|mobile);\sppc;/i], [[u, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?:\smac|;|\))/i], [[u, /ower/, "", g.lowerize]], [/(sun4\w)[;\)]/i], [[u, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|arm(?:64|(?=v\d+[;l]))|(?=atmel\s)avr|(?:irix|mips|sparc)(?:64)?(?=;)|pa-risc)/i], [[u, g.lowerize]]],
                    device: [[/\((ipad|playbook);[\w\s\),;-]+(rim|apple)/i], [s, c, [l, _]], [/applecoremedia\/[\w\.]+ \((ipad)/], [s, [c, "Apple"], [l, _]], [/(apple\s{0,1}tv)/i], [[s, "Apple TV"], [c, "Apple"], [l, p]], [/(archos)\s(gamepad2?)/i, /(hp).+(touchpad)/i, /(hp).+(tablet)/i, /(kindle)\/([\w\.]+)/i, /\s(nook)[\w\s]+build\/(\w+)/i, /(dell)\s(strea[kpr\s\d]*[\dko])/i], [c, s, [l, _]], [/(kf[A-z]+)\sbuild\/.+silk\//i], [s, [c, "Amazon"], [l, _]], [/(sd|kf)[0349hijorstuw]+\sbuild\/.+silk\//i], [[s, v.str, y.device.amazon.model], [c, "Amazon"], [l, f]], [/android.+aft([bms])\sbuild/i], [s, [c, "Amazon"], [l, p]], [/\((ip[honed|\s\w*]+);.+(apple)/i], [s, c, [l, f]], [/\((ip[honed|\s\w*]+);/i], [s, [c, "Apple"], [l, f]], [/(blackberry)[\s-]?(\w+)/i, /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[\s_-]?([\w-]*)/i, /(hp)\s([\w\s]+\w)/i, /(asus)-?(\w+)/i], [c, s, [l, f]], [/\(bb10;\s(\w+)/i], [s, [c, "BlackBerry"], [l, f]], [/android.+(transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus 7|padfone|p00c)/i], [s, [c, "Asus"], [l, _]], [/(sony)\s(tablet\s[ps])\sbuild\//i, /(sony)?(?:sgp.+)\sbuild\//i], [[c, "Sony"], [s, "Xperia Tablet"], [l, _]], [/android.+\s([c-g]\d{4}|so[-l]\w+)(?=\sbuild\/|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [s, [c, "Sony"], [l, f]], [/\s(ouya)\s/i, /(nintendo)\s([wids3u]+)/i], [c, s, [l, d]], [/android.+;\s(shield)\sbuild/i], [s, [c, "Nvidia"], [l, d]], [/(playstation\s[34portablevi]+)/i], [s, [c, "Sony"], [l, d]], [/(sprint\s(\w+))/i], [[c, v.str, y.device.sprint.vendor], [s, v.str, y.device.sprint.model], [l, f]], [/(htc)[;_\s-]+([\w\s]+(?=\)|\sbuild)|\w+)/i, /(zte)-(\w*)/i, /(alcatel|geeksphone|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]*)/i], [c, [s, /_/g, " "], [l, f]], [/(nexus\s9)/i], [s, [c, "HTC"], [l, _]], [/d\/huawei([\w\s-]+)[;\)]/i, /(nexus\s6p|vog-l29|ane-lx1|eml-l29)/i], [s, [c, "Huawei"], [l, f]], [/android.+(bah2?-a?[lw]\d{2})/i], [s, [c, "Huawei"], [l, _]], [/(microsoft);\s(lumia[\s\w]+)/i], [c, s, [l, f]], [/[\s\(;](xbox(?:\sone)?)[\s\);]/i], [s, [c, "Microsoft"], [l, d]], [/(kin\.[onetw]{3})/i], [[s, /\./g, " "], [c, "Microsoft"], [l, f]], [/\s(milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?:?(\s4g)?)[\w\s]+build\//i, /mot[\s-]?(\w*)/i, /(XT\d{3,4}) build\//i, /(nexus\s6)/i], [s, [c, "Motorola"], [l, f]], [/android.+\s(mz60\d|xoom[\s2]{0,2})\sbuild\//i], [s, [c, "Motorola"], [l, _]], [/hbbtv\/\d+\.\d+\.\d+\s+\([\w\s]*;\s*(\w[^;]*);([^;]*)/i], [[c, g.trim], [s, g.trim], [l, p]], [/hbbtv.+maple;(\d+)/i], [[s, /^/, "SmartTV"], [c, "Samsung"], [l, p]], [/\(dtv[\);].+(aquos)/i], [s, [c, "Sharp"], [l, p]], [/android.+((sch-i[89]0\d|shw-m380s|gt-p\d{4}|gt-n\d+|sgh-t8[56]9|nexus 10))/i, /((SM-T\w+))/i], [[c, "Samsung"], s, [l, _]], [/smart-tv.+(samsung)/i], [c, [l, p], s], [/((s[cgp]h-\w+|gt-\w+|galaxy\snexus|sm-\w[\w\d]+))/i, /(sam[sung]*)[\s-]*(\w+-?[\w-]*)/i, /sec-((sgh\w+))/i], [[c, "Samsung"], s, [l, f]], [/sie-(\w*)/i], [s, [c, "Siemens"], [l, f]], [/(maemo|nokia).*(n900|lumia\s\d+)/i, /(nokia)[\s_-]?([\w-]*)/i], [[c, "Nokia"], s, [l, f]], [/android[x\d\.\s;]+\s([ab][1-7]\-?[0178a]\d\d?)/i], [s, [c, "Acer"], [l, _]], [/android.+([vl]k\-?\d{3})\s+build/i], [s, [c, "LG"], [l, _]], [/android\s3\.[\s\w;-]{10}(lg?)-([06cv9]{3,4})/i], [[c, "LG"], s, [l, _]], [/(lg) netcast\.tv/i], [c, s, [l, p]], [/(nexus\s[45])/i, /lg[e;\s\/-]+(\w*)/i, /android.+lg(\-?[\d\w]+)\s+build/i], [s, [c, "LG"], [l, f]], [/(lenovo)\s?(s(?:5000|6000)(?:[\w-]+)|tab(?:[\s\w]+))/i], [c, s, [l, _]], [/android.+(ideatab[a-z0-9\-\s]+)/i], [s, [c, "Lenovo"], [l, _]], [/(lenovo)[_\s-]?([\w-]+)/i], [c, s, [l, f]], [/linux;.+((jolla));/i], [c, s, [l, f]], [/((pebble))app\/[\d\.]+\s/i], [c, s, [l, m]], [/android.+;\s(oppo)\s?([\w\s]+)\sbuild/i], [c, s, [l, f]], [/crkey/i], [[s, "Chromecast"], [c, "Google"], [l, p]], [/android.+;\s(glass)\s\d/i], [s, [c, "Google"], [l, m]], [/android.+;\s(pixel c)[\s)]/i], [s, [c, "Google"], [l, _]], [/android.+;\s(pixel( [23])?( xl)?)[\s)]/i], [s, [c, "Google"], [l, f]], [/android.+;\s(\w+)\s+build\/hm\1/i, /android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i, /android.+(mi[\s\-_]*(?:a\d|one|one[\s_]plus|note lte)?[\s_]*(?:\d?\w?)[\s_]*(?:plus)?)\s+build/i, /android.+(redmi[\s\-_]*(?:note)?(?:[\s_]*[\w\s]+))\s+build/i], [[s, /_/g, " "], [c, "Xiaomi"], [l, f]], [/android.+(mi[\s\-_]*(?:pad)(?:[\s_]*[\w\s]+))\s+build/i], [[s, /_/g, " "], [c, "Xiaomi"], [l, _]], [/android.+;\s(m[1-5]\snote)\sbuild/i], [s, [c, "Meizu"], [l, f]], [/(mz)-([\w-]{2,})/i], [[c, "Meizu"], s, [l, f]], [/android.+a000(1)\s+build/i, /android.+oneplus\s(a\d{4})[\s)]/i], [s, [c, "OnePlus"], [l, f]], [/android.+[;\/]\s*(RCT[\d\w]+)\s+build/i], [s, [c, "RCA"], [l, _]], [/android.+[;\/\s]+(Venue[\d\s]{2,7})\s+build/i], [s, [c, "Dell"], [l, _]], [/android.+[;\/]\s*(Q[T|M][\d\w]+)\s+build/i], [s, [c, "Verizon"], [l, _]], [/android.+[;\/]\s+(Barnes[&\s]+Noble\s+|BN[RT])(V?.*)\s+build/i], [[c, "Barnes & Noble"], s, [l, _]], [/android.+[;\/]\s+(TM\d{3}.*\b)\s+build/i], [s, [c, "NuVision"], [l, _]], [/android.+;\s(k88)\sbuild/i], [s, [c, "ZTE"], [l, _]], [/android.+[;\/]\s*(gen\d{3})\s+build.*49h/i], [s, [c, "Swiss"], [l, f]], [/android.+[;\/]\s*(zur\d{3})\s+build/i], [s, [c, "Swiss"], [l, _]], [/android.+[;\/]\s*((Zeki)?TB.*\b)\s+build/i], [s, [c, "Zeki"], [l, _]], [/(android).+[;\/]\s+([YR]\d{2})\s+build/i, /android.+[;\/]\s+(Dragon[\-\s]+Touch\s+|DT)(\w{5})\sbuild/i], [[c, "Dragon Touch"], s, [l, _]], [/android.+[;\/]\s*(NS-?\w{0,9})\sbuild/i], [s, [c, "Insignia"], [l, _]], [/android.+[;\/]\s*((NX|Next)-?\w{0,9})\s+build/i], [s, [c, "NextBook"], [l, _]], [/android.+[;\/]\s*(Xtreme\_)?(V(1[045]|2[015]|30|40|60|7[05]|90))\s+build/i], [[c, "Voice"], s, [l, f]], [/android.+[;\/]\s*(LVTEL\-)?(V1[12])\s+build/i], [[c, "LvTel"], s, [l, f]], [/android.+;\s(PH-1)\s/i], [s, [c, "Essential"], [l, f]], [/android.+[;\/]\s*(V(100MD|700NA|7011|917G).*\b)\s+build/i], [s, [c, "Envizen"], [l, _]], [/android.+[;\/]\s*(Le[\s\-]+Pan)[\s\-]+(\w{1,9})\s+build/i], [c, s, [l, _]], [/android.+[;\/]\s*(Trio[\s\-]*.*)\s+build/i], [s, [c, "MachSpeed"], [l, _]], [/android.+[;\/]\s*(Trinity)[\-\s]*(T\d{3})\s+build/i], [c, s, [l, _]], [/android.+[;\/]\s*TU_(1491)\s+build/i], [s, [c, "Rotor"], [l, _]], [/android.+(KS(.+))\s+build/i], [s, [c, "Amazon"], [l, _]], [/android.+(Gigaset)[\s\-]+(Q\w{1,9})\s+build/i], [c, s, [l, _]], [/\s(tablet|tab)[;\/]/i, /\s(mobile)(?:[;\/]|\ssafari)/i], [[l, g.lowerize], c, s], [/[\s\/\(](smart-?tv)[;\)]/i], [[l, p]], [/(android[\w\.\s\-]{0,9});.+build/i], [s, [c, "Generic"]]],
                    engine: [[/windows.+\sedge\/([\w\.]+)/i], [h, [a, "EdgeHTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [h, [a, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i, /(icab)[\/\s]([23]\.[\d\.]+)/i], [a, h], [/rv\:([\w\.]{1,9}).+(gecko)/i], [h, a]],
                    os: [[/microsoft\s(windows)\s(vista|xp)/i], [a, h], [/(windows)\snt\s6\.2;\s(arm)/i, /(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s\w]*)/i, /(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i], [a, [h, v.str, y.os.windows.version]], [/(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i], [[a, "Windows"], [h, v.str, y.os.windows.version]], [/\((bb)(10);/i], [[a, "BlackBerry"], h], [/(blackberry)\w*\/?([\w\.]*)/i, /(tizen|kaios)[\/\s]([\w\.]+)/i, /(android|webos|palm\sos|qnx|bada|rim\stablet\sos|meego|sailfish|contiki)[\/\s-]?([\w\.]*)/i], [a, h], [/(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]*)/i], [[a, "Symbian"], h], [/\((series40);/i], [a], [/mozilla.+\(mobile;.+gecko.+firefox/i], [[a, "Firefox OS"], h], [/(nintendo|playstation)\s([wids34portablevu]+)/i, /(mint)[\/\s\(]?(\w*)/i, /(mageia|vectorlinux)[;\s]/i, /(joli|[kxln]?ubuntu|debian|suse|opensuse|gentoo|(?=\s)arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\/\s-]?(?!chrom)([\w\.-]*)/i, /(hurd|linux)\s?([\w\.]*)/i, /(gnu)\s?([\w\.]*)/i], [a, h], [/(cros)\s[\w]+\s([\w\.]+\w)/i], [[a, "Chromium OS"], h], [/(sunos)\s?([\w\.\d]*)/i], [[a, "Solaris"], h], [/\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]*)/i], [a, h], [/(haiku)\s(\w+)/i], [a, h], [/cfnetwork\/.+darwin/i, /ip[honead]{2,4}(?:.*os\s([\w]+)\slike\smac|;\sopera)/i], [[h, /_/g, "."], [a, "iOS"]], [/(mac\sos\sx)\s?([\w\s\.]*)/i, /(macintosh|mac(?=_powerpc)\s)/i], [[a, "Mac OS"], [h, /_/g, "."]], [/((?:open)?solaris)[\/\s-]?([\w\.]*)/i, /(aix)\s((\d)(?=\.|\)|\s)[\w\.])*/i, /(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms|fuchsia)/i, /(unix)\s?([\w\.]*)/i], [a, h]]
                }
                  , x = function(t, e) {
                    if ("object" == typeof t && (e = t,
                    t = r),
                    !(this instanceof x))
                        return new x(t,e).getResult();
                    var o = t || (i && i.navigator && i.navigator.userAgent ? i.navigator.userAgent : "")
                      , n = e ? g.extend(b, e) : b;
                    return this.getBrowser = function() {
                        var t = {
                            name: r,
                            version: r
                        };
                        return v.rgx.call(t, o, n.browser),
                        t.major = g.major(t.version),
                        t
                    }
                    ,
                    this.getCPU = function() {
                        var t = {
                            architecture: r
                        };
                        return v.rgx.call(t, o, n.cpu),
                        t
                    }
                    ,
                    this.getDevice = function() {
                        var t = {
                            vendor: r,
                            model: r,
                            type: r
                        };
                        return v.rgx.call(t, o, n.device),
                        t
                    }
                    ,
                    this.getEngine = function() {
                        var t = {
                            name: r,
                            version: r
                        };
                        return v.rgx.call(t, o, n.engine),
                        t
                    }
                    ,
                    this.getOS = function() {
                        var t = {
                            name: r,
                            version: r
                        };
                        return v.rgx.call(t, o, n.os),
                        t
                    }
                    ,
                    this.getResult = function() {
                        return {
                            ua: this.getUA(),
                            browser: this.getBrowser(),
                            engine: this.getEngine(),
                            os: this.getOS(),
                            device: this.getDevice(),
                            cpu: this.getCPU()
                        }
                    }
                    ,
                    this.getUA = function() {
                        return o
                    }
                    ,
                    this.setUA = function(t) {
                        return o = t,
                        this
                    }
                    ,
                    this
                };
                x.VERSION = "0.7.21",
                x.BROWSER = {
                    NAME: a,
                    MAJOR: "major",
                    VERSION: h
                },
                x.CPU = {
                    ARCHITECTURE: u
                },
                x.DEVICE = {
                    MODEL: s,
                    VENDOR: c,
                    TYPE: l,
                    CONSOLE: d,
                    MOBILE: f,
                    SMARTTV: p,
                    TABLET: _,
                    WEARABLE: m,
                    EMBEDDED: "embedded"
                },
                x.ENGINE = {
                    NAME: a,
                    VERSION: h
                },
                x.OS = {
                    NAME: a,
                    VERSION: h
                },
                t.exports && (e = t.exports = x),
                e.UAParser = x;
                var w = i && (i.jQuery || i.Zepto);
                if (w && !w.ua) {
                    var T = new x;
                    w.ua = T.getResult(),
                    w.ua.get = function() {
                        return T.getUA()
                    }
                    ,
                    w.ua.set = function(t) {
                        T.setUA(t);
                        var e = T.getResult();
                        for (var i in e)
                            w.ua[i] = e[i];
                    }
                    ;
                }
            }("object" == typeof window ? window : this);
        }
        ));
        const Os = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPoAAABTCAYAAAC2/xobAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAFcVJREFUeNrsXW+MVcUVHxRbQWG3YqHWwK6JEayFfZBGUwX2kUrSJiqblEYNpi71Q0lL0/ULppjGp40m7hfXio1+sC6JRpqmcUETTbTJLqyY2oTddduKiU13MbSFWPoWGpFiur2/uzO7c8+dmTv3vbn3vgfzS25g35/77p05f37nzJlz501PTzMPD48LG5f4IfDw8Iru4eHhFd3Dw8MruoeHh1d0Dw8Pr+geHh5e0T08PLyie3h4eEX38PCK7uHh4RXdw8OjuTDfD4FHg6EUHK38/4N+OJpP0TGBXcFR5hPZUcD9TgbHRHCMciEacHju9uCo8Hts4a9N8d/p80KbCIxdd3C0kdf38vcmMvjNVi6X7fwoGhPkcIZ5OexeK/OJ6mxA4Zrk19Zf53m6uTK3GD7zdHD0pPBmWQhQEd5ZGPZRfkwolG0wwfBP8fOMOlLubn50sMbFJJdLyFW17rNB0TM8+qabAwPB0VrjPZZT/E6P4vvtwdEfHNWM77HKf6c14zkXYzKhuY5Bfs/is4Mprr+9zuvqyWGcs5i3nnrnJKuJhjCNNtmAjtaoBBMpf0cW1q4CBA+/V7K8t26iiBPcWJQTvmN7Dd0pr72/Dpnsn25u1OOMMqPuiH23aDnJJ2fZsX+dzZ0LtSyYz9asWGz6yBiniNUU1HQkwjE/Pc9eeud48O/nbNtt17K2qxfQ7zzI6ViJU9aWAmjhFP/9CcN99SdQW1UoEhsPi3xJLKR7Yv9H7Meb21jLwsuU4WYN94t7uf8CyGOM8TFuiBgdsc+LKuXGBL42coKdPvt5oaN1x9qlgSC1sw0rr6o1lhbA556SX7hnzxH2+sjJ8P+LA8Py9z230+/s5wm7wYLzFnv5XKli2AlLA/Qoz3FYGXgb/PCFcfby4eNsxZIFbN/OtSrDvElKbJalRGhVSrTSJN8jqt+CLI4fO8MOfniqYTR5YyCTq1csYneuXVZPricXRZ+gmVMMKCawaAWneO4Hq9l9gddV4DqDtysToxbxFF/d+XbkPt/YdTM1KGNc+F6lJ37/2OlZI+ESG1ZdpTJqU5rEX1rvJ4/VtOqenjjwEXs+GGuNh57FoUDhvtP73uzf64NrfjMYPwUTaEtgCj3c6MAA/E11TffsGSmEVdoChu75B1brnNGmtKs4rpfXYssjGNRGVHJgx6/Hw38Vyl5ReLsKFyCjp7O4zw6dkn87EPJMxukAY0/esypkMXIkw2kg9YD3q65tKrguCJ8iFOnhR9l0T/gXSpuk7BZos3j/Vc5YWK7j7BAwQjB6GmdUUY13noreRV/Yte9obFBBaUFNFEKjBejVsESxYO03qq2dEtUgdoa3pFZ81ysfBNeylApgOeXyT92A18tS+JAz0NB03X3Pxsu4NjFvH/R20rHSxowYb3FP4x+fYe8Hx4YUc1YnYLA+o/mTZlByKp8YM6IrnZytTBSl6GU6sMMk/vnR7W3s4S3Xp7fsgcDJ54KS7w7Okwa9994YJsqEJxceWCGAbdJAVlgO6637dq6bjU+zAOi7JsxKNLAJYyUMRncD6snl8h+Ye6rkyNcgaWqIiXMDQtzXj5yM5LHw78vBdStkvcxS1H+4VvQIrYVQUE9ek5I7BGgQJlw2GoeOnlIJr+C5P83r2hCT3bd+hqa9NHw8ovTbbr129r0k5nLvnmjiG+xHcX+TzE0RTTun/21Zj49YrcE9IokmG6I1yxclytb7x87ExgUG1uZ307DPWgFjExqcF1hk7nGPu9XjXhh1jyZXjp6KKVmRSi6ApRtZ0TUDqQxFBJ2iRsxEvVT33LpwvjJBJRSSjh0EzYb2gmpTPKxmPhULKu8iZrZWYsTPqnga/ybRbcwnwhMYS62if3w6Jo/6UOd8MHdHwwQhjMvxZ76Vm+xCPmVFH3awKpDrppbWBlDylNcRiz/T0utxg0FwmKCaFc49b03YevN+Sbn7WLRGPzPDLwyY8MQmJcbraYR8MiGLTufCpOjPvjUZ86p50fuEWo/GV/QmRGuSV6jXi1UDL+RK0SGcVGnAGgze3HnRDhjFwdC7no8plkjqNTpUBvPYJ2ebWpC9opuB2DNSAAIPDE88bknddRAFIa5iP5VwIq5XnH+Me/N210r+bPD7WSkzxmtFcC8IedYsn/F4SDDK6+6u8Pj++ArIQ/uOhodL7L7relMFoFf0HIGii0hVFSbl3cpt2i9c+cCbkb8VBTPW3l4GqqXMuYD4MqZmVaJH8upOqbpmCS8Ri3lpMmUBq5cvchra2OJXb0/m8jswippipuZWdGS7ay03pNSpnnNBoFJ49CFWQKkqjTdNeQUYBZo3wDKmhi1AwX/OFIUx8MhUWWPjPnw8ligUwgrvhHnRVZwJhiGW+mgBDq2Mg4K3NEhep9mRq6JDAFyVHbo8VwKQpPq3SrkQj/beuyqVMCKZh3VSrOmbkkFp42LqIR/W1xjAaL2hOocN7VYmIg8w9ucnO0Ol/UtvZ5hgw5hg/Vc+J5YHcyyYqRmoRoPBcir7io1cWMPPazw8dU9GbCebXEYJL6TZfBEDviOyyFh2c6HoKm++c3N7kvG5gr5Q78YOCLHwzllkjfPEfWEBzdLAIJ9UVaXVxGTlIi0RlmgSpV7RGwVyaScEHH/bCPcwqTJLE6qgIETJEIgAwZuDQqcFvmOzXq0ChLYZPHUa1iUbz4TdjolsizKlInIPuSo6soxpy1Z1A1bPuWgs2IigNE8lFIdI/b+I5e/eE98SDg9lKljCGvHG3qtihUBgHnKCDJtjZKNmsce/6UDzIzDkOJBTgEG0KfxCHghGmO5GLCrB6D16E+NZspxmyl3AIEC4TOEC3qdeiwoklPpC8t4qIL+hcgQYV7HMJkqSVWMBAwxWoIrJbbbrZgHf1z0Z5dw9CqHt8CRKxVyQTmBottxDDSjvKzvXhoqpA6g9jMHXdg3x1YrzM148UHC8TpUcqyCoq9co+Zj36BchqJCs0CSD4FFELbYNNEml3wXHd/2ox0MZHGGy853j2mVD2csjP6Lako36e0P5LDoOYRm3wyu6h9bzYDlLBznLH35evVV1K5vrud9Vg8ChU00/m1mdeORCG2MYR+SCcGBZFGXGuvp7quTYZwCqnpC138LqbL9VOHVvWRi1I43Smyu2M2xJuuWTqn3BjZPra11Ymz2mAqnI3A/xf+FRKqyGXmT8u/je4MXg5ZFIA623QdhGa/9HsV15RSBTj04TFRA83HTRWVpaE67xdPoJJJnppPLUeoHMLbLfKLKxNhZEyZHtVcSHo8zDWmlB31VdinQIm0YcnukrgPHHEp2im1FTKvqYTP2g0DRuQVM+2yUK13iJx1qUYmnWqK09lOvtt6odcqi/xnjaFtm8duSE0eimvceLDUisgYGCXSUpN2QcRUpV3upbVYuAJUoUzezibdSgA3k6PNeKPkhjPAyAvP4tJy/qAc7pYqcU4ijFgA8VKWRVzeYQeHUYJRsBoeu3GtbiFV0CEm/IoIOx2eyDFwou70AT7cpoF6OivbzrGL2PvoAkxurlixpyYsOMqLoMsV/6f3sRNFFHBcGIkjbl4PvUAymyvmBfVa/eTGKbR0LmlKTkcA6oh0fP/t2K9lVgXYjlUf+PZTXImQrCy9+4ayi2pNroio7gN9ZmFzeNG24kYLKw3dSwX7swRTeVoUKBadmrKkSRoVkPHvCqPQd4clOPATgrVAVCeSHPNiEUZAseHgYBhkHn8DDfquKnRqbuwhtGtkDC4uGGQVNeHzkRNumbLKB5vmhaAME30N/EzDO1+CuWuGscSL05hAPXLNdeg5Yjm6srAaa0/Q71Gq5XdOKFsUVXhIOYU+Q1EPK4oNY4Pw7ML5bo6BOLDmW8IpWFoldMFo48RKARkZrOuuwQOqmoccdWWCToZI+ja1oAAZJpO2ijwvugs4LPuJNxhuHcxscKcwovC3YE5cRYw+DWO9dwMCig6f10Vbg7Do6v1g0zRSo6tLhTleRI2rstngZie8OIU5E00Tw9xOgxoSTwchr61U28eilPgRsnLYnRvx5jhlwCffjA3c8ciYUf8BYJsTnNQTQtXO8Zl402SluFwQSDE11nZE9vmxjVGRbh5fNAFooemwxkiyGgU2fPK/toyzvTQFVNrZqEkst921DAYNuhE0+OwcQJ+vtu5VZqfLqIordSo5Ul6PlF0ZHwBHLP9pnk3JHZ8VLtZtPQ+wtC0WnDjY0OvSLCO1VLKSi/yJoLxrSRM6tG3vDjOhlXVim68EJQLlUsIlfM2TRdhCeXP0e9WJKRkCfttfhDDdtMXpxms9c7nlhK3WWPAWOG7bkRBhCMAzZSAI8TwV+vbpqApcOJZlVuUW0me9zZfIbDwiXsYNNly2kiDXKN5WJsZkHPQDghXOOhBnpKa+YePcvEVQJE9j+SGITFlY0EYiQFfSpLMWyu/eKSylbhoelz6OBd4PnpdzXtpPocX3IpL4ag6tQyq+TLFzntuw6Wh2w5DAsUFsfBo6esGnMMi/k5MHdtgu6LUKzZFb1ErW+WiasE9HNljSj6neuWRSiZ5jHF3TqFyHKrJ6Xt8CgqofhNEKp8s3I44tEozTQ8uMF1tr2FpXvMck1AklGn5IZ6iLoBRoVDJJExR4d4xZztzsFxzkDFHNmEp41O3TtMNHR9/vELMuj7qUenlAxCpLiPdmaxhu4yLqSlr7pED5QffepM1DLFY5iaAhhn1To0GkDgCa+KsTqXxXXAUYEBIl+CnYN4VBNyRKgTsS0Mg9KrHp3VLB69nOT91hRTITfIyDZAULzIuvSRkyraV1bFslkm42jG3TReEGzUJqi8nKa76CRrsiScvGsPxg2FKigWwjIX4vGE5S4wl7trYVVQQsiHnGHXNYnEdc0+HFHIPff4BxXJUQFsrKq1FVrjKTqNN4vZtYYJfyqiCOuWRhQdHv15FqN+XSr6Hl/ndjeEB1OOFzwLhJLSR/EkE+qMeEjSr8mt9DDNQyXzwgZeWgrjpeqSOsNk1tmc6mlWY3kvDIlQTlOGfYN6j8TsfeDYLYWwIs5HsRjmrZYGno2i6BEhUT17q6ClB3jlyK466r3D537Ht8+CBSTuvHFpvGhOI4kBoaBDFSNiqRIeT8FS+njeYpTQ+VQNI+D1kMQUCSps7EChiYv8y8yuxvn1JK0e5fdUU5ii6xcn5EQ0ipTD0Y2S17eJ84uAK0Vvp/H5QUW23VUiDueSt79ahAQD9PpAb+UJQ0a3N660sZkZzmjJBMoT2z5rMCIwCo8b4jwsubXtWkDP0cLHosQ9HhQ/1fPfVU0PYVgw36DWLlBj9nyMOWiAEXriu643PnGGykOjZdizTMbFKB/i3qy8OQwGhArKjmSMpiFDlSg6iWOjwqTJvpdtBCOLRJwpcSlaCcuGgSbm8B4+o9jp1sbHo5yk5GE5LclJ6IS/dWEhXcnQxgrLqJvY3JNh6wZi53oSbciuo7Dp2p/8Plzvh3GE4Zgs8ImsrmanWyUkNC52CXgqze4zgRFi7YnXWMp2EAHGRJDzLTHlHFwiTeISfdtpWCSMnZycC4tpgr8VcW0n0ywfznRROaEzfDEs5o0UUN5cAMTSnry8N8QcJR1pok1uRmG7Z53G+YcfubWQXJULRY/Rdrozpw46lujZLdGhmkRYaVo8Q+Io4/i4XC6kRkTX3gregQpY2GOcF/1ACOlON8TyiviwQxXz2zQEQeiE0Ac1CWkYDQzphpWZy3QnPz50blVqzLDTZF/ea+iuFL0nibab+mPrvEoexf74DVmw8bumhElWxTKqxKVqfZ4+KkjEhFjTnfPs8Z1uuMekOmxcgynmx+9gvEzZ5rhiRMULKwR5beIIsFJloOTQAw6pXgdEM+yHZj3+aWUlnU3MnkUzSRcxejcVGCqM2xImlwo1NsHkEc/QOB3KYereQru/uiqWUSUuqUDolJwmwMQSFI3ZsdMtaUxlocf3YaCx3IVYFV4IRjAN7aSfhZLlXShiyqek2SORKpkXxPiYA5TQgqqjYQXGEvG+TcKSXpcL5livRy/zOEmykieVMZxxcEBTD0QTSTc9NOSkftnUZALUP27lT2q9Du3+6moNnTIFyoBg+KiSY1x1T/7AfSXtdFPR0nCfdMgIzjhJMooqRNmrIUMP5oR7dN1UM6GhSPDeomAc5/4G1caYbAufnrosE+OSZmkNbADPn6dzrcnXTOSp6KUkobUZQAgEXe4SHtZmN5sJqECCFdUJAN2OqNnkYuWxsorPqYGB8uCeTDkKsdNNbqBpM5aq568lAMmvAX6A3UXW5KnBEZ5dtQW0XuBexXPadaEawhPZ8NB18UbDzNNxlUZiMG/qHh3M9VEl0VQAPUpfQBVUFrXwoqGiKU63DTN6AwomKDH+VVlaSplbpL+RNFN9jlJmU0gglNzGyIBCyuzAZtulTUqBzSxpbQ+OL3FW18c9TD9/P3Jvz+X4HHBT6CXKaB2NQy7AaoqLrcaXViqVeq7jchqj46IQC4rWPJtXf5l+B5tMdnBBmW3qcPlll4ZKt4J//+Tp/zqziAMPfoMta/mi8n28DuUOu9UEv/2Lrfq0MD57wzVXsJVfuZI9tvWG4F4Xxj6z+etXs9++9w927vP/hQIu3z+y1Lg39CZ7LPgdoazw4DN0dhnbu6MUu1aECH/861T4/i+/f5NOyWE85zFS5IPrwTXgaTRbb7lG9d3/BMcXEoZxkiv3z/jcwXujuu4zmsbgMlGmzAcG58Tpc+yfU+fCsckCdLx1c4gxeetPn4QdjRrZk/fv6GDfu/ka1dvb0yr6vOnp6XqvCT+YpnB3O7f8oP0jaShtLXBZkWcLZE1RE59V3KfAXm5wW7kCtqX8LuYDqydbJK89yhV6kKXvL2d8aCCM3THHzUENz2n/Q3DconpD1Azo+ugXARQe3REu4WkbUj7Nanh0lgtFR1XcqyniOdnaQzhfZB4ulFzOm4ykoOEl5r7jTCtTPMyjIFzHZure778A5nqM60/qDTsuYvQBpujlrqF/tFQWnmQTjeuyDuM4q5iyHNjtTaTkwpvaXnM3y6atVJUL5P6Cx+dBfn/dljLayBiqVclDwKM7OrqCY2Jajf7gaDV8F+9VgqM6nS1w/hL/zZLheoE+6Zrb+T3Q6xsNjm5+uMZgcAwY7qMnYT7KhvsblMYh66MrYZyzgmp8enKQsSxQqXceXFB3FW0r86SQ2BJZTfHdLun7nQ6t4QCbe443DT3KnMKOcg8wYPB0rUy9gaLEKeIWBSuo8M93Scky8Tut3OO082NQOhh/rUtKXIrY2RYliUlVa4y5XaDE7zPr9tm4t76E+evh19LWwB5ctP3qc8G6slB0j7k8RBoj55E/hHEtMdLWuyBUJZlxaoy9ont4XAS4xA+Bh4dXdA8PD6/oHh4eXtE9PDy8ont4eHhF9/Dw8Iru4eHhFd3Dw8MruoeHV3QPDw+v6B4eHs2F/wswAD9f5ORzGtg8AAAAAElFTkSuQmCC";
        class Fs {
            constructor(e) {
                this.options = e,
                this._UAParser = new ks,
                this.Year = (new Date).getFullYear(),
                this.mapReviewNumber = "",
                this.copyrightText = "",
                t.bindAll(["_updateLogo", "_delay_updateLogo", "onRemove"], this);
            }
            onAdd(t) {
                return this.isMob = "mobile" == this._UAParser.getDevice().type,
                this._map = t,
                this._updateLogo(),
                t.on("idle", this._updateLogo),
                this.isMob || t.on("moveend", this._delay_updateLogo),
                t.on("resize", this._updateLogo),
                this._container
            }
            _isHidden(t) {
                let e = window.getComputedStyle(t);
                return t.offsetHeight <= 0 || t.offsetWidth <= 0 || "none" == e.display || "hidden" == e.visibility
            }
            _checkOverflow() {
                let t = this.logoIcon;
                var e = t.getBoundingClientRect()
                  , i = [0, 0]
                  , r = document.documentElement
                  , o = Math.max(r.clientHeight, r.scrollHeight, r.offsetHeight)
                  , n = r.getBoundingClientRect().bottom || o;
                let s = !1;
                var a = t => {
                    var r = t.parentElement;
                    if (t && r && !this._isHidden(r)) {
                        var o = window.getComputedStyle(r);
                        if ("static" != o.position) {
                            var l = r.getBoundingClientRect()
                              , c = e.bottom - Math.min(n, l.bottom)
                              , h = Math.max(l.left, 0) - e.left;
                            "visible" != o.overflow && (c > 0 || h > 0) && (c > 0 && ("hidden" == o.overflowY || "auto" == o.overflowY && r.clientHeight == r.scrollHeight) && (i[1] = Math.max(c, i[1])),
                            h > 0 && ("hidden" == o.overflowX || "auto" == o.overflowX && r.clientWidth == r.scrollWidth) && (i[0] = Math.max(h, i[0]))),
                            i[0] >= e.width / 2 || i[1] >= e.height / 2 ? s = !0 : a(r);
                        }
                    }
                }
                ;
                return a(t),
                s
            }
            _checkOverLap() {
                let e = this.logoIcon
                  , i = this._map;
                var r = i.getCanvas();
                if (!i || this._isHidden(r))
                    return;
                let o = !1;
                if (document.elementFromPoint) {
                    var n = e.getBoundingClientRect();
                    let i = [[(n.left + n.right) / 2, (n.top + n.bottom) / 2], [n.left + 5, n.top + 5], [n.left + 5, n.bottom - 5], [n.right - 5, n.bottom - 5], [n.right - 5, n.top + 5]];
                    for (let e = 0; e < i.length; e++) {
                        let r = i[e]
                          , n = document.elementFromPoint(r[0], r[1]);
                        if (n) {
                            if (n != this.logoIcon || n.src != Os) {
                                o = !0,
                                t.warnOnce(n);
                                break
                            }
                        } else if (this._checkOverflow()) {
                            o = !0;
                            break
                        }
                    }
                    this._callbackOverLap(o);
                } else
                    o = this._checkOverflow(),
                    this._callbackOverLap(o);
            }
            _callbackOverLap(e) {
                let i = this._map;
                e ? t.setWaterMarkLayer(i, !0, this.copyrightText) : t.setWaterMarkLayer(i, !1);
            }
            _delay_updateLogo() {
                this._updateLogo(),
                clearTimeout(this.timer),
                this.timer = setTimeout(( () => {
                    this._checkOverLap(),
                    clearTimeout(this.timer),
                    this.timer = null;
                }
                ), 300 * Math.random());
            }
            _updateLogo() {
                this._container && this._container.remove(),
                this._container = _("div", void 0, this._map.getContainer()),
                this.logoIcon = _("img"),
                this._container.appendChild(this.logoIcon),
                this.isMob || (this.copyright = _("span"),
                this._container.appendChild(this.copyright));
                let e = {
                    "z-index": 2147483647,
                    position: "relative",
                    bottom: "auto",
                    top: "auto",
                    left: "auto",
                    right: "auto",
                    margin: 0,
                    padding: 0,
                    overflow: "visible",
                    display: "inline-block",
                    opacity: 1,
                    visibility: "visible",
                    "white-space": "nowrap",
                    "text-align": "left"
                }
                  , i = t.extend({}, e, {
                    width: "360px",
                    height: "23px",
                    position: "absolute",
                    bottom: 0,
                    left: 0
                });
                for (let t in i)
                    this._container.style.setProperty(t, i[t], "important");
                let r = t.extend({}, e, {
                    width: "64px",
                    height: "22px",
                    margin: "0 0 2px 4px",
                    bottom: 0,
                    left: 0,
                    content: "none",
                    "vertical-align": "middle"
                });
                for (let t in r)
                    this.logoIcon.style.setProperty(t, r[t], "important");
                if (this.logoIcon.style.imageRendering = "-moz-crisp-edges",
                this.logoIcon.style.imageRendering = "-webkit-optimize-contrast",
                this.logoIcon.style.imageRendering = "crisp-edges",
                this.logoIcon.src = Os,
                this.copyright) {
                    let i = t.extend({}, e, {
                        width: "auto",
                        height: "18px",
                        color: "#000",
                        font: "12px/20px Helvetica Neue,Arial,Helvetica,sans-serif",
                        "line-height": "18px",
                        "vertical-align": "middle",
                        padding: "0 3px"
                    });
                    for (let t in i)
                        this.copyright.style.setProperty(t, i[t], "important");
                    this.copyright.style.backgroundColor = "rgba(255, 255, 255, 0.8)",
                    this._getMapReviewNumber(),
                    this.copyrightText = this.mapReviewNumber + "甲测资字35100192",
                    this.copyright.innerText = "© " + this.Year + " 亿力吉奥 -" + this.mapReviewNumber + "甲测资字35100192";
                }
            }
            onRemove() {
                let t = this._map;
                this._container.remove(),
                clearTimeout(this.timer),
                this.timer = null,
                t.off("idle", this._updateLogo),
                this.isMob || t.off("moveend", this._delay_updateLogo),
                t.off("resize", this._updateLogo);
            }
            getDefaultPosition() {
                return "bottom-left"
            }
            _MapReviewNumberRequired() {
                let t = !1
                  , e = this._map.style;
                if (!this._map.style)
                    return t;
                const i = this._map.style._sourceCaches
                  , r = Object.keys(i);
                let o = {};
                for (const t in e._layers) {
                    let i = e._layers[t].source;
                    i && (o[i] = !0);
                }
                e.terrain && (o[e.terrain.get().source] = !0);
                for (let e = 0; e < r.length; e++) {
                    let n = i[r[e]].getSource();
                    if (!n || !n.tiles || "vector" != n.type && "raster" != n.type || !o[n.id])
                        continue;
                    let s = !0;
                    for (let t = 0; t < n.tiles.length; t++)
                        if (null == n.tiles[t].split("?")[0].match(/\.sg$/)) {
                            s = !1;
                            break
                        }
                    if (s) {
                        t = !0;
                        break
                    }
                }
                return t
            }
            _getMapReviewNumber() {
                let t = () => {
                    if (this._MapReviewNumberRequired()) {
                        let t = new SGMap.MapReviewNumberExtend({
                            map: this._map
                        }).getMapReviewNumber();
                        this.mapReviewNumber = t ? t + " -" : "";
                    } else
                        this.mapReviewNumber = "";
                }
                ;
                SGMap.MapReviewNumberExtend ? t() : window.SGMap.plugin(["SGMap.MapReviewNumberExtend"]).then(( () => {
                    t();
                }
                ));
            }
        }
        class Us {
            constructor() {
                this._queue = [],
                this._id = 0,
                this._cleared = !1,
                this._currentlyRunning = !1;
            }
            add(t) {
                const e = ++this._id;
                return this._queue.push({
                    callback: t,
                    id: e,
                    cancelled: !1
                }),
                e
            }
            remove(t) {
                const e = this._currentlyRunning
                  , i = e ? this._queue.concat(e) : this._queue;
                for (const e of i)
                    if (e.id === t)
                        return void (e.cancelled = !0)
            }
            run(t=0) {
                const e = this._currentlyRunning = this._queue;
                this._queue = [];
                for (const i of e)
                    if (!i.cancelled && (i.callback(t),
                    this._cleared))
                        break;
                this._cleared = !1,
                this._currentlyRunning = !1;
            }
            clear() {
                this._currentlyRunning && (this._cleared = !0),
                this._queue = [];
            }
        }
        function Ns(e, i, r) {
            if (e = new t.LngLat(e.lng,e.lat),
            i) {
                const o = new t.LngLat(e.lng - 360,e.lat)
                  , n = new t.LngLat(e.lng + 360,e.lat)
                  , s = 360 * Math.ceil(Math.abs(e.lng - r.center.lng) / 360)
                  , a = r.locationPoint(e).distSqr(i)
                  , l = i.x < 0 || i.y < 0 || i.x > r.width || i.y > r.height;
                r.locationPoint(o).distSqr(i) < a && (l || Math.abs(o.lng - r.center.lng) < s) ? e = o : r.locationPoint(n).distSqr(i) < a && (l || Math.abs(n.lng - r.center.lng) < s) && (e = n);
            }
            for (; Math.abs(e.lng - r.center.lng) > 180; ) {
                const t = r.locationPoint(e);
                if (t.x >= 0 && t.y >= 0 && t.x <= r.width && t.y <= r.height)
                    break;
                e.lng > r.center.lng ? e.lng -= 360 : e.lng += 360;
            }
            return e
        }
        const js = {
            center: "translate(-50%,-50%)",
            top: "translate(-50%,0)",
            "top-left": "translate(0,0)",
            "top-right": "translate(-100%,0)",
            bottom: "translate(-50%,-100%)",
            "bottom-left": "translate(0,-100%)",
            "bottom-right": "translate(-100%,-100%)",
            left: "translate(0,-50%)",
            right: "translate(-100%,-50%)"
        };
        class Gs extends t.Evented {
            constructor(e, i) {
                if (super(),
                (e instanceof t.window.HTMLElement || i) && (e = t.extend({
                    element: e
                }, i)),
                t.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this),
                this._anchor = e && e.anchor || "center",
                this._color = e && e.color || "#3FB1CE",
                this._scale = e && e.scale || 1,
                this._draggable = e && e.draggable || !1,
                this._clickTolerance = e && e.clickTolerance || 0,
                this._isDragging = !1,
                this._state = "inactive",
                this._rotation = e && e.rotation || 0,
                this._rotationAlignment = e && e.rotationAlignment || "auto",
                this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment || "auto",
                this._updateMoving = () => this._update(!0),
                e && e.element)
                    this._element = e.element,
                    this._offset = t.pointGeometry.convert(e && e.offset || [0, 0]);
                else {
                    this._defaultMarker = !0,
                    this._element = _("div");
                    const i = 41
                      , r = 27
                      , o = p("svg", {
                        display: "block",
                        height: i * this._scale + "px",
                        width: r * this._scale + "px",
                        viewBox: `0 0 ${r} ${i}`
                    }, this._element)
                      , n = p("radialGradient", {
                        id: "shadowGradient"
                    }, p("defs", {}, o));
                    p("stop", {
                        offset: "10%",
                        "stop-opacity": .4
                    }, n),
                    p("stop", {
                        offset: "100%",
                        "stop-opacity": .05
                    }, n),
                    p("ellipse", {
                        cx: 13.5,
                        cy: 34.8,
                        rx: 10.5,
                        ry: 5.25,
                        fill: "url(#shadowGradient)"
                    }, o),
                    p("path", {
                        fill: this._color,
                        d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z"
                    }, o),
                    p("path", {
                        opacity: .25,
                        d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z"
                    }, o),
                    p("circle", {
                        fill: "white",
                        cx: 13.5,
                        cy: 13.5,
                        r: 5.5
                    }, o),
                    this._offset = t.pointGeometry.convert(e && e.offset || [0, -14]);
                }
                this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"),
                this._element.classList.add("sgmap-marker"),
                this._element.addEventListener("dragstart", (t => {
                    t.preventDefault();
                }
                )),
                this._element.addEventListener("mousedown", (t => {
                    t.preventDefault();
                }
                ));
                const r = this._element.classList;
                for (const t in js)
                    r.remove(`sgmap-marker-anchor-${t}`);
                r.add(`sgmap-marker-anchor-${this._anchor}`),
                this._popup = null;
            }
            addTo(t) {
                return t === this._map || (this.remove(),
                this._map = t,
                t.getCanvasContainer().appendChild(this._element),
                t.on("move", this._updateMoving),
                t.on("moveend", this._update),
                t.on("remove", this._clearFadeTimer),
                t._addMarker(this),
                this.setDraggable(this._draggable),
                this._update(),
                t.on("click", this._onMapClick)),
                this
            }
            remove() {
                const t = this._map;
                return t && (t.off("click", this._onMapClick),
                t.off("move", this._updateMoving),
                t.off("moveend", this._update),
                t.off("mousedown", this._addDragHandler),
                t.off("touchstart", this._addDragHandler),
                t.off("mouseup", this._onUp),
                t.off("touchend", this._onUp),
                t.off("mousemove", this._onMove),
                t.off("touchmove", this._onMove),
                t.off("remove", this._clearFadeTimer),
                t._removeMarker(this),
                this._map = void 0),
                this._clearFadeTimer(),
                this._element.remove(),
                this._popup && this._popup.remove(),
                this
            }
            getLngLat() {
                return this._lngLat
            }
            setLngLat(e) {
                return this._lngLat = t.LngLat.convert(e),
                this._pos = null,
                this._popup && this._popup.setLngLat(this._lngLat),
                this._update(!0),
                this
            }
            getElement() {
                return this._element
            }
            setPopup(t) {
                if (this._popup && (this._popup.remove(),
                this._popup = null,
                this._element.removeAttribute("role"),
                this._element.removeEventListener("keypress", this._onKeyPress),
                this._originalTabIndex || this._element.removeAttribute("tabindex")),
                t) {
                    if (!("offset"in t.options)) {
                        const e = 38.1
                          , i = 13.5
                          , r = Math.sqrt(Math.pow(i, 2) / 2);
                        t.options.offset = this._defaultMarker ? {
                            top: [0, 0],
                            "top-left": [0, 0],
                            "top-right": [0, 0],
                            bottom: [0, -e],
                            "bottom-left": [r, -1 * (e - i + r)],
                            "bottom-right": [-r, -1 * (e - i + r)],
                            left: [i, -1 * (e - i)],
                            right: [-i, -1 * (e - i)]
                        } : this._offset;
                    }
                    this._popup = t,
                    t._marker = this,
                    this._lngLat && this._popup.setLngLat(this._lngLat),
                    this._element.setAttribute("role", "button"),
                    this._originalTabIndex = this._element.getAttribute("tabindex"),
                    this._originalTabIndex || this._element.setAttribute("tabindex", "0"),
                    this._element.addEventListener("keypress", this._onKeyPress),
                    this._element.setAttribute("aria-expanded", "false");
                }
                return this
            }
            _onKeyPress(t) {
                const e = t.code
                  , i = t.charCode || t.keyCode;
                "Space" !== e && "Enter" !== e && 32 !== i && 13 !== i || this.togglePopup();
            }
            _onMapClick(t) {
                const e = t.originalEvent.target
                  , i = this._element;
                this._popup && (e === i || i.contains(e)) && this.togglePopup();
            }
            getPopup() {
                return this._popup
            }
            togglePopup() {
                const t = this._popup;
                return t ? (t.isOpen() ? (t.remove(),
                this._element.setAttribute("aria-expanded", "false")) : this._map && (t.addTo(this._map),
                this._element.setAttribute("aria-expanded", "true")),
                this) : this
            }
            _behindTerrain() {
                const t = this._map;
                if (!t)
                    return !1;
                const e = t.unproject(this._pos)
                  , i = t.getFreeCameraOptions();
                if (!i.position)
                    return !1;
                const r = i.position.toLngLat();
                return r.distanceTo(e) < .9 * r.distanceTo(this._lngLat)
            }
            _evaluateOpacity() {
                const e = this._map;
                if (!e)
                    return;
                const i = this._pos;
                if (!i || i.x < 0 || i.x > e.transform.width || i.y < 0 || i.y > e.transform.height)
                    return void this._clearFadeTimer();
                const r = e.unproject(i);
                let o;
                e._showingGlobe() && t.isLngLatBehindGlobe(e.transform, this._lngLat) ? o = 0 : (o = 1 - e._queryFogOpacity(r),
                e.transform._terrainEnabled() && e.getTerrain() && this._behindTerrain() && (o *= .2)),
                this._element.style.opacity = `${o}`,
                this._element.style.pointerEvents = o > 0 ? "auto" : "none",
                this._popup && this._popup._setOpacity(o),
                this._fadeTimer = null;
            }
            _clearFadeTimer() {
                this._fadeTimer && (clearTimeout(this._fadeTimer),
                this._fadeTimer = null);
            }
            _updateDOM() {
                const t = this._pos;
                if (!t || !this._map)
                    return;
                const e = this._offset.mult(this._scale);
                this._element.style.transform = `\n            translate(${t.x}px,${t.y}px)\n            ${js[this._anchor]}\n            ${this._calculateXYTransform()} ${this._calculateZTransform()}\n            translate(${e.x}px,${e.y}px)\n        `;
            }
            _calculateXYTransform() {
                const e = this._pos
                  , i = this._map
                  , r = this.getPitchAlignment();
                if (!i || !e || "map" !== r)
                    return "";
                if (!i._showingGlobe()) {
                    const t = i.getPitch();
                    return t ? `rotateX(${t}deg)` : ""
                }
                const o = t.radToDeg(t.globeTiltAtLngLat(i.transform, this._lngLat))
                  , n = e.sub(t.globeCenterToScreenPoint(i.transform))
                  , s = Math.abs(n.x) + Math.abs(n.y);
                if (0 === s)
                    return "";
                const a = o / s;
                return `rotateX(${-n.y * a}deg) rotateY(${n.x * a}deg)`
            }
            _calculateZTransform() {
                const e = this._pos
                  , i = this._map;
                if (!i || !e)
                    return "";
                let r = 0;
                const o = this.getRotationAlignment();
                if ("map" === o)
                    if (i._showingGlobe()) {
                        const e = i.project(new t.LngLat(this._lngLat.lng,this._lngLat.lat + .001))
                          , o = i.project(new t.LngLat(this._lngLat.lng,this._lngLat.lat - .001)).sub(e);
                        r = t.radToDeg(Math.atan2(o.y, o.x)) - 90;
                    } else
                        r = -i.getBearing();
                else if ("horizon" === o) {
                    const o = t.smoothstep(4, 6, i.getZoom())
                      , n = t.globeCenterToScreenPoint(i.transform);
                    n.y += o * i.transform.height;
                    const s = e.sub(n)
                      , a = t.radToDeg(Math.atan2(s.y, s.x));
                    r = (a > 90 ? a - 270 : a + 90) * (1 - o);
                }
                return r += this._rotation,
                r ? `rotateZ(${r}deg)` : ""
            }
            _update(e) {
                t.window.cancelAnimationFrame(this._updateFrameId);
                const i = this._map;
                i && (i.transform.renderWorldCopies && (this._lngLat = Ns(this._lngLat, this._pos, i.transform)),
                this._pos = i.project(this._lngLat),
                !0 === e ? this._updateFrameId = t.window.requestAnimationFrame(( () => {
                    this._element && this._pos && this._anchor && (this._pos = this._pos.round(),
                    this._updateDOM());
                }
                )) : this._pos = this._pos.round(),
                i._requestDomTask(( () => {
                    this._map && (this._element && this._pos && this._anchor && this._updateDOM(),
                    (i._showingGlobe() || i.getTerrain() || i.getFog()) && !this._fadeTimer && (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)));
                }
                )));
            }
            getOffset() {
                return this._offset
            }
            setOffset(e) {
                return this._offset = t.pointGeometry.convert(e),
                this._update(),
                this
            }
            _onMove(e) {
                const i = this._map;
                if (i) {
                    if (!this._isDragging) {
                        const t = this._clickTolerance || i._clickTolerance;
                        this._isDragging = e.point.dist(this._pointerdownPos) >= t;
                    }
                    this._isDragging && (this._pos = e.point.sub(this._positionDelta),
                    this._lngLat = i.unproject(this._pos),
                    this.setLngLat(this._lngLat),
                    this._element.style.pointerEvents = "none",
                    "pending" === this._state && (this._state = "active",
                    this.fire(new t.Event("dragstart"))),
                    this.fire(new t.Event("drag")));
                }
            }
            _onUp() {
                this._element.style.pointerEvents = "auto",
                this._positionDelta = null,
                this._pointerdownPos = null,
                this._isDragging = !1;
                const e = this._map;
                e && (e.off("mousemove", this._onMove),
                e.off("touchmove", this._onMove)),
                "active" === this._state && this.fire(new t.Event("dragend")),
                this._state = "inactive";
            }
            _addDragHandler(t) {
                const e = this._map;
                e && this._element.contains(t.originalEvent.target) && (t.preventDefault(),
                this._positionDelta = t.point.sub(this._pos),
                this._pointerdownPos = t.point,
                this._state = "pending",
                e.on("mousemove", this._onMove),
                e.on("touchmove", this._onMove),
                e.once("mouseup", this._onUp),
                e.once("touchend", this._onUp));
            }
            setDraggable(t) {
                this._draggable = !!t;
                const e = this._map;
                return e && (t ? (e.on("mousedown", this._addDragHandler),
                e.on("touchstart", this._addDragHandler)) : (e.off("mousedown", this._addDragHandler),
                e.off("touchstart", this._addDragHandler))),
                this
            }
            isDraggable() {
                return this._draggable
            }
            setRotation(t) {
                return this._rotation = t || 0,
                this._update(),
                this
            }
            getRotation() {
                return this._rotation
            }
            setRotationAlignment(t) {
                return this._rotationAlignment = t || "auto",
                this._update(),
                this
            }
            getRotationAlignment() {
                return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment
            }
            setPitchAlignment(t) {
                return this._pitchAlignment = t || "auto",
                this._update(),
                this
            }
            getPitchAlignment() {
                return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment
            }
        }
        const Vs = {
            closeButton: !0,
            closeOnClick: !0,
            focusAfterOpen: !1,
            className: "",
            maxWidth: "240px"
        }
          , Zs = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function Ws(e=new t.pointGeometry(0,0), i="bottom") {
            if ("number" == typeof e) {
                const r = Math.round(Math.sqrt(.5 * Math.pow(e, 2)));
                switch (i) {
                case "top":
                    return new t.pointGeometry(0,e);
                case "top-left":
                    return new t.pointGeometry(r,r);
                case "top-right":
                    return new t.pointGeometry(-r,r);
                case "bottom":
                    return new t.pointGeometry(0,-e);
                case "bottom-left":
                    return new t.pointGeometry(r,-r);
                case "bottom-right":
                    return new t.pointGeometry(-r,-r);
                case "left":
                    return new t.pointGeometry(e,0);
                case "right":
                    return new t.pointGeometry(-e,0)
                }
                return new t.pointGeometry(0,0)
            }
            return e instanceof t.pointGeometry || Array.isArray(e) ? t.pointGeometry.convert(e) : t.pointGeometry.convert(e[i] || [0, 0])
        }
        class qs {
            constructor(t) {
                this.jumpTo(t);
            }
            getValue(e) {
                if (e <= this._startTime)
                    return this._start;
                if (e >= this._endTime)
                    return this._end;
                const i = t.easeCubicInOut((e - this._startTime) / (this._endTime - this._startTime));
                return this._start * (1 - i) + this._end * i
            }
            isEasing(t) {
                return t >= this._startTime && t <= this._endTime
            }
            jumpTo(t) {
                this._startTime = -1 / 0,
                this._endTime = -1 / 0,
                this._start = t,
                this._end = t;
            }
            easeTo(t, e, i) {
                this._start = this.getValue(e),
                this._end = t,
                this._startTime = e,
                this._endTime = e + i;
            }
        }
        const Hs = {
            "AttributionControl.ToggleAttribution": "Toggle attribution",
            "AttributionControl.MapFeedback": "Map feedback",
            "FullscreenControl.Enter": "Enter fullscreen",
            "FullscreenControl.Exit": "Exit fullscreen",
            "GeolocateControl.FindMyLocation": "Find my location",
            "GeolocateControl.LocationNotAvailable": "Location not available",
            "LogoControl.Title": "sgmap logo",
            "Map.Title": "Map",
            "NavigationControl.ResetBearing": "Reset bearing to north",
            "NavigationControl.ZoomIn": "Zoom in",
            "NavigationControl.ZoomOut": "Zoom out",
            "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map",
            "ScrollZoomBlocker.CmdMessage": "Use ⌘ + scroll to zoom the map",
            "TouchPanBlocker.Message": "Use two fingers to move the map"
        }
          , Xs = {
            center: [0, 0],
            zoom: 0,
            bearing: 0,
            pitch: 0,
            minZoom: 1,
            maxZoom: 22,
            minPitch: 0,
            maxPitch: 85,
            interactive: !0,
            scrollZoom: !0,
            boxZoom: !0,
            dragRotate: !0,
            dragPan: !0,
            keyboard: !0,
            doubleClickZoom: !0,
            touchZoomRotate: !0,
            touchPitch: !0,
            cooperativeGestures: !1,
            bearingSnap: 7,
            clickTolerance: 3,
            pitchWithRotate: !0,
            hash: !1,
            attributionControl: !0,
            failIfMajorPerformanceCaveat: !1,
            preserveDrawingBuffer: !1,
            trackResize: !0,
            optimizeForTerrain: !0,
            renderWorldCopies: !0,
            refreshExpiredTiles: !0,
            minTileCacheSize: null,
            maxTileCacheSize: null,
            localIdeographFontFamily: "sans-serif",
            localFontFamily: null,
            transformRequest: null,
            accessToken: null,
            fadeDuration: 300,
            crossSourceCollisions: !0
        };
        class Ys extends Ls {
            constructor(e) {
                if (null != (e = t.extend({}, Xs, e)).minZoom && null != e.maxZoom && e.minZoom > e.maxZoom)
                    throw new Error("maxZoom must be greater than or equal to minZoom");
                if (null != e.minPitch && null != e.maxPitch && e.minPitch > e.maxPitch)
                    throw new Error("maxPitch must be greater than or equal to minPitch");
                if (null != e.minPitch && e.minPitch < 0)
                    throw new Error("minPitch must be greater than or equal to 0");
                if (null != e.maxPitch && e.maxPitch > 85)
                    throw new Error("maxPitch must be less than or equal to 85");
                if (e.antialias && t.isSafariWithAntialiasingBug(t.window) && (e.antialias = !1,
                t.warnOnce("该浏览器不支持抗锯齿功能")),
                super(new Rn(e.minZoom,e.maxZoom,e.minPitch,e.maxPitch,e.renderWorldCopies), e),
                this._interactive = e.interactive,
                this._minTileCacheSize = e.minTileCacheSize,
                this._maxTileCacheSize = e.maxTileCacheSize,
                this._failIfMajorPerformanceCaveat = e.failIfMajorPerformanceCaveat,
                this._preserveDrawingBuffer = e.preserveDrawingBuffer,
                this._antialias = e.antialias,
                this._trackResize = e.trackResize,
                this._bearingSnap = e.bearingSnap,
                this._refreshExpiredTiles = e.refreshExpiredTiles,
                this._fadeDuration = e.fadeDuration,
                this._isInitialLoad = !0,
                this._crossSourceCollisions = e.crossSourceCollisions,
                this._crossFadingFactor = 1,
                this._collectResourceTiming = e.collectResourceTiming,
                this._optimizeForTerrain = e.optimizeForTerrain,
                this._language = "auto" === e.language ? t.window.navigator.language : e.language,
                this._worldview = e.worldview,
                this._renderTaskQueue = new Us,
                this._domRenderTaskQueue = new Us,
                this._controls = [],
                this._markers = [],
                this._popups = [],
                this._mapId = t.uniqueId(),
                this._locale = t.extend({}, Hs, e.locale),
                this._clickTolerance = e.clickTolerance,
                this._cooperativeGestures = e.cooperativeGestures,
                this._containerWidth = 0,
                this._containerHeight = 0,
                this._averageElevationLastSampledAt = -1 / 0,
                this._averageElevationExaggeration = 0,
                this._averageElevation = new qs(0),
                this._useExplicitProjection = !1,
                this._requestManager = new t.RequestManager(e.transformRequest,e.accessToken,e.testMode),
                this._silenceAuthErrors = !!e.testMode,
                "string" == typeof e.container) {
                    if (this._container = t.window.document.getElementById(e.container),
                    !this._container)
                        throw new Error(`Container '${e.container}' not found.`)
                } else {
                    if (!(e.container instanceof t.window.HTMLElement))
                        throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                    this._container = e.container;
                }
                if (this._container.childNodes.length > 0 && t.warnOnce("地图容器内容应为空，否则会影响地图的交互功能，如果想在浏览器不支持WEBGL时显示提示信息，请使用 SGMap.supported() 进行替代."),
                e.maxBounds && this.setMaxBounds(e.maxBounds),
                t.bindAll(["_onWindowOnline", "_onWindowResize", "_onMapScroll", "_contextLost", "_contextRestored"], this),
                this._setupContainer(),
                this._setupPainter(),
                void 0 === this.painter)
                    throw new Error("Failed to initialize WebGL.");
                this.on("move", ( () => this._update(!1))),
                this.on("moveend", ( () => this._update(!1))),
                this.on("zoom", ( () => this._update(!0))),
                void 0 !== t.window && (t.window.addEventListener("online", this._onWindowOnline, !1),
                t.window.addEventListener("resize", this._onWindowResize, !1),
                t.window.addEventListener("orientationchange", this._onWindowResize, !1),
                t.window.addEventListener("webkitfullscreenchange", this._onWindowResize, !1)),
                this.handlers = new Ds(this,e),
                this._localFontFamily = e.localFontFamily,
                this._localIdeographFontFamily = e.localIdeographFontFamily,
                e.style && this.setStyle(e.style, {
                    localFontFamily: this._localFontFamily,
                    localIdeographFontFamily: this._localIdeographFontFamily
                }),
                e.projection && this.setProjection(e.projection),
                this._hash = e.hash && new On("string" == typeof e.hash && e.hash || void 0).addTo(this),
                this._hash && this._hash._onHashChange() || (this.jumpTo({
                    center: e.center,
                    zoom: e.zoom,
                    bearing: e.bearing,
                    pitch: e.pitch
                }),
                e.bounds && (this.resize(),
                this.fitBounds(e.bounds, t.extend({}, e.fitBoundsOptions, {
                    duration: 0
                })))),
                this.resize(),
                e.attributionControl && this.addControl(new Rs({
                    customAttribution: e.customAttribution
                })),
                this.on("style.load", ( () => {
                    this.transform.unmodified && this.jumpTo(this.style.stylesheet);
                }
                )),
                this.on("data", (e => {
                    this._update("style" === e.dataType),
                    this.fire(new t.Event(`${e.dataType}data`,e));
                }
                )),
                this.on("dataloading", (e => {
                    this.fire(new t.Event(`${e.dataType}dataloading`,e));
                }
                ));
            }
            _getMapId() {
                return this._mapId
            }
            addControl(e, i) {
                if (void 0 === i && (i = e.getDefaultPosition ? e.getDefaultPosition() : "top-right"),
                !e || !e.onAdd)
                    return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
                const r = e.onAdd(this);
                this._controls.push(e);
                const o = this._controlPositions[i];
                return -1 !== i.indexOf("bottom") ? o.insertBefore(r, o.firstChild) : o.appendChild(r),
                this
            }
            removeControl(e) {
                if (!e || !e.onRemove)
                    return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
                const i = this._controls.indexOf(e);
                return i > -1 && this._controls.splice(i, 1),
                e.onRemove(this),
                this
            }
            hasControl(t) {
                return this._controls.indexOf(t) > -1
            }
            getContainer() {
                return this._container
            }
            getCanvasContainer() {
                return this._canvasContainer
            }
            getCanvas() {
                return this._canvas
            }
            resize(e) {
                if (this._updateContainerDimensions(),
                this._containerWidth === this.transform.width && this._containerHeight === this.transform.height)
                    return this;
                this._resizeCanvas(this._containerWidth, this._containerHeight),
                this.transform.resize(this._containerWidth, this._containerHeight),
                this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
                const i = !this._moving;
                return i && this.fire(new t.Event("movestart",e)).fire(new t.Event("move",e)),
                this.fire(new t.Event("resize",e)),
                i && this.fire(new t.Event("moveend",e)),
                this
            }
            getBounds() {
                return "globe" === this.transform.projection.name && t.warnOnce('Globe projection does not support getBounds API, this API may behave unexpectedly."'),
                this.transform.getBounds()
            }
            getMaxBounds() {
                return this.transform.getMaxBounds() || null
            }
            setMaxBounds(e) {
                return this.transform.setMaxBounds(t.LngLatBounds.convert(e)),
                this._update()
            }
            setMinZoom(e) {
                if ((e = null == e ? 1 : e) >= 1 && e <= this.transform.maxZoom)
                    return this.transform.minZoom = e,
                    this._update(),
                    this.getZoom() < e ? this.setZoom(e) : this.fire(new t.Event("zoomstart")).fire(new t.Event("zoom")).fire(new t.Event("zoomend")),
                    this;
                throw new Error("minZoom must be between 1 and the current maxZoom, inclusive")
            }
            getMinZoom() {
                return this.transform.minZoom
            }
            setMaxZoom(e) {
                if ((e = null == e ? 22 : e) >= this.transform.minZoom)
                    return this.transform.maxZoom = e,
                    this._update(),
                    this.getZoom() > e ? this.setZoom(e) : this.fire(new t.Event("zoomstart")).fire(new t.Event("zoom")).fire(new t.Event("zoomend")),
                    this;
                throw new Error("maxZoom must be greater than the current minZoom")
            }
            getMaxZoom() {
                return this.transform.maxZoom
            }
            setMinPitch(e) {
                if ((e = null == e ? 0 : e) < 0)
                    throw new Error("minPitch must be greater than or equal to 0");
                if (e >= 0 && e <= this.transform.maxPitch)
                    return this.transform.minPitch = e,
                    this._update(),
                    this.getPitch() < e ? this.setPitch(e) : this.fire(new t.Event("pitchstart")).fire(new t.Event("pitch")).fire(new t.Event("pitchend")),
                    this;
                throw new Error("minPitch must be between 0 and the current maxPitch, inclusive")
            }
            getMinPitch() {
                return this.transform.minPitch
            }
            setMaxPitch(e) {
                if ((e = null == e ? 85 : e) > 85)
                    throw new Error("maxPitch must be less than or equal to 85");
                if (e >= this.transform.minPitch)
                    return this.transform.maxPitch = e,
                    this._update(),
                    this.getPitch() > e ? this.setPitch(e) : this.fire(new t.Event("pitchstart")).fire(new t.Event("pitch")).fire(new t.Event("pitchend")),
                    this;
                throw new Error("maxPitch must be greater than or equal to minPitch")
            }
            getMaxPitch() {
                return this.transform.maxPitch
            }
            getRenderWorldCopies() {
                return this.transform.renderWorldCopies
            }
            setRenderWorldCopies(t) {
                return this.transform.renderWorldCopies = t,
                this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(!0),
                this._update()
            }
            getLanguage() {
                return this._language
            }
            setLanguage(e) {
                if (this._language = "auto" === e ? t.window.navigator.language : e,
                this.style)
                    for (const t in this.style._sourceCaches) {
                        const e = this.style._sourceCaches[t]._source;
                        e._setLanguage && e._setLanguage(this._language);
                    }
                for (const t of this._controls)
                    t._setLanguage && t._setLanguage(this._language);
                return this
            }
            getWorldview() {
                return this._worldview
            }
            setWorldview(t) {
                if (this._worldview = t,
                this.style)
                    for (const e in this.style._sourceCaches) {
                        const i = this.style._sourceCaches[e]._source;
                        i._setWorldview && i._setWorldview(t);
                    }
                return this
            }
            getProjection() {
                return this.transform.mercatorFromTransition ? {
                    name: "globe",
                    center: [0, 0]
                } : this.transform.getProjection()
            }
            _showingGlobe() {
                return "globe" === this.transform.projection.name
            }
            setProjection(t) {
                return this._lazyInitEmptyStyle(),
                t ? "string" == typeof t && (t = {
                    name: t
                }) : t = null,
                this._useExplicitProjection = !!t,
                this._prioritizeAndUpdateProjection(t, this.style.stylesheet ? this.style.stylesheet.projection : null)
            }
            _updateProjectionTransition() {
                if ("globe" !== this.getProjection().name)
                    return;
                const e = this.transform
                  , i = e.projection.name;
                let r;
                "globe" === i && e.zoom >= t.GLOBE_ZOOM_THRESHOLD_MAX ? (e.setMercatorFromTransition(),
                r = !0) : "mercator" === i && e.zoom < t.GLOBE_ZOOM_THRESHOLD_MAX && (e.setProjection({
                    name: "globe"
                }),
                r = !0),
                r && (this.style.applyProjectionUpdate(),
                this.style._forceSymbolLayerUpdate());
            }
            _prioritizeAndUpdateProjection(t, e) {
                return this._updateProjection(t || e || {
                    name: "mercator"
                })
            }
            _updateProjection(e) {
                let i;
                if (i = "globe" === e.name && this.transform.zoom >= t.GLOBE_ZOOM_THRESHOLD_MAX ? this.transform.setMercatorFromTransition() : this.transform.setProjection(e),
                this.style.applyProjectionUpdate(),
                i) {
                    this.painter.clearBackgroundTiles();
                    for (const t in this.style._sourceCaches)
                        this.style._sourceCaches[t].clearTiles();
                    this._update(!0),
                    this._forceMarkerAndPopupUpdate(!0);
                }
                return this
            }
            project(e) {
                return this.transform.locationPoint3D(t.LngLat.convert(e))
            }
            unproject(e) {
                return this.transform.pointLocation3D(t.pointGeometry.convert(e))
            }
            isMoving() {
                return this._moving || this.handlers && this.handlers.isMoving() || !1
            }
            isZooming() {
                return this._zooming || this.handlers && this.handlers.isZooming() || !1
            }
            isRotating() {
                return this._rotating || this.handlers && this.handlers.isRotating() || !1
            }
            _createDelegatedListener(t, e, i) {
                if ("mouseenter" === t || "mouseover" === t) {
                    let r = !1;
                    const o = o => {
                        const n = e.filter((t => this.getLayer(t)))
                          , s = n.length ? this.queryRenderedFeatures(o.point, {
                            layers: n
                        }) : [];
                        s.length ? r || (r = !0,
                        i.call(this, new Hn(t,this,o.originalEvent,{
                            features: s
                        }))) : r = !1;
                    }
                      , n = () => {
                        r = !1;
                    }
                    ;
                    return {
                        layers: new Set(e),
                        listener: i,
                        delegates: {
                            mousemove: o,
                            mouseout: n
                        }
                    }
                }
                if ("mouseleave" === t || "mouseout" === t) {
                    let r = !1;
                    const o = o => {
                        const n = e.filter((t => this.getLayer(t)));
                        (n.length ? this.queryRenderedFeatures(o.point, {
                            layers: n
                        }) : []).length ? r = !0 : r && (r = !1,
                        i.call(this, new Hn(t,this,o.originalEvent)));
                    }
                      , n = e => {
                        r && (r = !1,
                        i.call(this, new Hn(t,this,e.originalEvent)));
                    }
                    ;
                    return {
                        layers: new Set(e),
                        listener: i,
                        delegates: {
                            mousemove: o,
                            mouseout: n
                        }
                    }
                }
                {
                    const r = t => {
                        const r = e.filter((t => this.getLayer(t)))
                          , o = r.length ? this.queryRenderedFeatures(t.point, {
                            layers: r
                        }) : [];
                        o.length && (t.features = o,
                        i.call(this, t),
                        delete t.features);
                    }
                    ;
                    return {
                        layers: new Set(e),
                        listener: i,
                        delegates: {
                            [t]: r
                        }
                    }
                }
            }
            on(t, e, i) {
                if (void 0 === i)
                    return super.on(t, e);
                Array.isArray(e) || (e = [e]);
                const r = this._createDelegatedListener(t, e, i);
                this._delegatedListeners = this._delegatedListeners || {},
                this._delegatedListeners[t] = this._delegatedListeners[t] || [],
                this._delegatedListeners[t].push(r);
                for (const t in r.delegates)
                    this.on(t, r.delegates[t]);
                return this
            }
            once(t, e, i) {
                if (void 0 === i)
                    return super.once(t, e);
                Array.isArray(e) || (e = [e]);
                const r = this._createDelegatedListener(t, e, i);
                for (const t in r.delegates)
                    this.once(t, r.delegates[t]);
                return this
            }
            off(t, e, i) {
                if (void 0 === i)
                    return super.off(t, e);
                e = new Set(Array.isArray(e) ? e : [e]);
                const r = (t, e) => {
                    if (t.size !== e.size)
                        return !1;
                    for (const i of t)
                        if (!e.has(i))
                            return !1;
                    return !0
                }
                  , o = this._delegatedListeners ? this._delegatedListeners[t] : void 0;
                return o && (t => {
                    for (let o = 0; o < t.length; o++) {
                        const n = t[o];
                        if (n.listener === i && r(n.layers, e)) {
                            for (const t in n.delegates)
                                this.off(t, n.delegates[t]);
                            return t.splice(o, 1),
                            this
                        }
                    }
                }
                )(o),
                this
            }
            queryRenderedFeatures(e, i) {
                return this.style ? (void 0 !== i || void 0 === e || e instanceof t.pointGeometry || Array.isArray(e) || (i = e,
                e = void 0),
                this.style.queryRenderedFeatures(e = e || [[0, 0], [this.transform.width, this.transform.height]], i = i || {}, this.transform)) : []
            }
            querySourceFeatures(t, e) {
                return this.style.querySourceFeatures(t, e)
            }
            queryTerrainElevation(e, i) {
                const r = this.transform.elevation;
                return r ? (i = t.extend({}, {
                    exaggerated: !0
                }, i),
                r.getAtPoint(t.MercatorCoordinate.fromLngLat(e), null, i.exaggerated)) : null
            }
            setStyle(e, i) {
                return !1 !== (i = t.extend({}, {
                    localIdeographFontFamily: this._localIdeographFontFamily,
                    localFontFamily: this._localFontFamily
                }, i)).diff && i.localIdeographFontFamily === this._localIdeographFontFamily && i.localFontFamily === this._localFontFamily && this.style && e ? (this._diffStyle(e, i),
                this) : (this._localIdeographFontFamily = i.localIdeographFontFamily,
                this._localFontFamily = i.localFontFamily,
                this._updateStyle(e, i))
            }
            _getUIString(t) {
                const e = this._locale[t];
                if (null == e)
                    throw new Error(`Missing UI string '${t}'`);
                return e
            }
            _updateStyle(t, e) {
                return this.style && (this.style.setEventedParent(null),
                this.style._remove(),
                this.style = void 0),
                t && (this.style = new Ir(this,e || {}),
                this.style.setEventedParent(this, {
                    style: this.style
                }),
                "string" == typeof t ? this.style.loadURL(t) : this.style.loadJSON(t)),
                this._updateTerrain(),
                this
            }
            _lazyInitEmptyStyle() {
                this.style || (this.style = new Ir(this,{}),
                this.style.setEventedParent(this, {
                    style: this.style
                }),
                this.style.loadEmpty());
            }
            _diffStyle(e, i) {
                if ("string" == typeof e) {
                    const r = this._requestManager.normalizeStyleURL(e)
                      , o = this._requestManager.transformRequest(r, t.ResourceType.Style);
                    t.getJSON(o, ( (e, r) => {
                        e ? this.fire(new t.ErrorEvent(e)) : r && this._updateDiff(r, i);
                    }
                    ));
                } else
                    "object" == typeof e && this._updateDiff(e, i);
            }
            _updateDiff(e, i) {
                try {
                    this.style.setState(e) && this._update(!0);
                } catch (r) {
                    t.warnOnce(`Unable to perform style diff: ${r.message || r.error || r}.  Rebuilding the style from scratch.`),
                    this._updateStyle(e, i);
                }
            }
            getStyle() {
                if (this.style)
                    return this.style.serialize()
            }
            isStyleLoaded() {
                return this.style ? this.style.loaded() : (t.warnOnce("There is no style added to the map."),
                !1)
            }
            addSource(t, e) {
                return this._lazyInitEmptyStyle(),
                this.style.addSource(t, e),
                this._update(!0)
            }
            isSourceLoaded(t) {
                return !!this.style && this.style._isSourceCacheLoaded(t)
            }
            areTilesLoaded() {
                const t = this.style && this.style._sourceCaches;
                for (const e in t) {
                    const i = t[e]._tiles;
                    for (const t in i) {
                        const e = i[t];
                        if ("loaded" !== e.state && "errored" !== e.state)
                            return !1
                    }
                }
                return !0
            }
            addSourceType(t, e, i) {
                this._lazyInitEmptyStyle(),
                this.style.addSourceType(t, e, i);
            }
            removeSource(t) {
                return this.style.removeSource(t),
                this._updateTerrain(),
                this._update(!0)
            }
            getSource(t) {
                return this.style.getSource(t)
            }
            addImage(e, i, {pixelRatio: r=1, sdf: o=!1, stretchX: n, stretchY: s, content: a}={}) {
                if (this._lazyInitEmptyStyle(),
                i instanceof t.window.HTMLImageElement || t.window.ImageBitmap && i instanceof t.window.ImageBitmap) {
                    const {width: l, height: c, data: h} = t.exported.getImageData(i);
                    this.style.addImage(e, {
                        data: new t.RGBAImage({
                            width: l,
                            height: c
                        },h),
                        pixelRatio: r,
                        stretchX: n,
                        stretchY: s,
                        content: a,
                        sdf: o,
                        version: 0
                    });
                } else if (void 0 === i.width || void 0 === i.height)
                    this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                else {
                    const {width: l, height: c} = i
                      , h = i;
                    this.style.addImage(e, {
                        data: new t.RGBAImage({
                            width: l,
                            height: c
                        },new Uint8Array(h.data)),
                        pixelRatio: r,
                        stretchX: n,
                        stretchY: s,
                        content: a,
                        sdf: o,
                        version: 0,
                        userImage: h
                    }),
                    h.onAdd && h.onAdd(this, e);
                }
            }
            updateImage(e, i) {
                const r = this.style.getImage(e);
                if (!r)
                    return void this.fire(new t.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
                const o = i instanceof t.window.HTMLImageElement || t.window.ImageBitmap && i instanceof t.window.ImageBitmap ? t.exported.getImageData(i) : i
                  , {width: n, height: s} = o;
                void 0 !== n && void 0 !== s ? n === r.data.width && s === r.data.height ? (r.data.replace(o.data, !(i instanceof t.window.HTMLImageElement || t.window.ImageBitmap && i instanceof t.window.ImageBitmap)),
                this.style.updateImage(e, r)) : this.fire(new t.ErrorEvent(new Error(`The width and height of the updated image (${n}, ${s})\n                must be that same as the previous version of the image\n                (${r.data.width}, ${r.data.height})`))) : this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            }
            hasImage(e) {
                return e ? !!this.style.getImage(e) : (this.fire(new t.ErrorEvent(new Error("Missing required image id"))),
                !1)
            }
            removeImage(t) {
                this.style.removeImage(t);
            }
            loadImage(e, i) {
                t.getImage(this._requestManager.transformRequest(e, t.ResourceType.Image), ( (e, r) => {
                    i(e, r instanceof t.window.HTMLImageElement ? t.exported.getImageData(r) : r);
                }
                ));
            }
            listImages() {
                return this.style.listImages()
            }
            addLayer(t, e) {
                return this._lazyInitEmptyStyle(),
                this.style.addLayer(t, e),
                this._update(!0)
            }
            moveLayer(t, e) {
                return this.style.moveLayer(t, e),
                this._update(!0)
            }
            removeLayer(t) {
                return this.style.removeLayer(t),
                this._update(!0)
            }
            getLayer(t) {
                return this.style.getLayer(t)
            }
            setLayerZoomRange(t, e, i) {
                return this.style.setLayerZoomRange(t, e, i),
                this._update(!0)
            }
            setFilter(t, e, i={}) {
                return this.style.setFilter(t, e, i),
                this._update(!0)
            }
            getFilter(t) {
                return this.style.getFilter(t)
            }
            setPaintProperty(t, e, i, r={}) {
                return this.style.setPaintProperty(t, e, i, r),
                this._update(!0)
            }
            getPaintProperty(t, e) {
                return this.style.getPaintProperty(t, e)
            }
            setLayoutProperty(t, e, i, r={}) {
                return this.style.setLayoutProperty(t, e, i, r),
                this._update(!0)
            }
            getLayoutProperty(t, e) {
                return this.style.getLayoutProperty(t, e)
            }
            setLight(t, e={}) {
                return this._lazyInitEmptyStyle(),
                this.style.setLight(t, e),
                this._update(!0)
            }
            getLight() {
                return this.style.getLight()
            }
            setTerrain(t) {
                return this._lazyInitEmptyStyle(),
                !t && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(t),
                this._averageElevationLastSampledAt = -1 / 0,
                this._update(!0)
            }
            getTerrain() {
                return this.style ? this.style.getTerrain() : null
            }
            setFog(t) {
                return this._lazyInitEmptyStyle(),
                this.style.setFog(t),
                this._update(!0)
            }
            getFog() {
                return this.style ? this.style.getFog() : null
            }
            _queryFogOpacity(e) {
                return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(t.LngLat.convert(e), this.transform) : 0
            }
            setFeatureState(t, e) {
                return this.style.setFeatureState(t, e),
                this._update()
            }
            removeFeatureState(t, e) {
                return this.style.removeFeatureState(t, e),
                this._update()
            }
            getFeatureState(t) {
                return this.style.getFeatureState(t)
            }
            _updateContainerDimensions() {
                if (!this._container)
                    return;
                const e = this._container.getBoundingClientRect().width || 400
                  , i = this._container.getBoundingClientRect().height || 300;
                let r, o, n, s = this._container;
                for (; s && (!o || !n); ) {
                    const e = t.window.getComputedStyle(s).transform;
                    e && "none" !== e && (r = e.match(/matrix.*\((.+)\)/)[1].split(", "),
                    r[0] && "0" !== r[0] && "1" !== r[0] && (o = r[0]),
                    r[3] && "0" !== r[3] && "1" !== r[3] && (n = r[3])),
                    s = s.parentElement;
                }
                this._containerWidth = o ? Math.abs(e / o) : e,
                this._containerHeight = n ? Math.abs(i / n) : i;
            }
            _detectMissingCSS() {
                "rgb(250, 128, 114)" !== t.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && t.warnOnce("请引入sgmap的css文件");
            }
            _setupContainer() {
                const t = this._container;
                t.classList.add("sgmap-map"),
                (this._missingCSSCanary = _("div", "sgmap-canary", t)).style.visibility = "hidden",
                this._detectMissingCSS();
                const e = this._canvasContainer = _("div", "sgmap-canvas-container", t);
                this._interactive && e.classList.add("sgmap-interactive"),
                this._canvas = _("canvas", "sgmap-canvas", e),
                this._canvas.addEventListener("webglcontextlost", this._contextLost, !1),
                this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1),
                this._canvas.setAttribute("tabindex", "0"),
                this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")),
                this._canvas.setAttribute("role", "region"),
                this._updateContainerDimensions(),
                this._resizeCanvas(this._containerWidth, this._containerHeight);
                const i = this._controlContainer = _("div", "sgmap-control-container", t)
                  , r = this._controlPositions = {};
                ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((t => {
                    r[t] = _("div", `sgmap-ctrl-${t}`, i);
                }
                )),
                this._container.addEventListener("scroll", this._onMapScroll, !1);
            }
            _resizeCanvas(e, i) {
                const r = t.exported.devicePixelRatio || 1;
                this._canvas.width = r * Math.ceil(e),
                this._canvas.height = r * Math.ceil(i),
                this._canvas.style.width = `${e}px`,
                this._canvas.style.height = `${i}px`;
            }
            _addMarker(t) {
                this._markers.push(t);
            }
            _removeMarker(t) {
                const e = this._markers.indexOf(t);
                -1 !== e && this._markers.splice(e, 1);
            }
            _addPopup(t) {
                this._popups.push(t);
            }
            _removePopup(t) {
                const e = this._popups.indexOf(t);
                -1 !== e && this._popups.splice(e, 1);
            }
            _setupPainter() {
                const e = t.extend({}, h.webGLContextAttributes, {
                    failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
                    preserveDrawingBuffer: this._preserveDrawingBuffer,
                    antialias: this._antialias || !1
                })
                  , i = this._canvas.getContext("webgl", e) || this._canvas.getContext("experimental-webgl", e);
                i ? (this.painter = new wn(i,this.transform),
                this.on("data", (t => {
                    "source" === t.dataType && this.painter.setTileLoadedFlag(!0);
                }
                )),
                t.exported$1.testSupport(i)) : this.fire(new t.ErrorEvent(new Error("Failed to initialize WebGL")));
            }
            _contextLost(e) {
                e.preventDefault(),
                this._frame && (this._frame.cancel(),
                this._frame = null),
                this.fire(new t.Event("webglcontextlost",{
                    originalEvent: e
                }));
            }
            _contextRestored(e) {
                this._setupPainter(),
                this.resize(),
                this._update(),
                this.fire(new t.Event("webglcontextrestored",{
                    originalEvent: e
                }));
            }
            _onMapScroll(t) {
                if (t.target === this._container)
                    return this._container.scrollTop = 0,
                    this._container.scrollLeft = 0,
                    !1
            }
            loaded() {
                return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded()
            }
            _update(t) {
                return this.style ? (this._styleDirty = this._styleDirty || t,
                this._sourcesDirty = !0,
                this.triggerRepaint(),
                this) : this
            }
            _requestRenderFrame(t) {
                return this._update(),
                this._renderTaskQueue.add(t)
            }
            _cancelRenderFrame(t) {
                this._renderTaskQueue.remove(t);
            }
            _requestDomTask(t) {
                !this.loaded() || this.loaded() && !this.isMoving() ? t() : this._domRenderTaskQueue.add(t);
            }
            _render(e) {
                let i;
                const r = this.painter.context.extTimerQuery
                  , o = t.exported.now();
                if (this.listens("gpu-timing-frame") && (i = r.createQueryEXT(),
                r.beginQueryEXT(r.TIME_ELAPSED_EXT, i)),
                this.painter.context.setDirty(),
                this.painter.setBaseState(),
                this._renderTaskQueue.run(e),
                this._domRenderTaskQueue.run(e),
                this._removed)
                    return;
                this._updateProjectionTransition();
                let n = !1;
                const s = this._isInitialLoad ? 0 : this._fadeDuration;
                if (this.style && this._styleDirty) {
                    this._styleDirty = !1;
                    const e = this.transform.zoom
                      , i = this.transform.pitch
                      , r = t.exported.now();
                    this.style.zoomHistory.update(e, r);
                    const o = new t.EvaluationParameters(e,{
                        now: r,
                        fadeDuration: s,
                        pitch: i,
                        zoomHistory: this.style.zoomHistory,
                        transition: this.style.getTransition()
                    })
                      , a = o.crossFadingFactor();
                    1 === a && a === this._crossFadingFactor || (n = !0,
                    this._crossFadingFactor = a),
                    this.style.update(o);
                }
                this.style && this.style.fog && this.style.fog.hasTransition() && (this.style._markersNeedUpdate = !0,
                this._sourcesDirty = !0);
                let a = !1;
                if (this.style && this._sourcesDirty ? (this._sourcesDirty = !1,
                this.painter._updateFog(this.style),
                this._updateTerrain(),
                a = this._updateAverageElevation(o),
                this.style._updateSources(this.transform),
                this._forceMarkerAndPopupUpdate()) : a = this._updateAverageElevation(o),
                this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, s, this._crossSourceCollisions),
                this.style && this.painter.render(this.style, {
                    showTileBoundaries: this.showTileBoundaries,
                    showTerrainWireframe: this.showTerrainWireframe,
                    showOverdrawInspector: this._showOverdrawInspector,
                    showQueryGeometry: !!this._showQueryGeometry,
                    rotating: this.isRotating(),
                    zooming: this.isZooming(),
                    moving: this.isMoving(),
                    fadeDuration: s,
                    isInitialLoad: this._isInitialLoad,
                    showPadding: this.showPadding,
                    gpuTiming: !!this.listens("gpu-timing-layer"),
                    gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"),
                    speedIndexTiming: this.speedIndexTiming
                }),
                this.fire(new t.Event("render")),
                this.loaded() && !this._loaded && (this._loaded = !0,
                this.fire(new t.Event("load"))),
                this.style && (this.style.hasTransitions() || n) && (this._styleDirty = !0),
                this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(),
                i) {
                    const e = t.exported.now() - o;
                    r.endQueryEXT(r.TIME_ELAPSED_EXT, i),
                    setTimeout(( () => {
                        const n = r.getQueryObjectEXT(i, r.QUERY_RESULT_EXT) / 1e6;
                        r.deleteQueryEXT(i),
                        this.fire(new t.Event("gpu-timing-frame",{
                            cpuTime: e,
                            gpuTime: n
                        })),
                        t.window.performance.mark("frame-gpu", {
                            startTime: o,
                            detail: {
                                gpuTime: n
                            }
                        });
                    }
                    ), 50);
                }
                if (this.listens("gpu-timing-layer")) {
                    const e = this.painter.collectGpuTimers();
                    setTimeout(( () => {
                        const i = this.painter.queryGpuTimers(e);
                        this.fire(new t.Event("gpu-timing-layer",{
                            layerTimes: i
                        }));
                    }
                    ), 50);
                }
                if (this.listens("gpu-timing-deferred-render")) {
                    const e = this.painter.collectDeferredRenderGpuQueries();
                    setTimeout(( () => {
                        const i = this.painter.queryGpuTimeDeferredRender(e);
                        this.fire(new t.Event("gpu-timing-deferred-render",{
                            gpuTime: i
                        }));
                    }
                    ), 50);
                }
                const l = this._sourcesDirty || this._styleDirty || this._placementDirty || a;
                if (l || this._repaint)
                    this.triggerRepaint();
                else {
                    const e = !this.isMoving() && this.loaded();
                    if (e && (a = this._updateAverageElevation(o, !0)),
                    a)
                        this.triggerRepaint();
                    else if (this._triggerFrame(!1),
                    e && (this.fire(new t.Event("idle")),
                    this._isInitialLoad = !1,
                    this.speedIndexTiming)) {
                        const e = this._calculateSpeedIndex();
                        this.fire(new t.Event("speedindexcompleted",{
                            speedIndex: e
                        })),
                        this.speedIndexTiming = !1;
                    }
                }
                !this._loaded || this._fullyLoaded || l || (this._fullyLoaded = !0);
            }
            _forceMarkerAndPopupUpdate(t) {
                for (const e of this._markers)
                    t && !this.getRenderWorldCopies() && (e._lngLat = e._lngLat.wrap()),
                    e._update();
                for (const e of this._popups)
                    !t || this.getRenderWorldCopies() || e._trackPointer || (e._lngLat = e._lngLat.wrap()),
                    e._update();
            }
            _updateAverageElevation(t, e=!1) {
                const i = t => (this.transform.averageElevation = t,
                this._update(!1),
                !0);
                if (!this.painter.averageElevationNeedsEasing())
                    return 0 !== this.transform.averageElevation && i(0);
                if ((e || t - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(t)) {
                    const e = this.transform.averageElevation;
                    let r = this.transform.sampleAverageElevation()
                      , o = !1;
                    this.transform.elevation && (o = this.transform.elevation.exaggeration() !== this._averageElevationExaggeration,
                    this._averageElevationExaggeration = this.transform.elevation.exaggeration()),
                    isNaN(r) ? r = 0 : this._averageElevationLastSampledAt = t;
                    const n = Math.abs(e - r);
                    if (n > 1) {
                        if (this._isInitialLoad || o)
                            return this._averageElevation.jumpTo(r),
                            i(r);
                        this._averageElevation.easeTo(r, t, 300);
                    } else if (n > 1e-4)
                        return this._averageElevation.jumpTo(r),
                        i(r)
                }
                return !!this._averageElevation.isEasing(t) && i(this._averageElevation.getValue(t))
            }
            _updateTerrain() {
                this.painter.updateTerrain(this.style, this.isMoving() || this.isRotating() || this.isZooming());
            }
            _calculateSpeedIndex() {
                const t = this.painter.canvasCopy()
                  , e = this.painter.getCanvasCopiesAndTimestamps();
                e.timeStamps.push(performance.now());
                const i = this.painter.context.gl
                  , r = i.createFramebuffer();
                function o(t) {
                    i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, t, 0);
                    const e = new Uint8Array(i.drawingBufferWidth * i.drawingBufferHeight * 4);
                    return i.readPixels(0, 0, i.drawingBufferWidth, i.drawingBufferHeight, i.RGBA, i.UNSIGNED_BYTE, e),
                    e
                }
                return i.bindFramebuffer(i.FRAMEBUFFER, r),
                this._canvasPixelComparison(o(t), e.canvasCopies.map(o), e.timeStamps)
            }
            _canvasPixelComparison(t, e, i) {
                let r = i[1] - i[0];
                const o = t.length / 4;
                for (let n = 0; n < e.length; n++) {
                    const s = e[n];
                    let a = 0;
                    for (let e = 0; e < s.length; e += 4)
                        s[e] === t[e] && s[e + 1] === t[e + 1] && s[e + 2] === t[e + 2] && s[e + 3] === t[e + 3] && (a += 1);
                    r += (i[n + 2] - i[n + 1]) * (1 - a / o);
                }
                return r
            }
            remove() {
                this._hash && this._hash.remove();
                for (const t of this._controls)
                    t.onRemove(this);
                this._controls = [],
                this._frame && (this._frame.cancel(),
                this._frame = null),
                this._renderTaskQueue.clear(),
                this._domRenderTaskQueue.clear(),
                this.style && this.style.destroy(),
                this.painter.destroy(),
                this.handlers && this.handlers.destroy(),
                this.handlers = void 0,
                this.setStyle(null),
                void 0 !== t.window && (t.window.removeEventListener("resize", this._onWindowResize, !1),
                t.window.removeEventListener("orientationchange", this._onWindowResize, !1),
                t.window.removeEventListener("webkitfullscreenchange", this._onWindowResize, !1),
                t.window.removeEventListener("online", this._onWindowOnline, !1),
                t.window.removeEventListener("visibilitychange", this._onVisibilityChange, !1));
                const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
                e && e.loseContext(),
                this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1),
                this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1),
                this._canvasContainer.remove(),
                this._controlContainer.remove(),
                this._missingCSSCanary.remove(),
                this._canvas = void 0,
                this._canvasContainer = void 0,
                this._controlContainer = void 0,
                this._missingCSSCanary = void 0,
                this._container.classList.remove("sgmap-map"),
                this._container.removeEventListener("scroll", this._onMapScroll, !1),
                this._removed = !0,
                this.fire(new t.Event("remove"));
            }
            triggerRepaint() {
                this._triggerFrame(!0);
            }
            _triggerFrame(e) {
                this._renderNextFrame = this._renderNextFrame || e,
                this.style && !this._frame && (this._frame = t.exported.frame((t => {
                    const e = !!this._renderNextFrame;
                    this._frame = null,
                    this._renderNextFrame = null,
                    e && this._render(t);
                }
                )));
            }
            _preloadTiles(e) {
                const i = this.style ? Object.values(this.style._sourceCaches) : [];
                return t.asyncAll(i, ( (t, i) => t._preloadTiles(e, i)), ( () => {
                    this.triggerRepaint();
                }
                )),
                this
            }
            _onWindowOnline() {
                this._update();
            }
            _onWindowResize(t) {
                this._trackResize && this.resize({
                    originalEvent: t
                })._update();
            }
            get showTileBoundaries() {
                return !!this._showTileBoundaries
            }
            set showTileBoundaries(t) {
                this._showTileBoundaries !== t && (this._showTileBoundaries = t,
                this._update());
            }
            get showTerrainWireframe() {
                return !!this._showTerrainWireframe
            }
            set showTerrainWireframe(t) {
                this._showTerrainWireframe !== t && (this._showTerrainWireframe = t,
                this._update());
            }
            get speedIndexTiming() {
                return !!this._speedIndexTiming
            }
            set speedIndexTiming(t) {
                this._speedIndexTiming !== t && (this._speedIndexTiming = t,
                this._update());
            }
            get showPadding() {
                return !!this._showPadding
            }
            set showPadding(t) {
                this._showPadding !== t && (this._showPadding = t,
                this._update());
            }
            get showCollisionBoxes() {
                return !!this._showCollisionBoxes
            }
            set showCollisionBoxes(t) {
                this._showCollisionBoxes !== t && (this._showCollisionBoxes = t,
                t ? this.style._generateCollisionBoxes() : this._update());
            }
            get showOverdrawInspector() {
                return !!this._showOverdrawInspector
            }
            set showOverdrawInspector(t) {
                this._showOverdrawInspector !== t && (this._showOverdrawInspector = t,
                this._update());
            }
            get repaint() {
                return !!this._repaint
            }
            set repaint(t) {
                this._repaint !== t && (this._repaint = t,
                this.triggerRepaint());
            }
            get vertices() {
                return !!this._vertices
            }
            set vertices(t) {
                this._vertices = t,
                this._update();
            }
            _setCacheLimits(e, i) {
                t.setCacheLimits(e, i);
            }
            get version() {
                return f
            }
        }
        let Ks = [];
        const Js = {
            showCompass: !0,
            showZoom: !0,
            visualizePitch: !1
        };
        class $s {
            constructor(e, i, r=!1) {
                this._clickTolerance = 10,
                this.element = i,
                this.mouseRotate = new ss({
                    clickTolerance: e.dragRotate._mouseRotate._clickTolerance
                }),
                this.map = e,
                r && (this.mousePitch = new as({
                    clickTolerance: e.dragRotate._mousePitch._clickTolerance
                })),
                t.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this),
                i.addEventListener("mousedown", this.mousedown),
                i.addEventListener("touchstart", this.touchstart, {
                    passive: !1
                }),
                i.addEventListener("touchmove", this.touchmove),
                i.addEventListener("touchend", this.touchend),
                i.addEventListener("touchcancel", this.reset);
            }
            down(t, e) {
                this.mouseRotate.mousedown(t, e),
                this.mousePitch && this.mousePitch.mousedown(t, e),
                y();
            }
            move(t, e) {
                const i = this.map
                  , r = this.mouseRotate.mousemoveWindow(t, e)
                  , o = r && r.bearingDelta;
                if (o && i.setBearing(i.getBearing() + o),
                this.mousePitch) {
                    const r = this.mousePitch.mousemoveWindow(t, e)
                      , o = r && r.pitchDelta;
                    o && i.setPitch(i.getPitch() + o);
                }
            }
            off() {
                const t = this.element;
                t.removeEventListener("mousedown", this.mousedown),
                t.removeEventListener("touchstart", this.touchstart, {
                    passive: !1
                }),
                t.removeEventListener("touchmove", this.touchmove),
                t.removeEventListener("touchend", this.touchend),
                t.removeEventListener("touchcancel", this.reset),
                this.offTemp();
            }
            offTemp() {
                b(),
                t.window.removeEventListener("mousemove", this.mousemove),
                t.window.removeEventListener("mouseup", this.mouseup);
            }
            mousedown(e) {
                this.down(t.extend({}, e, {
                    ctrlKey: !0,
                    preventDefault: () => e.preventDefault()
                }), T(this.element, e)),
                t.window.addEventListener("mousemove", this.mousemove),
                t.window.addEventListener("mouseup", this.mouseup);
            }
            mousemove(t) {
                this.move(t, T(this.element, t));
            }
            mouseup(t) {
                this.mouseRotate.mouseupWindow(t),
                this.mousePitch && this.mousePitch.mouseupWindow(t),
                this.offTemp();
            }
            touchstart(t) {
                1 !== t.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = E(this.element, t.targetTouches)[0],
                this.down({
                    type: "mousedown",
                    button: 0,
                    ctrlKey: !0,
                    preventDefault: () => t.preventDefault()
                }, this._startPos));
            }
            touchmove(t) {
                1 !== t.targetTouches.length ? this.reset() : (this._lastPos = E(this.element, t.targetTouches)[0],
                this.move({
                    preventDefault: () => t.preventDefault()
                }, this._lastPos));
            }
            touchend(t) {
                0 === t.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(),
                this.reset();
            }
            reset() {
                this.mouseRotate.reset(),
                this.mousePitch && this.mousePitch.reset(),
                delete this._startPos,
                delete this._lastPos,
                this.offTemp();
            }
        }
        const Qs = {
            positionOptions: {
                enableHighAccuracy: !1,
                maximumAge: 0,
                timeout: 6e3
            },
            fitBoundsOptions: {
                maxZoom: 15
            },
            trackUserLocation: !1,
            showAccuracyCircle: !0,
            showUserLocation: !0,
            showUserHeading: !1
        };
        class ta extends t.Evented {
            constructor(e) {
                super(),
                this.options = t.extend({
                    geolocation: t.window.navigator.geolocation
                }, Qs, e),
                t.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this),
                this._updateMarkerRotationThrottled = kn(this._updateMarkerRotation, 20),
                this._numberOfWatches = 0;
            }
            onAdd(t) {
                return this._map = t,
                this._container = _("div", "sgmap-ctrl sgmap-ctrl-group"),
                this._checkGeolocationSupport(this._setupUI),
                this._container
            }
            onRemove() {
                void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID),
                this._geolocationWatchID = void 0),
                this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(),
                this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(),
                this._container.remove(),
                this._map.off("zoom", this._onZoom),
                this._map = void 0,
                this._numberOfWatches = 0,
                this._noTimeout = !1;
            }
            _checkGeolocationSupport(e) {
                void 0 !== this._supportsGeolocation ? e(this._supportsGeolocation) : void 0 !== t.window.navigator.permissions ? t.window.navigator.permissions.query({
                    name: "geolocation"
                }).then((t => {
                    this._supportsGeolocation = "denied" !== t.state,
                    e(this._supportsGeolocation);
                }
                )) : (this._supportsGeolocation = !!this.options.geolocation,
                e(this._supportsGeolocation));
            }
            _isOutOfMapMaxBounds(t) {
                const e = this._map.getMaxBounds()
                  , i = t.coords;
                return !!e && (i.longitude < e.getWest() || i.longitude > e.getEast() || i.latitude < e.getSouth() || i.latitude > e.getNorth())
            }
            _setErrorState() {
                switch (this._watchState) {
                case "WAITING_ACTIVE":
                    this._watchState = "ACTIVE_ERROR",
                    this._geolocateButton.classList.remove("sgmap-ctrl-geolocate-active"),
                    this._geolocateButton.classList.add("sgmap-ctrl-geolocate-active-error");
                    break;
                case "ACTIVE_LOCK":
                    this._watchState = "ACTIVE_ERROR",
                    this._geolocateButton.classList.remove("sgmap-ctrl-geolocate-active"),
                    this._geolocateButton.classList.add("sgmap-ctrl-geolocate-active-error"),
                    this._geolocateButton.classList.add("sgmap-ctrl-geolocate-waiting");
                    break;
                case "BACKGROUND":
                    this._watchState = "BACKGROUND_ERROR",
                    this._geolocateButton.classList.remove("sgmap-ctrl-geolocate-background"),
                    this._geolocateButton.classList.add("sgmap-ctrl-geolocate-background-error"),
                    this._geolocateButton.classList.add("sgmap-ctrl-geolocate-waiting");
                }
            }
            _onSuccess(e) {
                if (this._map) {
                    if (this._isOutOfMapMaxBounds(e))
                        return this._setErrorState(),
                        this.fire(new t.Event("outofmaxbounds",e)),
                        this._updateMarker(),
                        void this._finish();
                    if (this.options.trackUserLocation)
                        switch (this._lastKnownPosition = e,
                        this._watchState) {
                        case "WAITING_ACTIVE":
                        case "ACTIVE_LOCK":
                        case "ACTIVE_ERROR":
                            this._watchState = "ACTIVE_LOCK",
                            this._geolocateButton.classList.remove("sgmap-ctrl-geolocate-waiting"),
                            this._geolocateButton.classList.remove("sgmap-ctrl-geolocate-active-error"),
                            this._geolocateButton.classList.add("sgmap-ctrl-geolocate-active");
                            break;
                        case "BACKGROUND":
                        case "BACKGROUND_ERROR":
                            this._watchState = "BACKGROUND",
                            this._geolocateButton.classList.remove("sgmap-ctrl-geolocate-waiting"),
                            this._geolocateButton.classList.remove("sgmap-ctrl-geolocate-background-error"),
                            this._geolocateButton.classList.add("sgmap-ctrl-geolocate-background");
                        }
                    this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e),
                    this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e),
                    this.options.showUserLocation && this._dotElement.classList.remove("sgmap-user-location-dot-stale"),
                    this.fire(new t.Event("geolocate",e)),
                    this._finish();
                }
            }
            _updateCamera(e) {
                const i = new t.LngLat(e.coords.longitude,e.coords.latitude)
                  , r = e.coords.accuracy
                  , o = this._map.getBearing()
                  , n = t.extend({
                    bearing: o
                }, this.options.fitBoundsOptions);
                this._map.fitBounds(i.toBounds(r), n, {
                    geolocateSource: !0
                });
            }
            _updateMarker(e) {
                if (e) {
                    const i = new t.LngLat(e.coords.longitude,e.coords.latitude);
                    this._accuracyCircleMarker.setLngLat(i).addTo(this._map),
                    this._userLocationDotMarker.setLngLat(i).addTo(this._map),
                    this._accuracy = e.coords.accuracy,
                    this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
                } else
                    this._userLocationDotMarker.remove(),
                    this._accuracyCircleMarker.remove();
            }
            _updateCircleRadius() {
                const e = this._map.transform
                  , i = t.mercatorZfromAltitude(1, e._center.lat) * e.worldSize
                  , r = Math.ceil(2 * this._accuracy * i);
                this._circleElement.style.width = `${r}px`,
                this._circleElement.style.height = `${r}px`;
            }
            _onZoom() {
                this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            }
            _updateMarkerRotation() {
                this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading),
                this._dotElement.classList.add("sgmap-user-location-show-heading")) : (this._dotElement.classList.remove("sgmap-user-location-show-heading"),
                this._userLocationDotMarker.setRotation(0));
            }
            _onError(e) {
                if (this._map) {
                    if (this.options.trackUserLocation)
                        if (1 === e.code) {
                            this._watchState = "OFF",
                            this._geolocateButton.classList.remove("sgmap-ctrl-geolocate-waiting"),
                            this._geolocateButton.classList.remove("sgmap-ctrl-geolocate-active"),
                            this._geolocateButton.classList.remove("sgmap-ctrl-geolocate-active-error"),
                            this._geolocateButton.classList.remove("sgmap-ctrl-geolocate-background"),
                            this._geolocateButton.classList.remove("sgmap-ctrl-geolocate-background-error"),
                            this._geolocateButton.disabled = !0;
                            const t = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                            this._geolocateButton.setAttribute("aria-label", t),
                            this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t),
                            void 0 !== this._geolocationWatchID && this._clearWatch();
                        } else {
                            if (3 === e.code && this._noTimeout)
                                return;
                            this._setErrorState();
                        }
                    "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("sgmap-user-location-dot-stale"),
                    this.fire(new t.Event("error",e)),
                    this._finish();
                }
            }
            _finish() {
                this._timeoutId && clearTimeout(this._timeoutId),
                this._timeoutId = void 0;
            }
            _setupUI(e) {
                if (this._container.addEventListener("contextmenu", (t => t.preventDefault())),
                this._geolocateButton = _("button", "sgmap-ctrl-geolocate", this._container),
                _("span", "sgmap-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"),
                this._geolocateButton.type = "button",
                !1 === e) {
                    t.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
                    const e = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                    this._geolocateButton.disabled = !0,
                    this._geolocateButton.setAttribute("aria-label", e),
                    this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e);
                } else {
                    const t = this._map._getUIString("GeolocateControl.FindMyLocation");
                    this._geolocateButton.setAttribute("aria-label", t),
                    this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t);
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"),
                this._watchState = "OFF"),
                this.options.showUserLocation && (this._dotElement = _("div", "sgmap-user-location"),
                this._dotElement.appendChild(_("div", "sgmap-user-location-dot")),
                this._dotElement.appendChild(_("div", "sgmap-user-location-heading")),
                this._userLocationDotMarker = new Gs({
                    element: this._dotElement,
                    rotationAlignment: "map",
                    pitchAlignment: "map"
                }),
                this._circleElement = _("div", "sgmap-user-location-accuracy-circle"),
                this._accuracyCircleMarker = new Gs({
                    element: this._circleElement,
                    pitchAlignment: "map"
                }),
                this.options.trackUserLocation && (this._watchState = "OFF"),
                this._map.on("zoom", this._onZoom)),
                this._geolocateButton.addEventListener("click", this.trigger.bind(this)),
                this._setup = !0,
                this.options.trackUserLocation && this._map.on("movestart", (e => {
                    e.geolocateSource || "ACTIVE_LOCK" !== this._watchState || e.originalEvent && "resize" === e.originalEvent.type || (this._watchState = "BACKGROUND",
                    this._geolocateButton.classList.add("sgmap-ctrl-geolocate-background"),
                    this._geolocateButton.classList.remove("sgmap-ctrl-geolocate-active"),
                    this.fire(new t.Event("trackuserlocationend")));
                }
                ));
            }
            _onDeviceOrientation(t) {
                this._userLocationDotMarker && (t.webkitCompassHeading ? this._heading = t.webkitCompassHeading : !0 === t.absolute && (this._heading = -1 * t.alpha),
                this._updateMarkerRotationThrottled());
            }
            trigger() {
                if (!this._setup)
                    return t.warnOnce("Geolocate control triggered before added to a map"),
                    !1;
                if (this.options.trackUserLocation) {
                    switch (this._watchState) {
                    case "OFF":
                        this._watchState = "WAITING_ACTIVE",
                        this.fire(new t.Event("trackuserlocationstart"));
                        break;
                    case "WAITING_ACTIVE":
                    case "ACTIVE_LOCK":
                    case "ACTIVE_ERROR":
                    case "BACKGROUND_ERROR":
                        this._numberOfWatches--,
                        this._noTimeout = !1,
                        this._watchState = "OFF",
                        this._geolocateButton.classList.remove("sgmap-ctrl-geolocate-waiting"),
                        this._geolocateButton.classList.remove("sgmap-ctrl-geolocate-active"),
                        this._geolocateButton.classList.remove("sgmap-ctrl-geolocate-active-error"),
                        this._geolocateButton.classList.remove("sgmap-ctrl-geolocate-background"),
                        this._geolocateButton.classList.remove("sgmap-ctrl-geolocate-background-error"),
                        this.fire(new t.Event("trackuserlocationend"));
                        break;
                    case "BACKGROUND":
                        this._watchState = "ACTIVE_LOCK",
                        this._geolocateButton.classList.remove("sgmap-ctrl-geolocate-background"),
                        this._lastKnownPosition && this._updateCamera(this._lastKnownPosition),
                        this.fire(new t.Event("trackuserlocationstart"));
                    }
                    switch (this._watchState) {
                    case "WAITING_ACTIVE":
                        this._geolocateButton.classList.add("sgmap-ctrl-geolocate-waiting"),
                        this._geolocateButton.classList.add("sgmap-ctrl-geolocate-active");
                        break;
                    case "ACTIVE_LOCK":
                        this._geolocateButton.classList.add("sgmap-ctrl-geolocate-active");
                        break;
                    case "ACTIVE_ERROR":
                        this._geolocateButton.classList.add("sgmap-ctrl-geolocate-waiting"),
                        this._geolocateButton.classList.add("sgmap-ctrl-geolocate-active-error");
                        break;
                    case "BACKGROUND":
                        this._geolocateButton.classList.add("sgmap-ctrl-geolocate-background");
                        break;
                    case "BACKGROUND_ERROR":
                        this._geolocateButton.classList.add("sgmap-ctrl-geolocate-waiting"),
                        this._geolocateButton.classList.add("sgmap-ctrl-geolocate-background-error");
                    }
                    if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID)
                        this._clearWatch();
                    else if (void 0 === this._geolocationWatchID) {
                        let t;
                        this._geolocateButton.classList.add("sgmap-ctrl-geolocate-waiting"),
                        this._geolocateButton.setAttribute("aria-pressed", "true"),
                        this._numberOfWatches++,
                        this._numberOfWatches > 1 ? (t = {
                            maximumAge: 6e5,
                            timeout: 0
                        },
                        this._noTimeout = !0) : (t = this.options.positionOptions,
                        this._noTimeout = !1),
                        this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, t),
                        this.options.showUserHeading && this._addDeviceOrientationListener();
                    }
                } else
                    this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions),
                    this._timeoutId = setTimeout(this._finish, 1e4);
                return !0
            }
            _addDeviceOrientationListener() {
                const e = () => {
                    t.window.addEventListener("ondeviceorientationabsolute"in t.window ? "deviceorientationabsolute" : "deviceorientation", this._onDeviceOrientation);
                }
                ;
                void 0 !== t.window.DeviceMotionEvent && "function" == typeof t.window.DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then((t => {
                    "granted" === t && e();
                }
                )).catch(console.error) : e();
            }
            _clearWatch() {
                this.options.geolocation.clearWatch(this._geolocationWatchID),
                t.window.removeEventListener("deviceorientation", this._onDeviceOrientation),
                t.window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation),
                this._geolocationWatchID = void 0,
                this._geolocateButton.classList.remove("sgmap-ctrl-geolocate-waiting"),
                this._geolocateButton.setAttribute("aria-pressed", "false"),
                this.options.showUserLocation && this._updateMarker(null);
            }
        }
        const ea = {
            maxWidth: 100,
            unit: "metric"
        };
        function ia(t, e, i) {
            const r = ra(e)
              , o = r / e
              , n = {
                kilometer: "km",
                meter: "m",
                mile: "mi",
                foot: "ft",
                "nautical-mile": "nm"
            }[i];
            this._map._requestDomTask(( () => {
                this._container.style.width = t * o + "px",
                this._container.innerHTML = `${r}&nbsp;${n}`;
            }
            ));
        }
        function ra(t) {
            const e = Math.pow(10, `${Math.floor(t)}`.length - 1);
            let i = t / e;
            return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : i >= 1 ? 1 : function(t) {
                const e = Math.pow(10, Math.ceil(-Math.log(t) / Math.LN10));
                return Math.round(t * e) / e
            }(i),
            e * i
        }
        var oa = t.createCommonjsModule((function(t, e) {
            t.exports = function() {
                function t(t, e) {
                    (null == e || e > t.length) && (e = t.length);
                    for (var i = 0, r = new Array(e); i < e; i++)
                        r[i] = t[i];
                    return r
                }
                function e(e, i) {
                    var r;
                    if ("undefined" == typeof Symbol || null == e[Symbol.iterator]) {
                        if (Array.isArray(e) || (r = function(e, i) {
                            if (e) {
                                if ("string" == typeof e)
                                    return t(e, i);
                                var r = Object.prototype.toString.call(e).slice(8, -1);
                                return "Object" === r && e.constructor && (r = e.constructor.name),
                                "Map" === r || "Set" === r ? Array.from(e) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? t(e, i) : void 0
                            }
                        }(e)) || i && e && "number" == typeof e.length) {
                            r && (e = r);
                            var o = 0
                              , n = function() {};
                            return {
                                s: n,
                                n: function() {
                                    return o >= e.length ? {
                                        done: !0
                                    } : {
                                        done: !1,
                                        value: e[o++]
                                    }
                                },
                                e: function(t) {
                                    throw t
                                },
                                f: n
                            }
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }
                    var s, a = !0, l = !1;
                    return {
                        s: function() {
                            r = e[Symbol.iterator]();
                        },
                        n: function() {
                            var t = r.next();
                            return a = t.done,
                            t
                        },
                        e: function(t) {
                            l = !0,
                            s = t;
                        },
                        f: function() {
                            try {
                                a || null == r.return || r.return();
                            } finally {
                                if (l)
                                    throw s
                            }
                        }
                    }
                }
                var i = null
                  , r = i = i || function() {
                    var t, e, i, r, o, n, s, a, l, c, h, u, d, f, _, p, m, g, v, y, b, x, w, T, E, S, C, A, M, I, z, P, D, B, L, R, k, O, F, U, N, j, G, V, Z, W, q, H, X, Y, K, J, $, Q, tt, et, it, rt, ot, nt, st, at, lt, ct, ht, ut, dt, ft, _t, pt, mt, gt, vt, yt, bt, xt, wt, Tt, Et, St, Ct, At, Mt, It, zt, Pt = Pt || (t = Math,
                    e = Object.create || function(t) {
                        var e;
                        return Dt.prototype = t,
                        e = new Dt,
                        Dt.prototype = null,
                        e
                    }
                    ,
                    r = (i = {}).lib = {},
                    o = r.Base = {
                        extend: function(t) {
                            var i = e(this);
                            return t && i.mixIn(t),
                            i.hasOwnProperty("init") && this.init !== i.init || (i.init = function() {
                                i.$super.init.apply(this, arguments);
                            }
                            ),
                            (i.init.prototype = i).$super = this,
                            i
                        },
                        create: function() {
                            var t = this.extend();
                            return t.init.apply(t, arguments),
                            t
                        },
                        init: function() {},
                        mixIn: function(t) {
                            for (var e in t)
                                t.hasOwnProperty(e) && (this[e] = t[e]);
                            t.hasOwnProperty("toString") && (this.toString = t.toString);
                        },
                        clone: function() {
                            return this.init.prototype.extend(this)
                        }
                    },
                    n = r.WordArray = o.extend({
                        init: function(t, e) {
                            t = this.words = t || [],
                            this.sigBytes = null != e ? e : 4 * t.length;
                        },
                        toString: function(t) {
                            return (t || a).stringify(this)
                        },
                        concat: function(t) {
                            var e = this.words
                              , i = t.words
                              , r = this.sigBytes
                              , o = t.sigBytes;
                            if (this.clamp(),
                            r % 4)
                                for (var n = 0; n < o; n++)
                                    e[r + n >>> 2] |= (i[n >>> 2] >>> 24 - n % 4 * 8 & 255) << 24 - (r + n) % 4 * 8;
                            else
                                for (n = 0; n < o; n += 4)
                                    e[r + n >>> 2] = i[n >>> 2];
                            return this.sigBytes += o,
                            this
                        },
                        clamp: function() {
                            var e = this.words
                              , i = this.sigBytes;
                            e[i >>> 2] &= 4294967295 << 32 - i % 4 * 8,
                            e.length = t.ceil(i / 4);
                        },
                        clone: function() {
                            var t = o.clone.call(this);
                            return t.words = this.words.slice(0),
                            t
                        },
                        random: function(e) {
                            for (var i = [], r = function(e) {
                                e = e;
                                var i = 987654321
                                  , r = 4294967295;
                                return function() {
                                    var o = ((i = 36969 * (65535 & i) + (i >> 16) & r) << 16) + (e = 18e3 * (65535 & e) + (e >> 16) & r) & r;
                                    return o /= 4294967296,
                                    (o += .5) * (.5 < t.random() ? 1 : -1)
                                }
                            }, o = 0; o < e; o += 4) {
                                var s = r(4294967296 * (a || t.random()))
                                  , a = 987654071 * s();
                                i.push(4294967296 * s() | 0);
                            }
                            return new n.init(i,e)
                        }
                    }),
                    s = i.enc = {},
                    a = s.Hex = {
                        stringify: function(t) {
                            for (var e = t.words, i = t.sigBytes, r = [], o = 0; o < i; o++) {
                                var n = e[o >>> 2] >>> 24 - o % 4 * 8 & 255;
                                r.push((n >>> 4).toString(16)),
                                r.push((15 & n).toString(16));
                            }
                            return r.join("")
                        },
                        parse: function(t) {
                            for (var e = t.length, i = [], r = 0; r < e; r += 2)
                                i[r >>> 3] |= parseInt(t.substr(r, 2), 16) << 24 - r % 8 * 4;
                            return new n.init(i,e / 2)
                        }
                    },
                    l = s.Latin1 = {
                        stringify: function(t) {
                            for (var e = t.words, i = t.sigBytes, r = [], o = 0; o < i; o++)
                                r.push(String.fromCharCode(e[o >>> 2] >>> 24 - o % 4 * 8 & 255));
                            return r.join("")
                        },
                        parse: function(t) {
                            for (var e = t.length, i = [], r = 0; r < e; r++)
                                i[r >>> 2] |= (255 & t.charCodeAt(r)) << 24 - r % 4 * 8;
                            return new n.init(i,e)
                        }
                    },
                    c = s.Utf8 = {
                        stringify: function(t) {
                            try {
                                return decodeURIComponent(escape(l.stringify(t)))
                            } catch (t) {
                                throw new Error("Malformed UTF-8 data")
                            }
                        },
                        parse: function(t) {
                            return l.parse(unescape(encodeURIComponent(t)))
                        }
                    },
                    h = r.BufferedBlockAlgorithm = o.extend({
                        reset: function() {
                            this._data = new n.init,
                            this._nDataBytes = 0;
                        },
                        _append: function(t) {
                            "string" == typeof t && (t = c.parse(t)),
                            this._data.concat(t),
                            this._nDataBytes += t.sigBytes;
                        },
                        _process: function(e) {
                            var i = this._data
                              , r = i.words
                              , o = i.sigBytes
                              , s = this.blockSize
                              , a = o / (4 * s)
                              , l = (a = e ? t.ceil(a) : t.max((0 | a) - this._minBufferSize, 0)) * s
                              , c = t.min(4 * l, o);
                            if (l) {
                                for (var h = 0; h < l; h += s)
                                    this._doProcessBlock(r, h);
                                var u = r.splice(0, l);
                                i.sigBytes -= c;
                            }
                            return new n.init(u,c)
                        },
                        clone: function() {
                            var t = o.clone.call(this);
                            return t._data = this._data.clone(),
                            t
                        },
                        _minBufferSize: 0
                    }),
                    r.Hasher = h.extend({
                        cfg: o.extend(),
                        init: function(t) {
                            this.cfg = this.cfg.extend(t),
                            this.reset();
                        },
                        reset: function() {
                            h.reset.call(this),
                            this._doReset();
                        },
                        update: function(t) {
                            return this._append(t),
                            this._process(),
                            this
                        },
                        finalize: function(t) {
                            return t && this._append(t),
                            this._doFinalize()
                        },
                        blockSize: 16,
                        _createHelper: function(t) {
                            return function(e, i) {
                                return new t.init(i).finalize(e)
                            }
                        },
                        _createHmacHelper: function(t) {
                            return function(e, i) {
                                return new u.HMAC.init(t,i).finalize(e)
                            }
                        }
                    }),
                    u = i.algo = {},
                    i);
                    function Dt() {}
                    function Bt(t, e, i) {
                        return t & e | ~t & i
                    }
                    function Lt(t, e, i) {
                        return t & i | e & ~i
                    }
                    function Rt(t, e) {
                        return t << e | t >>> 32 - e
                    }
                    function kt(t, e, i, r) {
                        var o, n = this._iv;
                        n ? (o = n.slice(0),
                        this._iv = void 0) : o = this._prevBlock,
                        r.encryptBlock(o, 0);
                        for (var s = 0; s < i; s++)
                            t[e + s] ^= o[s];
                    }
                    function Ot(t) {
                        var e, i, r;
                        return 255 == (t >> 24 & 255) ? (i = t >> 8 & 255,
                        r = 255 & t,
                        255 == (e = t >> 16 & 255) ? (e = 0,
                        255 === i ? (i = 0,
                        255 === r ? r = 0 : ++r) : ++i) : ++e,
                        t = 0,
                        t += e << 16,
                        t += i << 8,
                        t += r) : t += 1 << 24,
                        t
                    }
                    function Ft() {
                        for (var t = this._X, e = this._C, i = 0; i < 8; i++)
                            bt[i] = e[i];
                        for (e[0] = e[0] + 1295307597 + this._b | 0,
                        e[1] = e[1] + 3545052371 + (e[0] >>> 0 < bt[0] >>> 0 ? 1 : 0) | 0,
                        e[2] = e[2] + 886263092 + (e[1] >>> 0 < bt[1] >>> 0 ? 1 : 0) | 0,
                        e[3] = e[3] + 1295307597 + (e[2] >>> 0 < bt[2] >>> 0 ? 1 : 0) | 0,
                        e[4] = e[4] + 3545052371 + (e[3] >>> 0 < bt[3] >>> 0 ? 1 : 0) | 0,
                        e[5] = e[5] + 886263092 + (e[4] >>> 0 < bt[4] >>> 0 ? 1 : 0) | 0,
                        e[6] = e[6] + 1295307597 + (e[5] >>> 0 < bt[5] >>> 0 ? 1 : 0) | 0,
                        e[7] = e[7] + 3545052371 + (e[6] >>> 0 < bt[6] >>> 0 ? 1 : 0) | 0,
                        this._b = e[7] >>> 0 < bt[7] >>> 0 ? 1 : 0,
                        i = 0; i < 8; i++) {
                            var r = t[i] + e[i]
                              , o = 65535 & r
                              , n = r >>> 16;
                            xt[i] = ((o * o >>> 17) + o * n >>> 15) + n * n ^ ((4294901760 & r) * r | 0) + ((65535 & r) * r | 0);
                        }
                        t[0] = xt[0] + (xt[7] << 16 | xt[7] >>> 16) + (xt[6] << 16 | xt[6] >>> 16) | 0,
                        t[1] = xt[1] + (xt[0] << 8 | xt[0] >>> 24) + xt[7] | 0,
                        t[2] = xt[2] + (xt[1] << 16 | xt[1] >>> 16) + (xt[0] << 16 | xt[0] >>> 16) | 0,
                        t[3] = xt[3] + (xt[2] << 8 | xt[2] >>> 24) + xt[1] | 0,
                        t[4] = xt[4] + (xt[3] << 16 | xt[3] >>> 16) + (xt[2] << 16 | xt[2] >>> 16) | 0,
                        t[5] = xt[5] + (xt[4] << 8 | xt[4] >>> 24) + xt[3] | 0,
                        t[6] = xt[6] + (xt[5] << 16 | xt[5] >>> 16) + (xt[4] << 16 | xt[4] >>> 16) | 0,
                        t[7] = xt[7] + (xt[6] << 8 | xt[6] >>> 24) + xt[5] | 0;
                    }
                    function Ut() {
                        for (var t = this._X, e = this._C, i = 0; i < 8; i++)
                            Mt[i] = e[i];
                        for (e[0] = e[0] + 1295307597 + this._b | 0,
                        e[1] = e[1] + 3545052371 + (e[0] >>> 0 < Mt[0] >>> 0 ? 1 : 0) | 0,
                        e[2] = e[2] + 886263092 + (e[1] >>> 0 < Mt[1] >>> 0 ? 1 : 0) | 0,
                        e[3] = e[3] + 1295307597 + (e[2] >>> 0 < Mt[2] >>> 0 ? 1 : 0) | 0,
                        e[4] = e[4] + 3545052371 + (e[3] >>> 0 < Mt[3] >>> 0 ? 1 : 0) | 0,
                        e[5] = e[5] + 886263092 + (e[4] >>> 0 < Mt[4] >>> 0 ? 1 : 0) | 0,
                        e[6] = e[6] + 1295307597 + (e[5] >>> 0 < Mt[5] >>> 0 ? 1 : 0) | 0,
                        e[7] = e[7] + 3545052371 + (e[6] >>> 0 < Mt[6] >>> 0 ? 1 : 0) | 0,
                        this._b = e[7] >>> 0 < Mt[7] >>> 0 ? 1 : 0,
                        i = 0; i < 8; i++) {
                            var r = t[i] + e[i]
                              , o = 65535 & r
                              , n = r >>> 16;
                            It[i] = ((o * o >>> 17) + o * n >>> 15) + n * n ^ ((4294901760 & r) * r | 0) + ((65535 & r) * r | 0);
                        }
                        t[0] = It[0] + (It[7] << 16 | It[7] >>> 16) + (It[6] << 16 | It[6] >>> 16) | 0,
                        t[1] = It[1] + (It[0] << 8 | It[0] >>> 24) + It[7] | 0,
                        t[2] = It[2] + (It[1] << 16 | It[1] >>> 16) + (It[0] << 16 | It[0] >>> 16) | 0,
                        t[3] = It[3] + (It[2] << 8 | It[2] >>> 24) + It[1] | 0,
                        t[4] = It[4] + (It[3] << 16 | It[3] >>> 16) + (It[2] << 16 | It[2] >>> 16) | 0,
                        t[5] = It[5] + (It[4] << 8 | It[4] >>> 24) + It[3] | 0,
                        t[6] = It[6] + (It[5] << 16 | It[5] >>> 16) + (It[4] << 16 | It[4] >>> 16) | 0,
                        t[7] = It[7] + (It[6] << 8 | It[6] >>> 24) + It[5] | 0;
                    }
                    return d = Pt.lib.WordArray,
                    Pt.enc.Base64 = {
                        stringify: function(t) {
                            var e = t.words
                              , i = t.sigBytes
                              , r = this._map;
                            t.clamp();
                            for (var o = [], n = 0; n < i; n += 3)
                                for (var s = (e[n >>> 2] >>> 24 - n % 4 * 8 & 255) << 16 | (e[n + 1 >>> 2] >>> 24 - (n + 1) % 4 * 8 & 255) << 8 | e[n + 2 >>> 2] >>> 24 - (n + 2) % 4 * 8 & 255, a = 0; a < 4 && n + .75 * a < i; a++)
                                    o.push(r.charAt(s >>> 6 * (3 - a) & 63));
                            var l = r.charAt(64);
                            if (l)
                                for (; o.length % 4; )
                                    o.push(l);
                            return o.join("")
                        },
                        parse: function(t) {
                            var e = t.length
                              , i = this._map
                              , r = this._reverseMap;
                            if (!r) {
                                r = this._reverseMap = [];
                                for (var o = 0; o < i.length; o++)
                                    r[i.charCodeAt(o)] = o;
                            }
                            var n, s = i.charAt(64);
                            return !s || -1 !== (n = t.indexOf(s)) && (e = n),
                            function(t, e, i) {
                                for (var r = [], o = 0, n = 0; n < e; n++) {
                                    var s, a;
                                    n % 4 && (s = i[t.charCodeAt(n - 1)] << n % 4 * 2,
                                    a = i[t.charCodeAt(n)] >>> 6 - n % 4 * 2,
                                    r[o >>> 2] |= (s | a) << 24 - o % 4 * 8,
                                    o++);
                                }
                                return d.create(r, o)
                            }(t, e, r)
                        },
                        _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
                    },
                    function(t) {
                        var e = Pt
                          , i = e.lib
                          , r = i.WordArray
                          , o = i.Hasher
                          , n = e.algo
                          , s = [];
                        !function() {
                            for (var e = 0; e < 64; e++)
                                s[e] = 4294967296 * t.abs(t.sin(e + 1)) | 0;
                        }();
                        var a = n.MD5 = o.extend({
                            _doReset: function() {
                                this._hash = new r.init([1732584193, 4023233417, 2562383102, 271733878]);
                            },
                            _doProcessBlock: function(t, e) {
                                for (var i = 0; i < 16; i++) {
                                    var r = e + i
                                      , o = t[r];
                                    t[r] = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8);
                                }
                                var n = this._hash.words
                                  , a = t[e + 0]
                                  , d = t[e + 1]
                                  , f = t[e + 2]
                                  , _ = t[e + 3]
                                  , p = t[e + 4]
                                  , m = t[e + 5]
                                  , g = t[e + 6]
                                  , v = t[e + 7]
                                  , y = t[e + 8]
                                  , b = t[e + 9]
                                  , x = t[e + 10]
                                  , w = t[e + 11]
                                  , T = t[e + 12]
                                  , E = t[e + 13]
                                  , S = t[e + 14]
                                  , C = t[e + 15]
                                  , A = l(A = n[0], z = n[1], I = n[2], M = n[3], a, 7, s[0])
                                  , M = l(M, A, z, I, d, 12, s[1])
                                  , I = l(I, M, A, z, f, 17, s[2])
                                  , z = l(z, I, M, A, _, 22, s[3]);
                                A = l(A, z, I, M, p, 7, s[4]),
                                M = l(M, A, z, I, m, 12, s[5]),
                                I = l(I, M, A, z, g, 17, s[6]),
                                z = l(z, I, M, A, v, 22, s[7]),
                                A = l(A, z, I, M, y, 7, s[8]),
                                M = l(M, A, z, I, b, 12, s[9]),
                                I = l(I, M, A, z, x, 17, s[10]),
                                z = l(z, I, M, A, w, 22, s[11]),
                                A = l(A, z, I, M, T, 7, s[12]),
                                M = l(M, A, z, I, E, 12, s[13]),
                                I = l(I, M, A, z, S, 17, s[14]),
                                A = c(A, z = l(z, I, M, A, C, 22, s[15]), I, M, d, 5, s[16]),
                                M = c(M, A, z, I, g, 9, s[17]),
                                I = c(I, M, A, z, w, 14, s[18]),
                                z = c(z, I, M, A, a, 20, s[19]),
                                A = c(A, z, I, M, m, 5, s[20]),
                                M = c(M, A, z, I, x, 9, s[21]),
                                I = c(I, M, A, z, C, 14, s[22]),
                                z = c(z, I, M, A, p, 20, s[23]),
                                A = c(A, z, I, M, b, 5, s[24]),
                                M = c(M, A, z, I, S, 9, s[25]),
                                I = c(I, M, A, z, _, 14, s[26]),
                                z = c(z, I, M, A, y, 20, s[27]),
                                A = c(A, z, I, M, E, 5, s[28]),
                                M = c(M, A, z, I, f, 9, s[29]),
                                I = c(I, M, A, z, v, 14, s[30]),
                                A = h(A, z = c(z, I, M, A, T, 20, s[31]), I, M, m, 4, s[32]),
                                M = h(M, A, z, I, y, 11, s[33]),
                                I = h(I, M, A, z, w, 16, s[34]),
                                z = h(z, I, M, A, S, 23, s[35]),
                                A = h(A, z, I, M, d, 4, s[36]),
                                M = h(M, A, z, I, p, 11, s[37]),
                                I = h(I, M, A, z, v, 16, s[38]),
                                z = h(z, I, M, A, x, 23, s[39]),
                                A = h(A, z, I, M, E, 4, s[40]),
                                M = h(M, A, z, I, a, 11, s[41]),
                                I = h(I, M, A, z, _, 16, s[42]),
                                z = h(z, I, M, A, g, 23, s[43]),
                                A = h(A, z, I, M, b, 4, s[44]),
                                M = h(M, A, z, I, T, 11, s[45]),
                                I = h(I, M, A, z, C, 16, s[46]),
                                A = u(A, z = h(z, I, M, A, f, 23, s[47]), I, M, a, 6, s[48]),
                                M = u(M, A, z, I, v, 10, s[49]),
                                I = u(I, M, A, z, S, 15, s[50]),
                                z = u(z, I, M, A, m, 21, s[51]),
                                A = u(A, z, I, M, T, 6, s[52]),
                                M = u(M, A, z, I, _, 10, s[53]),
                                I = u(I, M, A, z, x, 15, s[54]),
                                z = u(z, I, M, A, d, 21, s[55]),
                                A = u(A, z, I, M, y, 6, s[56]),
                                M = u(M, A, z, I, C, 10, s[57]),
                                I = u(I, M, A, z, g, 15, s[58]),
                                z = u(z, I, M, A, E, 21, s[59]),
                                A = u(A, z, I, M, p, 6, s[60]),
                                M = u(M, A, z, I, w, 10, s[61]),
                                I = u(I, M, A, z, f, 15, s[62]),
                                z = u(z, I, M, A, b, 21, s[63]),
                                n[0] = n[0] + A | 0,
                                n[1] = n[1] + z | 0,
                                n[2] = n[2] + I | 0,
                                n[3] = n[3] + M | 0;
                            },
                            _doFinalize: function() {
                                var e = this._data
                                  , i = e.words
                                  , r = 8 * this._nDataBytes
                                  , o = 8 * e.sigBytes;
                                i[o >>> 5] |= 128 << 24 - o % 32;
                                var n = t.floor(r / 4294967296)
                                  , s = r;
                                i[15 + (64 + o >>> 9 << 4)] = 16711935 & (n << 8 | n >>> 24) | 4278255360 & (n << 24 | n >>> 8),
                                i[14 + (64 + o >>> 9 << 4)] = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8),
                                e.sigBytes = 4 * (i.length + 1),
                                this._process();
                                for (var a = this._hash, l = a.words, c = 0; c < 4; c++) {
                                    var h = l[c];
                                    l[c] = 16711935 & (h << 8 | h >>> 24) | 4278255360 & (h << 24 | h >>> 8);
                                }
                                return a
                            },
                            clone: function() {
                                var t = o.clone.call(this);
                                return t._hash = this._hash.clone(),
                                t
                            }
                        });
                        function l(t, e, i, r, o, n, s) {
                            var a = t + (e & i | ~e & r) + o + s;
                            return (a << n | a >>> 32 - n) + e
                        }
                        function c(t, e, i, r, o, n, s) {
                            var a = t + (e & r | i & ~r) + o + s;
                            return (a << n | a >>> 32 - n) + e
                        }
                        function h(t, e, i, r, o, n, s) {
                            var a = t + (e ^ i ^ r) + o + s;
                            return (a << n | a >>> 32 - n) + e
                        }
                        function u(t, e, i, r, o, n, s) {
                            var a = t + (i ^ (e | ~r)) + o + s;
                            return (a << n | a >>> 32 - n) + e
                        }
                        e.MD5 = o._createHelper(a),
                        e.HmacMD5 = o._createHmacHelper(a);
                    }(Math),
                    _ = (f = Pt).lib,
                    p = _.WordArray,
                    g = [],
                    v = f.algo.SHA1 = (m = _.Hasher).extend({
                        _doReset: function() {
                            this._hash = new p.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
                        },
                        _doProcessBlock: function(t, e) {
                            for (var i, r = this._hash.words, o = r[0], n = r[1], s = r[2], a = r[3], l = r[4], c = 0; c < 80; c++) {
                                g[c] = c < 16 ? 0 | t[e + c] : (i = g[c - 3] ^ g[c - 8] ^ g[c - 14] ^ g[c - 16]) << 1 | i >>> 31;
                                var h = (o << 5 | o >>> 27) + l + g[c];
                                h += c < 20 ? 1518500249 + (n & s | ~n & a) : c < 40 ? 1859775393 + (n ^ s ^ a) : c < 60 ? (n & s | n & a | s & a) - 1894007588 : (n ^ s ^ a) - 899497514,
                                l = a,
                                a = s,
                                s = n << 30 | n >>> 2,
                                n = o,
                                o = h;
                            }
                            r[0] = r[0] + o | 0,
                            r[1] = r[1] + n | 0,
                            r[2] = r[2] + s | 0,
                            r[3] = r[3] + a | 0,
                            r[4] = r[4] + l | 0;
                        },
                        _doFinalize: function() {
                            var t = this._data
                              , e = t.words
                              , i = 8 * this._nDataBytes
                              , r = 8 * t.sigBytes;
                            return e[r >>> 5] |= 128 << 24 - r % 32,
                            e[14 + (64 + r >>> 9 << 4)] = Math.floor(i / 4294967296),
                            e[15 + (64 + r >>> 9 << 4)] = i,
                            t.sigBytes = 4 * e.length,
                            this._process(),
                            this._hash
                        },
                        clone: function() {
                            var t = m.clone.call(this);
                            return t._hash = this._hash.clone(),
                            t
                        }
                    }),
                    f.SHA1 = m._createHelper(v),
                    f.HmacSHA1 = m._createHmacHelper(v),
                    function(t) {
                        var e = Pt
                          , i = e.lib
                          , r = i.WordArray
                          , o = i.Hasher
                          , n = e.algo
                          , s = []
                          , a = [];
                        !function() {
                            function e(t) {
                                return 4294967296 * (t - (0 | t)) | 0
                            }
                            for (var i = 2, r = 0; r < 64; )
                                !function(e) {
                                    for (var i = t.sqrt(e), r = 2; r <= i; r++)
                                        if (!(e % r))
                                            return;
                                    return 1
                                }(i) || (r < 8 && (s[r] = e(t.pow(i, .5))),
                                a[r] = e(t.pow(i, 1 / 3)),
                                r++),
                                i++;
                        }();
                        var l = []
                          , c = n.SHA256 = o.extend({
                            _doReset: function() {
                                this._hash = new r.init(s.slice(0));
                            },
                            _doProcessBlock: function(t, e) {
                                for (var i, r, o, n, s = this._hash.words, c = s[0], h = s[1], u = s[2], d = s[3], f = s[4], _ = s[5], p = s[6], m = s[7], g = 0; g < 64; g++) {
                                    g < 16 ? l[g] = 0 | t[e + g] : (r = ((i = l[g - 15]) << 25 | i >>> 7) ^ (i << 14 | i >>> 18) ^ i >>> 3,
                                    n = ((o = l[g - 2]) << 15 | o >>> 17) ^ (o << 13 | o >>> 19) ^ o >>> 10,
                                    l[g] = r + l[g - 7] + n + l[g - 16]);
                                    var v = c & h ^ c & u ^ h & u
                                      , y = m + ((f << 26 | f >>> 6) ^ (f << 21 | f >>> 11) ^ (f << 7 | f >>> 25)) + (f & _ ^ ~f & p) + a[g] + l[g];
                                    m = p,
                                    p = _,
                                    _ = f,
                                    f = d + y | 0,
                                    d = u,
                                    u = h,
                                    h = c,
                                    c = y + (((c << 30 | c >>> 2) ^ (c << 19 | c >>> 13) ^ (c << 10 | c >>> 22)) + v) | 0;
                                }
                                s[0] = s[0] + c | 0,
                                s[1] = s[1] + h | 0,
                                s[2] = s[2] + u | 0,
                                s[3] = s[3] + d | 0,
                                s[4] = s[4] + f | 0,
                                s[5] = s[5] + _ | 0,
                                s[6] = s[6] + p | 0,
                                s[7] = s[7] + m | 0;
                            },
                            _doFinalize: function() {
                                var e = this._data
                                  , i = e.words
                                  , r = 8 * this._nDataBytes
                                  , o = 8 * e.sigBytes;
                                return i[o >>> 5] |= 128 << 24 - o % 32,
                                i[14 + (64 + o >>> 9 << 4)] = t.floor(r / 4294967296),
                                i[15 + (64 + o >>> 9 << 4)] = r,
                                e.sigBytes = 4 * i.length,
                                this._process(),
                                this._hash
                            },
                            clone: function() {
                                var t = o.clone.call(this);
                                return t._hash = this._hash.clone(),
                                t
                            }
                        });
                        e.SHA256 = o._createHelper(c),
                        e.HmacSHA256 = o._createHmacHelper(c);
                    }(Math),
                    function() {
                        var t = Pt.lib.WordArray
                          , e = Pt.enc;
                        function i(t) {
                            return t << 8 & 4278255360 | t >>> 8 & 16711935
                        }
                        e.Utf16 = e.Utf16BE = {
                            stringify: function(t) {
                                for (var e = t.words, i = t.sigBytes, r = [], o = 0; o < i; o += 2)
                                    r.push(String.fromCharCode(e[o >>> 2] >>> 16 - o % 4 * 8 & 65535));
                                return r.join("")
                            },
                            parse: function(e) {
                                for (var i = e.length, r = [], o = 0; o < i; o++)
                                    r[o >>> 1] |= e.charCodeAt(o) << 16 - o % 2 * 16;
                                return t.create(r, 2 * i)
                            }
                        },
                        e.Utf16LE = {
                            stringify: function(t) {
                                for (var e = t.words, r = t.sigBytes, o = [], n = 0; n < r; n += 2) {
                                    var s = i(e[n >>> 2] >>> 16 - n % 4 * 8 & 65535);
                                    o.push(String.fromCharCode(s));
                                }
                                return o.join("")
                            },
                            parse: function(e) {
                                for (var r = e.length, o = [], n = 0; n < r; n++)
                                    o[n >>> 1] |= i(e.charCodeAt(n) << 16 - n % 2 * 16);
                                return t.create(o, 2 * r)
                            }
                        };
                    }(),
                    "function" == typeof ArrayBuffer && (b = (y = Pt.lib.WordArray).init,
                    (y.init = function(t) {
                        if (t instanceof ArrayBuffer && (t = new Uint8Array(t)),
                        (t instanceof Int8Array || "undefined" != typeof Uint8ClampedArray && t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array || t instanceof Float64Array) && (t = new Uint8Array(t.buffer,t.byteOffset,t.byteLength)),
                        t instanceof Uint8Array) {
                            for (var e = t.byteLength, i = [], r = 0; r < e; r++)
                                i[r >>> 2] |= t[r] << 24 - r % 4 * 8;
                            b.call(this, i, e);
                        } else
                            b.apply(this, arguments);
                    }
                    ).prototype = y),
                    w = (x = Pt).lib,
                    E = w.Hasher,
                    S = x.algo,
                    C = (T = w.WordArray).create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]),
                    A = T.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]),
                    M = T.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]),
                    I = T.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]),
                    z = T.create([0, 1518500249, 1859775393, 2400959708, 2840853838]),
                    P = T.create([1352829926, 1548603684, 1836072691, 2053994217, 0]),
                    D = S.RIPEMD160 = E.extend({
                        _doReset: function() {
                            this._hash = T.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
                        },
                        _doProcessBlock: function(t, e) {
                            for (var i = 0; i < 16; i++) {
                                var r = e + i
                                  , o = t[r];
                                t[r] = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8);
                            }
                            var n, s, a, l, c, h, u = this._hash.words, d = z.words, f = P.words, _ = C.words, p = A.words, m = M.words, g = I.words, v = n = u[0], y = s = u[1], b = a = u[2], x = l = u[3], w = c = u[4];
                            for (i = 0; i < 80; i += 1)
                                h = n + t[e + _[i]] | 0,
                                h += i < 16 ? (s ^ a ^ l) + d[0] : i < 32 ? Bt(s, a, l) + d[1] : i < 48 ? ((s | ~a) ^ l) + d[2] : i < 64 ? Lt(s, a, l) + d[3] : (s ^ (a | ~l)) + d[4],
                                h = (h = Rt(h |= 0, m[i])) + c | 0,
                                n = c,
                                c = l,
                                l = Rt(a, 10),
                                a = s,
                                s = h,
                                h = v + t[e + p[i]] | 0,
                                h += i < 16 ? (y ^ (b | ~x)) + f[0] : i < 32 ? Lt(y, b, x) + f[1] : i < 48 ? ((y | ~b) ^ x) + f[2] : i < 64 ? Bt(y, b, x) + f[3] : (y ^ b ^ x) + f[4],
                                h = (h = Rt(h |= 0, g[i])) + w | 0,
                                v = w,
                                w = x,
                                x = Rt(b, 10),
                                b = y,
                                y = h;
                            h = u[1] + a + x | 0,
                            u[1] = u[2] + l + w | 0,
                            u[2] = u[3] + c + v | 0,
                            u[3] = u[4] + n + y | 0,
                            u[4] = u[0] + s + b | 0,
                            u[0] = h;
                        },
                        _doFinalize: function() {
                            var t = this._data
                              , e = t.words
                              , i = 8 * this._nDataBytes
                              , r = 8 * t.sigBytes;
                            e[r >>> 5] |= 128 << 24 - r % 32,
                            e[14 + (64 + r >>> 9 << 4)] = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8),
                            t.sigBytes = 4 * (e.length + 1),
                            this._process();
                            for (var o = this._hash, n = o.words, s = 0; s < 5; s++) {
                                var a = n[s];
                                n[s] = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8);
                            }
                            return o
                        },
                        clone: function() {
                            var t = E.clone.call(this);
                            return t._hash = this._hash.clone(),
                            t
                        }
                    }),
                    x.RIPEMD160 = E._createHelper(D),
                    x.HmacRIPEMD160 = E._createHmacHelper(D),
                    B = Pt.enc.Utf8,
                    Pt.algo.HMAC = Pt.lib.Base.extend({
                        init: function(t, e) {
                            t = this._hasher = new t.init,
                            "string" == typeof e && (e = B.parse(e));
                            var i = t.blockSize
                              , r = 4 * i;
                            e.sigBytes > r && (e = t.finalize(e)),
                            e.clamp();
                            for (var o = this._oKey = e.clone(), n = this._iKey = e.clone(), s = o.words, a = n.words, l = 0; l < i; l++)
                                s[l] ^= 1549556828,
                                a[l] ^= 909522486;
                            o.sigBytes = n.sigBytes = r,
                            this.reset();
                        },
                        reset: function() {
                            var t = this._hasher;
                            t.reset(),
                            t.update(this._iKey);
                        },
                        update: function(t) {
                            return this._hasher.update(t),
                            this
                        },
                        finalize: function(t) {
                            var e = this._hasher
                              , i = e.finalize(t);
                            return e.reset(),
                            e.finalize(this._oKey.clone().concat(i))
                        }
                    }),
                    R = (L = Pt).lib,
                    O = R.WordArray,
                    U = (F = L.algo).HMAC,
                    N = F.PBKDF2 = (k = R.Base).extend({
                        cfg: k.extend({
                            keySize: 4,
                            hasher: F.SHA1,
                            iterations: 1
                        }),
                        init: function(t) {
                            this.cfg = this.cfg.extend(t);
                        },
                        compute: function(t, e) {
                            for (var i = this.cfg, r = U.create(i.hasher, t), o = O.create(), n = O.create([1]), s = o.words, a = n.words, l = i.keySize, c = i.iterations; s.length < l; ) {
                                var h = r.update(e).finalize(n);
                                r.reset();
                                for (var u = h.words, d = u.length, f = h, _ = 1; _ < c; _++) {
                                    f = r.finalize(f),
                                    r.reset();
                                    for (var p = f.words, m = 0; m < d; m++)
                                        u[m] ^= p[m];
                                }
                                o.concat(h),
                                a[0]++;
                            }
                            return o.sigBytes = 4 * l,
                            o
                        }
                    }),
                    L.PBKDF2 = function(t, e, i) {
                        return N.create(i).compute(t, e)
                    }
                    ,
                    G = (j = Pt).lib,
                    Z = G.WordArray,
                    q = (W = j.algo).EvpKDF = (V = G.Base).extend({
                        cfg: V.extend({
                            keySize: 4,
                            hasher: W.MD5,
                            iterations: 1
                        }),
                        init: function(t) {
                            this.cfg = this.cfg.extend(t);
                        },
                        compute: function(t, e) {
                            for (var i = this.cfg, r = i.hasher.create(), o = Z.create(), n = o.words, s = i.keySize, a = i.iterations; n.length < s; ) {
                                l && r.update(l);
                                var l = r.update(t).finalize(e);
                                r.reset();
                                for (var c = 1; c < a; c++)
                                    l = r.finalize(l),
                                    r.reset();
                                o.concat(l);
                            }
                            return o.sigBytes = 4 * s,
                            o
                        }
                    }),
                    j.EvpKDF = function(t, e, i) {
                        return q.create(i).compute(t, e)
                    }
                    ,
                    X = (H = Pt).lib.WordArray,
                    J = (Y = H.algo).SHA224 = (K = Y.SHA256).extend({
                        _doReset: function() {
                            this._hash = new X.init([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]);
                        },
                        _doFinalize: function() {
                            var t = K._doFinalize.call(this);
                            return t.sigBytes -= 4,
                            t
                        }
                    }),
                    H.SHA224 = K._createHelper(J),
                    H.HmacSHA224 = K._createHmacHelper(J),
                    Q = ($ = Pt.lib).Base,
                    tt = $.WordArray,
                    (et = Pt.x64 = {}).Word = Q.extend({
                        init: function(t, e) {
                            this.high = t,
                            this.low = e;
                        }
                    }),
                    et.WordArray = Q.extend({
                        init: function(t, e) {
                            t = this.words = t || [],
                            this.sigBytes = null != e ? e : 8 * t.length;
                        },
                        toX32: function() {
                            for (var t = this.words, e = t.length, i = [], r = 0; r < e; r++) {
                                var o = t[r];
                                i.push(o.high),
                                i.push(o.low);
                            }
                            return tt.create(i, this.sigBytes)
                        },
                        clone: function() {
                            for (var t = Q.clone.call(this), e = t.words = this.words.slice(0), i = e.length, r = 0; r < i; r++)
                                e[r] = e[r].clone();
                            return t
                        }
                    }),
                    function(t) {
                        var e = Pt
                          , i = e.lib
                          , r = i.WordArray
                          , o = i.Hasher
                          , n = e.x64.Word
                          , s = e.algo
                          , a = []
                          , l = []
                          , c = [];
                        !function() {
                            for (var t = 1, e = 0, i = 0; i < 24; i++) {
                                a[t + 5 * e] = (i + 1) * (i + 2) / 2 % 64;
                                var r = (2 * t + 3 * e) % 5;
                                t = e % 5,
                                e = r;
                            }
                            for (t = 0; t < 5; t++)
                                for (e = 0; e < 5; e++)
                                    l[t + 5 * e] = e + (2 * t + 3 * e) % 5 * 5;
                            for (var o = 1, s = 0; s < 24; s++) {
                                for (var h, u = 0, d = 0, f = 0; f < 7; f++)
                                    1 & o && ((h = (1 << f) - 1) < 32 ? d ^= 1 << h : u ^= 1 << h - 32),
                                    128 & o ? o = o << 1 ^ 113 : o <<= 1;
                                c[s] = n.create(u, d);
                            }
                        }();
                        var h = [];
                        !function() {
                            for (var t = 0; t < 25; t++)
                                h[t] = n.create();
                        }();
                        var u = s.SHA3 = o.extend({
                            cfg: o.cfg.extend({
                                outputLength: 512
                            }),
                            _doReset: function() {
                                for (var t = this._state = [], e = 0; e < 25; e++)
                                    t[e] = new n.init;
                                this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
                            },
                            _doProcessBlock: function(t, e) {
                                for (var i = this._state, r = this.blockSize / 2, o = 0; o < r; o++) {
                                    var n = 16711935 & ((n = t[e + 2 * o]) << 8 | n >>> 24) | 4278255360 & (n << 24 | n >>> 8)
                                      , s = 16711935 & ((s = t[e + 2 * o + 1]) << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8);
                                    (M = i[o]).high ^= s,
                                    M.low ^= n;
                                }
                                for (var u = 0; u < 24; u++) {
                                    for (var d = 0; d < 5; d++) {
                                        for (var f = 0, _ = 0, p = 0; p < 5; p++)
                                            f ^= (M = i[d + 5 * p]).high,
                                            _ ^= M.low;
                                        var m = h[d];
                                        m.high = f,
                                        m.low = _;
                                    }
                                    for (d = 0; d < 5; d++) {
                                        var g = h[(d + 4) % 5]
                                          , v = h[(d + 1) % 5]
                                          , y = v.high
                                          , b = v.low;
                                        for (f = g.high ^ (y << 1 | b >>> 31),
                                        _ = g.low ^ (b << 1 | y >>> 31),
                                        p = 0; p < 5; p++)
                                            (M = i[d + 5 * p]).high ^= f,
                                            M.low ^= _;
                                    }
                                    for (var x = 1; x < 25; x++) {
                                        var w = (M = i[x]).high
                                          , T = M.low
                                          , E = a[x];
                                        _ = E < 32 ? (f = w << E | T >>> 32 - E,
                                        T << E | w >>> 32 - E) : (f = T << E - 32 | w >>> 64 - E,
                                        w << E - 32 | T >>> 64 - E);
                                        var S = h[l[x]];
                                        S.high = f,
                                        S.low = _;
                                    }
                                    var C = h[0]
                                      , A = i[0];
                                    for (C.high = A.high,
                                    C.low = A.low,
                                    d = 0; d < 5; d++)
                                        for (p = 0; p < 5; p++) {
                                            var M = i[x = d + 5 * p]
                                              , I = h[x]
                                              , z = h[(d + 1) % 5 + 5 * p]
                                              , P = h[(d + 2) % 5 + 5 * p];
                                            M.high = I.high ^ ~z.high & P.high,
                                            M.low = I.low ^ ~z.low & P.low;
                                        }
                                    var D = c[u];
                                    (M = i[0]).high ^= D.high,
                                    M.low ^= D.low;
                                }
                            },
                            _doFinalize: function() {
                                var e = this._data
                                  , i = e.words
                                  , o = 8 * e.sigBytes
                                  , n = 32 * this.blockSize;
                                i[o >>> 5] |= 1 << 24 - o % 32,
                                i[(t.ceil((1 + o) / n) * n >>> 5) - 1] |= 128,
                                e.sigBytes = 4 * i.length,
                                this._process();
                                for (var s = this._state, a = this.cfg.outputLength / 8, l = a / 8, c = [], h = 0; h < l; h++) {
                                    var u = s[h]
                                      , d = 16711935 & ((d = u.high) << 8 | d >>> 24) | 4278255360 & (d << 24 | d >>> 8)
                                      , f = 16711935 & ((f = u.low) << 8 | f >>> 24) | 4278255360 & (f << 24 | f >>> 8);
                                    c.push(f),
                                    c.push(d);
                                }
                                return new r.init(c,a)
                            },
                            clone: function() {
                                for (var t = o.clone.call(this), e = t._state = this._state.slice(0), i = 0; i < 25; i++)
                                    e[i] = e[i].clone();
                                return t
                            }
                        });
                        e.SHA3 = o._createHelper(u),
                        e.HmacSHA3 = o._createHmacHelper(u);
                    }(Math),
                    function() {
                        var t = Pt
                          , e = t.lib.Hasher
                          , i = t.x64
                          , r = i.Word
                          , o = i.WordArray
                          , n = t.algo;
                        function s() {
                            return r.create.apply(r, arguments)
                        }
                        var a = [s(1116352408, 3609767458), s(1899447441, 602891725), s(3049323471, 3964484399), s(3921009573, 2173295548), s(961987163, 4081628472), s(1508970993, 3053834265), s(2453635748, 2937671579), s(2870763221, 3664609560), s(3624381080, 2734883394), s(310598401, 1164996542), s(607225278, 1323610764), s(1426881987, 3590304994), s(1925078388, 4068182383), s(2162078206, 991336113), s(2614888103, 633803317), s(3248222580, 3479774868), s(3835390401, 2666613458), s(4022224774, 944711139), s(264347078, 2341262773), s(604807628, 2007800933), s(770255983, 1495990901), s(1249150122, 1856431235), s(1555081692, 3175218132), s(1996064986, 2198950837), s(2554220882, 3999719339), s(2821834349, 766784016), s(2952996808, 2566594879), s(3210313671, 3203337956), s(3336571891, 1034457026), s(3584528711, 2466948901), s(113926993, 3758326383), s(338241895, 168717936), s(666307205, 1188179964), s(773529912, 1546045734), s(1294757372, 1522805485), s(1396182291, 2643833823), s(1695183700, 2343527390), s(1986661051, 1014477480), s(2177026350, 1206759142), s(2456956037, 344077627), s(2730485921, 1290863460), s(2820302411, 3158454273), s(3259730800, 3505952657), s(3345764771, 106217008), s(3516065817, 3606008344), s(3600352804, 1432725776), s(4094571909, 1467031594), s(275423344, 851169720), s(430227734, 3100823752), s(506948616, 1363258195), s(659060556, 3750685593), s(883997877, 3785050280), s(958139571, 3318307427), s(1322822218, 3812723403), s(1537002063, 2003034995), s(1747873779, 3602036899), s(1955562222, 1575990012), s(2024104815, 1125592928), s(2227730452, 2716904306), s(2361852424, 442776044), s(2428436474, 593698344), s(2756734187, 3733110249), s(3204031479, 2999351573), s(3329325298, 3815920427), s(3391569614, 3928383900), s(3515267271, 566280711), s(3940187606, 3454069534), s(4118630271, 4000239992), s(116418474, 1914138554), s(174292421, 2731055270), s(289380356, 3203993006), s(460393269, 320620315), s(685471733, 587496836), s(852142971, 1086792851), s(1017036298, 365543100), s(1126000580, 2618297676), s(1288033470, 3409855158), s(1501505948, 4234509866), s(1607167915, 987167468), s(1816402316, 1246189591)]
                          , l = [];
                        !function() {
                            for (var t = 0; t < 80; t++)
                                l[t] = s();
                        }();
                        var c = n.SHA512 = e.extend({
                            _doReset: function() {
                                this._hash = new o.init([new r.init(1779033703,4089235720), new r.init(3144134277,2227873595), new r.init(1013904242,4271175723), new r.init(2773480762,1595750129), new r.init(1359893119,2917565137), new r.init(2600822924,725511199), new r.init(528734635,4215389547), new r.init(1541459225,327033209)]);
                            },
                            _doProcessBlock: function(t, e) {
                                for (var i = this._hash.words, r = i[0], o = i[1], n = i[2], s = i[3], c = i[4], h = i[5], u = i[6], d = i[7], f = r.high, _ = r.low, p = o.high, m = o.low, g = n.high, v = n.low, y = s.high, b = s.low, x = c.high, w = c.low, T = h.high, E = h.low, S = u.high, C = u.low, A = d.high, M = d.low, I = f, z = _, P = p, D = m, B = g, L = v, R = y, k = b, O = x, F = w, U = T, N = E, j = S, G = C, V = A, Z = M, W = 0; W < 80; W++) {
                                    var q, H, X, Y, K, J, $, Q, tt, et, it, rt, ot, nt, st, at = l[W];
                                    W < 16 ? (st = at.high = 0 | t[e + 2 * W],
                                    nt = at.low = 0 | t[e + 2 * W + 1]) : (Y = ((H = (q = l[W - 15]).high) >>> 1 | (X = q.low) << 31) ^ (H >>> 8 | X << 24) ^ H >>> 7,
                                    tt = (($ = (J = l[W - 2]).high) >>> 19 | (Q = J.low) << 13) ^ ($ << 3 | Q >>> 29) ^ $ >>> 6,
                                    st = (st = (st = Y + (it = l[W - 7]).high + ((nt = (K = (X >>> 1 | H << 31) ^ (X >>> 8 | H << 24) ^ (X >>> 7 | H << 25)) + it.low) >>> 0 < K >>> 0 ? 1 : 0)) + tt + ((nt += et = (Q >>> 19 | $ << 13) ^ (Q << 3 | $ >>> 29) ^ (Q >>> 6 | $ << 26)) >>> 0 < et >>> 0 ? 1 : 0)) + (rt = l[W - 16]).high + ((nt += ot = rt.low) >>> 0 < ot >>> 0 ? 1 : 0),
                                    at.high = st,
                                    at.low = nt);
                                    var lt = O & U ^ ~O & j
                                      , ct = F & N ^ ~F & G
                                      , ht = I & P ^ I & B ^ P & B
                                      , ut = (z >>> 28 | I << 4) ^ (z << 30 | I >>> 2) ^ (z << 25 | I >>> 7)
                                      , dt = a[W]
                                      , ft = dt.low
                                      , _t = Z + ((F >>> 14 | O << 18) ^ (F >>> 18 | O << 14) ^ (F << 23 | O >>> 9))
                                      , pt = V + ((O >>> 14 | F << 18) ^ (O >>> 18 | F << 14) ^ (O << 23 | F >>> 9)) + (_t >>> 0 < Z >>> 0 ? 1 : 0)
                                      , mt = ut + (z & D ^ z & L ^ D & L);
                                    V = j,
                                    Z = G,
                                    j = U,
                                    G = N,
                                    U = O,
                                    N = F,
                                    O = R + (pt = (pt = (pt = pt + lt + ((_t += ct) >>> 0 < ct >>> 0 ? 1 : 0)) + dt.high + ((_t += ft) >>> 0 < ft >>> 0 ? 1 : 0)) + st + ((_t += nt) >>> 0 < nt >>> 0 ? 1 : 0)) + ((F = k + _t | 0) >>> 0 < k >>> 0 ? 1 : 0) | 0,
                                    R = B,
                                    k = L,
                                    B = P,
                                    L = D,
                                    P = I,
                                    D = z,
                                    I = pt + (((I >>> 28 | z << 4) ^ (I << 30 | z >>> 2) ^ (I << 25 | z >>> 7)) + ht + (mt >>> 0 < ut >>> 0 ? 1 : 0)) + ((z = _t + mt | 0) >>> 0 < _t >>> 0 ? 1 : 0) | 0;
                                }
                                _ = r.low = _ + z,
                                r.high = f + I + (_ >>> 0 < z >>> 0 ? 1 : 0),
                                m = o.low = m + D,
                                o.high = p + P + (m >>> 0 < D >>> 0 ? 1 : 0),
                                v = n.low = v + L,
                                n.high = g + B + (v >>> 0 < L >>> 0 ? 1 : 0),
                                b = s.low = b + k,
                                s.high = y + R + (b >>> 0 < k >>> 0 ? 1 : 0),
                                w = c.low = w + F,
                                c.high = x + O + (w >>> 0 < F >>> 0 ? 1 : 0),
                                E = h.low = E + N,
                                h.high = T + U + (E >>> 0 < N >>> 0 ? 1 : 0),
                                C = u.low = C + G,
                                u.high = S + j + (C >>> 0 < G >>> 0 ? 1 : 0),
                                M = d.low = M + Z,
                                d.high = A + V + (M >>> 0 < Z >>> 0 ? 1 : 0);
                            },
                            _doFinalize: function() {
                                var t = this._data
                                  , e = t.words
                                  , i = 8 * this._nDataBytes
                                  , r = 8 * t.sigBytes;
                                return e[r >>> 5] |= 128 << 24 - r % 32,
                                e[30 + (128 + r >>> 10 << 5)] = Math.floor(i / 4294967296),
                                e[31 + (128 + r >>> 10 << 5)] = i,
                                t.sigBytes = 4 * e.length,
                                this._process(),
                                this._hash.toX32()
                            },
                            clone: function() {
                                var t = e.clone.call(this);
                                return t._hash = this._hash.clone(),
                                t
                            },
                            blockSize: 32
                        });
                        t.SHA512 = e._createHelper(c),
                        t.HmacSHA512 = e._createHmacHelper(c);
                    }(),
                    rt = (it = Pt).x64,
                    ot = rt.Word,
                    nt = rt.WordArray,
                    lt = (st = it.algo).SHA384 = (at = st.SHA512).extend({
                        _doReset: function() {
                            this._hash = new nt.init([new ot.init(3418070365,3238371032), new ot.init(1654270250,914150663), new ot.init(2438529370,812702999), new ot.init(355462360,4144912697), new ot.init(1731405415,4290775857), new ot.init(2394180231,1750603025), new ot.init(3675008525,1694076839), new ot.init(1203062813,3204075428)]);
                        },
                        _doFinalize: function() {
                            var t = at._doFinalize.call(this);
                            return t.sigBytes -= 16,
                            t
                        }
                    }),
                    it.SHA384 = at._createHelper(lt),
                    it.HmacSHA384 = at._createHmacHelper(lt),
                    Pt.lib.Cipher || function() {
                        var t = Pt
                          , e = t.lib
                          , i = e.Base
                          , r = e.WordArray
                          , o = e.BufferedBlockAlgorithm
                          , n = t.enc.Base64
                          , s = t.algo.EvpKDF
                          , a = e.Cipher = o.extend({
                            cfg: i.extend(),
                            createEncryptor: function(t, e) {
                                return this.create(this._ENC_XFORM_MODE, t, e)
                            },
                            createDecryptor: function(t, e) {
                                return this.create(this._DEC_XFORM_MODE, t, e)
                            },
                            init: function(t, e, i) {
                                this.cfg = this.cfg.extend(i),
                                this._xformMode = t,
                                this._key = e,
                                this.reset();
                            },
                            reset: function() {
                                o.reset.call(this),
                                this._doReset();
                            },
                            process: function(t) {
                                return this._append(t),
                                this._process()
                            },
                            finalize: function(t) {
                                return t && this._append(t),
                                this._doFinalize()
                            },
                            keySize: 4,
                            ivSize: 4,
                            _ENC_XFORM_MODE: 1,
                            _DEC_XFORM_MODE: 2,
                            _createHelper: function(t) {
                                return {
                                    encrypt: function(e, i, r) {
                                        return l(i).encrypt(t, e, i, r)
                                    },
                                    decrypt: function(e, i, r) {
                                        return l(i).decrypt(t, e, i, r)
                                    }
                                }
                            }
                        });
                        function l(t) {
                            return "string" == typeof t ? y : g
                        }
                        e.StreamCipher = a.extend({
                            _doFinalize: function() {
                                return this._process(!0)
                            },
                            blockSize: 1
                        });
                        var c, h = t.mode = {}, u = e.BlockCipherMode = i.extend({
                            createEncryptor: function(t, e) {
                                return this.Encryptor.create(t, e)
                            },
                            createDecryptor: function(t, e) {
                                return this.Decryptor.create(t, e)
                            },
                            init: function(t, e) {
                                this._cipher = t,
                                this._iv = e;
                            }
                        }), d = h.CBC = ((c = u.extend()).Encryptor = c.extend({
                            processBlock: function(t, e) {
                                var i = this._cipher
                                  , r = i.blockSize;
                                f.call(this, t, e, r),
                                i.encryptBlock(t, e),
                                this._prevBlock = t.slice(e, e + r);
                            }
                        }),
                        c.Decryptor = c.extend({
                            processBlock: function(t, e) {
                                var i = this._cipher
                                  , r = i.blockSize
                                  , o = t.slice(e, e + r);
                                i.decryptBlock(t, e),
                                f.call(this, t, e, r),
                                this._prevBlock = o;
                            }
                        }),
                        c);
                        function f(t, e, i) {
                            var r, o = this._iv;
                            o ? (r = o,
                            this._iv = void 0) : r = this._prevBlock;
                            for (var n = 0; n < i; n++)
                                t[e + n] ^= r[n];
                        }
                        var _ = (t.pad = {}).Pkcs7 = {
                            pad: function(t, e) {
                                for (var i = 4 * e, o = i - t.sigBytes % i, n = o << 24 | o << 16 | o << 8 | o, s = [], a = 0; a < o; a += 4)
                                    s.push(n);
                                var l = r.create(s, o);
                                t.concat(l);
                            },
                            unpad: function(t) {
                                t.sigBytes -= 255 & t.words[t.sigBytes - 1 >>> 2];
                            }
                        }
                          , p = (e.BlockCipher = a.extend({
                            cfg: a.cfg.extend({
                                mode: d,
                                padding: _
                            }),
                            reset: function() {
                                a.reset.call(this);
                                var t, e = this.cfg, i = e.iv, r = e.mode;
                                this._xformMode == this._ENC_XFORM_MODE ? t = r.createEncryptor : (t = r.createDecryptor,
                                this._minBufferSize = 1),
                                this._mode && this._mode.__creator == t ? this._mode.init(this, i && i.words) : (this._mode = t.call(r, this, i && i.words),
                                this._mode.__creator = t);
                            },
                            _doProcessBlock: function(t, e) {
                                this._mode.processBlock(t, e);
                            },
                            _doFinalize: function() {
                                var t, e = this.cfg.padding;
                                return this._xformMode == this._ENC_XFORM_MODE ? (e.pad(this._data, this.blockSize),
                                t = this._process(!0)) : (t = this._process(!0),
                                e.unpad(t)),
                                t
                            },
                            blockSize: 4
                        }),
                        e.CipherParams = i.extend({
                            init: function(t) {
                                this.mixIn(t);
                            },
                            toString: function(t) {
                                return (t || this.formatter).stringify(this)
                            }
                        }))
                          , m = (t.format = {}).OpenSSL = {
                            stringify: function(t) {
                                var e = t.ciphertext
                                  , i = t.salt;
                                return (i ? r.create([1398893684, 1701076831]).concat(i).concat(e) : e).toString(n)
                            },
                            parse: function(t) {
                                var e, i = n.parse(t), o = i.words;
                                return 1398893684 == o[0] && 1701076831 == o[1] && (e = r.create(o.slice(2, 4)),
                                o.splice(0, 4),
                                i.sigBytes -= 16),
                                p.create({
                                    ciphertext: i,
                                    salt: e
                                })
                            }
                        }
                          , g = e.SerializableCipher = i.extend({
                            cfg: i.extend({
                                format: m
                            }),
                            encrypt: function(t, e, i, r) {
                                r = this.cfg.extend(r);
                                var o = t.createEncryptor(i, r)
                                  , n = o.finalize(e)
                                  , s = o.cfg;
                                return p.create({
                                    ciphertext: n,
                                    key: i,
                                    iv: s.iv,
                                    algorithm: t,
                                    mode: s.mode,
                                    padding: s.padding,
                                    blockSize: t.blockSize,
                                    formatter: r.format
                                })
                            },
                            decrypt: function(t, e, i, r) {
                                return r = this.cfg.extend(r),
                                e = this._parse(e, r.format),
                                t.createDecryptor(i, r).finalize(e.ciphertext)
                            },
                            _parse: function(t, e) {
                                return "string" == typeof t ? e.parse(t, this) : t
                            }
                        })
                          , v = (t.kdf = {}).OpenSSL = {
                            execute: function(t, e, i, o) {
                                o = o || r.random(8);
                                var n = s.create({
                                    keySize: e + i
                                }).compute(t, o)
                                  , a = r.create(n.words.slice(e), 4 * i);
                                return n.sigBytes = 4 * e,
                                p.create({
                                    key: n,
                                    iv: a,
                                    salt: o
                                })
                            }
                        }
                          , y = e.PasswordBasedCipher = g.extend({
                            cfg: g.cfg.extend({
                                kdf: v
                            }),
                            encrypt: function(t, e, i, r) {
                                var o = (r = this.cfg.extend(r)).kdf.execute(i, t.keySize, t.ivSize);
                                r.iv = o.iv;
                                var n = g.encrypt.call(this, t, e, o.key, r);
                                return n.mixIn(o),
                                n
                            },
                            decrypt: function(t, e, i, r) {
                                r = this.cfg.extend(r),
                                e = this._parse(e, r.format);
                                var o = r.kdf.execute(i, t.keySize, t.ivSize, e.salt);
                                return r.iv = o.iv,
                                g.decrypt.call(this, t, e, o.key, r)
                            }
                        });
                    }(),
                    Pt.mode.CFB = ((ct = Pt.lib.BlockCipherMode.extend()).Encryptor = ct.extend({
                        processBlock: function(t, e) {
                            var i = this._cipher
                              , r = i.blockSize;
                            kt.call(this, t, e, r, i),
                            this._prevBlock = t.slice(e, e + r);
                        }
                    }),
                    ct.Decryptor = ct.extend({
                        processBlock: function(t, e) {
                            var i = this._cipher
                              , r = i.blockSize
                              , o = t.slice(e, e + r);
                            kt.call(this, t, e, r, i),
                            this._prevBlock = o;
                        }
                    }),
                    ct),
                    Pt.mode.ECB = ((ht = Pt.lib.BlockCipherMode.extend()).Encryptor = ht.extend({
                        processBlock: function(t, e) {
                            this._cipher.encryptBlock(t, e);
                        }
                    }),
                    ht.Decryptor = ht.extend({
                        processBlock: function(t, e) {
                            this._cipher.decryptBlock(t, e);
                        }
                    }),
                    ht),
                    Pt.pad.AnsiX923 = {
                        pad: function(t, e) {
                            var i = t.sigBytes
                              , r = 4 * e
                              , o = r - i % r
                              , n = i + o - 1;
                            t.clamp(),
                            t.words[n >>> 2] |= o << 24 - n % 4 * 8,
                            t.sigBytes += o;
                        },
                        unpad: function(t) {
                            t.sigBytes -= 255 & t.words[t.sigBytes - 1 >>> 2];
                        }
                    },
                    Pt.pad.Iso10126 = {
                        pad: function(t, e) {
                            var i = 4 * e
                              , r = i - t.sigBytes % i;
                            t.concat(Pt.lib.WordArray.random(r - 1)).concat(Pt.lib.WordArray.create([r << 24], 1));
                        },
                        unpad: function(t) {
                            t.sigBytes -= 255 & t.words[t.sigBytes - 1 >>> 2];
                        }
                    },
                    Pt.pad.Iso97971 = {
                        pad: function(t, e) {
                            t.concat(Pt.lib.WordArray.create([2147483648], 1)),
                            Pt.pad.ZeroPadding.pad(t, e);
                        },
                        unpad: function(t) {
                            Pt.pad.ZeroPadding.unpad(t),
                            t.sigBytes--;
                        }
                    },
                    Pt.mode.OFB = (dt = (ut = Pt.lib.BlockCipherMode.extend()).Encryptor = ut.extend({
                        processBlock: function(t, e) {
                            var i = this._cipher
                              , r = i.blockSize
                              , o = this._iv
                              , n = this._keystream;
                            o && (n = this._keystream = o.slice(0),
                            this._iv = void 0),
                            i.encryptBlock(n, 0);
                            for (var s = 0; s < r; s++)
                                t[e + s] ^= n[s];
                        }
                    }),
                    ut.Decryptor = dt,
                    ut),
                    Pt.pad.NoPadding = {
                        pad: function() {},
                        unpad: function() {}
                    },
                    ft = Pt.lib.CipherParams,
                    _t = Pt.enc.Hex,
                    Pt.format.Hex = {
                        stringify: function(t) {
                            return t.ciphertext.toString(_t)
                        },
                        parse: function(t) {
                            var e = _t.parse(t);
                            return ft.create({
                                ciphertext: e
                            })
                        }
                    },
                    function() {
                        var t = Pt
                          , e = t.lib.BlockCipher
                          , i = t.algo
                          , r = []
                          , o = []
                          , n = []
                          , s = []
                          , a = []
                          , l = []
                          , c = []
                          , h = []
                          , u = []
                          , d = [];
                        !function() {
                            for (var t = [], e = 0; e < 256; e++)
                                t[e] = e < 128 ? e << 1 : e << 1 ^ 283;
                            var i = 0
                              , f = 0;
                            for (e = 0; e < 256; e++) {
                                var _ = (_ = f ^ f << 1 ^ f << 2 ^ f << 3 ^ f << 4) >>> 8 ^ 255 & _ ^ 99;
                                r[i] = _;
                                var p = t[o[_] = i]
                                  , m = t[p]
                                  , g = t[m]
                                  , v = 257 * t[_] ^ 16843008 * _;
                                n[i] = v << 24 | v >>> 8,
                                s[i] = v << 16 | v >>> 16,
                                a[i] = v << 8 | v >>> 24,
                                l[i] = v,
                                c[_] = (v = 16843009 * g ^ 65537 * m ^ 257 * p ^ 16843008 * i) << 24 | v >>> 8,
                                h[_] = v << 16 | v >>> 16,
                                u[_] = v << 8 | v >>> 24,
                                d[_] = v,
                                i ? (i = p ^ t[t[t[g ^ p]]],
                                f ^= t[t[f]]) : i = f = 1;
                            }
                        }();
                        var f = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54]
                          , _ = i.AES = e.extend({
                            _doReset: function() {
                                if (!this._nRounds || this._keyPriorReset !== this._key) {
                                    for (var t = this._keyPriorReset = this._key, e = t.words, i = t.sigBytes / 4, o = 4 * (1 + (this._nRounds = 6 + i)), n = this._keySchedule = [], s = 0; s < o; s++)
                                        s < i ? n[s] = e[s] : (_ = n[s - 1],
                                        s % i ? 6 < i && s % i == 4 && (_ = r[_ >>> 24] << 24 | r[_ >>> 16 & 255] << 16 | r[_ >>> 8 & 255] << 8 | r[255 & _]) : (_ = r[(_ = _ << 8 | _ >>> 24) >>> 24] << 24 | r[_ >>> 16 & 255] << 16 | r[_ >>> 8 & 255] << 8 | r[255 & _],
                                        _ ^= f[s / i | 0] << 24),
                                        n[s] = n[s - i] ^ _);
                                    for (var a = this._invKeySchedule = [], l = 0; l < o; l++) {
                                        var _;
                                        s = o - l,
                                        _ = l % 4 ? n[s] : n[s - 4],
                                        a[l] = l < 4 || s <= 4 ? _ : c[r[_ >>> 24]] ^ h[r[_ >>> 16 & 255]] ^ u[r[_ >>> 8 & 255]] ^ d[r[255 & _]];
                                    }
                                }
                            },
                            encryptBlock: function(t, e) {
                                this._doCryptBlock(t, e, this._keySchedule, n, s, a, l, r);
                            },
                            decryptBlock: function(t, e) {
                                var i = t[e + 1];
                                t[e + 1] = t[e + 3],
                                t[e + 3] = i,
                                this._doCryptBlock(t, e, this._invKeySchedule, c, h, u, d, o),
                                i = t[e + 1],
                                t[e + 1] = t[e + 3],
                                t[e + 3] = i;
                            },
                            _doCryptBlock: function(t, e, i, r, o, n, s, a) {
                                for (var l = this._nRounds, c = t[e] ^ i[0], h = t[e + 1] ^ i[1], u = t[e + 2] ^ i[2], d = t[e + 3] ^ i[3], f = 4, _ = 1; _ < l; _++) {
                                    var p = r[c >>> 24] ^ o[h >>> 16 & 255] ^ n[u >>> 8 & 255] ^ s[255 & d] ^ i[f++]
                                      , m = r[h >>> 24] ^ o[u >>> 16 & 255] ^ n[d >>> 8 & 255] ^ s[255 & c] ^ i[f++]
                                      , g = r[u >>> 24] ^ o[d >>> 16 & 255] ^ n[c >>> 8 & 255] ^ s[255 & h] ^ i[f++]
                                      , v = r[d >>> 24] ^ o[c >>> 16 & 255] ^ n[h >>> 8 & 255] ^ s[255 & u] ^ i[f++];
                                    c = p,
                                    h = m,
                                    u = g,
                                    d = v;
                                }
                                p = (a[c >>> 24] << 24 | a[h >>> 16 & 255] << 16 | a[u >>> 8 & 255] << 8 | a[255 & d]) ^ i[f++],
                                m = (a[h >>> 24] << 24 | a[u >>> 16 & 255] << 16 | a[d >>> 8 & 255] << 8 | a[255 & c]) ^ i[f++],
                                g = (a[u >>> 24] << 24 | a[d >>> 16 & 255] << 16 | a[c >>> 8 & 255] << 8 | a[255 & h]) ^ i[f++],
                                v = (a[d >>> 24] << 24 | a[c >>> 16 & 255] << 16 | a[h >>> 8 & 255] << 8 | a[255 & u]) ^ i[f++],
                                t[e] = p,
                                t[e + 1] = m,
                                t[e + 2] = g,
                                t[e + 3] = v;
                            },
                            keySize: 8
                        });
                        t.AES = e._createHelper(_);
                    }(),
                    function() {
                        var t = Pt
                          , e = t.lib
                          , i = e.WordArray
                          , r = e.BlockCipher
                          , o = t.algo
                          , n = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4]
                          , s = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32]
                          , a = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28]
                          , l = [{
                            0: 8421888,
                            268435456: 32768,
                            536870912: 8421378,
                            805306368: 2,
                            1073741824: 512,
                            1342177280: 8421890,
                            1610612736: 8389122,
                            1879048192: 8388608,
                            2147483648: 514,
                            2415919104: 8389120,
                            2684354560: 33280,
                            2952790016: 8421376,
                            3221225472: 32770,
                            3489660928: 8388610,
                            3758096384: 0,
                            4026531840: 33282,
                            134217728: 0,
                            402653184: 8421890,
                            671088640: 33282,
                            939524096: 32768,
                            1207959552: 8421888,
                            1476395008: 512,
                            1744830464: 8421378,
                            2013265920: 2,
                            2281701376: 8389120,
                            2550136832: 33280,
                            2818572288: 8421376,
                            3087007744: 8389122,
                            3355443200: 8388610,
                            3623878656: 32770,
                            3892314112: 514,
                            4160749568: 8388608,
                            1: 32768,
                            268435457: 2,
                            536870913: 8421888,
                            805306369: 8388608,
                            1073741825: 8421378,
                            1342177281: 33280,
                            1610612737: 512,
                            1879048193: 8389122,
                            2147483649: 8421890,
                            2415919105: 8421376,
                            2684354561: 8388610,
                            2952790017: 33282,
                            3221225473: 514,
                            3489660929: 8389120,
                            3758096385: 32770,
                            4026531841: 0,
                            134217729: 8421890,
                            402653185: 8421376,
                            671088641: 8388608,
                            939524097: 512,
                            1207959553: 32768,
                            1476395009: 8388610,
                            1744830465: 2,
                            2013265921: 33282,
                            2281701377: 32770,
                            2550136833: 8389122,
                            2818572289: 514,
                            3087007745: 8421888,
                            3355443201: 8389120,
                            3623878657: 0,
                            3892314113: 33280,
                            4160749569: 8421378
                        }, {
                            0: 1074282512,
                            16777216: 16384,
                            33554432: 524288,
                            50331648: 1074266128,
                            67108864: 1073741840,
                            83886080: 1074282496,
                            100663296: 1073758208,
                            117440512: 16,
                            134217728: 540672,
                            150994944: 1073758224,
                            167772160: 1073741824,
                            184549376: 540688,
                            201326592: 524304,
                            218103808: 0,
                            234881024: 16400,
                            251658240: 1074266112,
                            8388608: 1073758208,
                            25165824: 540688,
                            41943040: 16,
                            58720256: 1073758224,
                            75497472: 1074282512,
                            92274688: 1073741824,
                            109051904: 524288,
                            125829120: 1074266128,
                            142606336: 524304,
                            159383552: 0,
                            176160768: 16384,
                            192937984: 1074266112,
                            209715200: 1073741840,
                            226492416: 540672,
                            243269632: 1074282496,
                            260046848: 16400,
                            268435456: 0,
                            285212672: 1074266128,
                            301989888: 1073758224,
                            318767104: 1074282496,
                            335544320: 1074266112,
                            352321536: 16,
                            369098752: 540688,
                            385875968: 16384,
                            402653184: 16400,
                            419430400: 524288,
                            436207616: 524304,
                            452984832: 1073741840,
                            469762048: 540672,
                            486539264: 1073758208,
                            503316480: 1073741824,
                            520093696: 1074282512,
                            276824064: 540688,
                            293601280: 524288,
                            310378496: 1074266112,
                            327155712: 16384,
                            343932928: 1073758208,
                            360710144: 1074282512,
                            377487360: 16,
                            394264576: 1073741824,
                            411041792: 1074282496,
                            427819008: 1073741840,
                            444596224: 1073758224,
                            461373440: 524304,
                            478150656: 0,
                            494927872: 16400,
                            511705088: 1074266128,
                            528482304: 540672
                        }, {
                            0: 260,
                            1048576: 0,
                            2097152: 67109120,
                            3145728: 65796,
                            4194304: 65540,
                            5242880: 67108868,
                            6291456: 67174660,
                            7340032: 67174400,
                            8388608: 67108864,
                            9437184: 67174656,
                            10485760: 65792,
                            11534336: 67174404,
                            12582912: 67109124,
                            13631488: 65536,
                            14680064: 4,
                            15728640: 256,
                            524288: 67174656,
                            1572864: 67174404,
                            2621440: 0,
                            3670016: 67109120,
                            4718592: 67108868,
                            5767168: 65536,
                            6815744: 65540,
                            7864320: 260,
                            8912896: 4,
                            9961472: 256,
                            11010048: 67174400,
                            12058624: 65796,
                            13107200: 65792,
                            14155776: 67109124,
                            15204352: 67174660,
                            16252928: 67108864,
                            16777216: 67174656,
                            17825792: 65540,
                            18874368: 65536,
                            19922944: 67109120,
                            20971520: 256,
                            22020096: 67174660,
                            23068672: 67108868,
                            24117248: 0,
                            25165824: 67109124,
                            26214400: 67108864,
                            27262976: 4,
                            28311552: 65792,
                            29360128: 67174400,
                            30408704: 260,
                            31457280: 65796,
                            32505856: 67174404,
                            17301504: 67108864,
                            18350080: 260,
                            19398656: 67174656,
                            20447232: 0,
                            21495808: 65540,
                            22544384: 67109120,
                            23592960: 256,
                            24641536: 67174404,
                            25690112: 65536,
                            26738688: 67174660,
                            27787264: 65796,
                            28835840: 67108868,
                            29884416: 67109124,
                            30932992: 67174400,
                            31981568: 4,
                            33030144: 65792
                        }, {
                            0: 2151682048,
                            65536: 2147487808,
                            131072: 4198464,
                            196608: 2151677952,
                            262144: 0,
                            327680: 4198400,
                            393216: 2147483712,
                            458752: 4194368,
                            524288: 2147483648,
                            589824: 4194304,
                            655360: 64,
                            720896: 2147487744,
                            786432: 2151678016,
                            851968: 4160,
                            917504: 4096,
                            983040: 2151682112,
                            32768: 2147487808,
                            98304: 64,
                            163840: 2151678016,
                            229376: 2147487744,
                            294912: 4198400,
                            360448: 2151682112,
                            425984: 0,
                            491520: 2151677952,
                            557056: 4096,
                            622592: 2151682048,
                            688128: 4194304,
                            753664: 4160,
                            819200: 2147483648,
                            884736: 4194368,
                            950272: 4198464,
                            1015808: 2147483712,
                            1048576: 4194368,
                            1114112: 4198400,
                            1179648: 2147483712,
                            1245184: 0,
                            1310720: 4160,
                            1376256: 2151678016,
                            1441792: 2151682048,
                            1507328: 2147487808,
                            1572864: 2151682112,
                            1638400: 2147483648,
                            1703936: 2151677952,
                            1769472: 4198464,
                            1835008: 2147487744,
                            1900544: 4194304,
                            1966080: 64,
                            2031616: 4096,
                            1081344: 2151677952,
                            1146880: 2151682112,
                            1212416: 0,
                            1277952: 4198400,
                            1343488: 4194368,
                            1409024: 2147483648,
                            1474560: 2147487808,
                            1540096: 64,
                            1605632: 2147483712,
                            1671168: 4096,
                            1736704: 2147487744,
                            1802240: 2151678016,
                            1867776: 4160,
                            1933312: 2151682048,
                            1998848: 4194304,
                            2064384: 4198464
                        }, {
                            0: 128,
                            4096: 17039360,
                            8192: 262144,
                            12288: 536870912,
                            16384: 537133184,
                            20480: 16777344,
                            24576: 553648256,
                            28672: 262272,
                            32768: 16777216,
                            36864: 537133056,
                            40960: 536871040,
                            45056: 553910400,
                            49152: 553910272,
                            53248: 0,
                            57344: 17039488,
                            61440: 553648128,
                            2048: 17039488,
                            6144: 553648256,
                            10240: 128,
                            14336: 17039360,
                            18432: 262144,
                            22528: 537133184,
                            26624: 553910272,
                            30720: 536870912,
                            34816: 537133056,
                            38912: 0,
                            43008: 553910400,
                            47104: 16777344,
                            51200: 536871040,
                            55296: 553648128,
                            59392: 16777216,
                            63488: 262272,
                            65536: 262144,
                            69632: 128,
                            73728: 536870912,
                            77824: 553648256,
                            81920: 16777344,
                            86016: 553910272,
                            90112: 537133184,
                            94208: 16777216,
                            98304: 553910400,
                            102400: 553648128,
                            106496: 17039360,
                            110592: 537133056,
                            114688: 262272,
                            118784: 536871040,
                            122880: 0,
                            126976: 17039488,
                            67584: 553648256,
                            71680: 16777216,
                            75776: 17039360,
                            79872: 537133184,
                            83968: 536870912,
                            88064: 17039488,
                            92160: 128,
                            96256: 553910272,
                            100352: 262272,
                            104448: 553910400,
                            108544: 0,
                            112640: 553648128,
                            116736: 16777344,
                            120832: 262144,
                            124928: 537133056,
                            129024: 536871040
                        }, {
                            0: 268435464,
                            256: 8192,
                            512: 270532608,
                            768: 270540808,
                            1024: 268443648,
                            1280: 2097152,
                            1536: 2097160,
                            1792: 268435456,
                            2048: 0,
                            2304: 268443656,
                            2560: 2105344,
                            2816: 8,
                            3072: 270532616,
                            3328: 2105352,
                            3584: 8200,
                            3840: 270540800,
                            128: 270532608,
                            384: 270540808,
                            640: 8,
                            896: 2097152,
                            1152: 2105352,
                            1408: 268435464,
                            1664: 268443648,
                            1920: 8200,
                            2176: 2097160,
                            2432: 8192,
                            2688: 268443656,
                            2944: 270532616,
                            3200: 0,
                            3456: 270540800,
                            3712: 2105344,
                            3968: 268435456,
                            4096: 268443648,
                            4352: 270532616,
                            4608: 270540808,
                            4864: 8200,
                            5120: 2097152,
                            5376: 268435456,
                            5632: 268435464,
                            5888: 2105344,
                            6144: 2105352,
                            6400: 0,
                            6656: 8,
                            6912: 270532608,
                            7168: 8192,
                            7424: 268443656,
                            7680: 270540800,
                            7936: 2097160,
                            4224: 8,
                            4480: 2105344,
                            4736: 2097152,
                            4992: 268435464,
                            5248: 268443648,
                            5504: 8200,
                            5760: 270540808,
                            6016: 270532608,
                            6272: 270540800,
                            6528: 270532616,
                            6784: 8192,
                            7040: 2105352,
                            7296: 2097160,
                            7552: 0,
                            7808: 268435456,
                            8064: 268443656
                        }, {
                            0: 1048576,
                            16: 33555457,
                            32: 1024,
                            48: 1049601,
                            64: 34604033,
                            80: 0,
                            96: 1,
                            112: 34603009,
                            128: 33555456,
                            144: 1048577,
                            160: 33554433,
                            176: 34604032,
                            192: 34603008,
                            208: 1025,
                            224: 1049600,
                            240: 33554432,
                            8: 34603009,
                            24: 0,
                            40: 33555457,
                            56: 34604032,
                            72: 1048576,
                            88: 33554433,
                            104: 33554432,
                            120: 1025,
                            136: 1049601,
                            152: 33555456,
                            168: 34603008,
                            184: 1048577,
                            200: 1024,
                            216: 34604033,
                            232: 1,
                            248: 1049600,
                            256: 33554432,
                            272: 1048576,
                            288: 33555457,
                            304: 34603009,
                            320: 1048577,
                            336: 33555456,
                            352: 34604032,
                            368: 1049601,
                            384: 1025,
                            400: 34604033,
                            416: 1049600,
                            432: 1,
                            448: 0,
                            464: 34603008,
                            480: 33554433,
                            496: 1024,
                            264: 1049600,
                            280: 33555457,
                            296: 34603009,
                            312: 1,
                            328: 33554432,
                            344: 1048576,
                            360: 1025,
                            376: 34604032,
                            392: 33554433,
                            408: 34603008,
                            424: 0,
                            440: 34604033,
                            456: 1049601,
                            472: 1024,
                            488: 33555456,
                            504: 1048577
                        }, {
                            0: 134219808,
                            1: 131072,
                            2: 134217728,
                            3: 32,
                            4: 131104,
                            5: 134350880,
                            6: 134350848,
                            7: 2048,
                            8: 134348800,
                            9: 134219776,
                            10: 133120,
                            11: 134348832,
                            12: 2080,
                            13: 0,
                            14: 134217760,
                            15: 133152,
                            2147483648: 2048,
                            2147483649: 134350880,
                            2147483650: 134219808,
                            2147483651: 134217728,
                            2147483652: 134348800,
                            2147483653: 133120,
                            2147483654: 133152,
                            2147483655: 32,
                            2147483656: 134217760,
                            2147483657: 2080,
                            2147483658: 131104,
                            2147483659: 134350848,
                            2147483660: 0,
                            2147483661: 134348832,
                            2147483662: 134219776,
                            2147483663: 131072,
                            16: 133152,
                            17: 134350848,
                            18: 32,
                            19: 2048,
                            20: 134219776,
                            21: 134217760,
                            22: 134348832,
                            23: 131072,
                            24: 0,
                            25: 131104,
                            26: 134348800,
                            27: 134219808,
                            28: 134350880,
                            29: 133120,
                            30: 2080,
                            31: 134217728,
                            2147483664: 131072,
                            2147483665: 2048,
                            2147483666: 134348832,
                            2147483667: 133152,
                            2147483668: 32,
                            2147483669: 134348800,
                            2147483670: 134217728,
                            2147483671: 134219808,
                            2147483672: 134350880,
                            2147483673: 134217760,
                            2147483674: 134219776,
                            2147483675: 0,
                            2147483676: 133120,
                            2147483677: 2080,
                            2147483678: 131104,
                            2147483679: 134350848
                        }]
                          , c = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679]
                          , h = o.DES = r.extend({
                            _doReset: function() {
                                for (var t = this._key.words, e = [], i = 0; i < 56; i++) {
                                    var r = n[i] - 1;
                                    e[i] = t[r >>> 5] >>> 31 - r % 32 & 1;
                                }
                                for (var o = this._subKeys = [], l = 0; l < 16; l++) {
                                    var c = o[l] = []
                                      , h = a[l];
                                    for (i = 0; i < 24; i++)
                                        c[i / 6 | 0] |= e[(s[i] - 1 + h) % 28] << 31 - i % 6,
                                        c[4 + (i / 6 | 0)] |= e[28 + (s[i + 24] - 1 + h) % 28] << 31 - i % 6;
                                    for (c[0] = c[0] << 1 | c[0] >>> 31,
                                    i = 1; i < 7; i++)
                                        c[i] = c[i] >>> 4 * (i - 1) + 3;
                                    c[7] = c[7] << 5 | c[7] >>> 27;
                                }
                                var u = this._invSubKeys = [];
                                for (i = 0; i < 16; i++)
                                    u[i] = o[15 - i];
                            },
                            encryptBlock: function(t, e) {
                                this._doCryptBlock(t, e, this._subKeys);
                            },
                            decryptBlock: function(t, e) {
                                this._doCryptBlock(t, e, this._invSubKeys);
                            },
                            _doCryptBlock: function(t, e, i) {
                                this._lBlock = t[e],
                                this._rBlock = t[e + 1],
                                u.call(this, 4, 252645135),
                                u.call(this, 16, 65535),
                                d.call(this, 2, 858993459),
                                d.call(this, 8, 16711935),
                                u.call(this, 1, 1431655765);
                                for (var r = 0; r < 16; r++) {
                                    for (var o = i[r], n = this._lBlock, s = this._rBlock, a = 0, h = 0; h < 8; h++)
                                        a |= l[h][((s ^ o[h]) & c[h]) >>> 0];
                                    this._lBlock = s,
                                    this._rBlock = n ^ a;
                                }
                                var f = this._lBlock;
                                this._lBlock = this._rBlock,
                                this._rBlock = f,
                                u.call(this, 1, 1431655765),
                                d.call(this, 8, 16711935),
                                d.call(this, 2, 858993459),
                                u.call(this, 16, 65535),
                                u.call(this, 4, 252645135),
                                t[e] = this._lBlock,
                                t[e + 1] = this._rBlock;
                            },
                            keySize: 2,
                            ivSize: 2,
                            blockSize: 2
                        });
                        function u(t, e) {
                            var i = (this._lBlock >>> t ^ this._rBlock) & e;
                            this._rBlock ^= i,
                            this._lBlock ^= i << t;
                        }
                        function d(t, e) {
                            var i = (this._rBlock >>> t ^ this._lBlock) & e;
                            this._lBlock ^= i,
                            this._rBlock ^= i << t;
                        }
                        t.DES = r._createHelper(h);
                        var f = o.TripleDES = r.extend({
                            _doReset: function() {
                                var t = this._key.words;
                                this._des1 = h.createEncryptor(i.create(t.slice(0, 2))),
                                this._des2 = h.createEncryptor(i.create(t.slice(2, 4))),
                                this._des3 = h.createEncryptor(i.create(t.slice(4, 6)));
                            },
                            encryptBlock: function(t, e) {
                                this._des1.encryptBlock(t, e),
                                this._des2.decryptBlock(t, e),
                                this._des3.encryptBlock(t, e);
                            },
                            decryptBlock: function(t, e) {
                                this._des3.decryptBlock(t, e),
                                this._des2.encryptBlock(t, e),
                                this._des1.decryptBlock(t, e);
                            },
                            keySize: 6,
                            ivSize: 2,
                            blockSize: 2
                        });
                        t.TripleDES = r._createHelper(f);
                    }(),
                    function() {
                        var t = Pt
                          , e = t.lib.StreamCipher
                          , i = t.algo
                          , r = i.RC4 = e.extend({
                            _doReset: function() {
                                for (var t = this._key, e = t.words, i = t.sigBytes, r = this._S = [], o = 0; o < 256; o++)
                                    r[o] = o;
                                o = 0;
                                for (var n = 0; o < 256; o++) {
                                    var s = o % i
                                      , a = r[o];
                                    r[o] = r[n = (n + r[o] + (e[s >>> 2] >>> 24 - s % 4 * 8 & 255)) % 256],
                                    r[n] = a;
                                }
                                this._i = this._j = 0;
                            },
                            _doProcessBlock: function(t, e) {
                                t[e] ^= o.call(this);
                            },
                            keySize: 8,
                            ivSize: 0
                        });
                        function o() {
                            for (var t = this._S, e = this._i, i = this._j, r = 0, o = 0; o < 4; o++) {
                                i = (i + t[e = (e + 1) % 256]) % 256;
                                var n = t[e];
                                t[e] = t[i],
                                t[i] = n,
                                r |= t[(t[e] + t[i]) % 256] << 24 - 8 * o;
                            }
                            return this._i = e,
                            this._j = i,
                            r
                        }
                        t.RC4 = e._createHelper(r);
                        var n = i.RC4Drop = r.extend({
                            cfg: r.cfg.extend({
                                drop: 192
                            }),
                            _doReset: function() {
                                r._doReset.call(this);
                                for (var t = this.cfg.drop; 0 < t; t--)
                                    o.call(this);
                            }
                        });
                        t.RC4Drop = e._createHelper(n);
                    }(),
                    Pt.mode.CTRGladman = (mt = (pt = Pt.lib.BlockCipherMode.extend()).Encryptor = pt.extend({
                        processBlock: function(t, e) {
                            var i, r = this._cipher, o = r.blockSize, n = this._iv, s = this._counter;
                            n && (s = this._counter = n.slice(0),
                            this._iv = void 0),
                            0 === ((i = s)[0] = Ot(i[0])) && (i[1] = Ot(i[1]));
                            var a = s.slice(0);
                            r.encryptBlock(a, 0);
                            for (var l = 0; l < o; l++)
                                t[e + l] ^= a[l];
                        }
                    }),
                    pt.Decryptor = mt,
                    pt),
                    vt = (gt = Pt).lib.StreamCipher,
                    yt = [],
                    bt = [],
                    xt = [],
                    wt = gt.algo.Rabbit = vt.extend({
                        _doReset: function() {
                            for (var t = this._key.words, e = this.cfg.iv, i = 0; i < 4; i++)
                                t[i] = 16711935 & (t[i] << 8 | t[i] >>> 24) | 4278255360 & (t[i] << 24 | t[i] >>> 8);
                            var r = this._X = [t[0], t[3] << 16 | t[2] >>> 16, t[1], t[0] << 16 | t[3] >>> 16, t[2], t[1] << 16 | t[0] >>> 16, t[3], t[2] << 16 | t[1] >>> 16]
                              , o = this._C = [t[2] << 16 | t[2] >>> 16, 4294901760 & t[0] | 65535 & t[1], t[3] << 16 | t[3] >>> 16, 4294901760 & t[1] | 65535 & t[2], t[0] << 16 | t[0] >>> 16, 4294901760 & t[2] | 65535 & t[3], t[1] << 16 | t[1] >>> 16, 4294901760 & t[3] | 65535 & t[0]];
                            for (i = this._b = 0; i < 4; i++)
                                Ft.call(this);
                            for (i = 0; i < 8; i++)
                                o[i] ^= r[i + 4 & 7];
                            if (e) {
                                var n = e.words
                                  , s = n[0]
                                  , a = n[1]
                                  , l = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8)
                                  , c = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8)
                                  , h = l >>> 16 | 4294901760 & c
                                  , u = c << 16 | 65535 & l;
                                for (o[0] ^= l,
                                o[1] ^= h,
                                o[2] ^= c,
                                o[3] ^= u,
                                o[4] ^= l,
                                o[5] ^= h,
                                o[6] ^= c,
                                o[7] ^= u,
                                i = 0; i < 4; i++)
                                    Ft.call(this);
                            }
                        },
                        _doProcessBlock: function(t, e) {
                            var i = this._X;
                            Ft.call(this),
                            yt[0] = i[0] ^ i[5] >>> 16 ^ i[3] << 16,
                            yt[1] = i[2] ^ i[7] >>> 16 ^ i[5] << 16,
                            yt[2] = i[4] ^ i[1] >>> 16 ^ i[7] << 16,
                            yt[3] = i[6] ^ i[3] >>> 16 ^ i[1] << 16;
                            for (var r = 0; r < 4; r++)
                                yt[r] = 16711935 & (yt[r] << 8 | yt[r] >>> 24) | 4278255360 & (yt[r] << 24 | yt[r] >>> 8),
                                t[e + r] ^= yt[r];
                        },
                        blockSize: 4,
                        ivSize: 2
                    }),
                    gt.Rabbit = vt._createHelper(wt),
                    Pt.mode.CTR = (Et = (Tt = Pt.lib.BlockCipherMode.extend()).Encryptor = Tt.extend({
                        processBlock: function(t, e) {
                            var i = this._cipher
                              , r = i.blockSize
                              , o = this._iv
                              , n = this._counter;
                            o && (n = this._counter = o.slice(0),
                            this._iv = void 0);
                            var s = n.slice(0);
                            i.encryptBlock(s, 0),
                            n[r - 1] = n[r - 1] + 1 | 0;
                            for (var a = 0; a < r; a++)
                                t[e + a] ^= s[a];
                        }
                    }),
                    Tt.Decryptor = Et,
                    Tt),
                    Ct = (St = Pt).lib.StreamCipher,
                    At = [],
                    Mt = [],
                    It = [],
                    zt = St.algo.RabbitLegacy = Ct.extend({
                        _doReset: function() {
                            for (var t = this._key.words, e = this.cfg.iv, i = this._X = [t[0], t[3] << 16 | t[2] >>> 16, t[1], t[0] << 16 | t[3] >>> 16, t[2], t[1] << 16 | t[0] >>> 16, t[3], t[2] << 16 | t[1] >>> 16], r = this._C = [t[2] << 16 | t[2] >>> 16, 4294901760 & t[0] | 65535 & t[1], t[3] << 16 | t[3] >>> 16, 4294901760 & t[1] | 65535 & t[2], t[0] << 16 | t[0] >>> 16, 4294901760 & t[2] | 65535 & t[3], t[1] << 16 | t[1] >>> 16, 4294901760 & t[3] | 65535 & t[0]], o = this._b = 0; o < 4; o++)
                                Ut.call(this);
                            for (o = 0; o < 8; o++)
                                r[o] ^= i[o + 4 & 7];
                            if (e) {
                                var n = e.words
                                  , s = n[0]
                                  , a = n[1]
                                  , l = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8)
                                  , c = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8)
                                  , h = l >>> 16 | 4294901760 & c
                                  , u = c << 16 | 65535 & l;
                                for (r[0] ^= l,
                                r[1] ^= h,
                                r[2] ^= c,
                                r[3] ^= u,
                                r[4] ^= l,
                                r[5] ^= h,
                                r[6] ^= c,
                                r[7] ^= u,
                                o = 0; o < 4; o++)
                                    Ut.call(this);
                            }
                        },
                        _doProcessBlock: function(t, e) {
                            var i = this._X;
                            Ut.call(this),
                            At[0] = i[0] ^ i[5] >>> 16 ^ i[3] << 16,
                            At[1] = i[2] ^ i[7] >>> 16 ^ i[5] << 16,
                            At[2] = i[4] ^ i[1] >>> 16 ^ i[7] << 16,
                            At[3] = i[6] ^ i[3] >>> 16 ^ i[1] << 16;
                            for (var r = 0; r < 4; r++)
                                At[r] = 16711935 & (At[r] << 8 | At[r] >>> 24) | 4278255360 & (At[r] << 24 | At[r] >>> 8),
                                t[e + r] ^= At[r];
                        },
                        blockSize: 4,
                        ivSize: 2
                    }),
                    St.RabbitLegacy = Ct._createHelper(zt),
                    Pt.pad.ZeroPadding = {
                        pad: function(t, e) {
                            var i = 4 * e;
                            t.clamp(),
                            t.sigBytes += i - (t.sigBytes % i || i);
                        },
                        unpad: function(t) {
                            for (var e = t.words, i = t.sigBytes - 1; !(e[i >>> 2] >>> 24 - i % 4 * 8 & 255); )
                                i--;
                            t.sigBytes = i + 1;
                        }
                    },
                    Pt
                }()
                  , o = null
                  , n = (o || (function(t) {
                    !function() {
                        function e(t, e) {
                            return t << (e %= 32) | t >>> 32 - e
                        }
                        function i(t) {
                            return s[(4026531840 & t) >>> 28][(251658240 & t) >>> 24] << 24 | s[(15728640 & t) >>> 20][(983040 & t) >>> 16] << 16 | s[(61440 & t) >>> 12][(3840 & t) >>> 8] << 8 | s[(240 & t) >>> 4][(15 & t) >>> 0] << 0
                        }
                        var r = t
                          , o = r.lib.BlockCipher
                          , n = r.algo
                          , s = new Array;
                        s[0] = new Array(214,144,233,254,204,225,61,183,22,182,20,194,40,251,44,5),
                        s[1] = new Array(43,103,154,118,42,190,4,195,170,68,19,38,73,134,6,153),
                        s[2] = new Array(156,66,80,244,145,239,152,122,51,84,11,67,237,207,172,98),
                        s[3] = new Array(228,179,28,169,201,8,232,149,128,223,148,250,117,143,63,166),
                        s[4] = new Array(71,7,167,252,243,115,23,186,131,89,60,25,230,133,79,168),
                        s[5] = new Array(104,107,129,178,113,100,218,139,248,235,15,75,112,86,157,53),
                        s[6] = new Array(30,36,14,94,99,88,209,162,37,34,124,59,1,33,120,135),
                        s[7] = new Array(212,0,70,87,159,211,39,82,76,54,2,231,160,196,200,158),
                        s[8] = new Array(234,191,138,210,64,199,56,181,163,247,242,206,249,97,21,161),
                        s[9] = new Array(224,174,93,164,155,52,26,85,173,147,50,48,245,140,177,227),
                        s[10] = new Array(29,246,226,46,130,102,202,96,192,41,35,171,13,83,78,111),
                        s[11] = new Array(213,219,55,69,222,253,142,47,3,255,106,114,109,108,91,81),
                        s[12] = new Array(141,27,175,146,187,221,188,127,17,217,92,65,31,16,90,216),
                        s[13] = new Array(10,193,49,136,165,205,123,189,45,116,208,18,184,229,180,176),
                        s[14] = new Array(137,105,151,74,12,150,119,126,101,185,241,9,197,110,198,132),
                        s[15] = new Array(24,240,125,236,58,220,77,32,121,238,95,62,215,203,57,72);
                        var a = [462357, 472066609, 943670861, 1415275113, 1886879365, 2358483617, 2830087869, 3301692121, 3773296373, 4228057617, 404694573, 876298825, 1347903077, 1819507329, 2291111581, 2762715833, 3234320085, 3705924337, 4177462797, 337322537, 808926789, 1280531041, 1752135293, 2223739545, 2695343797, 3166948049, 3638552301, 4110090761, 269950501, 741554753, 1213159005, 1684763257]
                          , l = [2746333894, 1453994832, 1736282519, 2993693404]
                          , c = n.SM4 = o.extend({
                            _doReset: function() {
                                for (var t = function(t) {
                                    var r = new Array
                                      , o = new Array;
                                    r[0] = t[0] ^ l[0],
                                    r[1] = t[1] ^ l[1],
                                    r[2] = t[2] ^ l[2],
                                    r[3] = t[3] ^ l[3];
                                    for (var n, s = 0; s < 32; s++)
                                        r[s + 4] = r[s] ^ (n = i(n = r[s + 1] ^ r[s + 2] ^ r[s + 3] ^ a[s])) ^ e(n, 13) ^ e(n, 23),
                                        o[s] = r[s + 4].toString(16);
                                    return o
                                }(this._key.words), r = this._SK = [], o = 0; o < t.length; o++)
                                    r[o] = t[o];
                                var n = this._invSK = [];
                                for (o = t.length - 1; 0 <= o; o--)
                                    n[t.length - 1 - o] = t[o];
                            },
                            encryptBlock: function(t, e) {
                                this._doCryptBlock(t, e, this._SK);
                            },
                            decryptBlock: function(t, e) {
                                this._doCryptBlock(t, e, this._invSK);
                            },
                            _doCryptBlock: function(t, r, o) {
                                var n = [];
                                n[0] = t[r],
                                n[1] = t[r + 1],
                                n[2] = t[r + 2],
                                n[3] = t[r + 3];
                                for (var s, a = 0; a < 32; a++)
                                    n[a + 4] = n[a] ^ (s = i(s = n[a + 1] ^ n[a + 2] ^ n[a + 3] ^ parseInt(o[a], 16))) ^ e(s, 2) ^ e(s, 10) ^ e(s, 18) ^ e(s, 24);
                                t[r] = n[35],
                                t[r + 1] = n[34],
                                t[r + 2] = n[33],
                                t[r + 3] = n[32];
                            },
                            keySize: 4,
                            ivSize: 4,
                            blockSize: 4
                        });
                        r.SM4 = o._createHelper(c);
                    }();
                }(r),
                o = r.SM4),
                o)
                  , s = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
                function a(t, e) {
                    return t(e = {
                        exports: {}
                    }, e.exports),
                    e.exports
                }
                var l = a((function(t) {
                    var e, i;
                    e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
                    i = {
                        rotl: function(t, e) {
                            return t << e | t >>> 32 - e
                        },
                        rotr: function(t, e) {
                            return t << 32 - e | t >>> e
                        },
                        endian: function(t) {
                            if (t.constructor == Number)
                                return 16711935 & i.rotl(t, 8) | 4278255360 & i.rotl(t, 24);
                            for (var e = 0; e < t.length; e++)
                                t[e] = i.endian(t[e]);
                            return t
                        },
                        randomBytes: function(t) {
                            for (var e = []; 0 < t; t--)
                                e.push(Math.floor(256 * Math.random()));
                            return e
                        },
                        bytesToWords: function(t) {
                            for (var e = [], i = 0, r = 0; i < t.length; i++,
                            r += 8)
                                e[r >>> 5] |= t[i] << 24 - r % 32;
                            return e
                        },
                        wordsToBytes: function(t) {
                            for (var e = [], i = 0; i < 32 * t.length; i += 8)
                                e.push(t[i >>> 5] >>> 24 - i % 32 & 255);
                            return e
                        },
                        bytesToHex: function(t) {
                            for (var e = [], i = 0; i < t.length; i++)
                                e.push((t[i] >>> 4).toString(16)),
                                e.push((15 & t[i]).toString(16));
                            return e.join("")
                        },
                        hexToBytes: function(t) {
                            for (var e = [], i = 0; i < t.length; i += 2)
                                e.push(parseInt(t.substr(i, 2), 16));
                            return e
                        },
                        bytesToBase64: function(t) {
                            for (var i = [], r = 0; r < t.length; r += 3)
                                for (var o = t[r] << 16 | t[r + 1] << 8 | t[r + 2], n = 0; n < 4; n++)
                                    i.push(8 * r + 6 * n <= 8 * t.length ? e.charAt(o >>> 6 * (3 - n) & 63) : "=");
                            return i.join("")
                        },
                        base64ToBytes: function(t) {
                            t = t.replace(/[^A-Z0-9+\/]/gi, "");
                            for (var i = [], r = 0, o = 0; r < t.length; o = ++r % 4)
                                0 != o && i.push((e.indexOf(t.charAt(r - 1)) & Math.pow(2, -2 * o + 8) - 1) << 2 * o | e.indexOf(t.charAt(r)) >>> 6 - 2 * o);
                            return i
                        }
                    },
                    t.exports = i;
                }
                ))
                  , c = {
                    utf8: {
                        stringToBytes: function(t) {
                            return c.bin.stringToBytes(unescape(encodeURIComponent(t)))
                        },
                        bytesToString: function(t) {
                            return decodeURIComponent(escape(c.bin.bytesToString(t)))
                        }
                    },
                    bin: {
                        stringToBytes: function(t) {
                            for (var e = [], i = 0; i < t.length; i++)
                                e.push(255 & t.charCodeAt(i));
                            return e
                        },
                        bytesToString: function(t) {
                            for (var e = [], i = 0; i < t.length; i++)
                                e.push(String.fromCharCode(t[i]));
                            return e.join("")
                        }
                    }
                }
                  , h = c
                  , u = function(t) {
                    return null != t && (d(t) || "function" == typeof (e = t).readFloatLE && "function" == typeof e.slice && d(e.slice(0, 0)) || !!t._isBuffer);
                    var e;
                };
                function d(t) {
                    return !!t.constructor && "function" == typeof t.constructor.isBuffer && t.constructor.isBuffer(t)
                }
                var f = a((function(t) {
                    var e, i, r, o, n;
                    e = l,
                    i = h.utf8,
                    r = u,
                    o = h.bin,
                    (n = function(t, s) {
                        t.constructor == String ? t = s && "binary" === s.encoding ? o.stringToBytes(t) : i.stringToBytes(t) : r(t) ? t = Array.prototype.slice.call(t, 0) : Array.isArray(t) || (t = t.toString());
                        for (var a = e.bytesToWords(t), l = 8 * t.length, c = 1732584193, h = -271733879, u = -1732584194, d = 271733878, f = 0; f < a.length; f++)
                            a[f] = 16711935 & (a[f] << 8 | a[f] >>> 24) | 4278255360 & (a[f] << 24 | a[f] >>> 8);
                        a[l >>> 5] |= 128 << l % 32,
                        a[14 + (64 + l >>> 9 << 4)] = l;
                        var _ = n._ff
                          , p = n._gg
                          , m = n._hh
                          , g = n._ii;
                        for (f = 0; f < a.length; f += 16) {
                            var v = c
                              , y = h
                              , b = u
                              , x = d;
                            c = _(c, h, u, d, a[f + 0], 7, -680876936),
                            d = _(d, c, h, u, a[f + 1], 12, -389564586),
                            u = _(u, d, c, h, a[f + 2], 17, 606105819),
                            h = _(h, u, d, c, a[f + 3], 22, -1044525330),
                            c = _(c, h, u, d, a[f + 4], 7, -176418897),
                            d = _(d, c, h, u, a[f + 5], 12, 1200080426),
                            u = _(u, d, c, h, a[f + 6], 17, -1473231341),
                            h = _(h, u, d, c, a[f + 7], 22, -45705983),
                            c = _(c, h, u, d, a[f + 8], 7, 1770035416),
                            d = _(d, c, h, u, a[f + 9], 12, -1958414417),
                            u = _(u, d, c, h, a[f + 10], 17, -42063),
                            h = _(h, u, d, c, a[f + 11], 22, -1990404162),
                            c = _(c, h, u, d, a[f + 12], 7, 1804603682),
                            d = _(d, c, h, u, a[f + 13], 12, -40341101),
                            u = _(u, d, c, h, a[f + 14], 17, -1502002290),
                            c = p(c, h = _(h, u, d, c, a[f + 15], 22, 1236535329), u, d, a[f + 1], 5, -165796510),
                            d = p(d, c, h, u, a[f + 6], 9, -1069501632),
                            u = p(u, d, c, h, a[f + 11], 14, 643717713),
                            h = p(h, u, d, c, a[f + 0], 20, -373897302),
                            c = p(c, h, u, d, a[f + 5], 5, -701558691),
                            d = p(d, c, h, u, a[f + 10], 9, 38016083),
                            u = p(u, d, c, h, a[f + 15], 14, -660478335),
                            h = p(h, u, d, c, a[f + 4], 20, -405537848),
                            c = p(c, h, u, d, a[f + 9], 5, 568446438),
                            d = p(d, c, h, u, a[f + 14], 9, -1019803690),
                            u = p(u, d, c, h, a[f + 3], 14, -187363961),
                            h = p(h, u, d, c, a[f + 8], 20, 1163531501),
                            c = p(c, h, u, d, a[f + 13], 5, -1444681467),
                            d = p(d, c, h, u, a[f + 2], 9, -51403784),
                            u = p(u, d, c, h, a[f + 7], 14, 1735328473),
                            c = m(c, h = p(h, u, d, c, a[f + 12], 20, -1926607734), u, d, a[f + 5], 4, -378558),
                            d = m(d, c, h, u, a[f + 8], 11, -2022574463),
                            u = m(u, d, c, h, a[f + 11], 16, 1839030562),
                            h = m(h, u, d, c, a[f + 14], 23, -35309556),
                            c = m(c, h, u, d, a[f + 1], 4, -1530992060),
                            d = m(d, c, h, u, a[f + 4], 11, 1272893353),
                            u = m(u, d, c, h, a[f + 7], 16, -155497632),
                            h = m(h, u, d, c, a[f + 10], 23, -1094730640),
                            c = m(c, h, u, d, a[f + 13], 4, 681279174),
                            d = m(d, c, h, u, a[f + 0], 11, -358537222),
                            u = m(u, d, c, h, a[f + 3], 16, -722521979),
                            h = m(h, u, d, c, a[f + 6], 23, 76029189),
                            c = m(c, h, u, d, a[f + 9], 4, -640364487),
                            d = m(d, c, h, u, a[f + 12], 11, -421815835),
                            u = m(u, d, c, h, a[f + 15], 16, 530742520),
                            c = g(c, h = m(h, u, d, c, a[f + 2], 23, -995338651), u, d, a[f + 0], 6, -198630844),
                            d = g(d, c, h, u, a[f + 7], 10, 1126891415),
                            u = g(u, d, c, h, a[f + 14], 15, -1416354905),
                            h = g(h, u, d, c, a[f + 5], 21, -57434055),
                            c = g(c, h, u, d, a[f + 12], 6, 1700485571),
                            d = g(d, c, h, u, a[f + 3], 10, -1894986606),
                            u = g(u, d, c, h, a[f + 10], 15, -1051523),
                            h = g(h, u, d, c, a[f + 1], 21, -2054922799),
                            c = g(c, h, u, d, a[f + 8], 6, 1873313359),
                            d = g(d, c, h, u, a[f + 15], 10, -30611744),
                            u = g(u, d, c, h, a[f + 6], 15, -1560198380),
                            h = g(h, u, d, c, a[f + 13], 21, 1309151649),
                            c = g(c, h, u, d, a[f + 4], 6, -145523070),
                            d = g(d, c, h, u, a[f + 11], 10, -1120210379),
                            u = g(u, d, c, h, a[f + 2], 15, 718787259),
                            h = g(h, u, d, c, a[f + 9], 21, -343485551),
                            c = c + v >>> 0,
                            h = h + y >>> 0,
                            u = u + b >>> 0,
                            d = d + x >>> 0;
                        }
                        return e.endian([c, h, u, d])
                    }
                    )._ff = function(t, e, i, r, o, n, s) {
                        var a = t + (e & i | ~e & r) + (o >>> 0) + s;
                        return (a << n | a >>> 32 - n) + e
                    }
                    ,
                    n._gg = function(t, e, i, r, o, n, s) {
                        var a = t + (e & r | i & ~r) + (o >>> 0) + s;
                        return (a << n | a >>> 32 - n) + e
                    }
                    ,
                    n._hh = function(t, e, i, r, o, n, s) {
                        var a = t + (e ^ i ^ r) + (o >>> 0) + s;
                        return (a << n | a >>> 32 - n) + e
                    }
                    ,
                    n._ii = function(t, e, i, r, o, n, s) {
                        var a = t + (i ^ (e | ~r)) + (o >>> 0) + s;
                        return (a << n | a >>> 32 - n) + e
                    }
                    ,
                    n._blocksize = 16,
                    n._digestsize = 16,
                    t.exports = function(t, i) {
                        if (null == t)
                            throw new Error("Illegal argument " + t);
                        var r = e.wordsToBytes(n(t, i));
                        return i && i.asBytes ? r : i && i.asString ? o.bytesToString(r) : e.bytesToHex(r)
                    }
                    ;
                }
                ));
                function _() {}
                function p(t, e, i, r, o) {
                    for (var n, s = (n = e + o > t.length && r + o <= i.length ? t.length - e : r + o > i.length && e + o <= t.length ? i.length - r : e + o <= t.length && r + o <= i.length ? o : i.length < t.length ? i.length - r : t.length - r,
                    0); s < n; s++)
                        i[s + r] = t[s + e];
                }
                function m(t) {
                    for (var e, i = new Array(4 * t.length), r = 0; r < t.length; r++)
                        p((e = t[r],
                        new Array(e >> 24 & 255,e >> 16 & 255,e >> 8 & 255,255 & e)), 0, i, 4 * r, 4);
                    return i
                }
                function g(t) {
                    for (var e = Math.ceil(t.length / 4), i = new Array(e), r = 0; r < t.length; r++)
                        t[r] = 255 & t[r];
                    var o, n;
                    for (r = 0; r < i.length; r++)
                        i[r] = 3 + (n = 4 * r) < (o = t).length ? o[n] << 24 | o[n + 1] << 16 | o[n + 2] << 8 | o[n + 3] : n + 2 < o.length ? o[n + 1] << 16 | o[n + 2] << 8 | o[n + 3] : n + 1 < o.length ? o[n] << 8 | o[n + 1] : o[n];
                    return i
                }
                function v() {
                    this.ivByte = new Array(115,128,22,111,73,20,178,185,23,36,66,215,218,138,6,0,169,111,48,188,22,49,56,170,227,141,238,77,176,251,14,78),
                    this.iv = g(this.ivByte),
                    this.tj = new Array(64),
                    this.BLOCK_BYTE_LEN = 64,
                    this.vbuf = new Array(8),
                    this.dataBuf = new Array(64),
                    this.dataBufLen = 0;
                    for (var t = this.totalLen = 0; t < 64; t++)
                        this.tj[t] = t <= 15 ? 2043430169 : 2055708042;
                    p(this.iv, 0, this.vbuf, 0, this.vbuf.length);
                }
                _.encode = function(t, e, i) {
                    for (var r = new Array(2 * i), o = new Array("0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"), n = e, s = 0; n < i + e; n++,
                    s++)
                        r[s] = o[(255 & t[n]) >> 4],
                        r[++s] = o[15 & t[n]];
                    return r.join("")
                }
                ,
                _.decode = function(t) {
                    if (null == t || "" == t)
                        return null;
                    if (t.length % 2 != 0)
                        return null;
                    for (var e = t.length / 2, i = this.toCharCodeArray(t), r = new Array(e), o = 0; o < e; o++) {
                        if (48 <= i[2 * o] && i[2 * o] <= 57)
                            r[o] = i[2 * o] - 48 << 4;
                        else if (65 <= i[2 * o] && i[2 * o] <= 70)
                            r[o] = i[2 * o] - 65 + 10 << 4;
                        else {
                            if (!(97 <= i[2 * o] && i[2 * o] <= 102))
                                return null;
                            r[o] = i[2 * o] - 97 + 10 << 4;
                        }
                        if (48 <= i[2 * o + 1] && i[2 * o + 1] <= 57)
                            r[o] = r[o] | i[2 * o + 1] - 48;
                        else if (65 <= i[2 * o + 1] && i[2 * o + 1] <= 70)
                            r[o] = r[o] | i[2 * o + 1] - 65 + 10;
                        else {
                            if (!(97 <= i[2 * o + 1] && i[2 * o + 1] <= 102))
                                return null;
                            r[o] = r[o] | i[2 * o + 1] - 97 + 10;
                        }
                    }
                    return r
                }
                ,
                _.utf8StrToHex = function(t) {
                    for (var e = encodeURIComponent(t), i = unescape(e), r = i.length, o = [], n = 0; n < r; n++)
                        o[n] = i.charCodeAt(n).toString(16);
                    return o.join("")
                }
                ,
                _.utf8StrToBytes = function(t) {
                    for (var e = encodeURIComponent(t), i = unescape(e), r = i.length, o = [], n = 0; n < r; n++)
                        o[n] = i.charCodeAt(n);
                    return o
                }
                ,
                _.hexToUtf8Str = function(t) {
                    for (var e = _.decode(t), i = [], r = 0; r < e.length; r++)
                        i.push(String.fromCharCode(e[r]));
                    return decodeURIComponent(escape(i.join("")))
                }
                ,
                _.bytesToUtf8Str = function(t) {
                    for (var e = t, i = [], r = 0; r < e.length; r++)
                        i.push(String.fromCharCode(e[r]));
                    return decodeURIComponent(escape(i.join("")))
                }
                ,
                _.toCharCodeArray = function(t) {
                    for (var e = new Array(t.length), i = 0; i < t.length; i++)
                        e[i] = t.charCodeAt(i);
                    return e
                }
                ,
                v.prototype = {
                    ffj: function(t, e, i, r) {
                        return r <= 15 ? t ^ e ^ i : t & e | t & i | e & i
                    },
                    ggj: function(t, e, i, r) {
                        return r <= 15 ? t ^ e ^ i : t & e | ~t & i
                    },
                    p0: function(t) {
                        return t ^ (t << 9 | t >>> 23) ^ (t << 17 | t >>> 15)
                    },
                    p1: function(t) {
                        return t ^ (t << 15 | t >>> 17) ^ (t << 23 | t >>> 9)
                    },
                    cycleLeft: function(t, e) {
                        return t << e | t >>> 32 - e
                    },
                    padding: function(t) {
                        var e, i, r = 0, o = t.length;
                        return 64 <= (r = 64 - (o + 1 + 8) % 64) && (r = 0),
                        (e = new Array(r + 1 + o + 8))[o] = 128,
                        p(t, 0, e, 0, o),
                        p((i = this.totalLen << 3,
                        new Array(0,0,0,0,i >> 24 & 255,i >> 16 & 255,i >> 8 & 255,255 & i)), 0, e, o + r + 1, 8),
                        e
                    },
                    iterate: function(t) {
                        for (var e, i = parseInt(t.length / 16), r = this.vbuf, o = new Array(16), n = 0; n < i; n++)
                            p(t, 16 * n, o, 0, o.length),
                            e = this.expand(o),
                            r = this.cf(r, e[0], e[1]);
                        p(r, 0, this.vbuf, 0, r.length);
                    },
                    expand: function(t) {
                        var e = new Array(68)
                          , i = new Array(64);
                        p(t, 0, e, 0, t.length);
                        for (var r = 16; r < e.length; r++)
                            e[r] = this.p1(e[r - 16] ^ e[r - 9] ^ this.cycleLeft(e[r - 3], 15)) ^ this.cycleLeft(e[r - 13], 7) ^ e[r - 6];
                        for (r = 0; r < i.length; r++)
                            i[r] = e[r] ^ e[r + 4];
                        return new Array(e,i)
                    },
                    cf: function(t, e, i) {
                        for (var r, o, n, s, a, l = t[0], c = t[1], h = t[2], u = t[3], d = t[4], f = t[5], _ = t[6], p = t[7], m = 0; m < 64; m++)
                            n = (o = this.cycleLeft(this.cycleLeft(l, 12) + d + this.cycleLeft(this.tj[m], m), 7)) ^ this.cycleLeft(l, 12),
                            s = this.ffj(l, c, h, m) + u + n + i[m],
                            a = this.ggj(d, f, _, m) + p + o + e[m],
                            u = h,
                            h = this.cycleLeft(c, 9),
                            c = l,
                            l = s,
                            p = _,
                            _ = this.cycleLeft(f, 19),
                            f = d,
                            d = this.p0(a);
                        return (r = new Array(8))[0] = l ^ t[0],
                        r[1] = c ^ t[1],
                        r[2] = h ^ t[2],
                        r[3] = u ^ t[3],
                        r[4] = d ^ t[4],
                        r[5] = f ^ t[5],
                        r[6] = _ ^ t[6],
                        r[7] = p ^ t[7],
                        r
                    },
                    digest: function(t) {
                        var e = g(this.padding(t));
                        return this.iterate(e),
                        m(this.vbuf)
                    },
                    update: function(t, e, i) {
                        var r, o = parseInt((i + this.dataBufLen) / 64);
                        if (this.totalLen += i,
                        i + this.dataBufLen < this.BLOCK_BYTE_LEN)
                            p(t, 0, this.dataBuf, this.dataBufLen, i),
                            this.dataBufLen = i + this.dataBufLen;
                        else {
                            p(t, 0, this.dataBuf, this.dataBufLen, this.BLOCK_BYTE_LEN - this.dataBufLen),
                            r = g(this.dataBuf),
                            this.iterate(r);
                            for (var n = 1; n < o; n++)
                                p(t, n * this.BLOCK_BYTE_LEN - this.dataBufLen, this.dataBuf, 0, this.BLOCK_BYTE_LEN),
                                r = g(this.dataBuf),
                                this.iterate(r);
                            p(t, o * this.BLOCK_BYTE_LEN - this.dataBufLen, this.dataBuf, 0, i - (o * this.BLOCK_BYTE_LEN - this.dataBufLen)),
                            this.dataBufLen = i - (o * this.BLOCK_BYTE_LEN - this.dataBufLen);
                        }
                    },
                    doFinal: function() {
                        var t = new Array(this.dataBufLen);
                        p(this.dataBuf, 0, t, 0, this.dataBufLen);
                        var e = g(this.padding(t));
                        return this.iterate(e),
                        m(this.vbuf)
                    }
                };
                var y = function(t) {
                    return f(t)
                }
                  , b = function(t) {
                    var e = _.utf8StrToBytes(t)
                      , i = new v;
                    i.update(e, 0, e.length);
                    var r = i.doFinal();
                    return _.encode(r, 0, r.length).toLocaleLowerCase()
                }
                  , x = function(t, e) {
                    if (!r)
                        return null;
                    var i = r.enc.Utf8.parse(e);
                    return n.encrypt(r.enc.Utf8.parse(t), i, {
                        mode: r.mode.ECB,
                        padding: r.pad.Pkcs7
                    }).ciphertext.toString(r.enc.Base64)
                }
                  , w = function(t, e) {
                    if (!r)
                        return null;
                    var i = r.enc.Utf8.parse(e);
                    return n.decrypt({
                        ciphertext: r.enc.Base64.parse(t)
                    }, i, {
                        mode: r.mode.ECB,
                        padding: r.pad.Pkcs7
                    }).toString(r.enc.Utf8)
                }
                  , T = function(t) {
                    var e = [];
                    for (var i in t) {
                        var r = t[i];
                        e.push("".concat(i, "=").concat(r));
                    }
                    return e.join("&")
                }
                  , E = function() {
                    return window.SGMap
                }
                  , S = (a((function(t, e) {
                    !function(i, r) {
                        var o = "function"
                          , n = "model"
                          , s = "name"
                          , a = "type"
                          , l = "vendor"
                          , c = "version"
                          , h = "architecture"
                          , u = "console"
                          , d = "mobile"
                          , f = "tablet"
                          , _ = "smarttv"
                          , p = "wearable"
                          , m = {
                            extend: function(t, e) {
                                var i = {};
                                for (var r in t)
                                    i[r] = e[r] && e[r].length % 2 == 0 ? e[r].concat(t[r]) : t[r];
                                return i
                            },
                            has: function(t, e) {
                                return "string" == typeof t && -1 !== e.toLowerCase().indexOf(t.toLowerCase())
                            },
                            lowerize: function(t) {
                                return t.toLowerCase()
                            },
                            major: function(t) {
                                return "string" == typeof t ? t.replace(/[^\d\.]/g, "").split(".")[0] : r
                            },
                            trim: function(t) {
                                return t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
                            }
                        }
                          , g = {
                            rgx: function(t, e) {
                                for (var i, n, s, a, l, c = 0; c < e.length && !a; ) {
                                    for (var h = e[c], u = e[c + 1], d = i = 0; d < h.length && !a; )
                                        if (a = h[d++].exec(t))
                                            for (n = 0; n < u.length; n++)
                                                l = a[++i],
                                                "object" == typeof (s = u[n]) && 0 < s.length ? 2 == s.length ? this[s[0]] = typeof s[1] == o ? s[1].call(this, l) : s[1] : 3 == s.length ? this[s[0]] = typeof s[1] != o || s[1].exec && s[1].test ? l ? l.replace(s[1], s[2]) : r : l ? s[1].call(this, l, s[2]) : r : 4 == s.length && (this[s[0]] = l ? s[3].call(this, l.replace(s[1], s[2])) : r) : this[s] = l || r;
                                    c += 2;
                                }
                            },
                            str: function(t, e) {
                                for (var i in e)
                                    if ("object" == typeof e[i] && 0 < e[i].length) {
                                        for (var o = 0; o < e[i].length; o++)
                                            if (m.has(e[i][o], t))
                                                return "?" === i ? r : i
                                    } else if (m.has(e[i], t))
                                        return "?" === i ? r : i;
                                return t
                            }
                        }
                          , v = {
                            browser: {
                                oldsafari: {
                                    version: {
                                        "1.0": "/8",
                                        1.2: "/1",
                                        1.3: "/3",
                                        "2.0": "/412",
                                        "2.0.2": "/416",
                                        "2.0.3": "/417",
                                        "2.0.4": "/419",
                                        "?": "/"
                                    }
                                }
                            },
                            device: {
                                amazon: {
                                    model: {
                                        "Fire Phone": ["SD", "KF"]
                                    }
                                },
                                sprint: {
                                    model: {
                                        "Evo Shift 4G": "7373KT"
                                    },
                                    vendor: {
                                        HTC: "APA",
                                        Sprint: "Sprint"
                                    }
                                }
                            },
                            os: {
                                windows: {
                                    version: {
                                        ME: "4.90",
                                        "NT 3.11": "NT3.51",
                                        "NT 4.0": "NT4.0",
                                        2e3: "NT 5.0",
                                        XP: ["NT 5.1", "NT 5.2"],
                                        Vista: "NT 6.0",
                                        7: "NT 6.1",
                                        8: "NT 6.2",
                                        8.1: "NT 6.3",
                                        10: ["NT 6.4", "NT 10.0"],
                                        RT: "ARM"
                                    }
                                }
                            }
                        }
                          , y = {
                            browser: [[/(opera\smini)\/([\w\.-]+)/i, /(opera\s[mobiletab]+).+version\/([\w\.-]+)/i, /(opera).+version\/([\w\.]+)/i, /(opera)[\/\s]+([\w\.]+)/i], [s, c], [/(opios)[\/\s]+([\w\.]+)/i], [[s, "Opera Mini"], c], [/\s(opr)\/([\w\.]+)/i], [[s, "Opera"], c], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]*)/i, /(avant\s|iemobile|slim)(?:browser)?[\/\s]?([\w\.]*)/i, /(bidubrowser|baidubrowser)[\/\s]?([\w\.]+)/i, /(?:ms|\()(ie)\s([\w\.]+)/i, /(rekonq)\/([\w\.]*)/i, /(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon)\/([\w\.-]+)/i], [s, c], [/(konqueror)\/([\w\.]+)/i], [[s, "Konqueror"], c], [/(trident).+rv[:\s]([\w\.]+).+like\sgecko/i], [[s, "IE"], c], [/(edge|edgios|edga|edg)\/((\d+)?[\w\.]+)/i], [[s, "Edge"], c], [/(yabrowser)\/([\w\.]+)/i], [[s, "Yandex"], c], [/(Avast)\/([\w\.]+)/i], [[s, "Avast Secure Browser"], c], [/(AVG)\/([\w\.]+)/i], [[s, "AVG Secure Browser"], c], [/(puffin)\/([\w\.]+)/i], [[s, "Puffin"], c], [/(focus)\/([\w\.]+)/i], [[s, "Firefox Focus"], c], [/(opt)\/([\w\.]+)/i], [[s, "Opera Touch"], c], [/((?:[\s\/])uc?\s?browser|(?:juc.+)ucweb)[\/\s]?([\w\.]+)/i], [[s, "UCBrowser"], c], [/(comodo_dragon)\/([\w\.]+)/i], [[s, /_/g, " "], c], [/(windowswechat qbcore)\/([\w\.]+)/i], [[s, "WeChat(Win) Desktop"], c], [/(micromessenger)\/([\w\.]+)/i], [[s, "WeChat"], c], [/(brave)\/([\w\.]+)/i], [[s, "Brave"], c], [/(qqbrowserlite)\/([\w\.]+)/i], [s, c], [/(QQ)\/([\d\.]+)/i], [s, c], [/m?(qqbrowser)[\/\s]?([\w\.]+)/i], [s, c], [/(baiduboxapp)[\/\s]?([\w\.]+)/i], [s, c], [/(2345Explorer)[\/\s]?([\w\.]+)/i], [s, c], [/(MetaSr)[\/\s]?([\w\.]+)/i], [s], [/(LBBROWSER)/i], [s], [/xiaomi\/miuibrowser\/([\w\.]+)/i], [c, [s, "MIUI Browser"]], [/;fbav\/([\w\.]+);/i], [c, [s, "Facebook"]], [/safari\s(line)\/([\w\.]+)/i, /android.+(line)\/([\w\.]+)\/iab/i], [s, c], [/headlesschrome(?:\/([\w\.]+)|\s)/i], [c, [s, "Chrome Headless"]], [/\swv\).+(chrome)\/([\w\.]+)/i], [[s, /(.+)/, "$1 WebView"], c], [/((?:oculus|samsung)browser)\/([\w\.]+)/i], [[s, /(.+(?:g|us))(.+)/, "$1 $2"], c], [/android.+version\/([\w\.]+)\s+(?:mobile\s?safari|safari)*/i], [c, [s, "Android Browser"]], [/(sailfishbrowser)\/([\w\.]+)/i], [[s, "Sailfish Browser"], c], [/(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i], [s, c], [/(dolfin)\/([\w\.]+)/i], [[s, "Dolphin"], c], [/(qihu|qhbrowser|qihoobrowser|360browser)/i], [[s, "360 Browser"]], [/((?:android.+)crmo|crios)\/([\w\.]+)/i], [[s, "Chrome"], c], [/(coast)\/([\w\.]+)/i], [[s, "Opera Coast"], c], [/fxios\/([\w\.-]+)/i], [c, [s, "Firefox"]], [/version\/([\w\.]+).+?mobile\/\w+\s(safari)/i], [c, [s, "Mobile Safari"]], [/version\/([\w\.]+).+?(mobile\s?safari|safari)/i], [c, s], [/webkit.+?(gsa)\/([\w\.]+).+?(mobile\s?safari|safari)(\/[\w\.]+)/i], [[s, "GSA"], c], [/webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i], [s, [c, g.str, v.browser.oldsafari.version]], [/(webkit|khtml)\/([\w\.]+)/i], [s, c], [/(navigator|netscape)\/([\w\.-]+)/i], [[s, "Netscape"], c], [/(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i, /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([\w\.-]+)$/i, /(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i, /(links)\s\(([\w\.]+)/i, /(gobrowser)\/?([\w\.]*)/i, /(ice\s?browser)\/v?([\w\._]+)/i, /(mosaic)[\/\s]([\w\.]+)/i], [s, c]],
                            cpu: [[/(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\)]/i], [[h, "amd64"]], [/(ia32(?=;))/i], [[h, m.lowerize]], [/((?:i[346]|x)86)[;\)]/i], [[h, "ia32"]], [/windows\s(ce|mobile);\sppc;/i], [[h, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?:\smac|;|\))/i], [[h, /ower/, "", m.lowerize]], [/(sun4\w)[;\)]/i], [[h, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|arm(?:64|(?=v\d+[;l]))|(?=atmel\s)avr|(?:irix|mips|sparc)(?:64)?(?=;)|pa-risc)/i], [[h, m.lowerize]]],
                            device: [[/\((ipad|playbook);[\w\s\),;-]+(rim|apple)/i], [n, l, [a, f]], [/applecoremedia\/[\w\.]+ \((ipad)/], [n, [l, "Apple"], [a, f]], [/(apple\s{0,1}tv)/i], [[n, "Apple TV"], [l, "Apple"], [a, _]], [/(archos)\s(gamepad2?)/i, /(hp).+(touchpad)/i, /(hp).+(tablet)/i, /(kindle)\/([\w\.]+)/i, /\s(nook)[\w\s]+build\/(\w+)/i, /(dell)\s(strea[kpr\s\d]*[\dko])/i], [l, n, [a, f]], [/(kf[A-z]+)\sbuild\/.+silk\//i], [n, [l, "Amazon"], [a, f]], [/(sd|kf)[0349hijorstuw]+\sbuild\/.+silk\//i], [[n, g.str, v.device.amazon.model], [l, "Amazon"], [a, d]], [/android.+aft([bms])\sbuild/i], [n, [l, "Amazon"], [a, _]], [/\((ip[honed|\s\w*]+);.+(apple)/i], [n, l, [a, d]], [/\((ip[honed|\s\w*]+);/i], [n, [l, "Apple"], [a, d]], [/(blackberry)[\s-]?(\w+)/i, /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[\s_-]?([\w-]*)/i, /(hp)\s([\w\s]+\w)/i, /(asus)-?(\w+)/i], [l, n, [a, d]], [/\(bb10;\s(\w+)/i], [n, [l, "BlackBerry"], [a, d]], [/android.+(transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus 7|padfone|p00c)/i], [n, [l, "Asus"], [a, f]], [/(sony)\s(tablet\s[ps])\sbuild\//i, /(sony)?(?:sgp.+)\sbuild\//i], [[l, "Sony"], [n, "Xperia Tablet"], [a, f]], [/android.+\s([c-g]\d{4}|so[-l]\w+)(?=\sbuild\/|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [n, [l, "Sony"], [a, d]], [/\s(ouya)\s/i, /(nintendo)\s([wids3u]+)/i], [l, n, [a, u]], [/android.+;\s(shield)\sbuild/i], [n, [l, "Nvidia"], [a, u]], [/(playstation\s[34portablevi]+)/i], [n, [l, "Sony"], [a, u]], [/(sprint\s(\w+))/i], [[l, g.str, v.device.sprint.vendor], [n, g.str, v.device.sprint.model], [a, d]], [/(htc)[;_\s-]+([\w\s]+(?=\)|\sbuild)|\w+)/i, /(zte)-(\w*)/i, /(alcatel|geeksphone|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]*)/i], [l, [n, /_/g, " "], [a, d]], [/(nexus\s9)/i], [n, [l, "HTC"], [a, f]], [/d\/huawei([\w\s-]+)[;\)]/i, /(nexus\s6p|vog-l29|ane-lx1|eml-l29|ele-l29)/i], [n, [l, "Huawei"], [a, d]], [/android.+(bah2?-a?[lw]\d{2})/i], [n, [l, "Huawei"], [a, f]], [/(microsoft);\s(lumia[\s\w]+)/i], [l, n, [a, d]], [/[\s\(;](xbox(?:\sone)?)[\s\);]/i], [n, [l, "Microsoft"], [a, u]], [/(kin\.[onetw]{3})/i], [[n, /\./g, " "], [l, "Microsoft"], [a, d]], [/\s(milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?:?(\s4g)?)[\w\s]+build\//i, /mot[\s-]?(\w*)/i, /(XT\d{3,4}) build\//i, /(nexus\s6)/i], [n, [l, "Motorola"], [a, d]], [/android.+\s(mz60\d|xoom[\s2]{0,2})\sbuild\//i], [n, [l, "Motorola"], [a, f]], [/hbbtv\/\d+\.\d+\.\d+\s+\([\w\s]*;\s*(\w[^;]*);([^;]*)/i], [[l, m.trim], [n, m.trim], [a, _]], [/hbbtv.+maple;(\d+)/i], [[n, /^/, "SmartTV"], [l, "Samsung"], [a, _]], [/\(dtv[\);].+(aquos)/i], [n, [l, "Sharp"], [a, _]], [/android.+((sch-i[89]0\d|shw-m380s|gt-p\d{4}|gt-n\d+|sgh-t8[56]9|nexus 10))/i, /((SM-T\w+))/i], [[l, "Samsung"], n, [a, f]], [/smart-tv.+(samsung)/i], [l, [a, _], n], [/((s[cgp]h-\w+|gt-\w+|galaxy\snexus|sm-\w[\w\d]+))/i, /(sam[sung]*)[\s-]*(\w+-?[\w-]*)/i, /sec-((sgh\w+))/i], [[l, "Samsung"], n, [a, d]], [/sie-(\w*)/i], [n, [l, "Siemens"], [a, d]], [/(maemo|nokia).*(n900|lumia\s\d+)/i, /(nokia)[\s_-]?([\w-]*)/i], [[l, "Nokia"], n, [a, d]], [/android[x\d\.\s;]+\s([ab][1-7]\-?[0178a]\d\d?)/i], [n, [l, "Acer"], [a, f]], [/android.+([vl]k\-?\d{3})\s+build/i], [n, [l, "LG"], [a, f]], [/android\s3\.[\s\w;-]{10}(lg?)-([06cv9]{3,4})/i], [[l, "LG"], n, [a, f]], [/(lg) netcast\.tv/i], [l, n, [a, _]], [/(nexus\s[45])/i, /lg[e;\s\/-]+(\w*)/i, /android.+lg(\-?[\d\w]+)\s+build/i], [n, [l, "LG"], [a, d]], [/(lenovo)\s?(s(?:5000|6000)(?:[\w-]+)|tab(?:[\s\w]+))/i], [l, n, [a, f]], [/android.+(ideatab[a-z0-9\-\s]+)/i], [n, [l, "Lenovo"], [a, f]], [/(lenovo)[_\s-]?([\w-]+)/i], [l, n, [a, d]], [/linux;.+((jolla));/i], [l, n, [a, d]], [/((pebble))app\/[\d\.]+\s/i], [l, n, [a, p]], [/android.+;\s(oppo)\s?([\w\s]+)\sbuild/i], [l, n, [a, d]], [/crkey/i], [[n, "Chromecast"], [l, "Google"], [a, _]], [/android.+;\s(glass)\s\d/i], [n, [l, "Google"], [a, p]], [/android.+;\s(pixel c)[\s)]/i], [n, [l, "Google"], [a, f]], [/android.+;\s(pixel( [23])?( xl)?)[\s)]/i], [n, [l, "Google"], [a, d]], [/android.+;\s(\w+)\s+build\/hm\1/i, /android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i, /android.+(mi[\s\-_]*(?:a\d|one|one[\s_]plus|note lte)?[\s_]*(?:\d?\w?)[\s_]*(?:plus)?)\s+build/i, /android.+(redmi[\s\-_]*(?:note)?(?:[\s_]?[\w\s]+))\s+build/i], [[n, /_/g, " "], [l, "Xiaomi"], [a, d]], [/android.+(mi[\s\-_]*(?:pad)(?:[\s_]?[\w\s]+))\s+build/i], [[n, /_/g, " "], [l, "Xiaomi"], [a, f]], [/android.+;\s(m[1-5]\snote)\sbuild/i], [n, [l, "Meizu"], [a, d]], [/(mz)-([\w-]{2,})/i], [[l, "Meizu"], n, [a, d]], [/android.+a000(1)\s+build/i, /android.+oneplus\s(a\d{4})[\s)]/i], [n, [l, "OnePlus"], [a, d]], [/android.+[;\/]\s*(RCT[\d\w]+)\s+build/i], [n, [l, "RCA"], [a, f]], [/android.+[;\/\s]+(Venue[\d\s]{2,7})\s+build/i], [n, [l, "Dell"], [a, f]], [/android.+[;\/]\s*(Q[T|M][\d\w]+)\s+build/i], [n, [l, "Verizon"], [a, f]], [/android.+[;\/]\s+(Barnes[&\s]+Noble\s+|BN[RT])(V?.*)\s+build/i], [[l, "Barnes & Noble"], n, [a, f]], [/android.+[;\/]\s+(TM\d{3}.*\b)\s+build/i], [n, [l, "NuVision"], [a, f]], [/android.+;\s(k88)\sbuild/i], [n, [l, "ZTE"], [a, f]], [/android.+[;\/]\s*(gen\d{3})\s+build.*49h/i], [n, [l, "Swiss"], [a, d]], [/android.+[;\/]\s*(zur\d{3})\s+build/i], [n, [l, "Swiss"], [a, f]], [/android.+[;\/]\s*((Zeki)?TB.*\b)\s+build/i], [n, [l, "Zeki"], [a, f]], [/(android).+[;\/]\s+([YR]\d{2})\s+build/i, /android.+[;\/]\s+(Dragon[\-\s]+Touch\s+|DT)(\w{5})\sbuild/i], [[l, "Dragon Touch"], n, [a, f]], [/android.+[;\/]\s*(NS-?\w{0,9})\sbuild/i], [n, [l, "Insignia"], [a, f]], [/android.+[;\/]\s*((NX|Next)-?\w{0,9})\s+build/i], [n, [l, "NextBook"], [a, f]], [/android.+[;\/]\s*(Xtreme\_)?(V(1[045]|2[015]|30|40|60|7[05]|90))\s+build/i], [[l, "Voice"], n, [a, d]], [/android.+[;\/]\s*(LVTEL\-)?(V1[12])\s+build/i], [[l, "LvTel"], n, [a, d]], [/android.+;\s(PH-1)\s/i], [n, [l, "Essential"], [a, d]], [/android.+[;\/]\s*(V(100MD|700NA|7011|917G).*\b)\s+build/i], [n, [l, "Envizen"], [a, f]], [/android.+[;\/]\s*(Le[\s\-]+Pan)[\s\-]+(\w{1,9})\s+build/i], [l, n, [a, f]], [/android.+[;\/]\s*(Trio[\s\-]*.*)\s+build/i], [n, [l, "MachSpeed"], [a, f]], [/android.+[;\/]\s*(Trinity)[\-\s]*(T\d{3})\s+build/i], [l, n, [a, f]], [/android.+[;\/]\s*TU_(1491)\s+build/i], [n, [l, "Rotor"], [a, f]], [/android.+(KS(.+))\s+build/i], [n, [l, "Amazon"], [a, f]], [/android.+(Gigaset)[\s\-]+(Q\w{1,9})\s+build/i], [l, n, [a, f]], [/\s(tablet|tab)[;\/]/i, /\s(mobile)(?:[;\/]|\ssafari)/i], [[a, m.lowerize], l, n], [/[\s\/\(](smart-?tv)[;\)]/i], [[a, _]], [/(android[\w\.\s\-]{0,9});.+build/i], [n, [l, "Generic"]]],
                            engine: [[/windows.+\sedge\/([\w\.]+)/i], [c, [s, "EdgeHTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [c, [s, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i, /(icab)[\/\s]([23]\.[\d\.]+)/i], [s, c], [/rv\:([\w\.]{1,9}).+(gecko)/i], [c, s]],
                            os: [[/microsoft\s(windows)\s(vista|xp)/i], [s, c], [/(windows)\snt\s6\.2;\s(arm)/i, /(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s\w]*)/i, /(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i], [s, [c, g.str, v.os.windows.version]], [/(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i], [[s, "Windows"], [c, g.str, v.os.windows.version]], [/\((bb)(10);/i], [[s, "BlackBerry"], c], [/(blackberry)\w*\/?([\w\.]*)/i, /(tizen|kaios)[\/\s]([\w\.]+)/i, /(android|webos|palm\sos|qnx|bada|rim\stablet\sos|meego|sailfish|contiki)[\/\s-]?([\w\.]*)/i], [s, c], [/(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]*)/i], [[s, "Symbian"], c], [/\((series40);/i], [s], [/mozilla.+\(mobile;.+gecko.+firefox/i], [[s, "Firefox OS"], c], [/(nintendo|playstation)\s([wids34portablevu]+)/i, /(mint)[\/\s\(]?(\w*)/i, /(mageia|vectorlinux)[;\s]/i, /(joli|[kxln]?ubuntu|debian|suse|opensuse|gentoo|(?=\s)arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\/\s-]?(?!chrom)([\w\.-]*)/i, /(hurd|linux)\s?([\w\.]*)/i, /(gnu)\s?([\w\.]*)/i], [s, c], [/(cros)\s[\w]+\s([\w\.]+\w)/i], [[s, "Chromium OS"], c], [/(sunos)\s?([\w\.\d]*)/i], [[s, "Solaris"], c], [/\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]*)/i], [s, c], [/(haiku)\s(\w+)/i], [s, c], [/cfnetwork\/.+darwin/i, /ip[honead]{2,4}(?:.*os\s([\w]+)\slike\smac|;\sopera)/i], [[c, /_/g, "."], [s, "iOS"]], [/(mac\sos\sx)\s?([\w\s\.]*)/i, /(macintosh|mac(?=_powerpc)\s)/i], [[s, "Mac OS"], [c, /_/g, "."]], [/((?:open)?solaris)[\/\s-]?([\w\.]*)/i, /(aix)\s((\d)(?=\.|\)|\s)[\w\.])*/i, /(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms|fuchsia)/i, /(unix)\s?([\w\.]*)/i], [s, c]]
                        }
                          , b = function(t, e) {
                            if ("object" == typeof t && (e = t,
                            t = r),
                            !(this instanceof b))
                                return new b(t,e).getResult();
                            var o = t || (i && i.navigator && i.navigator.userAgent ? i.navigator.userAgent : "")
                              , n = e ? m.extend(y, e) : y;
                            return this.getBrowser = function() {
                                var t = {
                                    name: r,
                                    version: r
                                };
                                return g.rgx.call(t, o, n.browser),
                                t.major = m.major(t.version),
                                t
                            }
                            ,
                            this.getCPU = function() {
                                var t = {
                                    architecture: r
                                };
                                return g.rgx.call(t, o, n.cpu),
                                t
                            }
                            ,
                            this.getDevice = function() {
                                var t = {
                                    vendor: r,
                                    model: r,
                                    type: r
                                };
                                return g.rgx.call(t, o, n.device),
                                t
                            }
                            ,
                            this.getEngine = function() {
                                var t = {
                                    name: r,
                                    version: r
                                };
                                return g.rgx.call(t, o, n.engine),
                                t
                            }
                            ,
                            this.getOS = function() {
                                var t = {
                                    name: r,
                                    version: r
                                };
                                return g.rgx.call(t, o, n.os),
                                t
                            }
                            ,
                            this.getResult = function() {
                                return {
                                    ua: this.getUA(),
                                    browser: this.getBrowser(),
                                    engine: this.getEngine(),
                                    os: this.getOS(),
                                    device: this.getDevice(),
                                    cpu: this.getCPU()
                                }
                            }
                            ,
                            this.getUA = function() {
                                return o
                            }
                            ,
                            this.setUA = function(t) {
                                return o = t,
                                this
                            }
                            ,
                            this
                        };
                        b.VERSION = "0.7.22",
                        b.BROWSER = {
                            NAME: s,
                            MAJOR: "major",
                            VERSION: c
                        },
                        b.CPU = {
                            ARCHITECTURE: h
                        },
                        b.DEVICE = {
                            MODEL: n,
                            VENDOR: l,
                            TYPE: a,
                            CONSOLE: u,
                            MOBILE: d,
                            SMARTTV: _,
                            TABLET: f,
                            WEARABLE: p,
                            EMBEDDED: "embedded"
                        },
                        b.ENGINE = {
                            NAME: s,
                            VERSION: c
                        },
                        b.OS = {
                            NAME: s,
                            VERSION: c
                        },
                        t.exports && (e = t.exports = b),
                        e.UAParser = b;
                        var x, w = i && (i.jQuery || i.Zepto);
                        w && !w.ua && (x = new b,
                        w.ua = x.getResult(),
                        w.ua.get = function() {
                            return x.getUA()
                        }
                        ,
                        w.ua.set = function(t) {
                            x.setUA(t);
                            var e = x.getResult();
                            for (var i in e)
                                w.ua[i] = e[i];
                        }
                        );
                    }("object" == typeof window ? window : s);
                }
                )),
                function() {
                    this._OPTS = {
                        isAuto: !0
                    },
                    this._firstLogin = !0,
                    this._timer = null;
                }
                );
                return S.prototype.login = function(t, i, r) {
                    var o, n;
                    this._opts = (o = this._OPTS,
                    n = r,
                    Object.assign = Object.assign || function(t, i) {
                        var r, o = e(i);
                        try {
                            for (o.s(); !(r = o.n()).done; ) {
                                var n = r.value;
                                for (var s in t)
                                    t[s] = n[s];
                            }
                        } catch (t) {
                            o.e(t);
                        } finally {
                            o.f();
                        }
                        return t
                    }
                    ,
                    Object.assign(o, n)),
                    this._key = t,
                    this._sn = i;
                    var s = y(t + i).substring(5, 21)
                      , a = b(JSON.stringify({
                        appKey: t,
                        appSecret: i
                    }))
                      , l = x(JSON.stringify({
                        appKey: t,
                        appSecret: i
                    }), s);
                    this._firstLogin && (this._parseOpts(),
                    this._firstLogin = !1);
                    var c = a + l;
                    E()._loader.config.enc = c;
                    var h = this;
                    return E().ajax({
                        method: "POST",
                        url: "".concat(E().baseApiUrl, "/authentication/v2/login/sysLogin"),
                        type: "json",
                        headers: {
                            "Content-Type": "application/x-www-form-urlencoded;charset=utf-8"
                        },
                        body: T({
                            key: t,
                            enc: encodeURIComponent(c)
                        })
                    }).then((function(e) {
                        if ("10000" != e.code)
                            throw new Error("校验错误");
                        var r, o, n, a, l, c = JSON.parse(w(e.resultValue.substring(64), s)).token;
                        return h._setToken(c.accessToken, c.refreshToken),
                        localStorage && (E().plugin(["SGMap.Logan"]).then((function() {
                            var e = new (E().Logan)({
                                key: t,
                                sn: i
                            });
                            e.addErrorListener(),
                            E().Logan = e;
                        }
                        )).catch((function(t) {}
                        )),
                        r = JSON.parse(localStorage.getItem("SGMAP_KEY")),
                        o = window.location.origin,
                        r ? r[o] && -1 != r[o].indexOf(h._key) || (r[o] ? r[o].push(h._key) : r[o] = [h._key],
                        localStorage.setItem("SGMAP_KEY", JSON.stringify(r))) : localStorage.setItem("SGMAP_KEY", JSON.stringify((l = [h._key],
                        (a = o)in (n = {}) ? Object.defineProperty(n, a, {
                            value: l,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : n[a] = l,
                        n)))),
                        new Promise((function(t, i) {
                            t(e),
                            i("error");
                        }
                        ))
                    }
                    )).catch((function(t) {
                        console.log(t);
                    }
                    ))
                }
                ,
                S.prototype.getAccessToken = function() {
                    return E().accessToken
                }
                ,
                S.prototype._parseOpts = function() {
                    this._opts.isAuto && window && this._initAutoLogin();
                }
                ,
                S.prototype._initAutoLogin = function() {
                    var t, e, i;
                    t = window,
                    e = "online",
                    i = this._autoLogin.bind(this),
                    t.addEventListener ? t.addEventListener(e, i, !1) : t.attachEvent("on" + e, i);
                }
                ,
                S.prototype._autoLogin = function() {
                    this.login(this._key, this._sn);
                    var t = null;
                    this._opts && this._opts.onAutoLogin && (t = this._opts.onAutoLogin),
                    t && t(this);
                }
                ,
                S.prototype._setToken = function(t, e) {
                    this._setConfigAccessToken(t);
                    var i = this._accessToken
                      , r = this._refreshToken;
                    this._accessToken = t,
                    this._refreshToken = e,
                    i && r && this.loginoutToken(i, r),
                    this._triggerTimer();
                }
                ,
                S.prototype._setConfigAccessToken = function(t) {
                    E().config.ACCESS_TOKEN = t,
                    this._setting("ACCESS_TOKEN", t);
                }
                ,
                S.prototype._triggerTimer = function() {
                    this._timer && clearTimeout(this._timer);
                    var t = this;
                    this._timer = setTimeout((function() {
                        t._refreshTokens();
                    }
                    ), this._getInterval());
                }
                ,
                S.prototype._getInterval = function() {
                    var t = this._accessToken.split(".")
                      , e = JSON.parse(atob(t[1]))
                      , i = e.exp - e.iat - 60;
                    return 1e3 * (2e6 < i ? 2e6 : i)
                }
                ,
                S.prototype._refreshTokens = function() {
                    var t = this;
                    return E().ajax({
                        url: "".concat(E().baseApiUrl, "/authentication/token/refresh"),
                        method: "POST",
                        body: T({
                            accessToken: t._accessToken,
                            refreshToken: t._refreshToken
                        }),
                        headers: {
                            Authorization: t._accessToken,
                            "Content-Type": "application/x-www-form-urlencoded;charset=utf-8"
                        }
                    }).then((function(e) {
                        var i = JSON.parse(e);
                        t._setToken(i.resultValue.accessToken, i.resultValue.refreshToken);
                    }
                    )).catch((function(t) {
                        throw new Error(t)
                    }
                    ))
                }
                ,
                S.prototype.loginout = function() {
                    return this.loginoutToken(this._accessToken, this._refreshToken)
                }
                ,
                S.prototype.loginoutToken = function(t, e) {
                    var i = this._key
                      , r = y(i + this._sn).substring(5, 21)
                      , o = b(JSON.stringify({
                        accessToken: t,
                        refreshToken: e
                    })) + x(JSON.stringify({
                        accessToken: t,
                        refreshToken: e
                    }), r);
                    return E()._loader.config.enc = o,
                    E().ajax({
                        url: "".concat(E().baseApiUrl, "/authentication/v2/sysLogout"),
                        body: T({
                            key: i,
                            enc: encodeURIComponent(o)
                        }),
                        headers: {
                            Authorization: this._accessToken,
                            "Content-Type": "application/x-www-form-urlencoded;charset=utf-8"
                        },
                        method: "POST"
                    }).then((function(t) {
                        return !0
                    }
                    )).catch((function(t) {
                        throw new Error(t)
                    }
                    ))
                }
                ,
                S
            }();
        }
        ))
          , na = t.createCommonjsModule((function(t, e) {
            !function(e, i) {
                t.exports = i();
            }(0, (function() {
                var t = {
                    isDev: !1,
                    apiUrl: "https://lbs.sgmap.cn",
                    version: "1.3.0",
                    expires: 36e4,
                    enc: "epgis"
                }
                  , e = null
                  , r = e = e || function() {
                    var t, e, i, r, o, n, s, a, l, c, h, u, d, f, _, p, m, g, v, y, b, x, w, T, E, S, C, A, M, I, z, P, D, B, L, R, k, O, F, U, N, j, G, V, Z, W, q, H, X, Y, K, J, $, Q, tt, et, it, rt, ot, nt, st, at, lt, ct, ht, ut, dt, ft, _t, pt, mt, gt, vt, yt, bt, xt, wt, Tt, Et, St, Ct, At, Mt, It, zt, Pt = Pt || (t = Math,
                    e = Object.create || function(t) {
                        var e;
                        return Dt.prototype = t,
                        e = new Dt,
                        Dt.prototype = null,
                        e
                    }
                    ,
                    r = (i = {}).lib = {},
                    o = r.Base = {
                        extend: function(t) {
                            var i = e(this);
                            return t && i.mixIn(t),
                            i.hasOwnProperty("init") && this.init !== i.init || (i.init = function() {
                                i.$super.init.apply(this, arguments);
                            }
                            ),
                            (i.init.prototype = i).$super = this,
                            i
                        },
                        create: function() {
                            var t = this.extend();
                            return t.init.apply(t, arguments),
                            t
                        },
                        init: function() {},
                        mixIn: function(t) {
                            for (var e in t)
                                t.hasOwnProperty(e) && (this[e] = t[e]);
                            t.hasOwnProperty("toString") && (this.toString = t.toString);
                        },
                        clone: function() {
                            return this.init.prototype.extend(this)
                        }
                    },
                    n = r.WordArray = o.extend({
                        init: function(t, e) {
                            t = this.words = t || [],
                            this.sigBytes = null != e ? e : 4 * t.length;
                        },
                        toString: function(t) {
                            return (t || a).stringify(this)
                        },
                        concat: function(t) {
                            var e = this.words
                              , i = t.words
                              , r = this.sigBytes
                              , o = t.sigBytes;
                            if (this.clamp(),
                            r % 4)
                                for (var n = 0; n < o; n++)
                                    e[r + n >>> 2] |= (i[n >>> 2] >>> 24 - n % 4 * 8 & 255) << 24 - (r + n) % 4 * 8;
                            else
                                for (n = 0; n < o; n += 4)
                                    e[r + n >>> 2] = i[n >>> 2];
                            return this.sigBytes += o,
                            this
                        },
                        clamp: function() {
                            var e = this.words
                              , i = this.sigBytes;
                            e[i >>> 2] &= 4294967295 << 32 - i % 4 * 8,
                            e.length = t.ceil(i / 4);
                        },
                        clone: function() {
                            var t = o.clone.call(this);
                            return t.words = this.words.slice(0),
                            t
                        },
                        random: function(e) {
                            for (var i = [], r = function(e) {
                                e = e;
                                var i = 987654321
                                  , r = 4294967295;
                                return function() {
                                    var o = ((i = 36969 * (65535 & i) + (i >> 16) & r) << 16) + (e = 18e3 * (65535 & e) + (e >> 16) & r) & r;
                                    return o /= 4294967296,
                                    (o += .5) * (.5 < t.random() ? 1 : -1)
                                }
                            }, o = 0; o < e; o += 4) {
                                var s = r(4294967296 * (a || t.random()))
                                  , a = 987654071 * s();
                                i.push(4294967296 * s() | 0);
                            }
                            return new n.init(i,e)
                        }
                    }),
                    s = i.enc = {},
                    a = s.Hex = {
                        stringify: function(t) {
                            for (var e = t.words, i = t.sigBytes, r = [], o = 0; o < i; o++) {
                                var n = e[o >>> 2] >>> 24 - o % 4 * 8 & 255;
                                r.push((n >>> 4).toString(16)),
                                r.push((15 & n).toString(16));
                            }
                            return r.join("")
                        },
                        parse: function(t) {
                            for (var e = t.length, i = [], r = 0; r < e; r += 2)
                                i[r >>> 3] |= parseInt(t.substr(r, 2), 16) << 24 - r % 8 * 4;
                            return new n.init(i,e / 2)
                        }
                    },
                    l = s.Latin1 = {
                        stringify: function(t) {
                            for (var e = t.words, i = t.sigBytes, r = [], o = 0; o < i; o++)
                                r.push(String.fromCharCode(e[o >>> 2] >>> 24 - o % 4 * 8 & 255));
                            return r.join("")
                        },
                        parse: function(t) {
                            for (var e = t.length, i = [], r = 0; r < e; r++)
                                i[r >>> 2] |= (255 & t.charCodeAt(r)) << 24 - r % 4 * 8;
                            return new n.init(i,e)
                        }
                    },
                    c = s.Utf8 = {
                        stringify: function(t) {
                            try {
                                return decodeURIComponent(escape(l.stringify(t)))
                            } catch (t) {
                                throw new Error("Malformed UTF-8 data")
                            }
                        },
                        parse: function(t) {
                            return l.parse(unescape(encodeURIComponent(t)))
                        }
                    },
                    h = r.BufferedBlockAlgorithm = o.extend({
                        reset: function() {
                            this._data = new n.init,
                            this._nDataBytes = 0;
                        },
                        _append: function(t) {
                            "string" == typeof t && (t = c.parse(t)),
                            this._data.concat(t),
                            this._nDataBytes += t.sigBytes;
                        },
                        _process: function(e) {
                            var i = this._data
                              , r = i.words
                              , o = i.sigBytes
                              , s = this.blockSize
                              , a = o / (4 * s)
                              , l = (a = e ? t.ceil(a) : t.max((0 | a) - this._minBufferSize, 0)) * s
                              , c = t.min(4 * l, o);
                            if (l) {
                                for (var h = 0; h < l; h += s)
                                    this._doProcessBlock(r, h);
                                var u = r.splice(0, l);
                                i.sigBytes -= c;
                            }
                            return new n.init(u,c)
                        },
                        clone: function() {
                            var t = o.clone.call(this);
                            return t._data = this._data.clone(),
                            t
                        },
                        _minBufferSize: 0
                    }),
                    r.Hasher = h.extend({
                        cfg: o.extend(),
                        init: function(t) {
                            this.cfg = this.cfg.extend(t),
                            this.reset();
                        },
                        reset: function() {
                            h.reset.call(this),
                            this._doReset();
                        },
                        update: function(t) {
                            return this._append(t),
                            this._process(),
                            this
                        },
                        finalize: function(t) {
                            return t && this._append(t),
                            this._doFinalize()
                        },
                        blockSize: 16,
                        _createHelper: function(t) {
                            return function(e, i) {
                                return new t.init(i).finalize(e)
                            }
                        },
                        _createHmacHelper: function(t) {
                            return function(e, i) {
                                return new u.HMAC.init(t,i).finalize(e)
                            }
                        }
                    }),
                    u = i.algo = {},
                    i);
                    function Dt() {}
                    function Bt(t, e, i) {
                        return t & e | ~t & i
                    }
                    function Lt(t, e, i) {
                        return t & i | e & ~i
                    }
                    function Rt(t, e) {
                        return t << e | t >>> 32 - e
                    }
                    function kt(t, e, i, r) {
                        var o, n = this._iv;
                        n ? (o = n.slice(0),
                        this._iv = void 0) : o = this._prevBlock,
                        r.encryptBlock(o, 0);
                        for (var s = 0; s < i; s++)
                            t[e + s] ^= o[s];
                    }
                    function Ot(t) {
                        var e, i, r;
                        return 255 == (t >> 24 & 255) ? (i = t >> 8 & 255,
                        r = 255 & t,
                        255 == (e = t >> 16 & 255) ? (e = 0,
                        255 === i ? (i = 0,
                        255 === r ? r = 0 : ++r) : ++i) : ++e,
                        t = 0,
                        t += e << 16,
                        t += i << 8,
                        t += r) : t += 1 << 24,
                        t
                    }
                    function Ft() {
                        for (var t = this._X, e = this._C, i = 0; i < 8; i++)
                            bt[i] = e[i];
                        for (e[0] = e[0] + 1295307597 + this._b | 0,
                        e[1] = e[1] + 3545052371 + (e[0] >>> 0 < bt[0] >>> 0 ? 1 : 0) | 0,
                        e[2] = e[2] + 886263092 + (e[1] >>> 0 < bt[1] >>> 0 ? 1 : 0) | 0,
                        e[3] = e[3] + 1295307597 + (e[2] >>> 0 < bt[2] >>> 0 ? 1 : 0) | 0,
                        e[4] = e[4] + 3545052371 + (e[3] >>> 0 < bt[3] >>> 0 ? 1 : 0) | 0,
                        e[5] = e[5] + 886263092 + (e[4] >>> 0 < bt[4] >>> 0 ? 1 : 0) | 0,
                        e[6] = e[6] + 1295307597 + (e[5] >>> 0 < bt[5] >>> 0 ? 1 : 0) | 0,
                        e[7] = e[7] + 3545052371 + (e[6] >>> 0 < bt[6] >>> 0 ? 1 : 0) | 0,
                        this._b = e[7] >>> 0 < bt[7] >>> 0 ? 1 : 0,
                        i = 0; i < 8; i++) {
                            var r = t[i] + e[i]
                              , o = 65535 & r
                              , n = r >>> 16;
                            xt[i] = ((o * o >>> 17) + o * n >>> 15) + n * n ^ ((4294901760 & r) * r | 0) + ((65535 & r) * r | 0);
                        }
                        t[0] = xt[0] + (xt[7] << 16 | xt[7] >>> 16) + (xt[6] << 16 | xt[6] >>> 16) | 0,
                        t[1] = xt[1] + (xt[0] << 8 | xt[0] >>> 24) + xt[7] | 0,
                        t[2] = xt[2] + (xt[1] << 16 | xt[1] >>> 16) + (xt[0] << 16 | xt[0] >>> 16) | 0,
                        t[3] = xt[3] + (xt[2] << 8 | xt[2] >>> 24) + xt[1] | 0,
                        t[4] = xt[4] + (xt[3] << 16 | xt[3] >>> 16) + (xt[2] << 16 | xt[2] >>> 16) | 0,
                        t[5] = xt[5] + (xt[4] << 8 | xt[4] >>> 24) + xt[3] | 0,
                        t[6] = xt[6] + (xt[5] << 16 | xt[5] >>> 16) + (xt[4] << 16 | xt[4] >>> 16) | 0,
                        t[7] = xt[7] + (xt[6] << 8 | xt[6] >>> 24) + xt[5] | 0;
                    }
                    function Ut() {
                        for (var t = this._X, e = this._C, i = 0; i < 8; i++)
                            Mt[i] = e[i];
                        for (e[0] = e[0] + 1295307597 + this._b | 0,
                        e[1] = e[1] + 3545052371 + (e[0] >>> 0 < Mt[0] >>> 0 ? 1 : 0) | 0,
                        e[2] = e[2] + 886263092 + (e[1] >>> 0 < Mt[1] >>> 0 ? 1 : 0) | 0,
                        e[3] = e[3] + 1295307597 + (e[2] >>> 0 < Mt[2] >>> 0 ? 1 : 0) | 0,
                        e[4] = e[4] + 3545052371 + (e[3] >>> 0 < Mt[3] >>> 0 ? 1 : 0) | 0,
                        e[5] = e[5] + 886263092 + (e[4] >>> 0 < Mt[4] >>> 0 ? 1 : 0) | 0,
                        e[6] = e[6] + 1295307597 + (e[5] >>> 0 < Mt[5] >>> 0 ? 1 : 0) | 0,
                        e[7] = e[7] + 3545052371 + (e[6] >>> 0 < Mt[6] >>> 0 ? 1 : 0) | 0,
                        this._b = e[7] >>> 0 < Mt[7] >>> 0 ? 1 : 0,
                        i = 0; i < 8; i++) {
                            var r = t[i] + e[i]
                              , o = 65535 & r
                              , n = r >>> 16;
                            It[i] = ((o * o >>> 17) + o * n >>> 15) + n * n ^ ((4294901760 & r) * r | 0) + ((65535 & r) * r | 0);
                        }
                        t[0] = It[0] + (It[7] << 16 | It[7] >>> 16) + (It[6] << 16 | It[6] >>> 16) | 0,
                        t[1] = It[1] + (It[0] << 8 | It[0] >>> 24) + It[7] | 0,
                        t[2] = It[2] + (It[1] << 16 | It[1] >>> 16) + (It[0] << 16 | It[0] >>> 16) | 0,
                        t[3] = It[3] + (It[2] << 8 | It[2] >>> 24) + It[1] | 0,
                        t[4] = It[4] + (It[3] << 16 | It[3] >>> 16) + (It[2] << 16 | It[2] >>> 16) | 0,
                        t[5] = It[5] + (It[4] << 8 | It[4] >>> 24) + It[3] | 0,
                        t[6] = It[6] + (It[5] << 16 | It[5] >>> 16) + (It[4] << 16 | It[4] >>> 16) | 0,
                        t[7] = It[7] + (It[6] << 8 | It[6] >>> 24) + It[5] | 0;
                    }
                    return d = Pt.lib.WordArray,
                    Pt.enc.Base64 = {
                        stringify: function(t) {
                            var e = t.words
                              , i = t.sigBytes
                              , r = this._map;
                            t.clamp();
                            for (var o = [], n = 0; n < i; n += 3)
                                for (var s = (e[n >>> 2] >>> 24 - n % 4 * 8 & 255) << 16 | (e[n + 1 >>> 2] >>> 24 - (n + 1) % 4 * 8 & 255) << 8 | e[n + 2 >>> 2] >>> 24 - (n + 2) % 4 * 8 & 255, a = 0; a < 4 && n + .75 * a < i; a++)
                                    o.push(r.charAt(s >>> 6 * (3 - a) & 63));
                            var l = r.charAt(64);
                            if (l)
                                for (; o.length % 4; )
                                    o.push(l);
                            return o.join("")
                        },
                        parse: function(t) {
                            var e = t.length
                              , i = this._map
                              , r = this._reverseMap;
                            if (!r) {
                                r = this._reverseMap = [];
                                for (var o = 0; o < i.length; o++)
                                    r[i.charCodeAt(o)] = o;
                            }
                            var n, s = i.charAt(64);
                            return !s || -1 !== (n = t.indexOf(s)) && (e = n),
                            function(t, e, i) {
                                for (var r = [], o = 0, n = 0; n < e; n++) {
                                    var s, a;
                                    n % 4 && (s = i[t.charCodeAt(n - 1)] << n % 4 * 2,
                                    a = i[t.charCodeAt(n)] >>> 6 - n % 4 * 2,
                                    r[o >>> 2] |= (s | a) << 24 - o % 4 * 8,
                                    o++);
                                }
                                return d.create(r, o)
                            }(t, e, r)
                        },
                        _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
                    },
                    function(t) {
                        var e = Pt
                          , i = e.lib
                          , r = i.WordArray
                          , o = i.Hasher
                          , n = e.algo
                          , s = [];
                        !function() {
                            for (var e = 0; e < 64; e++)
                                s[e] = 4294967296 * t.abs(t.sin(e + 1)) | 0;
                        }();
                        var a = n.MD5 = o.extend({
                            _doReset: function() {
                                this._hash = new r.init([1732584193, 4023233417, 2562383102, 271733878]);
                            },
                            _doProcessBlock: function(t, e) {
                                for (var i = 0; i < 16; i++) {
                                    var r = e + i
                                      , o = t[r];
                                    t[r] = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8);
                                }
                                var n = this._hash.words
                                  , a = t[e + 0]
                                  , d = t[e + 1]
                                  , f = t[e + 2]
                                  , _ = t[e + 3]
                                  , p = t[e + 4]
                                  , m = t[e + 5]
                                  , g = t[e + 6]
                                  , v = t[e + 7]
                                  , y = t[e + 8]
                                  , b = t[e + 9]
                                  , x = t[e + 10]
                                  , w = t[e + 11]
                                  , T = t[e + 12]
                                  , E = t[e + 13]
                                  , S = t[e + 14]
                                  , C = t[e + 15]
                                  , A = l(A = n[0], z = n[1], I = n[2], M = n[3], a, 7, s[0])
                                  , M = l(M, A, z, I, d, 12, s[1])
                                  , I = l(I, M, A, z, f, 17, s[2])
                                  , z = l(z, I, M, A, _, 22, s[3]);
                                A = l(A, z, I, M, p, 7, s[4]),
                                M = l(M, A, z, I, m, 12, s[5]),
                                I = l(I, M, A, z, g, 17, s[6]),
                                z = l(z, I, M, A, v, 22, s[7]),
                                A = l(A, z, I, M, y, 7, s[8]),
                                M = l(M, A, z, I, b, 12, s[9]),
                                I = l(I, M, A, z, x, 17, s[10]),
                                z = l(z, I, M, A, w, 22, s[11]),
                                A = l(A, z, I, M, T, 7, s[12]),
                                M = l(M, A, z, I, E, 12, s[13]),
                                I = l(I, M, A, z, S, 17, s[14]),
                                A = c(A, z = l(z, I, M, A, C, 22, s[15]), I, M, d, 5, s[16]),
                                M = c(M, A, z, I, g, 9, s[17]),
                                I = c(I, M, A, z, w, 14, s[18]),
                                z = c(z, I, M, A, a, 20, s[19]),
                                A = c(A, z, I, M, m, 5, s[20]),
                                M = c(M, A, z, I, x, 9, s[21]),
                                I = c(I, M, A, z, C, 14, s[22]),
                                z = c(z, I, M, A, p, 20, s[23]),
                                A = c(A, z, I, M, b, 5, s[24]),
                                M = c(M, A, z, I, S, 9, s[25]),
                                I = c(I, M, A, z, _, 14, s[26]),
                                z = c(z, I, M, A, y, 20, s[27]),
                                A = c(A, z, I, M, E, 5, s[28]),
                                M = c(M, A, z, I, f, 9, s[29]),
                                I = c(I, M, A, z, v, 14, s[30]),
                                A = h(A, z = c(z, I, M, A, T, 20, s[31]), I, M, m, 4, s[32]),
                                M = h(M, A, z, I, y, 11, s[33]),
                                I = h(I, M, A, z, w, 16, s[34]),
                                z = h(z, I, M, A, S, 23, s[35]),
                                A = h(A, z, I, M, d, 4, s[36]),
                                M = h(M, A, z, I, p, 11, s[37]),
                                I = h(I, M, A, z, v, 16, s[38]),
                                z = h(z, I, M, A, x, 23, s[39]),
                                A = h(A, z, I, M, E, 4, s[40]),
                                M = h(M, A, z, I, a, 11, s[41]),
                                I = h(I, M, A, z, _, 16, s[42]),
                                z = h(z, I, M, A, g, 23, s[43]),
                                A = h(A, z, I, M, b, 4, s[44]),
                                M = h(M, A, z, I, T, 11, s[45]),
                                I = h(I, M, A, z, C, 16, s[46]),
                                A = u(A, z = h(z, I, M, A, f, 23, s[47]), I, M, a, 6, s[48]),
                                M = u(M, A, z, I, v, 10, s[49]),
                                I = u(I, M, A, z, S, 15, s[50]),
                                z = u(z, I, M, A, m, 21, s[51]),
                                A = u(A, z, I, M, T, 6, s[52]),
                                M = u(M, A, z, I, _, 10, s[53]),
                                I = u(I, M, A, z, x, 15, s[54]),
                                z = u(z, I, M, A, d, 21, s[55]),
                                A = u(A, z, I, M, y, 6, s[56]),
                                M = u(M, A, z, I, C, 10, s[57]),
                                I = u(I, M, A, z, g, 15, s[58]),
                                z = u(z, I, M, A, E, 21, s[59]),
                                A = u(A, z, I, M, p, 6, s[60]),
                                M = u(M, A, z, I, w, 10, s[61]),
                                I = u(I, M, A, z, f, 15, s[62]),
                                z = u(z, I, M, A, b, 21, s[63]),
                                n[0] = n[0] + A | 0,
                                n[1] = n[1] + z | 0,
                                n[2] = n[2] + I | 0,
                                n[3] = n[3] + M | 0;
                            },
                            _doFinalize: function() {
                                var e = this._data
                                  , i = e.words
                                  , r = 8 * this._nDataBytes
                                  , o = 8 * e.sigBytes;
                                i[o >>> 5] |= 128 << 24 - o % 32;
                                var n = t.floor(r / 4294967296)
                                  , s = r;
                                i[15 + (64 + o >>> 9 << 4)] = 16711935 & (n << 8 | n >>> 24) | 4278255360 & (n << 24 | n >>> 8),
                                i[14 + (64 + o >>> 9 << 4)] = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8),
                                e.sigBytes = 4 * (i.length + 1),
                                this._process();
                                for (var a = this._hash, l = a.words, c = 0; c < 4; c++) {
                                    var h = l[c];
                                    l[c] = 16711935 & (h << 8 | h >>> 24) | 4278255360 & (h << 24 | h >>> 8);
                                }
                                return a
                            },
                            clone: function() {
                                var t = o.clone.call(this);
                                return t._hash = this._hash.clone(),
                                t
                            }
                        });
                        function l(t, e, i, r, o, n, s) {
                            var a = t + (e & i | ~e & r) + o + s;
                            return (a << n | a >>> 32 - n) + e
                        }
                        function c(t, e, i, r, o, n, s) {
                            var a = t + (e & r | i & ~r) + o + s;
                            return (a << n | a >>> 32 - n) + e
                        }
                        function h(t, e, i, r, o, n, s) {
                            var a = t + (e ^ i ^ r) + o + s;
                            return (a << n | a >>> 32 - n) + e
                        }
                        function u(t, e, i, r, o, n, s) {
                            var a = t + (i ^ (e | ~r)) + o + s;
                            return (a << n | a >>> 32 - n) + e
                        }
                        e.MD5 = o._createHelper(a),
                        e.HmacMD5 = o._createHmacHelper(a);
                    }(Math),
                    _ = (f = Pt).lib,
                    p = _.WordArray,
                    g = [],
                    v = f.algo.SHA1 = (m = _.Hasher).extend({
                        _doReset: function() {
                            this._hash = new p.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
                        },
                        _doProcessBlock: function(t, e) {
                            for (var i, r = this._hash.words, o = r[0], n = r[1], s = r[2], a = r[3], l = r[4], c = 0; c < 80; c++) {
                                g[c] = c < 16 ? 0 | t[e + c] : (i = g[c - 3] ^ g[c - 8] ^ g[c - 14] ^ g[c - 16]) << 1 | i >>> 31;
                                var h = (o << 5 | o >>> 27) + l + g[c];
                                h += c < 20 ? 1518500249 + (n & s | ~n & a) : c < 40 ? 1859775393 + (n ^ s ^ a) : c < 60 ? (n & s | n & a | s & a) - 1894007588 : (n ^ s ^ a) - 899497514,
                                l = a,
                                a = s,
                                s = n << 30 | n >>> 2,
                                n = o,
                                o = h;
                            }
                            r[0] = r[0] + o | 0,
                            r[1] = r[1] + n | 0,
                            r[2] = r[2] + s | 0,
                            r[3] = r[3] + a | 0,
                            r[4] = r[4] + l | 0;
                        },
                        _doFinalize: function() {
                            var t = this._data
                              , e = t.words
                              , i = 8 * this._nDataBytes
                              , r = 8 * t.sigBytes;
                            return e[r >>> 5] |= 128 << 24 - r % 32,
                            e[14 + (64 + r >>> 9 << 4)] = Math.floor(i / 4294967296),
                            e[15 + (64 + r >>> 9 << 4)] = i,
                            t.sigBytes = 4 * e.length,
                            this._process(),
                            this._hash
                        },
                        clone: function() {
                            var t = m.clone.call(this);
                            return t._hash = this._hash.clone(),
                            t
                        }
                    }),
                    f.SHA1 = m._createHelper(v),
                    f.HmacSHA1 = m._createHmacHelper(v),
                    function(t) {
                        var e = Pt
                          , i = e.lib
                          , r = i.WordArray
                          , o = i.Hasher
                          , n = e.algo
                          , s = []
                          , a = [];
                        !function() {
                            function e(t) {
                                return 4294967296 * (t - (0 | t)) | 0
                            }
                            for (var i = 2, r = 0; r < 64; )
                                !function(e) {
                                    for (var i = t.sqrt(e), r = 2; r <= i; r++)
                                        if (!(e % r))
                                            return;
                                    return 1
                                }(i) || (r < 8 && (s[r] = e(t.pow(i, .5))),
                                a[r] = e(t.pow(i, 1 / 3)),
                                r++),
                                i++;
                        }();
                        var l = []
                          , c = n.SHA256 = o.extend({
                            _doReset: function() {
                                this._hash = new r.init(s.slice(0));
                            },
                            _doProcessBlock: function(t, e) {
                                for (var i, r, o, n, s = this._hash.words, c = s[0], h = s[1], u = s[2], d = s[3], f = s[4], _ = s[5], p = s[6], m = s[7], g = 0; g < 64; g++) {
                                    g < 16 ? l[g] = 0 | t[e + g] : (r = ((i = l[g - 15]) << 25 | i >>> 7) ^ (i << 14 | i >>> 18) ^ i >>> 3,
                                    n = ((o = l[g - 2]) << 15 | o >>> 17) ^ (o << 13 | o >>> 19) ^ o >>> 10,
                                    l[g] = r + l[g - 7] + n + l[g - 16]);
                                    var v = c & h ^ c & u ^ h & u
                                      , y = m + ((f << 26 | f >>> 6) ^ (f << 21 | f >>> 11) ^ (f << 7 | f >>> 25)) + (f & _ ^ ~f & p) + a[g] + l[g];
                                    m = p,
                                    p = _,
                                    _ = f,
                                    f = d + y | 0,
                                    d = u,
                                    u = h,
                                    h = c,
                                    c = y + (((c << 30 | c >>> 2) ^ (c << 19 | c >>> 13) ^ (c << 10 | c >>> 22)) + v) | 0;
                                }
                                s[0] = s[0] + c | 0,
                                s[1] = s[1] + h | 0,
                                s[2] = s[2] + u | 0,
                                s[3] = s[3] + d | 0,
                                s[4] = s[4] + f | 0,
                                s[5] = s[5] + _ | 0,
                                s[6] = s[6] + p | 0,
                                s[7] = s[7] + m | 0;
                            },
                            _doFinalize: function() {
                                var e = this._data
                                  , i = e.words
                                  , r = 8 * this._nDataBytes
                                  , o = 8 * e.sigBytes;
                                return i[o >>> 5] |= 128 << 24 - o % 32,
                                i[14 + (64 + o >>> 9 << 4)] = t.floor(r / 4294967296),
                                i[15 + (64 + o >>> 9 << 4)] = r,
                                e.sigBytes = 4 * i.length,
                                this._process(),
                                this._hash
                            },
                            clone: function() {
                                var t = o.clone.call(this);
                                return t._hash = this._hash.clone(),
                                t
                            }
                        });
                        e.SHA256 = o._createHelper(c),
                        e.HmacSHA256 = o._createHmacHelper(c);
                    }(Math),
                    function() {
                        var t = Pt.lib.WordArray
                          , e = Pt.enc;
                        function i(t) {
                            return t << 8 & 4278255360 | t >>> 8 & 16711935
                        }
                        e.Utf16 = e.Utf16BE = {
                            stringify: function(t) {
                                for (var e = t.words, i = t.sigBytes, r = [], o = 0; o < i; o += 2)
                                    r.push(String.fromCharCode(e[o >>> 2] >>> 16 - o % 4 * 8 & 65535));
                                return r.join("")
                            },
                            parse: function(e) {
                                for (var i = e.length, r = [], o = 0; o < i; o++)
                                    r[o >>> 1] |= e.charCodeAt(o) << 16 - o % 2 * 16;
                                return t.create(r, 2 * i)
                            }
                        },
                        e.Utf16LE = {
                            stringify: function(t) {
                                for (var e = t.words, r = t.sigBytes, o = [], n = 0; n < r; n += 2) {
                                    var s = i(e[n >>> 2] >>> 16 - n % 4 * 8 & 65535);
                                    o.push(String.fromCharCode(s));
                                }
                                return o.join("")
                            },
                            parse: function(e) {
                                for (var r = e.length, o = [], n = 0; n < r; n++)
                                    o[n >>> 1] |= i(e.charCodeAt(n) << 16 - n % 2 * 16);
                                return t.create(o, 2 * r)
                            }
                        };
                    }(),
                    "function" == typeof ArrayBuffer && (b = (y = Pt.lib.WordArray).init,
                    (y.init = function(t) {
                        if (t instanceof ArrayBuffer && (t = new Uint8Array(t)),
                        (t instanceof Int8Array || "undefined" != typeof Uint8ClampedArray && t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array || t instanceof Float64Array) && (t = new Uint8Array(t.buffer,t.byteOffset,t.byteLength)),
                        t instanceof Uint8Array) {
                            for (var e = t.byteLength, i = [], r = 0; r < e; r++)
                                i[r >>> 2] |= t[r] << 24 - r % 4 * 8;
                            b.call(this, i, e);
                        } else
                            b.apply(this, arguments);
                    }
                    ).prototype = y),
                    w = (x = Pt).lib,
                    E = w.Hasher,
                    S = x.algo,
                    C = (T = w.WordArray).create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]),
                    A = T.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]),
                    M = T.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]),
                    I = T.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]),
                    z = T.create([0, 1518500249, 1859775393, 2400959708, 2840853838]),
                    P = T.create([1352829926, 1548603684, 1836072691, 2053994217, 0]),
                    D = S.RIPEMD160 = E.extend({
                        _doReset: function() {
                            this._hash = T.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
                        },
                        _doProcessBlock: function(t, e) {
                            for (var i = 0; i < 16; i++) {
                                var r = e + i
                                  , o = t[r];
                                t[r] = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8);
                            }
                            var n, s, a, l, c, h, u = this._hash.words, d = z.words, f = P.words, _ = C.words, p = A.words, m = M.words, g = I.words, v = n = u[0], y = s = u[1], b = a = u[2], x = l = u[3], w = c = u[4];
                            for (i = 0; i < 80; i += 1)
                                h = n + t[e + _[i]] | 0,
                                h += i < 16 ? (s ^ a ^ l) + d[0] : i < 32 ? Bt(s, a, l) + d[1] : i < 48 ? ((s | ~a) ^ l) + d[2] : i < 64 ? Lt(s, a, l) + d[3] : (s ^ (a | ~l)) + d[4],
                                h = (h = Rt(h |= 0, m[i])) + c | 0,
                                n = c,
                                c = l,
                                l = Rt(a, 10),
                                a = s,
                                s = h,
                                h = v + t[e + p[i]] | 0,
                                h += i < 16 ? (y ^ (b | ~x)) + f[0] : i < 32 ? Lt(y, b, x) + f[1] : i < 48 ? ((y | ~b) ^ x) + f[2] : i < 64 ? Bt(y, b, x) + f[3] : (y ^ b ^ x) + f[4],
                                h = (h = Rt(h |= 0, g[i])) + w | 0,
                                v = w,
                                w = x,
                                x = Rt(b, 10),
                                b = y,
                                y = h;
                            h = u[1] + a + x | 0,
                            u[1] = u[2] + l + w | 0,
                            u[2] = u[3] + c + v | 0,
                            u[3] = u[4] + n + y | 0,
                            u[4] = u[0] + s + b | 0,
                            u[0] = h;
                        },
                        _doFinalize: function() {
                            var t = this._data
                              , e = t.words
                              , i = 8 * this._nDataBytes
                              , r = 8 * t.sigBytes;
                            e[r >>> 5] |= 128 << 24 - r % 32,
                            e[14 + (64 + r >>> 9 << 4)] = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8),
                            t.sigBytes = 4 * (e.length + 1),
                            this._process();
                            for (var o = this._hash, n = o.words, s = 0; s < 5; s++) {
                                var a = n[s];
                                n[s] = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8);
                            }
                            return o
                        },
                        clone: function() {
                            var t = E.clone.call(this);
                            return t._hash = this._hash.clone(),
                            t
                        }
                    }),
                    x.RIPEMD160 = E._createHelper(D),
                    x.HmacRIPEMD160 = E._createHmacHelper(D),
                    B = Pt.enc.Utf8,
                    Pt.algo.HMAC = Pt.lib.Base.extend({
                        init: function(t, e) {
                            t = this._hasher = new t.init,
                            "string" == typeof e && (e = B.parse(e));
                            var i = t.blockSize
                              , r = 4 * i;
                            e.sigBytes > r && (e = t.finalize(e)),
                            e.clamp();
                            for (var o = this._oKey = e.clone(), n = this._iKey = e.clone(), s = o.words, a = n.words, l = 0; l < i; l++)
                                s[l] ^= 1549556828,
                                a[l] ^= 909522486;
                            o.sigBytes = n.sigBytes = r,
                            this.reset();
                        },
                        reset: function() {
                            var t = this._hasher;
                            t.reset(),
                            t.update(this._iKey);
                        },
                        update: function(t) {
                            return this._hasher.update(t),
                            this
                        },
                        finalize: function(t) {
                            var e = this._hasher
                              , i = e.finalize(t);
                            return e.reset(),
                            e.finalize(this._oKey.clone().concat(i))
                        }
                    }),
                    R = (L = Pt).lib,
                    O = R.WordArray,
                    U = (F = L.algo).HMAC,
                    N = F.PBKDF2 = (k = R.Base).extend({
                        cfg: k.extend({
                            keySize: 4,
                            hasher: F.SHA1,
                            iterations: 1
                        }),
                        init: function(t) {
                            this.cfg = this.cfg.extend(t);
                        },
                        compute: function(t, e) {
                            for (var i = this.cfg, r = U.create(i.hasher, t), o = O.create(), n = O.create([1]), s = o.words, a = n.words, l = i.keySize, c = i.iterations; s.length < l; ) {
                                var h = r.update(e).finalize(n);
                                r.reset();
                                for (var u = h.words, d = u.length, f = h, _ = 1; _ < c; _++) {
                                    f = r.finalize(f),
                                    r.reset();
                                    for (var p = f.words, m = 0; m < d; m++)
                                        u[m] ^= p[m];
                                }
                                o.concat(h),
                                a[0]++;
                            }
                            return o.sigBytes = 4 * l,
                            o
                        }
                    }),
                    L.PBKDF2 = function(t, e, i) {
                        return N.create(i).compute(t, e)
                    }
                    ,
                    G = (j = Pt).lib,
                    Z = G.WordArray,
                    q = (W = j.algo).EvpKDF = (V = G.Base).extend({
                        cfg: V.extend({
                            keySize: 4,
                            hasher: W.MD5,
                            iterations: 1
                        }),
                        init: function(t) {
                            this.cfg = this.cfg.extend(t);
                        },
                        compute: function(t, e) {
                            for (var i = this.cfg, r = i.hasher.create(), o = Z.create(), n = o.words, s = i.keySize, a = i.iterations; n.length < s; ) {
                                l && r.update(l);
                                var l = r.update(t).finalize(e);
                                r.reset();
                                for (var c = 1; c < a; c++)
                                    l = r.finalize(l),
                                    r.reset();
                                o.concat(l);
                            }
                            return o.sigBytes = 4 * s,
                            o
                        }
                    }),
                    j.EvpKDF = function(t, e, i) {
                        return q.create(i).compute(t, e)
                    }
                    ,
                    X = (H = Pt).lib.WordArray,
                    J = (Y = H.algo).SHA224 = (K = Y.SHA256).extend({
                        _doReset: function() {
                            this._hash = new X.init([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]);
                        },
                        _doFinalize: function() {
                            var t = K._doFinalize.call(this);
                            return t.sigBytes -= 4,
                            t
                        }
                    }),
                    H.SHA224 = K._createHelper(J),
                    H.HmacSHA224 = K._createHmacHelper(J),
                    Q = ($ = Pt.lib).Base,
                    tt = $.WordArray,
                    (et = Pt.x64 = {}).Word = Q.extend({
                        init: function(t, e) {
                            this.high = t,
                            this.low = e;
                        }
                    }),
                    et.WordArray = Q.extend({
                        init: function(t, e) {
                            t = this.words = t || [],
                            this.sigBytes = null != e ? e : 8 * t.length;
                        },
                        toX32: function() {
                            for (var t = this.words, e = t.length, i = [], r = 0; r < e; r++) {
                                var o = t[r];
                                i.push(o.high),
                                i.push(o.low);
                            }
                            return tt.create(i, this.sigBytes)
                        },
                        clone: function() {
                            for (var t = Q.clone.call(this), e = t.words = this.words.slice(0), i = e.length, r = 0; r < i; r++)
                                e[r] = e[r].clone();
                            return t
                        }
                    }),
                    function(t) {
                        var e = Pt
                          , i = e.lib
                          , r = i.WordArray
                          , o = i.Hasher
                          , n = e.x64.Word
                          , s = e.algo
                          , a = []
                          , l = []
                          , c = [];
                        !function() {
                            for (var t = 1, e = 0, i = 0; i < 24; i++) {
                                a[t + 5 * e] = (i + 1) * (i + 2) / 2 % 64;
                                var r = (2 * t + 3 * e) % 5;
                                t = e % 5,
                                e = r;
                            }
                            for (t = 0; t < 5; t++)
                                for (e = 0; e < 5; e++)
                                    l[t + 5 * e] = e + (2 * t + 3 * e) % 5 * 5;
                            for (var o = 1, s = 0; s < 24; s++) {
                                for (var h, u = 0, d = 0, f = 0; f < 7; f++)
                                    1 & o && ((h = (1 << f) - 1) < 32 ? d ^= 1 << h : u ^= 1 << h - 32),
                                    128 & o ? o = o << 1 ^ 113 : o <<= 1;
                                c[s] = n.create(u, d);
                            }
                        }();
                        var h = [];
                        !function() {
                            for (var t = 0; t < 25; t++)
                                h[t] = n.create();
                        }();
                        var u = s.SHA3 = o.extend({
                            cfg: o.cfg.extend({
                                outputLength: 512
                            }),
                            _doReset: function() {
                                for (var t = this._state = [], e = 0; e < 25; e++)
                                    t[e] = new n.init;
                                this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
                            },
                            _doProcessBlock: function(t, e) {
                                for (var i = this._state, r = this.blockSize / 2, o = 0; o < r; o++) {
                                    var n = 16711935 & ((n = t[e + 2 * o]) << 8 | n >>> 24) | 4278255360 & (n << 24 | n >>> 8)
                                      , s = 16711935 & ((s = t[e + 2 * o + 1]) << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8);
                                    (M = i[o]).high ^= s,
                                    M.low ^= n;
                                }
                                for (var u = 0; u < 24; u++) {
                                    for (var d = 0; d < 5; d++) {
                                        for (var f = 0, _ = 0, p = 0; p < 5; p++)
                                            f ^= (M = i[d + 5 * p]).high,
                                            _ ^= M.low;
                                        var m = h[d];
                                        m.high = f,
                                        m.low = _;
                                    }
                                    for (d = 0; d < 5; d++) {
                                        var g = h[(d + 4) % 5]
                                          , v = h[(d + 1) % 5]
                                          , y = v.high
                                          , b = v.low;
                                        for (f = g.high ^ (y << 1 | b >>> 31),
                                        _ = g.low ^ (b << 1 | y >>> 31),
                                        p = 0; p < 5; p++)
                                            (M = i[d + 5 * p]).high ^= f,
                                            M.low ^= _;
                                    }
                                    for (var x = 1; x < 25; x++) {
                                        var w = (M = i[x]).high
                                          , T = M.low
                                          , E = a[x];
                                        _ = E < 32 ? (f = w << E | T >>> 32 - E,
                                        T << E | w >>> 32 - E) : (f = T << E - 32 | w >>> 64 - E,
                                        w << E - 32 | T >>> 64 - E);
                                        var S = h[l[x]];
                                        S.high = f,
                                        S.low = _;
                                    }
                                    var C = h[0]
                                      , A = i[0];
                                    for (C.high = A.high,
                                    C.low = A.low,
                                    d = 0; d < 5; d++)
                                        for (p = 0; p < 5; p++) {
                                            var M = i[x = d + 5 * p]
                                              , I = h[x]
                                              , z = h[(d + 1) % 5 + 5 * p]
                                              , P = h[(d + 2) % 5 + 5 * p];
                                            M.high = I.high ^ ~z.high & P.high,
                                            M.low = I.low ^ ~z.low & P.low;
                                        }
                                    var D = c[u];
                                    (M = i[0]).high ^= D.high,
                                    M.low ^= D.low;
                                }
                            },
                            _doFinalize: function() {
                                var e = this._data
                                  , i = e.words
                                  , o = 8 * e.sigBytes
                                  , n = 32 * this.blockSize;
                                i[o >>> 5] |= 1 << 24 - o % 32,
                                i[(t.ceil((1 + o) / n) * n >>> 5) - 1] |= 128,
                                e.sigBytes = 4 * i.length,
                                this._process();
                                for (var s = this._state, a = this.cfg.outputLength / 8, l = a / 8, c = [], h = 0; h < l; h++) {
                                    var u = s[h]
                                      , d = 16711935 & ((d = u.high) << 8 | d >>> 24) | 4278255360 & (d << 24 | d >>> 8)
                                      , f = 16711935 & ((f = u.low) << 8 | f >>> 24) | 4278255360 & (f << 24 | f >>> 8);
                                    c.push(f),
                                    c.push(d);
                                }
                                return new r.init(c,a)
                            },
                            clone: function() {
                                for (var t = o.clone.call(this), e = t._state = this._state.slice(0), i = 0; i < 25; i++)
                                    e[i] = e[i].clone();
                                return t
                            }
                        });
                        e.SHA3 = o._createHelper(u),
                        e.HmacSHA3 = o._createHmacHelper(u);
                    }(Math),
                    function() {
                        var t = Pt
                          , e = t.lib.Hasher
                          , i = t.x64
                          , r = i.Word
                          , o = i.WordArray
                          , n = t.algo;
                        function s() {
                            return r.create.apply(r, arguments)
                        }
                        var a = [s(1116352408, 3609767458), s(1899447441, 602891725), s(3049323471, 3964484399), s(3921009573, 2173295548), s(961987163, 4081628472), s(1508970993, 3053834265), s(2453635748, 2937671579), s(2870763221, 3664609560), s(3624381080, 2734883394), s(310598401, 1164996542), s(607225278, 1323610764), s(1426881987, 3590304994), s(1925078388, 4068182383), s(2162078206, 991336113), s(2614888103, 633803317), s(3248222580, 3479774868), s(3835390401, 2666613458), s(4022224774, 944711139), s(264347078, 2341262773), s(604807628, 2007800933), s(770255983, 1495990901), s(1249150122, 1856431235), s(1555081692, 3175218132), s(1996064986, 2198950837), s(2554220882, 3999719339), s(2821834349, 766784016), s(2952996808, 2566594879), s(3210313671, 3203337956), s(3336571891, 1034457026), s(3584528711, 2466948901), s(113926993, 3758326383), s(338241895, 168717936), s(666307205, 1188179964), s(773529912, 1546045734), s(1294757372, 1522805485), s(1396182291, 2643833823), s(1695183700, 2343527390), s(1986661051, 1014477480), s(2177026350, 1206759142), s(2456956037, 344077627), s(2730485921, 1290863460), s(2820302411, 3158454273), s(3259730800, 3505952657), s(3345764771, 106217008), s(3516065817, 3606008344), s(3600352804, 1432725776), s(4094571909, 1467031594), s(275423344, 851169720), s(430227734, 3100823752), s(506948616, 1363258195), s(659060556, 3750685593), s(883997877, 3785050280), s(958139571, 3318307427), s(1322822218, 3812723403), s(1537002063, 2003034995), s(1747873779, 3602036899), s(1955562222, 1575990012), s(2024104815, 1125592928), s(2227730452, 2716904306), s(2361852424, 442776044), s(2428436474, 593698344), s(2756734187, 3733110249), s(3204031479, 2999351573), s(3329325298, 3815920427), s(3391569614, 3928383900), s(3515267271, 566280711), s(3940187606, 3454069534), s(4118630271, 4000239992), s(116418474, 1914138554), s(174292421, 2731055270), s(289380356, 3203993006), s(460393269, 320620315), s(685471733, 587496836), s(852142971, 1086792851), s(1017036298, 365543100), s(1126000580, 2618297676), s(1288033470, 3409855158), s(1501505948, 4234509866), s(1607167915, 987167468), s(1816402316, 1246189591)]
                          , l = [];
                        !function() {
                            for (var t = 0; t < 80; t++)
                                l[t] = s();
                        }();
                        var c = n.SHA512 = e.extend({
                            _doReset: function() {
                                this._hash = new o.init([new r.init(1779033703,4089235720), new r.init(3144134277,2227873595), new r.init(1013904242,4271175723), new r.init(2773480762,1595750129), new r.init(1359893119,2917565137), new r.init(2600822924,725511199), new r.init(528734635,4215389547), new r.init(1541459225,327033209)]);
                            },
                            _doProcessBlock: function(t, e) {
                                for (var i = this._hash.words, r = i[0], o = i[1], n = i[2], s = i[3], c = i[4], h = i[5], u = i[6], d = i[7], f = r.high, _ = r.low, p = o.high, m = o.low, g = n.high, v = n.low, y = s.high, b = s.low, x = c.high, w = c.low, T = h.high, E = h.low, S = u.high, C = u.low, A = d.high, M = d.low, I = f, z = _, P = p, D = m, B = g, L = v, R = y, k = b, O = x, F = w, U = T, N = E, j = S, G = C, V = A, Z = M, W = 0; W < 80; W++) {
                                    var q, H, X, Y, K, J, $, Q, tt, et, it, rt, ot, nt, st, at = l[W];
                                    W < 16 ? (st = at.high = 0 | t[e + 2 * W],
                                    nt = at.low = 0 | t[e + 2 * W + 1]) : (Y = ((H = (q = l[W - 15]).high) >>> 1 | (X = q.low) << 31) ^ (H >>> 8 | X << 24) ^ H >>> 7,
                                    tt = (($ = (J = l[W - 2]).high) >>> 19 | (Q = J.low) << 13) ^ ($ << 3 | Q >>> 29) ^ $ >>> 6,
                                    st = (st = (st = Y + (it = l[W - 7]).high + ((nt = (K = (X >>> 1 | H << 31) ^ (X >>> 8 | H << 24) ^ (X >>> 7 | H << 25)) + it.low) >>> 0 < K >>> 0 ? 1 : 0)) + tt + ((nt += et = (Q >>> 19 | $ << 13) ^ (Q << 3 | $ >>> 29) ^ (Q >>> 6 | $ << 26)) >>> 0 < et >>> 0 ? 1 : 0)) + (rt = l[W - 16]).high + ((nt += ot = rt.low) >>> 0 < ot >>> 0 ? 1 : 0),
                                    at.high = st,
                                    at.low = nt);
                                    var lt = O & U ^ ~O & j
                                      , ct = F & N ^ ~F & G
                                      , ht = I & P ^ I & B ^ P & B
                                      , ut = (z >>> 28 | I << 4) ^ (z << 30 | I >>> 2) ^ (z << 25 | I >>> 7)
                                      , dt = a[W]
                                      , ft = dt.low
                                      , _t = Z + ((F >>> 14 | O << 18) ^ (F >>> 18 | O << 14) ^ (F << 23 | O >>> 9))
                                      , pt = V + ((O >>> 14 | F << 18) ^ (O >>> 18 | F << 14) ^ (O << 23 | F >>> 9)) + (_t >>> 0 < Z >>> 0 ? 1 : 0)
                                      , mt = ut + (z & D ^ z & L ^ D & L);
                                    V = j,
                                    Z = G,
                                    j = U,
                                    G = N,
                                    U = O,
                                    N = F,
                                    O = R + (pt = (pt = (pt = pt + lt + ((_t += ct) >>> 0 < ct >>> 0 ? 1 : 0)) + dt.high + ((_t += ft) >>> 0 < ft >>> 0 ? 1 : 0)) + st + ((_t += nt) >>> 0 < nt >>> 0 ? 1 : 0)) + ((F = k + _t | 0) >>> 0 < k >>> 0 ? 1 : 0) | 0,
                                    R = B,
                                    k = L,
                                    B = P,
                                    L = D,
                                    P = I,
                                    D = z,
                                    I = pt + (((I >>> 28 | z << 4) ^ (I << 30 | z >>> 2) ^ (I << 25 | z >>> 7)) + ht + (mt >>> 0 < ut >>> 0 ? 1 : 0)) + ((z = _t + mt | 0) >>> 0 < _t >>> 0 ? 1 : 0) | 0;
                                }
                                _ = r.low = _ + z,
                                r.high = f + I + (_ >>> 0 < z >>> 0 ? 1 : 0),
                                m = o.low = m + D,
                                o.high = p + P + (m >>> 0 < D >>> 0 ? 1 : 0),
                                v = n.low = v + L,
                                n.high = g + B + (v >>> 0 < L >>> 0 ? 1 : 0),
                                b = s.low = b + k,
                                s.high = y + R + (b >>> 0 < k >>> 0 ? 1 : 0),
                                w = c.low = w + F,
                                c.high = x + O + (w >>> 0 < F >>> 0 ? 1 : 0),
                                E = h.low = E + N,
                                h.high = T + U + (E >>> 0 < N >>> 0 ? 1 : 0),
                                C = u.low = C + G,
                                u.high = S + j + (C >>> 0 < G >>> 0 ? 1 : 0),
                                M = d.low = M + Z,
                                d.high = A + V + (M >>> 0 < Z >>> 0 ? 1 : 0);
                            },
                            _doFinalize: function() {
                                var t = this._data
                                  , e = t.words
                                  , i = 8 * this._nDataBytes
                                  , r = 8 * t.sigBytes;
                                return e[r >>> 5] |= 128 << 24 - r % 32,
                                e[30 + (128 + r >>> 10 << 5)] = Math.floor(i / 4294967296),
                                e[31 + (128 + r >>> 10 << 5)] = i,
                                t.sigBytes = 4 * e.length,
                                this._process(),
                                this._hash.toX32()
                            },
                            clone: function() {
                                var t = e.clone.call(this);
                                return t._hash = this._hash.clone(),
                                t
                            },
                            blockSize: 32
                        });
                        t.SHA512 = e._createHelper(c),
                        t.HmacSHA512 = e._createHmacHelper(c);
                    }(),
                    rt = (it = Pt).x64,
                    ot = rt.Word,
                    nt = rt.WordArray,
                    lt = (st = it.algo).SHA384 = (at = st.SHA512).extend({
                        _doReset: function() {
                            this._hash = new nt.init([new ot.init(3418070365,3238371032), new ot.init(1654270250,914150663), new ot.init(2438529370,812702999), new ot.init(355462360,4144912697), new ot.init(1731405415,4290775857), new ot.init(2394180231,1750603025), new ot.init(3675008525,1694076839), new ot.init(1203062813,3204075428)]);
                        },
                        _doFinalize: function() {
                            var t = at._doFinalize.call(this);
                            return t.sigBytes -= 16,
                            t
                        }
                    }),
                    it.SHA384 = at._createHelper(lt),
                    it.HmacSHA384 = at._createHmacHelper(lt),
                    Pt.lib.Cipher || function() {
                        var t = Pt
                          , e = t.lib
                          , i = e.Base
                          , r = e.WordArray
                          , o = e.BufferedBlockAlgorithm
                          , n = t.enc.Base64
                          , s = t.algo.EvpKDF
                          , a = e.Cipher = o.extend({
                            cfg: i.extend(),
                            createEncryptor: function(t, e) {
                                return this.create(this._ENC_XFORM_MODE, t, e)
                            },
                            createDecryptor: function(t, e) {
                                return this.create(this._DEC_XFORM_MODE, t, e)
                            },
                            init: function(t, e, i) {
                                this.cfg = this.cfg.extend(i),
                                this._xformMode = t,
                                this._key = e,
                                this.reset();
                            },
                            reset: function() {
                                o.reset.call(this),
                                this._doReset();
                            },
                            process: function(t) {
                                return this._append(t),
                                this._process()
                            },
                            finalize: function(t) {
                                return t && this._append(t),
                                this._doFinalize()
                            },
                            keySize: 4,
                            ivSize: 4,
                            _ENC_XFORM_MODE: 1,
                            _DEC_XFORM_MODE: 2,
                            _createHelper: function(t) {
                                return {
                                    encrypt: function(e, i, r) {
                                        return l(i).encrypt(t, e, i, r)
                                    },
                                    decrypt: function(e, i, r) {
                                        return l(i).decrypt(t, e, i, r)
                                    }
                                }
                            }
                        });
                        function l(t) {
                            return "string" == typeof t ? y : g
                        }
                        e.StreamCipher = a.extend({
                            _doFinalize: function() {
                                return this._process(!0)
                            },
                            blockSize: 1
                        });
                        var c, h = t.mode = {}, u = e.BlockCipherMode = i.extend({
                            createEncryptor: function(t, e) {
                                return this.Encryptor.create(t, e)
                            },
                            createDecryptor: function(t, e) {
                                return this.Decryptor.create(t, e)
                            },
                            init: function(t, e) {
                                this._cipher = t,
                                this._iv = e;
                            }
                        }), d = h.CBC = ((c = u.extend()).Encryptor = c.extend({
                            processBlock: function(t, e) {
                                var i = this._cipher
                                  , r = i.blockSize;
                                f.call(this, t, e, r),
                                i.encryptBlock(t, e),
                                this._prevBlock = t.slice(e, e + r);
                            }
                        }),
                        c.Decryptor = c.extend({
                            processBlock: function(t, e) {
                                var i = this._cipher
                                  , r = i.blockSize
                                  , o = t.slice(e, e + r);
                                i.decryptBlock(t, e),
                                f.call(this, t, e, r),
                                this._prevBlock = o;
                            }
                        }),
                        c);
                        function f(t, e, i) {
                            var r, o = this._iv;
                            o ? (r = o,
                            this._iv = void 0) : r = this._prevBlock;
                            for (var n = 0; n < i; n++)
                                t[e + n] ^= r[n];
                        }
                        var _ = (t.pad = {}).Pkcs7 = {
                            pad: function(t, e) {
                                for (var i = 4 * e, o = i - t.sigBytes % i, n = o << 24 | o << 16 | o << 8 | o, s = [], a = 0; a < o; a += 4)
                                    s.push(n);
                                var l = r.create(s, o);
                                t.concat(l);
                            },
                            unpad: function(t) {
                                t.sigBytes -= 255 & t.words[t.sigBytes - 1 >>> 2];
                            }
                        }
                          , p = (e.BlockCipher = a.extend({
                            cfg: a.cfg.extend({
                                mode: d,
                                padding: _
                            }),
                            reset: function() {
                                a.reset.call(this);
                                var t, e = this.cfg, i = e.iv, r = e.mode;
                                this._xformMode == this._ENC_XFORM_MODE ? t = r.createEncryptor : (t = r.createDecryptor,
                                this._minBufferSize = 1),
                                this._mode && this._mode.__creator == t ? this._mode.init(this, i && i.words) : (this._mode = t.call(r, this, i && i.words),
                                this._mode.__creator = t);
                            },
                            _doProcessBlock: function(t, e) {
                                this._mode.processBlock(t, e);
                            },
                            _doFinalize: function() {
                                var t, e = this.cfg.padding;
                                return this._xformMode == this._ENC_XFORM_MODE ? (e.pad(this._data, this.blockSize),
                                t = this._process(!0)) : (t = this._process(!0),
                                e.unpad(t)),
                                t
                            },
                            blockSize: 4
                        }),
                        e.CipherParams = i.extend({
                            init: function(t) {
                                this.mixIn(t);
                            },
                            toString: function(t) {
                                return (t || this.formatter).stringify(this)
                            }
                        }))
                          , m = (t.format = {}).OpenSSL = {
                            stringify: function(t) {
                                var e = t.ciphertext
                                  , i = t.salt;
                                return (i ? r.create([1398893684, 1701076831]).concat(i).concat(e) : e).toString(n)
                            },
                            parse: function(t) {
                                var e, i = n.parse(t), o = i.words;
                                return 1398893684 == o[0] && 1701076831 == o[1] && (e = r.create(o.slice(2, 4)),
                                o.splice(0, 4),
                                i.sigBytes -= 16),
                                p.create({
                                    ciphertext: i,
                                    salt: e
                                })
                            }
                        }
                          , g = e.SerializableCipher = i.extend({
                            cfg: i.extend({
                                format: m
                            }),
                            encrypt: function(t, e, i, r) {
                                r = this.cfg.extend(r);
                                var o = t.createEncryptor(i, r)
                                  , n = o.finalize(e)
                                  , s = o.cfg;
                                return p.create({
                                    ciphertext: n,
                                    key: i,
                                    iv: s.iv,
                                    algorithm: t,
                                    mode: s.mode,
                                    padding: s.padding,
                                    blockSize: t.blockSize,
                                    formatter: r.format
                                })
                            },
                            decrypt: function(t, e, i, r) {
                                return r = this.cfg.extend(r),
                                e = this._parse(e, r.format),
                                t.createDecryptor(i, r).finalize(e.ciphertext)
                            },
                            _parse: function(t, e) {
                                return "string" == typeof t ? e.parse(t, this) : t
                            }
                        })
                          , v = (t.kdf = {}).OpenSSL = {
                            execute: function(t, e, i, o) {
                                o = o || r.random(8);
                                var n = s.create({
                                    keySize: e + i
                                }).compute(t, o)
                                  , a = r.create(n.words.slice(e), 4 * i);
                                return n.sigBytes = 4 * e,
                                p.create({
                                    key: n,
                                    iv: a,
                                    salt: o
                                })
                            }
                        }
                          , y = e.PasswordBasedCipher = g.extend({
                            cfg: g.cfg.extend({
                                kdf: v
                            }),
                            encrypt: function(t, e, i, r) {
                                var o = (r = this.cfg.extend(r)).kdf.execute(i, t.keySize, t.ivSize);
                                r.iv = o.iv;
                                var n = g.encrypt.call(this, t, e, o.key, r);
                                return n.mixIn(o),
                                n
                            },
                            decrypt: function(t, e, i, r) {
                                r = this.cfg.extend(r),
                                e = this._parse(e, r.format);
                                var o = r.kdf.execute(i, t.keySize, t.ivSize, e.salt);
                                return r.iv = o.iv,
                                g.decrypt.call(this, t, e, o.key, r)
                            }
                        });
                    }(),
                    Pt.mode.CFB = ((ct = Pt.lib.BlockCipherMode.extend()).Encryptor = ct.extend({
                        processBlock: function(t, e) {
                            var i = this._cipher
                              , r = i.blockSize;
                            kt.call(this, t, e, r, i),
                            this._prevBlock = t.slice(e, e + r);
                        }
                    }),
                    ct.Decryptor = ct.extend({
                        processBlock: function(t, e) {
                            var i = this._cipher
                              , r = i.blockSize
                              , o = t.slice(e, e + r);
                            kt.call(this, t, e, r, i),
                            this._prevBlock = o;
                        }
                    }),
                    ct),
                    Pt.mode.ECB = ((ht = Pt.lib.BlockCipherMode.extend()).Encryptor = ht.extend({
                        processBlock: function(t, e) {
                            this._cipher.encryptBlock(t, e);
                        }
                    }),
                    ht.Decryptor = ht.extend({
                        processBlock: function(t, e) {
                            this._cipher.decryptBlock(t, e);
                        }
                    }),
                    ht),
                    Pt.pad.AnsiX923 = {
                        pad: function(t, e) {
                            var i = t.sigBytes
                              , r = 4 * e
                              , o = r - i % r
                              , n = i + o - 1;
                            t.clamp(),
                            t.words[n >>> 2] |= o << 24 - n % 4 * 8,
                            t.sigBytes += o;
                        },
                        unpad: function(t) {
                            t.sigBytes -= 255 & t.words[t.sigBytes - 1 >>> 2];
                        }
                    },
                    Pt.pad.Iso10126 = {
                        pad: function(t, e) {
                            var i = 4 * e
                              , r = i - t.sigBytes % i;
                            t.concat(Pt.lib.WordArray.random(r - 1)).concat(Pt.lib.WordArray.create([r << 24], 1));
                        },
                        unpad: function(t) {
                            t.sigBytes -= 255 & t.words[t.sigBytes - 1 >>> 2];
                        }
                    },
                    Pt.pad.Iso97971 = {
                        pad: function(t, e) {
                            t.concat(Pt.lib.WordArray.create([2147483648], 1)),
                            Pt.pad.ZeroPadding.pad(t, e);
                        },
                        unpad: function(t) {
                            Pt.pad.ZeroPadding.unpad(t),
                            t.sigBytes--;
                        }
                    },
                    Pt.mode.OFB = (dt = (ut = Pt.lib.BlockCipherMode.extend()).Encryptor = ut.extend({
                        processBlock: function(t, e) {
                            var i = this._cipher
                              , r = i.blockSize
                              , o = this._iv
                              , n = this._keystream;
                            o && (n = this._keystream = o.slice(0),
                            this._iv = void 0),
                            i.encryptBlock(n, 0);
                            for (var s = 0; s < r; s++)
                                t[e + s] ^= n[s];
                        }
                    }),
                    ut.Decryptor = dt,
                    ut),
                    Pt.pad.NoPadding = {
                        pad: function() {},
                        unpad: function() {}
                    },
                    ft = Pt.lib.CipherParams,
                    _t = Pt.enc.Hex,
                    Pt.format.Hex = {
                        stringify: function(t) {
                            return t.ciphertext.toString(_t)
                        },
                        parse: function(t) {
                            var e = _t.parse(t);
                            return ft.create({
                                ciphertext: e
                            })
                        }
                    },
                    function() {
                        var t = Pt
                          , e = t.lib.BlockCipher
                          , i = t.algo
                          , r = []
                          , o = []
                          , n = []
                          , s = []
                          , a = []
                          , l = []
                          , c = []
                          , h = []
                          , u = []
                          , d = [];
                        !function() {
                            for (var t = [], e = 0; e < 256; e++)
                                t[e] = e < 128 ? e << 1 : e << 1 ^ 283;
                            var i = 0
                              , f = 0;
                            for (e = 0; e < 256; e++) {
                                var _ = (_ = f ^ f << 1 ^ f << 2 ^ f << 3 ^ f << 4) >>> 8 ^ 255 & _ ^ 99;
                                r[i] = _;
                                var p = t[o[_] = i]
                                  , m = t[p]
                                  , g = t[m]
                                  , v = 257 * t[_] ^ 16843008 * _;
                                n[i] = v << 24 | v >>> 8,
                                s[i] = v << 16 | v >>> 16,
                                a[i] = v << 8 | v >>> 24,
                                l[i] = v,
                                c[_] = (v = 16843009 * g ^ 65537 * m ^ 257 * p ^ 16843008 * i) << 24 | v >>> 8,
                                h[_] = v << 16 | v >>> 16,
                                u[_] = v << 8 | v >>> 24,
                                d[_] = v,
                                i ? (i = p ^ t[t[t[g ^ p]]],
                                f ^= t[t[f]]) : i = f = 1;
                            }
                        }();
                        var f = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54]
                          , _ = i.AES = e.extend({
                            _doReset: function() {
                                if (!this._nRounds || this._keyPriorReset !== this._key) {
                                    for (var t = this._keyPriorReset = this._key, e = t.words, i = t.sigBytes / 4, o = 4 * (1 + (this._nRounds = 6 + i)), n = this._keySchedule = [], s = 0; s < o; s++)
                                        s < i ? n[s] = e[s] : (_ = n[s - 1],
                                        s % i ? 6 < i && s % i == 4 && (_ = r[_ >>> 24] << 24 | r[_ >>> 16 & 255] << 16 | r[_ >>> 8 & 255] << 8 | r[255 & _]) : (_ = r[(_ = _ << 8 | _ >>> 24) >>> 24] << 24 | r[_ >>> 16 & 255] << 16 | r[_ >>> 8 & 255] << 8 | r[255 & _],
                                        _ ^= f[s / i | 0] << 24),
                                        n[s] = n[s - i] ^ _);
                                    for (var a = this._invKeySchedule = [], l = 0; l < o; l++) {
                                        var _;
                                        s = o - l,
                                        _ = l % 4 ? n[s] : n[s - 4],
                                        a[l] = l < 4 || s <= 4 ? _ : c[r[_ >>> 24]] ^ h[r[_ >>> 16 & 255]] ^ u[r[_ >>> 8 & 255]] ^ d[r[255 & _]];
                                    }
                                }
                            },
                            encryptBlock: function(t, e) {
                                this._doCryptBlock(t, e, this._keySchedule, n, s, a, l, r);
                            },
                            decryptBlock: function(t, e) {
                                var i = t[e + 1];
                                t[e + 1] = t[e + 3],
                                t[e + 3] = i,
                                this._doCryptBlock(t, e, this._invKeySchedule, c, h, u, d, o),
                                i = t[e + 1],
                                t[e + 1] = t[e + 3],
                                t[e + 3] = i;
                            },
                            _doCryptBlock: function(t, e, i, r, o, n, s, a) {
                                for (var l = this._nRounds, c = t[e] ^ i[0], h = t[e + 1] ^ i[1], u = t[e + 2] ^ i[2], d = t[e + 3] ^ i[3], f = 4, _ = 1; _ < l; _++) {
                                    var p = r[c >>> 24] ^ o[h >>> 16 & 255] ^ n[u >>> 8 & 255] ^ s[255 & d] ^ i[f++]
                                      , m = r[h >>> 24] ^ o[u >>> 16 & 255] ^ n[d >>> 8 & 255] ^ s[255 & c] ^ i[f++]
                                      , g = r[u >>> 24] ^ o[d >>> 16 & 255] ^ n[c >>> 8 & 255] ^ s[255 & h] ^ i[f++]
                                      , v = r[d >>> 24] ^ o[c >>> 16 & 255] ^ n[h >>> 8 & 255] ^ s[255 & u] ^ i[f++];
                                    c = p,
                                    h = m,
                                    u = g,
                                    d = v;
                                }
                                p = (a[c >>> 24] << 24 | a[h >>> 16 & 255] << 16 | a[u >>> 8 & 255] << 8 | a[255 & d]) ^ i[f++],
                                m = (a[h >>> 24] << 24 | a[u >>> 16 & 255] << 16 | a[d >>> 8 & 255] << 8 | a[255 & c]) ^ i[f++],
                                g = (a[u >>> 24] << 24 | a[d >>> 16 & 255] << 16 | a[c >>> 8 & 255] << 8 | a[255 & h]) ^ i[f++],
                                v = (a[d >>> 24] << 24 | a[c >>> 16 & 255] << 16 | a[h >>> 8 & 255] << 8 | a[255 & u]) ^ i[f++],
                                t[e] = p,
                                t[e + 1] = m,
                                t[e + 2] = g,
                                t[e + 3] = v;
                            },
                            keySize: 8
                        });
                        t.AES = e._createHelper(_);
                    }(),
                    function() {
                        var t = Pt
                          , e = t.lib
                          , i = e.WordArray
                          , r = e.BlockCipher
                          , o = t.algo
                          , n = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4]
                          , s = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32]
                          , a = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28]
                          , l = [{
                            0: 8421888,
                            268435456: 32768,
                            536870912: 8421378,
                            805306368: 2,
                            1073741824: 512,
                            1342177280: 8421890,
                            1610612736: 8389122,
                            1879048192: 8388608,
                            2147483648: 514,
                            2415919104: 8389120,
                            2684354560: 33280,
                            2952790016: 8421376,
                            3221225472: 32770,
                            3489660928: 8388610,
                            3758096384: 0,
                            4026531840: 33282,
                            134217728: 0,
                            402653184: 8421890,
                            671088640: 33282,
                            939524096: 32768,
                            1207959552: 8421888,
                            1476395008: 512,
                            1744830464: 8421378,
                            2013265920: 2,
                            2281701376: 8389120,
                            2550136832: 33280,
                            2818572288: 8421376,
                            3087007744: 8389122,
                            3355443200: 8388610,
                            3623878656: 32770,
                            3892314112: 514,
                            4160749568: 8388608,
                            1: 32768,
                            268435457: 2,
                            536870913: 8421888,
                            805306369: 8388608,
                            1073741825: 8421378,
                            1342177281: 33280,
                            1610612737: 512,
                            1879048193: 8389122,
                            2147483649: 8421890,
                            2415919105: 8421376,
                            2684354561: 8388610,
                            2952790017: 33282,
                            3221225473: 514,
                            3489660929: 8389120,
                            3758096385: 32770,
                            4026531841: 0,
                            134217729: 8421890,
                            402653185: 8421376,
                            671088641: 8388608,
                            939524097: 512,
                            1207959553: 32768,
                            1476395009: 8388610,
                            1744830465: 2,
                            2013265921: 33282,
                            2281701377: 32770,
                            2550136833: 8389122,
                            2818572289: 514,
                            3087007745: 8421888,
                            3355443201: 8389120,
                            3623878657: 0,
                            3892314113: 33280,
                            4160749569: 8421378
                        }, {
                            0: 1074282512,
                            16777216: 16384,
                            33554432: 524288,
                            50331648: 1074266128,
                            67108864: 1073741840,
                            83886080: 1074282496,
                            100663296: 1073758208,
                            117440512: 16,
                            134217728: 540672,
                            150994944: 1073758224,
                            167772160: 1073741824,
                            184549376: 540688,
                            201326592: 524304,
                            218103808: 0,
                            234881024: 16400,
                            251658240: 1074266112,
                            8388608: 1073758208,
                            25165824: 540688,
                            41943040: 16,
                            58720256: 1073758224,
                            75497472: 1074282512,
                            92274688: 1073741824,
                            109051904: 524288,
                            125829120: 1074266128,
                            142606336: 524304,
                            159383552: 0,
                            176160768: 16384,
                            192937984: 1074266112,
                            209715200: 1073741840,
                            226492416: 540672,
                            243269632: 1074282496,
                            260046848: 16400,
                            268435456: 0,
                            285212672: 1074266128,
                            301989888: 1073758224,
                            318767104: 1074282496,
                            335544320: 1074266112,
                            352321536: 16,
                            369098752: 540688,
                            385875968: 16384,
                            402653184: 16400,
                            419430400: 524288,
                            436207616: 524304,
                            452984832: 1073741840,
                            469762048: 540672,
                            486539264: 1073758208,
                            503316480: 1073741824,
                            520093696: 1074282512,
                            276824064: 540688,
                            293601280: 524288,
                            310378496: 1074266112,
                            327155712: 16384,
                            343932928: 1073758208,
                            360710144: 1074282512,
                            377487360: 16,
                            394264576: 1073741824,
                            411041792: 1074282496,
                            427819008: 1073741840,
                            444596224: 1073758224,
                            461373440: 524304,
                            478150656: 0,
                            494927872: 16400,
                            511705088: 1074266128,
                            528482304: 540672
                        }, {
                            0: 260,
                            1048576: 0,
                            2097152: 67109120,
                            3145728: 65796,
                            4194304: 65540,
                            5242880: 67108868,
                            6291456: 67174660,
                            7340032: 67174400,
                            8388608: 67108864,
                            9437184: 67174656,
                            10485760: 65792,
                            11534336: 67174404,
                            12582912: 67109124,
                            13631488: 65536,
                            14680064: 4,
                            15728640: 256,
                            524288: 67174656,
                            1572864: 67174404,
                            2621440: 0,
                            3670016: 67109120,
                            4718592: 67108868,
                            5767168: 65536,
                            6815744: 65540,
                            7864320: 260,
                            8912896: 4,
                            9961472: 256,
                            11010048: 67174400,
                            12058624: 65796,
                            13107200: 65792,
                            14155776: 67109124,
                            15204352: 67174660,
                            16252928: 67108864,
                            16777216: 67174656,
                            17825792: 65540,
                            18874368: 65536,
                            19922944: 67109120,
                            20971520: 256,
                            22020096: 67174660,
                            23068672: 67108868,
                            24117248: 0,
                            25165824: 67109124,
                            26214400: 67108864,
                            27262976: 4,
                            28311552: 65792,
                            29360128: 67174400,
                            30408704: 260,
                            31457280: 65796,
                            32505856: 67174404,
                            17301504: 67108864,
                            18350080: 260,
                            19398656: 67174656,
                            20447232: 0,
                            21495808: 65540,
                            22544384: 67109120,
                            23592960: 256,
                            24641536: 67174404,
                            25690112: 65536,
                            26738688: 67174660,
                            27787264: 65796,
                            28835840: 67108868,
                            29884416: 67109124,
                            30932992: 67174400,
                            31981568: 4,
                            33030144: 65792
                        }, {
                            0: 2151682048,
                            65536: 2147487808,
                            131072: 4198464,
                            196608: 2151677952,
                            262144: 0,
                            327680: 4198400,
                            393216: 2147483712,
                            458752: 4194368,
                            524288: 2147483648,
                            589824: 4194304,
                            655360: 64,
                            720896: 2147487744,
                            786432: 2151678016,
                            851968: 4160,
                            917504: 4096,
                            983040: 2151682112,
                            32768: 2147487808,
                            98304: 64,
                            163840: 2151678016,
                            229376: 2147487744,
                            294912: 4198400,
                            360448: 2151682112,
                            425984: 0,
                            491520: 2151677952,
                            557056: 4096,
                            622592: 2151682048,
                            688128: 4194304,
                            753664: 4160,
                            819200: 2147483648,
                            884736: 4194368,
                            950272: 4198464,
                            1015808: 2147483712,
                            1048576: 4194368,
                            1114112: 4198400,
                            1179648: 2147483712,
                            1245184: 0,
                            1310720: 4160,
                            1376256: 2151678016,
                            1441792: 2151682048,
                            1507328: 2147487808,
                            1572864: 2151682112,
                            1638400: 2147483648,
                            1703936: 2151677952,
                            1769472: 4198464,
                            1835008: 2147487744,
                            1900544: 4194304,
                            1966080: 64,
                            2031616: 4096,
                            1081344: 2151677952,
                            1146880: 2151682112,
                            1212416: 0,
                            1277952: 4198400,
                            1343488: 4194368,
                            1409024: 2147483648,
                            1474560: 2147487808,
                            1540096: 64,
                            1605632: 2147483712,
                            1671168: 4096,
                            1736704: 2147487744,
                            1802240: 2151678016,
                            1867776: 4160,
                            1933312: 2151682048,
                            1998848: 4194304,
                            2064384: 4198464
                        }, {
                            0: 128,
                            4096: 17039360,
                            8192: 262144,
                            12288: 536870912,
                            16384: 537133184,
                            20480: 16777344,
                            24576: 553648256,
                            28672: 262272,
                            32768: 16777216,
                            36864: 537133056,
                            40960: 536871040,
                            45056: 553910400,
                            49152: 553910272,
                            53248: 0,
                            57344: 17039488,
                            61440: 553648128,
                            2048: 17039488,
                            6144: 553648256,
                            10240: 128,
                            14336: 17039360,
                            18432: 262144,
                            22528: 537133184,
                            26624: 553910272,
                            30720: 536870912,
                            34816: 537133056,
                            38912: 0,
                            43008: 553910400,
                            47104: 16777344,
                            51200: 536871040,
                            55296: 553648128,
                            59392: 16777216,
                            63488: 262272,
                            65536: 262144,
                            69632: 128,
                            73728: 536870912,
                            77824: 553648256,
                            81920: 16777344,
                            86016: 553910272,
                            90112: 537133184,
                            94208: 16777216,
                            98304: 553910400,
                            102400: 553648128,
                            106496: 17039360,
                            110592: 537133056,
                            114688: 262272,
                            118784: 536871040,
                            122880: 0,
                            126976: 17039488,
                            67584: 553648256,
                            71680: 16777216,
                            75776: 17039360,
                            79872: 537133184,
                            83968: 536870912,
                            88064: 17039488,
                            92160: 128,
                            96256: 553910272,
                            100352: 262272,
                            104448: 553910400,
                            108544: 0,
                            112640: 553648128,
                            116736: 16777344,
                            120832: 262144,
                            124928: 537133056,
                            129024: 536871040
                        }, {
                            0: 268435464,
                            256: 8192,
                            512: 270532608,
                            768: 270540808,
                            1024: 268443648,
                            1280: 2097152,
                            1536: 2097160,
                            1792: 268435456,
                            2048: 0,
                            2304: 268443656,
                            2560: 2105344,
                            2816: 8,
                            3072: 270532616,
                            3328: 2105352,
                            3584: 8200,
                            3840: 270540800,
                            128: 270532608,
                            384: 270540808,
                            640: 8,
                            896: 2097152,
                            1152: 2105352,
                            1408: 268435464,
                            1664: 268443648,
                            1920: 8200,
                            2176: 2097160,
                            2432: 8192,
                            2688: 268443656,
                            2944: 270532616,
                            3200: 0,
                            3456: 270540800,
                            3712: 2105344,
                            3968: 268435456,
                            4096: 268443648,
                            4352: 270532616,
                            4608: 270540808,
                            4864: 8200,
                            5120: 2097152,
                            5376: 268435456,
                            5632: 268435464,
                            5888: 2105344,
                            6144: 2105352,
                            6400: 0,
                            6656: 8,
                            6912: 270532608,
                            7168: 8192,
                            7424: 268443656,
                            7680: 270540800,
                            7936: 2097160,
                            4224: 8,
                            4480: 2105344,
                            4736: 2097152,
                            4992: 268435464,
                            5248: 268443648,
                            5504: 8200,
                            5760: 270540808,
                            6016: 270532608,
                            6272: 270540800,
                            6528: 270532616,
                            6784: 8192,
                            7040: 2105352,
                            7296: 2097160,
                            7552: 0,
                            7808: 268435456,
                            8064: 268443656
                        }, {
                            0: 1048576,
                            16: 33555457,
                            32: 1024,
                            48: 1049601,
                            64: 34604033,
                            80: 0,
                            96: 1,
                            112: 34603009,
                            128: 33555456,
                            144: 1048577,
                            160: 33554433,
                            176: 34604032,
                            192: 34603008,
                            208: 1025,
                            224: 1049600,
                            240: 33554432,
                            8: 34603009,
                            24: 0,
                            40: 33555457,
                            56: 34604032,
                            72: 1048576,
                            88: 33554433,
                            104: 33554432,
                            120: 1025,
                            136: 1049601,
                            152: 33555456,
                            168: 34603008,
                            184: 1048577,
                            200: 1024,
                            216: 34604033,
                            232: 1,
                            248: 1049600,
                            256: 33554432,
                            272: 1048576,
                            288: 33555457,
                            304: 34603009,
                            320: 1048577,
                            336: 33555456,
                            352: 34604032,
                            368: 1049601,
                            384: 1025,
                            400: 34604033,
                            416: 1049600,
                            432: 1,
                            448: 0,
                            464: 34603008,
                            480: 33554433,
                            496: 1024,
                            264: 1049600,
                            280: 33555457,
                            296: 34603009,
                            312: 1,
                            328: 33554432,
                            344: 1048576,
                            360: 1025,
                            376: 34604032,
                            392: 33554433,
                            408: 34603008,
                            424: 0,
                            440: 34604033,
                            456: 1049601,
                            472: 1024,
                            488: 33555456,
                            504: 1048577
                        }, {
                            0: 134219808,
                            1: 131072,
                            2: 134217728,
                            3: 32,
                            4: 131104,
                            5: 134350880,
                            6: 134350848,
                            7: 2048,
                            8: 134348800,
                            9: 134219776,
                            10: 133120,
                            11: 134348832,
                            12: 2080,
                            13: 0,
                            14: 134217760,
                            15: 133152,
                            2147483648: 2048,
                            2147483649: 134350880,
                            2147483650: 134219808,
                            2147483651: 134217728,
                            2147483652: 134348800,
                            2147483653: 133120,
                            2147483654: 133152,
                            2147483655: 32,
                            2147483656: 134217760,
                            2147483657: 2080,
                            2147483658: 131104,
                            2147483659: 134350848,
                            2147483660: 0,
                            2147483661: 134348832,
                            2147483662: 134219776,
                            2147483663: 131072,
                            16: 133152,
                            17: 134350848,
                            18: 32,
                            19: 2048,
                            20: 134219776,
                            21: 134217760,
                            22: 134348832,
                            23: 131072,
                            24: 0,
                            25: 131104,
                            26: 134348800,
                            27: 134219808,
                            28: 134350880,
                            29: 133120,
                            30: 2080,
                            31: 134217728,
                            2147483664: 131072,
                            2147483665: 2048,
                            2147483666: 134348832,
                            2147483667: 133152,
                            2147483668: 32,
                            2147483669: 134348800,
                            2147483670: 134217728,
                            2147483671: 134219808,
                            2147483672: 134350880,
                            2147483673: 134217760,
                            2147483674: 134219776,
                            2147483675: 0,
                            2147483676: 133120,
                            2147483677: 2080,
                            2147483678: 131104,
                            2147483679: 134350848
                        }]
                          , c = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679]
                          , h = o.DES = r.extend({
                            _doReset: function() {
                                for (var t = this._key.words, e = [], i = 0; i < 56; i++) {
                                    var r = n[i] - 1;
                                    e[i] = t[r >>> 5] >>> 31 - r % 32 & 1;
                                }
                                for (var o = this._subKeys = [], l = 0; l < 16; l++) {
                                    var c = o[l] = []
                                      , h = a[l];
                                    for (i = 0; i < 24; i++)
                                        c[i / 6 | 0] |= e[(s[i] - 1 + h) % 28] << 31 - i % 6,
                                        c[4 + (i / 6 | 0)] |= e[28 + (s[i + 24] - 1 + h) % 28] << 31 - i % 6;
                                    for (c[0] = c[0] << 1 | c[0] >>> 31,
                                    i = 1; i < 7; i++)
                                        c[i] = c[i] >>> 4 * (i - 1) + 3;
                                    c[7] = c[7] << 5 | c[7] >>> 27;
                                }
                                var u = this._invSubKeys = [];
                                for (i = 0; i < 16; i++)
                                    u[i] = o[15 - i];
                            },
                            encryptBlock: function(t, e) {
                                this._doCryptBlock(t, e, this._subKeys);
                            },
                            decryptBlock: function(t, e) {
                                this._doCryptBlock(t, e, this._invSubKeys);
                            },
                            _doCryptBlock: function(t, e, i) {
                                this._lBlock = t[e],
                                this._rBlock = t[e + 1],
                                u.call(this, 4, 252645135),
                                u.call(this, 16, 65535),
                                d.call(this, 2, 858993459),
                                d.call(this, 8, 16711935),
                                u.call(this, 1, 1431655765);
                                for (var r = 0; r < 16; r++) {
                                    for (var o = i[r], n = this._lBlock, s = this._rBlock, a = 0, h = 0; h < 8; h++)
                                        a |= l[h][((s ^ o[h]) & c[h]) >>> 0];
                                    this._lBlock = s,
                                    this._rBlock = n ^ a;
                                }
                                var f = this._lBlock;
                                this._lBlock = this._rBlock,
                                this._rBlock = f,
                                u.call(this, 1, 1431655765),
                                d.call(this, 8, 16711935),
                                d.call(this, 2, 858993459),
                                u.call(this, 16, 65535),
                                u.call(this, 4, 252645135),
                                t[e] = this._lBlock,
                                t[e + 1] = this._rBlock;
                            },
                            keySize: 2,
                            ivSize: 2,
                            blockSize: 2
                        });
                        function u(t, e) {
                            var i = (this._lBlock >>> t ^ this._rBlock) & e;
                            this._rBlock ^= i,
                            this._lBlock ^= i << t;
                        }
                        function d(t, e) {
                            var i = (this._rBlock >>> t ^ this._lBlock) & e;
                            this._lBlock ^= i,
                            this._rBlock ^= i << t;
                        }
                        t.DES = r._createHelper(h);
                        var f = o.TripleDES = r.extend({
                            _doReset: function() {
                                var t = this._key.words;
                                this._des1 = h.createEncryptor(i.create(t.slice(0, 2))),
                                this._des2 = h.createEncryptor(i.create(t.slice(2, 4))),
                                this._des3 = h.createEncryptor(i.create(t.slice(4, 6)));
                            },
                            encryptBlock: function(t, e) {
                                this._des1.encryptBlock(t, e),
                                this._des2.decryptBlock(t, e),
                                this._des3.encryptBlock(t, e);
                            },
                            decryptBlock: function(t, e) {
                                this._des3.decryptBlock(t, e),
                                this._des2.encryptBlock(t, e),
                                this._des1.decryptBlock(t, e);
                            },
                            keySize: 6,
                            ivSize: 2,
                            blockSize: 2
                        });
                        t.TripleDES = r._createHelper(f);
                    }(),
                    function() {
                        var t = Pt
                          , e = t.lib.StreamCipher
                          , i = t.algo
                          , r = i.RC4 = e.extend({
                            _doReset: function() {
                                for (var t = this._key, e = t.words, i = t.sigBytes, r = this._S = [], o = 0; o < 256; o++)
                                    r[o] = o;
                                o = 0;
                                for (var n = 0; o < 256; o++) {
                                    var s = o % i
                                      , a = r[o];
                                    r[o] = r[n = (n + r[o] + (e[s >>> 2] >>> 24 - s % 4 * 8 & 255)) % 256],
                                    r[n] = a;
                                }
                                this._i = this._j = 0;
                            },
                            _doProcessBlock: function(t, e) {
                                t[e] ^= o.call(this);
                            },
                            keySize: 8,
                            ivSize: 0
                        });
                        function o() {
                            for (var t = this._S, e = this._i, i = this._j, r = 0, o = 0; o < 4; o++) {
                                i = (i + t[e = (e + 1) % 256]) % 256;
                                var n = t[e];
                                t[e] = t[i],
                                t[i] = n,
                                r |= t[(t[e] + t[i]) % 256] << 24 - 8 * o;
                            }
                            return this._i = e,
                            this._j = i,
                            r
                        }
                        t.RC4 = e._createHelper(r);
                        var n = i.RC4Drop = r.extend({
                            cfg: r.cfg.extend({
                                drop: 192
                            }),
                            _doReset: function() {
                                r._doReset.call(this);
                                for (var t = this.cfg.drop; 0 < t; t--)
                                    o.call(this);
                            }
                        });
                        t.RC4Drop = e._createHelper(n);
                    }(),
                    Pt.mode.CTRGladman = (mt = (pt = Pt.lib.BlockCipherMode.extend()).Encryptor = pt.extend({
                        processBlock: function(t, e) {
                            var i, r = this._cipher, o = r.blockSize, n = this._iv, s = this._counter;
                            n && (s = this._counter = n.slice(0),
                            this._iv = void 0),
                            0 === ((i = s)[0] = Ot(i[0])) && (i[1] = Ot(i[1]));
                            var a = s.slice(0);
                            r.encryptBlock(a, 0);
                            for (var l = 0; l < o; l++)
                                t[e + l] ^= a[l];
                        }
                    }),
                    pt.Decryptor = mt,
                    pt),
                    vt = (gt = Pt).lib.StreamCipher,
                    yt = [],
                    bt = [],
                    xt = [],
                    wt = gt.algo.Rabbit = vt.extend({
                        _doReset: function() {
                            for (var t = this._key.words, e = this.cfg.iv, i = 0; i < 4; i++)
                                t[i] = 16711935 & (t[i] << 8 | t[i] >>> 24) | 4278255360 & (t[i] << 24 | t[i] >>> 8);
                            var r = this._X = [t[0], t[3] << 16 | t[2] >>> 16, t[1], t[0] << 16 | t[3] >>> 16, t[2], t[1] << 16 | t[0] >>> 16, t[3], t[2] << 16 | t[1] >>> 16]
                              , o = this._C = [t[2] << 16 | t[2] >>> 16, 4294901760 & t[0] | 65535 & t[1], t[3] << 16 | t[3] >>> 16, 4294901760 & t[1] | 65535 & t[2], t[0] << 16 | t[0] >>> 16, 4294901760 & t[2] | 65535 & t[3], t[1] << 16 | t[1] >>> 16, 4294901760 & t[3] | 65535 & t[0]];
                            for (i = this._b = 0; i < 4; i++)
                                Ft.call(this);
                            for (i = 0; i < 8; i++)
                                o[i] ^= r[i + 4 & 7];
                            if (e) {
                                var n = e.words
                                  , s = n[0]
                                  , a = n[1]
                                  , l = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8)
                                  , c = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8)
                                  , h = l >>> 16 | 4294901760 & c
                                  , u = c << 16 | 65535 & l;
                                for (o[0] ^= l,
                                o[1] ^= h,
                                o[2] ^= c,
                                o[3] ^= u,
                                o[4] ^= l,
                                o[5] ^= h,
                                o[6] ^= c,
                                o[7] ^= u,
                                i = 0; i < 4; i++)
                                    Ft.call(this);
                            }
                        },
                        _doProcessBlock: function(t, e) {
                            var i = this._X;
                            Ft.call(this),
                            yt[0] = i[0] ^ i[5] >>> 16 ^ i[3] << 16,
                            yt[1] = i[2] ^ i[7] >>> 16 ^ i[5] << 16,
                            yt[2] = i[4] ^ i[1] >>> 16 ^ i[7] << 16,
                            yt[3] = i[6] ^ i[3] >>> 16 ^ i[1] << 16;
                            for (var r = 0; r < 4; r++)
                                yt[r] = 16711935 & (yt[r] << 8 | yt[r] >>> 24) | 4278255360 & (yt[r] << 24 | yt[r] >>> 8),
                                t[e + r] ^= yt[r];
                        },
                        blockSize: 4,
                        ivSize: 2
                    }),
                    gt.Rabbit = vt._createHelper(wt),
                    Pt.mode.CTR = (Et = (Tt = Pt.lib.BlockCipherMode.extend()).Encryptor = Tt.extend({
                        processBlock: function(t, e) {
                            var i = this._cipher
                              , r = i.blockSize
                              , o = this._iv
                              , n = this._counter;
                            o && (n = this._counter = o.slice(0),
                            this._iv = void 0);
                            var s = n.slice(0);
                            i.encryptBlock(s, 0),
                            n[r - 1] = n[r - 1] + 1 | 0;
                            for (var a = 0; a < r; a++)
                                t[e + a] ^= s[a];
                        }
                    }),
                    Tt.Decryptor = Et,
                    Tt),
                    Ct = (St = Pt).lib.StreamCipher,
                    At = [],
                    Mt = [],
                    It = [],
                    zt = St.algo.RabbitLegacy = Ct.extend({
                        _doReset: function() {
                            for (var t = this._key.words, e = this.cfg.iv, i = this._X = [t[0], t[3] << 16 | t[2] >>> 16, t[1], t[0] << 16 | t[3] >>> 16, t[2], t[1] << 16 | t[0] >>> 16, t[3], t[2] << 16 | t[1] >>> 16], r = this._C = [t[2] << 16 | t[2] >>> 16, 4294901760 & t[0] | 65535 & t[1], t[3] << 16 | t[3] >>> 16, 4294901760 & t[1] | 65535 & t[2], t[0] << 16 | t[0] >>> 16, 4294901760 & t[2] | 65535 & t[3], t[1] << 16 | t[1] >>> 16, 4294901760 & t[3] | 65535 & t[0]], o = this._b = 0; o < 4; o++)
                                Ut.call(this);
                            for (o = 0; o < 8; o++)
                                r[o] ^= i[o + 4 & 7];
                            if (e) {
                                var n = e.words
                                  , s = n[0]
                                  , a = n[1]
                                  , l = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8)
                                  , c = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8)
                                  , h = l >>> 16 | 4294901760 & c
                                  , u = c << 16 | 65535 & l;
                                for (r[0] ^= l,
                                r[1] ^= h,
                                r[2] ^= c,
                                r[3] ^= u,
                                r[4] ^= l,
                                r[5] ^= h,
                                r[6] ^= c,
                                r[7] ^= u,
                                o = 0; o < 4; o++)
                                    Ut.call(this);
                            }
                        },
                        _doProcessBlock: function(t, e) {
                            var i = this._X;
                            Ut.call(this),
                            At[0] = i[0] ^ i[5] >>> 16 ^ i[3] << 16,
                            At[1] = i[2] ^ i[7] >>> 16 ^ i[5] << 16,
                            At[2] = i[4] ^ i[1] >>> 16 ^ i[7] << 16,
                            At[3] = i[6] ^ i[3] >>> 16 ^ i[1] << 16;
                            for (var r = 0; r < 4; r++)
                                At[r] = 16711935 & (At[r] << 8 | At[r] >>> 24) | 4278255360 & (At[r] << 24 | At[r] >>> 8),
                                t[e + r] ^= At[r];
                        },
                        blockSize: 4,
                        ivSize: 2
                    }),
                    St.RabbitLegacy = Ct._createHelper(zt),
                    Pt.pad.ZeroPadding = {
                        pad: function(t, e) {
                            var i = 4 * e;
                            t.clamp(),
                            t.sigBytes += i - (t.sigBytes % i || i);
                        },
                        unpad: function(t) {
                            for (var e = t.words, i = t.sigBytes - 1; !(e[i >>> 2] >>> 24 - i % 4 * 8 & 255); )
                                i--;
                            t.sigBytes = i + 1;
                        }
                    },
                    Pt
                }()
                  , o = null
                  , n = (o || (function(t) {
                    !function() {
                        function e(t, e) {
                            return t << (e %= 32) | t >>> 32 - e
                        }
                        function i(t) {
                            return s[(4026531840 & t) >>> 28][(251658240 & t) >>> 24] << 24 | s[(15728640 & t) >>> 20][(983040 & t) >>> 16] << 16 | s[(61440 & t) >>> 12][(3840 & t) >>> 8] << 8 | s[(240 & t) >>> 4][(15 & t) >>> 0] << 0
                        }
                        var r = t
                          , o = r.lib.BlockCipher
                          , n = r.algo
                          , s = new Array;
                        s[0] = new Array(214,144,233,254,204,225,61,183,22,182,20,194,40,251,44,5),
                        s[1] = new Array(43,103,154,118,42,190,4,195,170,68,19,38,73,134,6,153),
                        s[2] = new Array(156,66,80,244,145,239,152,122,51,84,11,67,237,207,172,98),
                        s[3] = new Array(228,179,28,169,201,8,232,149,128,223,148,250,117,143,63,166),
                        s[4] = new Array(71,7,167,252,243,115,23,186,131,89,60,25,230,133,79,168),
                        s[5] = new Array(104,107,129,178,113,100,218,139,248,235,15,75,112,86,157,53),
                        s[6] = new Array(30,36,14,94,99,88,209,162,37,34,124,59,1,33,120,135),
                        s[7] = new Array(212,0,70,87,159,211,39,82,76,54,2,231,160,196,200,158),
                        s[8] = new Array(234,191,138,210,64,199,56,181,163,247,242,206,249,97,21,161),
                        s[9] = new Array(224,174,93,164,155,52,26,85,173,147,50,48,245,140,177,227),
                        s[10] = new Array(29,246,226,46,130,102,202,96,192,41,35,171,13,83,78,111),
                        s[11] = new Array(213,219,55,69,222,253,142,47,3,255,106,114,109,108,91,81),
                        s[12] = new Array(141,27,175,146,187,221,188,127,17,217,92,65,31,16,90,216),
                        s[13] = new Array(10,193,49,136,165,205,123,189,45,116,208,18,184,229,180,176),
                        s[14] = new Array(137,105,151,74,12,150,119,126,101,185,241,9,197,110,198,132),
                        s[15] = new Array(24,240,125,236,58,220,77,32,121,238,95,62,215,203,57,72);
                        var a = [462357, 472066609, 943670861, 1415275113, 1886879365, 2358483617, 2830087869, 3301692121, 3773296373, 4228057617, 404694573, 876298825, 1347903077, 1819507329, 2291111581, 2762715833, 3234320085, 3705924337, 4177462797, 337322537, 808926789, 1280531041, 1752135293, 2223739545, 2695343797, 3166948049, 3638552301, 4110090761, 269950501, 741554753, 1213159005, 1684763257]
                          , l = [2746333894, 1453994832, 1736282519, 2993693404]
                          , c = n.SM4 = o.extend({
                            _doReset: function() {
                                for (var t = function(t) {
                                    var r = new Array
                                      , o = new Array;
                                    r[0] = t[0] ^ l[0],
                                    r[1] = t[1] ^ l[1],
                                    r[2] = t[2] ^ l[2],
                                    r[3] = t[3] ^ l[3];
                                    for (var n, s = 0; s < 32; s++)
                                        r[s + 4] = r[s] ^ (n = i(n = r[s + 1] ^ r[s + 2] ^ r[s + 3] ^ a[s])) ^ e(n, 13) ^ e(n, 23),
                                        o[s] = r[s + 4].toString(16);
                                    return o
                                }(this._key.words), r = this._SK = [], o = 0; o < t.length; o++)
                                    r[o] = t[o];
                                var n = this._invSK = [];
                                for (o = t.length - 1; 0 <= o; o--)
                                    n[t.length - 1 - o] = t[o];
                            },
                            encryptBlock: function(t, e) {
                                this._doCryptBlock(t, e, this._SK);
                            },
                            decryptBlock: function(t, e) {
                                this._doCryptBlock(t, e, this._invSK);
                            },
                            _doCryptBlock: function(t, r, o) {
                                var n = [];
                                n[0] = t[r],
                                n[1] = t[r + 1],
                                n[2] = t[r + 2],
                                n[3] = t[r + 3];
                                for (var s, a = 0; a < 32; a++)
                                    n[a + 4] = n[a] ^ (s = i(s = n[a + 1] ^ n[a + 2] ^ n[a + 3] ^ parseInt(o[a], 16))) ^ e(s, 2) ^ e(s, 10) ^ e(s, 18) ^ e(s, 24);
                                t[r] = n[35],
                                t[r + 1] = n[34],
                                t[r + 2] = n[33],
                                t[r + 3] = n[32];
                            },
                            keySize: 4,
                            ivSize: 4,
                            blockSize: 4
                        });
                        r.SM4 = o._createHelper(c);
                    }();
                }(r),
                o = r.SM4),
                o)
                  , s = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
                function a(t, e) {
                    return t(e = {
                        exports: {}
                    }, e.exports),
                    e.exports
                }
                var l, c, h, u, d, f, _, p, m, g, v, y, b = a((function(t) {
                    var e, i;
                    e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
                    i = {
                        rotl: function(t, e) {
                            return t << e | t >>> 32 - e
                        },
                        rotr: function(t, e) {
                            return t << 32 - e | t >>> e
                        },
                        endian: function(t) {
                            if (t.constructor == Number)
                                return 16711935 & i.rotl(t, 8) | 4278255360 & i.rotl(t, 24);
                            for (var e = 0; e < t.length; e++)
                                t[e] = i.endian(t[e]);
                            return t
                        },
                        randomBytes: function(t) {
                            for (var e = []; 0 < t; t--)
                                e.push(Math.floor(256 * Math.random()));
                            return e
                        },
                        bytesToWords: function(t) {
                            for (var e = [], i = 0, r = 0; i < t.length; i++,
                            r += 8)
                                e[r >>> 5] |= t[i] << 24 - r % 32;
                            return e
                        },
                        wordsToBytes: function(t) {
                            for (var e = [], i = 0; i < 32 * t.length; i += 8)
                                e.push(t[i >>> 5] >>> 24 - i % 32 & 255);
                            return e
                        },
                        bytesToHex: function(t) {
                            for (var e = [], i = 0; i < t.length; i++)
                                e.push((t[i] >>> 4).toString(16)),
                                e.push((15 & t[i]).toString(16));
                            return e.join("")
                        },
                        hexToBytes: function(t) {
                            for (var e = [], i = 0; i < t.length; i += 2)
                                e.push(parseInt(t.substr(i, 2), 16));
                            return e
                        },
                        bytesToBase64: function(t) {
                            for (var i = [], r = 0; r < t.length; r += 3)
                                for (var o = t[r] << 16 | t[r + 1] << 8 | t[r + 2], n = 0; n < 4; n++)
                                    i.push(8 * r + 6 * n <= 8 * t.length ? e.charAt(o >>> 6 * (3 - n) & 63) : "=");
                            return i.join("")
                        },
                        base64ToBytes: function(t) {
                            t = t.replace(/[^A-Z0-9+\/]/gi, "");
                            for (var i = [], r = 0, o = 0; r < t.length; o = ++r % 4)
                                0 != o && i.push((e.indexOf(t.charAt(r - 1)) & Math.pow(2, -2 * o + 8) - 1) << 2 * o | e.indexOf(t.charAt(r)) >>> 6 - 2 * o);
                            return i
                        }
                    },
                    t.exports = i;
                }
                )), x = {
                    utf8: {
                        stringToBytes: function(t) {
                            return x.bin.stringToBytes(unescape(encodeURIComponent(t)))
                        },
                        bytesToString: function(t) {
                            return decodeURIComponent(escape(x.bin.bytesToString(t)))
                        }
                    },
                    bin: {
                        stringToBytes: function(t) {
                            for (var e = [], i = 0; i < t.length; i++)
                                e.push(255 & t.charCodeAt(i));
                            return e
                        },
                        bytesToString: function(t) {
                            for (var e = [], i = 0; i < t.length; i++)
                                e.push(String.fromCharCode(t[i]));
                            return e.join("")
                        }
                    }
                }, w = x, T = function(t) {
                    return null != t && (E(t) || "function" == typeof (e = t).readFloatLE && "function" == typeof e.slice && E(e.slice(0, 0)) || !!t._isBuffer);
                    var e;
                };
                function E(t) {
                    return !!t.constructor && "function" == typeof t.constructor.isBuffer && t.constructor.isBuffer(t)
                }
                function S() {}
                function C(t, e, i) {
                    null != t && ("number" == typeof t ? this.fromNumber(t, e, i) : this.fromString(t, null == e && "string" != typeof t ? 256 : e));
                }
                function A() {
                    return new C(null)
                }
                function M(t) {
                    return L.charAt(t)
                }
                function I(t, e) {
                    var i = R[t.charCodeAt(e)];
                    return null == i ? -1 : i
                }
                function z(t) {
                    var e = A();
                    return e.fromInt(t),
                    e
                }
                function P(t) {
                    var e, i = 1;
                    return 0 != (e = t >>> 16) && (t = e,
                    i += 16),
                    0 != (e = t >> 8) && (t = e,
                    i += 8),
                    0 != (e = t >> 4) && (t = e,
                    i += 4),
                    0 != (e = t >> 2) && (t = e,
                    i += 2),
                    0 != (e = t >> 1) && (t = e,
                    i += 1),
                    i
                }
                function D(t) {
                    this.m = t;
                }
                function B(t) {
                    this.m = t,
                    this.mp = t.invDigit(),
                    this.mpl = 32767 & this.mp,
                    this.mph = this.mp >> 15,
                    this.um = (1 << t.DB - 15) - 1,
                    this.mt2 = 2 * t.t;
                }
                a((function(t) {
                    var e, i, r, o, n;
                    e = b,
                    i = w.utf8,
                    r = T,
                    o = w.bin,
                    (n = function t(n, s) {
                        n.constructor == String ? n = s && "binary" === s.encoding ? o.stringToBytes(n) : i.stringToBytes(n) : r(n) ? n = Array.prototype.slice.call(n, 0) : Array.isArray(n) || (n = n.toString());
                        for (var a = e.bytesToWords(n), l = 8 * n.length, c = 1732584193, h = -271733879, u = -1732584194, d = 271733878, f = 0; f < a.length; f++)
                            a[f] = 16711935 & (a[f] << 8 | a[f] >>> 24) | 4278255360 & (a[f] << 24 | a[f] >>> 8);
                        a[l >>> 5] |= 128 << l % 32,
                        a[14 + (64 + l >>> 9 << 4)] = l;
                        var _ = t._ff
                          , p = t._gg
                          , m = t._hh
                          , g = t._ii;
                        for (f = 0; f < a.length; f += 16) {
                            var v = c
                              , y = h
                              , b = u
                              , x = d;
                            c = _(c, h, u, d, a[f + 0], 7, -680876936),
                            d = _(d, c, h, u, a[f + 1], 12, -389564586),
                            u = _(u, d, c, h, a[f + 2], 17, 606105819),
                            h = _(h, u, d, c, a[f + 3], 22, -1044525330),
                            c = _(c, h, u, d, a[f + 4], 7, -176418897),
                            d = _(d, c, h, u, a[f + 5], 12, 1200080426),
                            u = _(u, d, c, h, a[f + 6], 17, -1473231341),
                            h = _(h, u, d, c, a[f + 7], 22, -45705983),
                            c = _(c, h, u, d, a[f + 8], 7, 1770035416),
                            d = _(d, c, h, u, a[f + 9], 12, -1958414417),
                            u = _(u, d, c, h, a[f + 10], 17, -42063),
                            h = _(h, u, d, c, a[f + 11], 22, -1990404162),
                            c = _(c, h, u, d, a[f + 12], 7, 1804603682),
                            d = _(d, c, h, u, a[f + 13], 12, -40341101),
                            u = _(u, d, c, h, a[f + 14], 17, -1502002290),
                            c = p(c, h = _(h, u, d, c, a[f + 15], 22, 1236535329), u, d, a[f + 1], 5, -165796510),
                            d = p(d, c, h, u, a[f + 6], 9, -1069501632),
                            u = p(u, d, c, h, a[f + 11], 14, 643717713),
                            h = p(h, u, d, c, a[f + 0], 20, -373897302),
                            c = p(c, h, u, d, a[f + 5], 5, -701558691),
                            d = p(d, c, h, u, a[f + 10], 9, 38016083),
                            u = p(u, d, c, h, a[f + 15], 14, -660478335),
                            h = p(h, u, d, c, a[f + 4], 20, -405537848),
                            c = p(c, h, u, d, a[f + 9], 5, 568446438),
                            d = p(d, c, h, u, a[f + 14], 9, -1019803690),
                            u = p(u, d, c, h, a[f + 3], 14, -187363961),
                            h = p(h, u, d, c, a[f + 8], 20, 1163531501),
                            c = p(c, h, u, d, a[f + 13], 5, -1444681467),
                            d = p(d, c, h, u, a[f + 2], 9, -51403784),
                            u = p(u, d, c, h, a[f + 7], 14, 1735328473),
                            c = m(c, h = p(h, u, d, c, a[f + 12], 20, -1926607734), u, d, a[f + 5], 4, -378558),
                            d = m(d, c, h, u, a[f + 8], 11, -2022574463),
                            u = m(u, d, c, h, a[f + 11], 16, 1839030562),
                            h = m(h, u, d, c, a[f + 14], 23, -35309556),
                            c = m(c, h, u, d, a[f + 1], 4, -1530992060),
                            d = m(d, c, h, u, a[f + 4], 11, 1272893353),
                            u = m(u, d, c, h, a[f + 7], 16, -155497632),
                            h = m(h, u, d, c, a[f + 10], 23, -1094730640),
                            c = m(c, h, u, d, a[f + 13], 4, 681279174),
                            d = m(d, c, h, u, a[f + 0], 11, -358537222),
                            u = m(u, d, c, h, a[f + 3], 16, -722521979),
                            h = m(h, u, d, c, a[f + 6], 23, 76029189),
                            c = m(c, h, u, d, a[f + 9], 4, -640364487),
                            d = m(d, c, h, u, a[f + 12], 11, -421815835),
                            u = m(u, d, c, h, a[f + 15], 16, 530742520),
                            c = g(c, h = m(h, u, d, c, a[f + 2], 23, -995338651), u, d, a[f + 0], 6, -198630844),
                            d = g(d, c, h, u, a[f + 7], 10, 1126891415),
                            u = g(u, d, c, h, a[f + 14], 15, -1416354905),
                            h = g(h, u, d, c, a[f + 5], 21, -57434055),
                            c = g(c, h, u, d, a[f + 12], 6, 1700485571),
                            d = g(d, c, h, u, a[f + 3], 10, -1894986606),
                            u = g(u, d, c, h, a[f + 10], 15, -1051523),
                            h = g(h, u, d, c, a[f + 1], 21, -2054922799),
                            c = g(c, h, u, d, a[f + 8], 6, 1873313359),
                            d = g(d, c, h, u, a[f + 15], 10, -30611744),
                            u = g(u, d, c, h, a[f + 6], 15, -1560198380),
                            h = g(h, u, d, c, a[f + 13], 21, 1309151649),
                            c = g(c, h, u, d, a[f + 4], 6, -145523070),
                            d = g(d, c, h, u, a[f + 11], 10, -1120210379),
                            u = g(u, d, c, h, a[f + 2], 15, 718787259),
                            h = g(h, u, d, c, a[f + 9], 21, -343485551),
                            c = c + v >>> 0,
                            h = h + y >>> 0,
                            u = u + b >>> 0,
                            d = d + x >>> 0;
                        }
                        return e.endian([c, h, u, d])
                    }
                    )._ff = function(t, e, i, r, o, n, s) {
                        var a = t + (e & i | ~e & r) + (o >>> 0) + s;
                        return (a << n | a >>> 32 - n) + e
                    }
                    ,
                    n._gg = function(t, e, i, r, o, n, s) {
                        var a = t + (e & r | i & ~r) + (o >>> 0) + s;
                        return (a << n | a >>> 32 - n) + e
                    }
                    ,
                    n._hh = function(t, e, i, r, o, n, s) {
                        var a = t + (e ^ i ^ r) + (o >>> 0) + s;
                        return (a << n | a >>> 32 - n) + e
                    }
                    ,
                    n._ii = function(t, e, i, r, o, n, s) {
                        var a = t + (i ^ (e | ~r)) + (o >>> 0) + s;
                        return (a << n | a >>> 32 - n) + e
                    }
                    ,
                    n._blocksize = 16,
                    n._digestsize = 16,
                    t.exports = function(t, i) {
                        if (null == t)
                            throw new Error("Illegal argument " + t);
                        var r = e.wordsToBytes(n(t, i));
                        return i && i.asBytes ? r : i && i.asString ? o.bytesToString(r) : e.bytesToHex(r)
                    }
                    ;
                }
                )),
                l = Math,
                h = (c = {}).lib = {},
                u = h.Base = {
                    extend: function(t) {
                        S.prototype = this;
                        var e = new S;
                        return t && e.mixIn(t),
                        e.hasOwnProperty("init") || (e.init = function() {
                            e.$super.init.apply(this, arguments);
                        }
                        ),
                        (e.init.prototype = e).$super = this,
                        e
                    },
                    create: function() {
                        var t = this.extend();
                        return t.init.apply(t, arguments),
                        t
                    },
                    init: function() {},
                    mixIn: function(t) {
                        for (var e in t)
                            t.hasOwnProperty(e) && (this[e] = t[e]);
                        t.hasOwnProperty("toString") && (this.toString = t.toString);
                    },
                    clone: function() {
                        return this.init.prototype.extend(this)
                    }
                },
                d = h.WordArray = u.extend({
                    init: function(t, e) {
                        t = this.words = t || [],
                        this.sigBytes = null != e ? e : 4 * t.length;
                    },
                    toString: function(t) {
                        return (t || _).stringify(this)
                    },
                    concat: function(t) {
                        var e = this.words
                          , i = t.words
                          , r = this.sigBytes
                          , o = t.sigBytes;
                        if (this.clamp(),
                        r % 4)
                            for (var n = 0; n < o; n++)
                                e[r + n >>> 2] |= (i[n >>> 2] >>> 24 - n % 4 * 8 & 255) << 24 - (r + n) % 4 * 8;
                        else if (65535 < i.length)
                            for (n = 0; n < o; n += 4)
                                e[r + n >>> 2] = i[n >>> 2];
                        else
                            e.push.apply(e, i);
                        return this.sigBytes += o,
                        this
                    },
                    clamp: function() {
                        var t = this.words
                          , e = this.sigBytes;
                        t[e >>> 2] &= 4294967295 << 32 - e % 4 * 8,
                        t.length = l.ceil(e / 4);
                    },
                    clone: function() {
                        var t = u.clone.call(this);
                        return t.words = this.words.slice(0),
                        t
                    },
                    random: function(t) {
                        for (var e = [], i = 0; i < t; i += 4)
                            e.push(4294967296 * l.random() | 0);
                        return new d.init(e,t)
                    }
                }),
                f = c.enc = {},
                _ = f.Hex = {
                    stringify: function(t) {
                        for (var e = t.words, i = t.sigBytes, r = [], o = 0; o < i; o++) {
                            var n = e[o >>> 2] >>> 24 - o % 4 * 8 & 255;
                            r.push((n >>> 4).toString(16)),
                            r.push((15 & n).toString(16));
                        }
                        return r.join("")
                    },
                    parse: function(t) {
                        for (var e = t.length, i = [], r = 0; r < e; r += 2)
                            i[r >>> 3] |= parseInt(t.substr(r, 2), 16) << 24 - r % 8 * 4;
                        return new d.init(i,e / 2)
                    }
                },
                p = f.Latin1 = {
                    stringify: function(t) {
                        for (var e = t.words, i = t.sigBytes, r = [], o = 0; o < i; o++)
                            r.push(String.fromCharCode(e[o >>> 2] >>> 24 - o % 4 * 8 & 255));
                        return r.join("")
                    },
                    parse: function(t) {
                        for (var e = t.length, i = [], r = 0; r < e; r++)
                            i[r >>> 2] |= (255 & t.charCodeAt(r)) << 24 - r % 4 * 8;
                        return new d.init(i,e)
                    }
                },
                m = f.Utf8 = {
                    stringify: function(t) {
                        try {
                            return decodeURIComponent(escape(p.stringify(t)))
                        } catch (t) {
                            throw new Error("Malformed UTF-8 data")
                        }
                    },
                    parse: function(t) {
                        return p.parse(unescape(encodeURIComponent(t)))
                    }
                },
                g = h.BufferedBlockAlgorithm = u.extend({
                    reset: function() {
                        this._data = new d.init,
                        this._nDataBytes = 0;
                    },
                    _append: function(t) {
                        "string" == typeof t && (t = m.parse(t)),
                        this._data.concat(t),
                        this._nDataBytes += t.sigBytes;
                    },
                    _process: function(t) {
                        var e = this._data
                          , i = e.words
                          , r = e.sigBytes
                          , o = this.blockSize
                          , n = r / (4 * o)
                          , s = (n = t ? l.ceil(n) : l.max((0 | n) - this._minBufferSize, 0)) * o
                          , a = l.min(4 * s, r);
                        if (s) {
                            for (var c = 0; c < s; c += o)
                                this._doProcessBlock(i, c);
                            var h = i.splice(0, s);
                            e.sigBytes -= a;
                        }
                        return new d.init(h,a)
                    },
                    clone: function() {
                        var t = u.clone.call(this);
                        return t._data = this._data.clone(),
                        t
                    },
                    _minBufferSize: 0
                }),
                h.Hasher = g.extend({
                    cfg: u.extend(),
                    init: function(t) {
                        this.cfg = this.cfg.extend(t),
                        this.reset();
                    },
                    reset: function() {
                        g.reset.call(this),
                        this._doReset();
                    },
                    update: function(t) {
                        return this._append(t),
                        this._process(),
                        this
                    },
                    finalize: function(t) {
                        return t && this._append(t),
                        this._doFinalize()
                    },
                    blockSize: 16,
                    _createHelper: function(t) {
                        return function(e, i) {
                            return new t.init(i).finalize(e)
                        }
                    },
                    _createHmacHelper: function(t) {
                        return function(e, i) {
                            return new v.HMAC.init(t,i).finalize(e)
                        }
                    }
                }),
                v = c.algo = {},
                Array.Clear = function(t, e, i) {
                    for (var r in t)
                        t[r] = null;
                }
                ,
                Array.Copy = function(t, e, i, r, o) {
                    for (var n = t.slice(e, e + o), s = 0; s < n.length; s++)
                        i[r] = n[s],
                        r++;
                }
                ,
                window.epgis_Int32 = {
                    minValue: -parseInt("10000000000000000000000000000000", 2),
                    maxValue: parseInt("1111111111111111111111111111111", 2),
                    parse: function(t) {
                        if (t < this.minValue) {
                            for (var e = (o = new Number(-t).toString(2)).substr(o.length - 31, 31), i = "", r = 0; r < e.length; r++)
                                i += "0" == e.substr(r, 1) ? "1" : "0";
                            return parseInt(i, 2) + 1
                        }
                        if (t > this.maxValue) {
                            var o;
                            for (e = (o = Number(t).toString(2)).substr(o.length - 31, 31),
                            i = "",
                            r = 0; r < e.length; r++)
                                i += "0" == e.substr(r, 1) ? "1" : "0";
                            return -(parseInt(i, 2) + 1)
                        }
                        return t
                    },
                    parseByte: function(t) {
                        if (t < 0) {
                            for (var e = (o = new Number(-t).toString(2)).substr(o.length - 8, 8), i = "", r = 0; r < e.length; r++)
                                i += "0" == e.substr(r, 1) ? "1" : "0";
                            return parseInt(i, 2) + 1
                        }
                        if (255 < t) {
                            var o = Number(t).toString(2);
                            return parseInt(o.substr(o.length - 8, 8), 2)
                        }
                        return t
                    }
                },
                y = "Microsoft Internet Explorer" == navigator.appName ? (C.prototype.am = function(t, e, i, r, o, n) {
                    for (var s = 32767 & e, a = e >> 15; 0 <= --n; ) {
                        var l = 32767 & this[t]
                          , c = this[t++] >> 15
                          , h = a * l + c * s;
                        o = ((l = s * l + ((32767 & h) << 15) + i[r] + (1073741823 & o)) >>> 30) + (h >>> 15) + a * c + (o >>> 30),
                        i[r++] = 1073741823 & l;
                    }
                    return o
                }
                ,
                30) : "Netscape" != navigator.appName ? (C.prototype.am = function(t, e, i, r, o, n) {
                    for (; 0 <= --n; ) {
                        var s = e * this[t++] + i[r] + o;
                        o = Math.floor(s / 67108864),
                        i[r++] = 67108863 & s;
                    }
                    return o
                }
                ,
                26) : (C.prototype.am = function(t, e, i, r, o, n) {
                    for (var s = 16383 & e, a = e >> 14; 0 <= --n; ) {
                        var l = 16383 & this[t]
                          , c = this[t++] >> 14
                          , h = a * l + c * s;
                        o = ((l = s * l + ((16383 & h) << 14) + i[r] + o) >> 28) + (h >> 14) + a * c,
                        i[r++] = 268435455 & l;
                    }
                    return o
                }
                ,
                28),
                C.prototype.DB = y,
                C.prototype.DM = (1 << y) - 1,
                C.prototype.DV = 1 << y,
                C.prototype.FV = Math.pow(2, 52),
                C.prototype.F1 = 52 - y,
                C.prototype.F2 = 2 * y - 52;
                for (var L = "0123456789abcdefghijklmnopqrstuvwxyz", R = new Array, k = "0".charCodeAt(0), O = 0; O <= 9; ++O)
                    R[k++] = O;
                for (k = "a".charCodeAt(0),
                O = 10; O < 36; ++O)
                    R[k++] = O;
                for (k = "A".charCodeAt(0),
                O = 10; O < 36; ++O)
                    R[k++] = O;
                function F(t, e) {
                    return t & e
                }
                function U(t, e) {
                    return t | e
                }
                function N(t, e) {
                    return t ^ e
                }
                function j(t, e) {
                    return t & ~e
                }
                function G() {}
                function V(t) {
                    return t
                }
                function Z(t) {
                    this.r2 = A(),
                    this.q3 = A(),
                    C.ONE.dlShiftTo(2 * t.t, this.r2),
                    this.mu = this.r2.divide(t),
                    this.m = t;
                }
                D.prototype.convert = function(t) {
                    return t.s < 0 || 0 <= t.compareTo(this.m) ? t.mod(this.m) : t
                }
                ,
                D.prototype.revert = function(t) {
                    return t
                }
                ,
                D.prototype.reduce = function(t) {
                    t.divRemTo(this.m, null, t);
                }
                ,
                D.prototype.mulTo = function(t, e, i) {
                    t.multiplyTo(e, i),
                    this.reduce(i);
                }
                ,
                D.prototype.sqrTo = function(t, e) {
                    t.squareTo(e),
                    this.reduce(e);
                }
                ,
                B.prototype.convert = function(t) {
                    var e = A();
                    return t.abs().dlShiftTo(this.m.t, e),
                    e.divRemTo(this.m, null, e),
                    t.s < 0 && 0 < e.compareTo(C.ZERO) && this.m.subTo(e, e),
                    e
                }
                ,
                B.prototype.revert = function(t) {
                    var e = A();
                    return t.copyTo(e),
                    this.reduce(e),
                    e
                }
                ,
                B.prototype.reduce = function(t) {
                    for (; t.t <= this.mt2; )
                        t[t.t++] = 0;
                    for (var e = 0; e < this.m.t; ++e) {
                        var i = 32767 & t[e]
                          , r = i * this.mpl + ((i * this.mph + (t[e] >> 15) * this.mpl & this.um) << 15) & t.DM;
                        for (t[i = e + this.m.t] += this.m.am(0, r, t, e, 0, this.m.t); t[i] >= t.DV; )
                            t[i] -= t.DV,
                            t[++i]++;
                    }
                    t.clamp(),
                    t.drShiftTo(this.m.t, t),
                    0 <= t.compareTo(this.m) && t.subTo(this.m, t);
                }
                ,
                B.prototype.mulTo = function(t, e, i) {
                    t.multiplyTo(e, i),
                    this.reduce(i);
                }
                ,
                B.prototype.sqrTo = function(t, e) {
                    t.squareTo(e),
                    this.reduce(e);
                }
                ,
                C.prototype.copyTo = function(t) {
                    for (var e = this.t - 1; 0 <= e; --e)
                        t[e] = this[e];
                    t.t = this.t,
                    t.s = this.s;
                }
                ,
                C.prototype.fromInt = function(t) {
                    this.t = 1,
                    this.s = t < 0 ? -1 : 0,
                    0 < t ? this[0] = t : t < -1 ? this[0] = t + this.DV : this.t = 0;
                }
                ,
                C.prototype.fromString = function(t, e) {
                    var i;
                    if (16 == e)
                        i = 4;
                    else if (8 == e)
                        i = 3;
                    else if (256 == e)
                        i = 8;
                    else if (2 == e)
                        i = 1;
                    else if (32 == e)
                        i = 5;
                    else {
                        if (4 != e)
                            return void this.fromRadix(t, e);
                        i = 2;
                    }
                    this.t = 0,
                    this.s = 0;
                    for (var r = t.length, o = !1, n = 0; 0 <= --r; ) {
                        var s = 8 == i ? 255 & t[r] : I(t, r);
                        s < 0 ? "-" == t.charAt(r) && (o = !0) : (o = !1,
                        0 == n ? this[this.t++] = s : n + i > this.DB ? (this[this.t - 1] |= (s & (1 << this.DB - n) - 1) << n,
                        this[this.t++] = s >> this.DB - n) : this[this.t - 1] |= s << n,
                        (n += i) >= this.DB && (n -= this.DB));
                    }
                    8 == i && 0 != (128 & t[0]) && (this.s = -1,
                    0 < n && (this[this.t - 1] |= (1 << this.DB - n) - 1 << n)),
                    this.clamp(),
                    o && C.ZERO.subTo(this, this);
                }
                ,
                C.prototype.clamp = function() {
                    for (var t = this.s & this.DM; 0 < this.t && this[this.t - 1] == t; )
                        --this.t;
                }
                ,
                C.prototype.dlShiftTo = function(t, e) {
                    for (var i = this.t - 1; 0 <= i; --i)
                        e[i + t] = this[i];
                    for (i = t - 1; 0 <= i; --i)
                        e[i] = 0;
                    e.t = this.t + t,
                    e.s = this.s;
                }
                ,
                C.prototype.drShiftTo = function(t, e) {
                    for (var i = t; i < this.t; ++i)
                        e[i - t] = this[i];
                    e.t = Math.max(this.t - t, 0),
                    e.s = this.s;
                }
                ,
                C.prototype.lShiftTo = function(t, e) {
                    for (var i = t % this.DB, r = this.DB - i, o = (1 << r) - 1, n = Math.floor(t / this.DB), s = this.s << i & this.DM, a = this.t - 1; 0 <= a; --a)
                        e[a + n + 1] = this[a] >> r | s,
                        s = (this[a] & o) << i;
                    for (a = n - 1; 0 <= a; --a)
                        e[a] = 0;
                    e[n] = s,
                    e.t = this.t + n + 1,
                    e.s = this.s,
                    e.clamp();
                }
                ,
                C.prototype.rShiftTo = function(t, e) {
                    e.s = this.s;
                    var i = Math.floor(t / this.DB);
                    if (i >= this.t)
                        e.t = 0;
                    else {
                        var r = t % this.DB
                          , o = this.DB - r
                          , n = (1 << r) - 1;
                        e[0] = this[i] >> r;
                        for (var s = i + 1; s < this.t; ++s)
                            e[s - i - 1] |= (this[s] & n) << o,
                            e[s - i] = this[s] >> r;
                        0 < r && (e[this.t - i - 1] |= (this.s & n) << o),
                        e.t = this.t - i,
                        e.clamp();
                    }
                }
                ,
                C.prototype.subTo = function(t, e) {
                    for (var i = 0, r = 0, o = Math.min(t.t, this.t); i < o; )
                        r += this[i] - t[i],
                        e[i++] = r & this.DM,
                        r >>= this.DB;
                    if (t.t < this.t) {
                        for (r -= t.s; i < this.t; )
                            r += this[i],
                            e[i++] = r & this.DM,
                            r >>= this.DB;
                        r += this.s;
                    } else {
                        for (r += this.s; i < t.t; )
                            r -= t[i],
                            e[i++] = r & this.DM,
                            r >>= this.DB;
                        r -= t.s;
                    }
                    e.s = r < 0 ? -1 : 0,
                    r < -1 ? e[i++] = this.DV + r : 0 < r && (e[i++] = r),
                    e.t = i,
                    e.clamp();
                }
                ,
                C.prototype.multiplyTo = function(t, e) {
                    var i = this.abs()
                      , r = t.abs()
                      , o = i.t;
                    for (e.t = o + r.t; 0 <= --o; )
                        e[o] = 0;
                    for (o = 0; o < r.t; ++o)
                        e[o + i.t] = i.am(0, r[o], e, o, 0, i.t);
                    e.s = 0,
                    e.clamp(),
                    this.s != t.s && C.ZERO.subTo(e, e);
                }
                ,
                C.prototype.squareTo = function(t) {
                    for (var e = this.abs(), i = t.t = 2 * e.t; 0 <= --i; )
                        t[i] = 0;
                    for (i = 0; i < e.t - 1; ++i) {
                        var r = e.am(i, e[i], t, 2 * i, 0, 1);
                        (t[i + e.t] += e.am(i + 1, 2 * e[i], t, 2 * i + 1, r, e.t - i - 1)) >= e.DV && (t[i + e.t] -= e.DV,
                        t[i + e.t + 1] = 1);
                    }
                    0 < t.t && (t[t.t - 1] += e.am(i, e[i], t, 2 * i, 0, 1)),
                    t.s = 0,
                    t.clamp();
                }
                ,
                C.prototype.divRemTo = function(t, e, i) {
                    var r = t.abs();
                    if (!(r.t <= 0)) {
                        var o = this.abs();
                        if (o.t < r.t)
                            return null != e && e.fromInt(0),
                            void (null != i && this.copyTo(i));
                        null == i && (i = A());
                        var n = A()
                          , s = this.s
                          , a = t.s
                          , l = this.DB - P(r[r.t - 1]);
                        0 < l ? (r.lShiftTo(l, n),
                        o.lShiftTo(l, i)) : (r.copyTo(n),
                        o.copyTo(i));
                        var c = n.t
                          , h = n[c - 1];
                        if (0 != h) {
                            var u = h * (1 << this.F1) + (1 < c ? n[c - 2] >> this.F2 : 0)
                              , d = this.FV / u
                              , f = (1 << this.F1) / u
                              , _ = 1 << this.F2
                              , p = i.t
                              , m = p - c
                              , g = null == e ? A() : e;
                            for (n.dlShiftTo(m, g),
                            0 <= i.compareTo(g) && (i[i.t++] = 1,
                            i.subTo(g, i)),
                            C.ONE.dlShiftTo(c, g),
                            g.subTo(n, n); n.t < c; )
                                n[n.t++] = 0;
                            for (; 0 <= --m; ) {
                                var v = i[--p] == h ? this.DM : Math.floor(i[p] * d + (i[p - 1] + _) * f);
                                if ((i[p] += n.am(0, v, i, m, 0, c)) < v)
                                    for (n.dlShiftTo(m, g),
                                    i.subTo(g, i); i[p] < --v; )
                                        i.subTo(g, i);
                            }
                            null != e && (i.drShiftTo(c, e),
                            s != a && C.ZERO.subTo(e, e)),
                            i.t = c,
                            i.clamp(),
                            0 < l && i.rShiftTo(l, i),
                            s < 0 && C.ZERO.subTo(i, i);
                        }
                    }
                }
                ,
                C.prototype.invDigit = function() {
                    if (this.t < 1)
                        return 0;
                    var t = this[0];
                    if (0 == (1 & t))
                        return 0;
                    var e = 3 & t;
                    return 0 < (e = (e = (e = (e = e * (2 - (15 & t) * e) & 15) * (2 - (255 & t) * e) & 255) * (2 - ((65535 & t) * e & 65535)) & 65535) * (2 - t * e % this.DV) % this.DV) ? this.DV - e : -e
                }
                ,
                C.prototype.isEven = function() {
                    return 0 == (0 < this.t ? 1 & this[0] : this.s)
                }
                ,
                C.prototype.exp = function(t, e) {
                    if (4294967295 < t || t < 1)
                        return C.ONE;
                    var i, r = A(), o = A(), n = e.convert(this), s = P(t) - 1;
                    for (n.copyTo(r); 0 <= --s; )
                        e.sqrTo(r, o),
                        0 < (t & 1 << s) ? e.mulTo(o, n, r) : (i = r,
                        r = o,
                        o = i);
                    return e.revert(r)
                }
                ,
                C.prototype.toString = function(t) {
                    if (this.s < 0)
                        return "-" + this.negate().toString(t);
                    var e;
                    if (16 == t)
                        e = 4;
                    else if (8 == t)
                        e = 3;
                    else if (2 == t)
                        e = 1;
                    else if (32 == t)
                        e = 5;
                    else {
                        if (4 != t)
                            return this.toRadix(t);
                        e = 2;
                    }
                    var i, r = (1 << e) - 1, o = !1, n = "", s = this.t, a = this.DB - s * this.DB % e;
                    if (0 < s--)
                        for (a < this.DB && 0 < (i = this[s] >> a) && (o = !0,
                        n = M(i)); 0 <= s; )
                            a < e ? (i = (this[s] & (1 << a) - 1) << e - a,
                            i |= this[--s] >> (a += this.DB - e)) : (i = this[s] >> (a -= e) & r,
                            a <= 0 && (a += this.DB,
                            --s)),
                            0 < i && (o = !0),
                            o && (n += M(i));
                    return o ? n : "0"
                }
                ,
                C.prototype.negate = function() {
                    var t = A();
                    return C.ZERO.subTo(this, t),
                    t
                }
                ,
                C.prototype.abs = function() {
                    return this.s < 0 ? this.negate() : this
                }
                ,
                C.prototype.compareTo = function(t) {
                    var e = this.s - t.s;
                    if (0 != e)
                        return e;
                    var i = this.t;
                    if (0 != (e = i - t.t))
                        return this.s < 0 ? -e : e;
                    for (; 0 <= --i; )
                        if (0 != (e = this[i] - t[i]))
                            return e;
                    return 0
                }
                ,
                C.prototype.bitLength = function() {
                    return this.t <= 0 ? 0 : this.DB * (this.t - 1) + P(this[this.t - 1] ^ this.s & this.DM)
                }
                ,
                C.prototype.mod = function(t) {
                    var e = A();
                    return this.abs().divRemTo(t, null, e),
                    this.s < 0 && 0 < e.compareTo(C.ZERO) && t.subTo(e, e),
                    e
                }
                ,
                C.prototype.modPowInt = function(t, e) {
                    var i = new (t < 256 || e.isEven() ? D : B)(e);
                    return this.exp(t, i)
                }
                ,
                C.ZERO = z(0),
                C.ONE = z(1),
                G.prototype.convert = V,
                G.prototype.revert = V,
                G.prototype.mulTo = function(t, e, i) {
                    t.multiplyTo(e, i);
                }
                ,
                G.prototype.sqrTo = function(t, e) {
                    t.squareTo(e);
                }
                ,
                Z.prototype.convert = function(t) {
                    if (t.s < 0 || t.t > 2 * this.m.t)
                        return t.mod(this.m);
                    if (t.compareTo(this.m) < 0)
                        return t;
                    var e = A();
                    return t.copyTo(e),
                    this.reduce(e),
                    e
                }
                ,
                Z.prototype.revert = function(t) {
                    return t
                }
                ,
                Z.prototype.reduce = function(t) {
                    for (t.drShiftTo(this.m.t - 1, this.r2),
                    t.t > this.m.t + 1 && (t.t = this.m.t + 1,
                    t.clamp()),
                    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3),
                    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); t.compareTo(this.r2) < 0; )
                        t.dAddOffset(1, this.m.t + 1);
                    for (t.subTo(this.r2, t); 0 <= t.compareTo(this.m); )
                        t.subTo(this.m, t);
                }
                ,
                Z.prototype.mulTo = function(t, e, i) {
                    t.multiplyTo(e, i),
                    this.reduce(i);
                }
                ,
                Z.prototype.sqrTo = function(t, e) {
                    t.squareTo(e),
                    this.reduce(e);
                }
                ;
                var W = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]
                  , q = (1 << 26) / W[W.length - 1];
                C.prototype.chunkSize = function(t) {
                    return Math.floor(Math.LN2 * this.DB / Math.log(t))
                }
                ,
                C.prototype.toRadix = function(t) {
                    if (null == t && (t = 10),
                    0 == this.signum() || t < 2 || 36 < t)
                        return "0";
                    var e = this.chunkSize(t)
                      , i = Math.pow(t, e)
                      , r = z(i)
                      , o = A()
                      , n = A()
                      , s = "";
                    for (this.divRemTo(r, o, n); 0 < o.signum(); )
                        s = (i + n.intValue()).toString(t).substr(1) + s,
                        o.divRemTo(r, o, n);
                    return n.intValue().toString(t) + s
                }
                ,
                C.prototype.fromRadix = function(t, e) {
                    this.fromInt(0),
                    null == e && (e = 10);
                    for (var i = this.chunkSize(e), r = Math.pow(e, i), o = !1, n = 0, s = 0, a = 0; a < t.length; ++a) {
                        var l = I(t, a);
                        l < 0 ? "-" == t.charAt(a) && 0 == this.signum() && (o = !0) : (s = e * s + l,
                        ++n >= i && (this.dMultiply(r),
                        this.dAddOffset(s, 0),
                        s = n = 0));
                    }
                    0 < n && (this.dMultiply(Math.pow(e, n)),
                    this.dAddOffset(s, 0)),
                    o && C.ZERO.subTo(this, this);
                }
                ,
                C.prototype.fromNumber = function(t, e, i) {
                    if ("number" == typeof e)
                        if (t < 2)
                            this.fromInt(1);
                        else
                            for (this.fromNumber(t, i),
                            this.testBit(t - 1) || this.bitwiseTo(C.ONE.shiftLeft(t - 1), U, this),
                            this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(e); )
                                this.dAddOffset(2, 0),
                                this.bitLength() > t && this.subTo(C.ONE.shiftLeft(t - 1), this);
                    else {
                        var r = new Array
                          , o = 7 & t;
                        r.length = 1 + (t >> 3),
                        e.nextBytes(r),
                        0 < o ? r[0] &= (1 << o) - 1 : r[0] = 0,
                        this.fromString(r, 256);
                    }
                }
                ,
                C.prototype.bitwiseTo = function(t, e, i) {
                    for (var r, o = Math.min(t.t, this.t), n = 0; n < o; ++n)
                        i[n] = e(this[n], t[n]);
                    if (t.t < this.t) {
                        for (r = t.s & this.DM,
                        n = o; n < this.t; ++n)
                            i[n] = e(this[n], r);
                        i.t = this.t;
                    } else {
                        for (r = this.s & this.DM,
                        n = o; n < t.t; ++n)
                            i[n] = e(r, t[n]);
                        i.t = t.t;
                    }
                    i.s = e(this.s, t.s),
                    i.clamp();
                }
                ,
                C.prototype.changeBit = function(t, e) {
                    var i = C.ONE.shiftLeft(t);
                    return this.bitwiseTo(i, e, i),
                    i
                }
                ,
                C.prototype.addTo = function(t, e) {
                    for (var i = 0, r = 0, o = Math.min(t.t, this.t); i < o; )
                        r += this[i] + t[i],
                        e[i++] = r & this.DM,
                        r >>= this.DB;
                    if (t.t < this.t) {
                        for (r += t.s; i < this.t; )
                            r += this[i],
                            e[i++] = r & this.DM,
                            r >>= this.DB;
                        r += this.s;
                    } else {
                        for (r += this.s; i < t.t; )
                            r += t[i],
                            e[i++] = r & this.DM,
                            r >>= this.DB;
                        r += t.s;
                    }
                    e.s = r < 0 ? -1 : 0,
                    0 < r ? e[i++] = r : r < -1 && (e[i++] = this.DV + r),
                    e.t = i,
                    e.clamp();
                }
                ,
                C.prototype.dMultiply = function(t) {
                    this[this.t] = this.am(0, t - 1, this, 0, 0, this.t),
                    ++this.t,
                    this.clamp();
                }
                ,
                C.prototype.dAddOffset = function(t, e) {
                    if (0 != t) {
                        for (; this.t <= e; )
                            this[this.t++] = 0;
                        for (this[e] += t; this[e] >= this.DV; )
                            this[e] -= this.DV,
                            ++e >= this.t && (this[this.t++] = 0),
                            ++this[e];
                    }
                }
                ,
                C.prototype.multiplyLowerTo = function(t, e, i) {
                    var r, o = Math.min(this.t + t.t, e);
                    for (i.s = 0,
                    i.t = o; 0 < o; )
                        i[--o] = 0;
                    for (r = i.t - this.t; o < r; ++o)
                        i[o + this.t] = this.am(0, t[o], i, o, 0, this.t);
                    for (r = Math.min(t.t, e); o < r; ++o)
                        this.am(0, t[o], i, o, 0, e - o);
                    i.clamp();
                }
                ,
                C.prototype.multiplyUpperTo = function(t, e, i) {
                    --e;
                    var r = i.t = this.t + t.t - e;
                    for (i.s = 0; 0 <= --r; )
                        i[r] = 0;
                    for (r = Math.max(e - this.t, 0); r < t.t; ++r)
                        i[this.t + r - e] = this.am(e - r, t[r], i, 0, 0, this.t + r - e);
                    i.clamp(),
                    i.drShiftTo(1, i);
                }
                ,
                C.prototype.modInt = function(t) {
                    if (t <= 0)
                        return 0;
                    var e = this.DV % t
                      , i = this.s < 0 ? t - 1 : 0;
                    if (0 < this.t)
                        if (0 == e)
                            i = this[0] % t;
                        else
                            for (var r = this.t - 1; 0 <= r; --r)
                                i = (e * i + this[r]) % t;
                    return i
                }
                ,
                C.prototype.millerRabin = function(t) {
                    var e = this.subtract(C.ONE)
                      , i = e.getLowestSetBit();
                    if (i <= 0)
                        return !1;
                    var r = e.shiftRight(i);
                    W.length < (t = t + 1 >> 1) && (t = W.length);
                    for (var o = A(), n = 0; n < t; ++n) {
                        o.fromInt(W[Math.floor(Math.random() * W.length)]);
                        var s = o.modPow(r, this);
                        if (0 != s.compareTo(C.ONE) && 0 != s.compareTo(e)) {
                            for (var a = 1; a++ < i && 0 != s.compareTo(e); )
                                if (0 == (s = s.modPowInt(2, this)).compareTo(C.ONE))
                                    return !1;
                            if (0 != s.compareTo(e))
                                return !1
                        }
                    }
                    return !0
                }
                ,
                C.prototype.clone = function() {
                    var t = A();
                    return this.copyTo(t),
                    t
                }
                ,
                C.prototype.intValue = function() {
                    if (this.s < 0) {
                        if (1 == this.t)
                            return this[0] - this.DV;
                        if (0 == this.t)
                            return -1
                    } else {
                        if (1 == this.t)
                            return this[0];
                        if (0 == this.t)
                            return 0
                    }
                    return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0]
                }
                ,
                C.prototype.byteValue = function() {
                    return 0 == this.t ? this.s : this[0] << 24 >> 24
                }
                ,
                C.prototype.shortValue = function() {
                    return 0 == this.t ? this.s : this[0] << 16 >> 16
                }
                ,
                C.prototype.signum = function() {
                    return this.s < 0 ? -1 : this.t <= 0 || 1 == this.t && this[0] <= 0 ? 0 : 1
                }
                ,
                C.prototype.toByteArray = function() {
                    var t = this.t
                      , e = new Array;
                    e[0] = this.s;
                    var i, r = this.DB - t * this.DB % 8, o = 0;
                    if (0 < t--)
                        for (r < this.DB && (i = this[t] >> r) != (this.s & this.DM) >> r && (e[o++] = i | this.s << this.DB - r); 0 <= t; )
                            r < 8 ? (i = (this[t] & (1 << r) - 1) << 8 - r,
                            i |= this[--t] >> (r += this.DB - 8)) : (i = this[t] >> (r -= 8) & 255,
                            r <= 0 && (r += this.DB,
                            --t)),
                            0 != (128 & i) && (i |= -256),
                            0 == o && (128 & this.s) != (128 & i) && ++o,
                            (0 < o || i != this.s) && (e[o++] = i);
                    return e
                }
                ,
                C.prototype.equals = function(t) {
                    return 0 == this.compareTo(t)
                }
                ,
                C.prototype.min = function(t) {
                    return this.compareTo(t) < 0 ? this : t
                }
                ,
                C.prototype.max = function(t) {
                    return 0 < this.compareTo(t) ? this : t
                }
                ,
                C.prototype.and = function(t) {
                    var e = A();
                    return this.bitwiseTo(t, F, e),
                    e
                }
                ,
                C.prototype.or = function(t) {
                    var e = A();
                    return this.bitwiseTo(t, U, e),
                    e
                }
                ,
                C.prototype.xor = function(t) {
                    var e = A();
                    return this.bitwiseTo(t, N, e),
                    e
                }
                ,
                C.prototype.andNot = function(t) {
                    var e = A();
                    return this.bitwiseTo(t, j, e),
                    e
                }
                ,
                C.prototype.not = function() {
                    for (var t = A(), e = 0; e < this.t; ++e)
                        t[e] = this.DM & ~this[e];
                    return t.t = this.t,
                    t.s = ~this.s,
                    t
                }
                ,
                C.prototype.shiftLeft = function(t) {
                    var e = A();
                    return t < 0 ? this.rShiftTo(-t, e) : this.lShiftTo(t, e),
                    e
                }
                ,
                C.prototype.shiftRight = function(t) {
                    var e = A();
                    return t < 0 ? this.lShiftTo(-t, e) : this.rShiftTo(t, e),
                    e
                }
                ,
                C.prototype.getLowestSetBit = function() {
                    for (var t = 0; t < this.t; ++t)
                        if (0 != this[t])
                            return t * this.DB + function(t) {
                                if (0 == t)
                                    return -1;
                                var e = 0;
                                return 0 == (65535 & t) && (t >>= 16,
                                e += 16),
                                0 == (255 & t) && (t >>= 8,
                                e += 8),
                                0 == (15 & t) && (t >>= 4,
                                e += 4),
                                0 == (3 & t) && (t >>= 2,
                                e += 2),
                                0 == (1 & t) && ++e,
                                e
                            }(this[t]);
                    return this.s < 0 ? this.t * this.DB : -1
                }
                ,
                C.prototype.bitCount = function() {
                    for (var t = 0, e = this.s & this.DM, i = 0; i < this.t; ++i)
                        t += function(t) {
                            for (var e = 0; 0 != t; )
                                t &= t - 1,
                                ++e;
                            return e
                        }(this[i] ^ e);
                    return t
                }
                ,
                C.prototype.testBit = function(t) {
                    var e = Math.floor(t / this.DB);
                    return e >= this.t ? 0 != this.s : 0 != (this[e] & 1 << t % this.DB)
                }
                ,
                C.prototype.setBit = function(t) {
                    return this.changeBit(t, U)
                }
                ,
                C.prototype.clearBit = function(t) {
                    return this.changeBit(t, j)
                }
                ,
                C.prototype.flipBit = function(t) {
                    return this.changeBit(t, N)
                }
                ,
                C.prototype.add = function(t) {
                    var e = A();
                    return this.addTo(t, e),
                    e
                }
                ,
                C.prototype.subtract = function(t) {
                    var e = A();
                    return this.subTo(t, e),
                    e
                }
                ,
                C.prototype.multiply = function(t) {
                    var e = A();
                    return this.multiplyTo(t, e),
                    e
                }
                ,
                C.prototype.divide = function(t) {
                    var e = A();
                    return this.divRemTo(t, e, null),
                    e
                }
                ,
                C.prototype.remainder = function(t) {
                    var e = A();
                    return this.divRemTo(t, null, e),
                    e
                }
                ,
                C.prototype.divideAndRemainder = function(t) {
                    var e = A()
                      , i = A();
                    return this.divRemTo(t, e, i),
                    new Array(e,i)
                }
                ,
                C.prototype.modPow = function(t, e) {
                    var i, r, o = t.bitLength(), n = z(1);
                    if (o <= 0)
                        return n;
                    i = o < 18 ? 1 : o < 48 ? 3 : o < 144 ? 4 : o < 768 ? 5 : 6,
                    r = new (o < 8 ? D : e.isEven() ? Z : B)(e);
                    var s = new Array
                      , a = 3
                      , l = i - 1
                      , c = (1 << i) - 1;
                    if (s[1] = r.convert(this),
                    1 < i) {
                        var h = A();
                        for (r.sqrTo(s[1], h); a <= c; )
                            s[a] = A(),
                            r.mulTo(h, s[a - 2], s[a]),
                            a += 2;
                    }
                    var u, d, f = t.t - 1, _ = !0, p = A();
                    for (o = P(t[f]) - 1; 0 <= f; ) {
                        for (l <= o ? u = t[f] >> o - l & c : (u = (t[f] & (1 << o + 1) - 1) << l - o,
                        0 < f && (u |= t[f - 1] >> this.DB + o - l)),
                        a = i; 0 == (1 & u); )
                            u >>= 1,
                            --a;
                        if ((o -= a) < 0 && (o += this.DB,
                        --f),
                        _)
                            s[u].copyTo(n),
                            _ = !1;
                        else {
                            for (; 1 < a; )
                                r.sqrTo(n, p),
                                r.sqrTo(p, n),
                                a -= 2;
                            0 < a ? r.sqrTo(n, p) : (d = n,
                            n = p,
                            p = d),
                            r.mulTo(p, s[u], n);
                        }
                        for (; 0 <= f && 0 == (t[f] & 1 << o); )
                            r.sqrTo(n, p),
                            d = n,
                            n = p,
                            p = d,
                            --o < 0 && (o = this.DB - 1,
                            --f);
                    }
                    return r.revert(n)
                }
                ,
                C.prototype.modInverse = function(t) {
                    var e = t.isEven();
                    if (this.isEven() && e || 0 == t.signum())
                        return C.ZERO;
                    for (var i = t.clone(), r = this.clone(), o = z(1), n = z(0), s = z(0), a = z(1); 0 != i.signum(); ) {
                        for (; i.isEven(); )
                            i.rShiftTo(1, i),
                            e ? (o.isEven() && n.isEven() || (o.addTo(this, o),
                            n.subTo(t, n)),
                            o.rShiftTo(1, o)) : n.isEven() || n.subTo(t, n),
                            n.rShiftTo(1, n);
                        for (; r.isEven(); )
                            r.rShiftTo(1, r),
                            e ? (s.isEven() && a.isEven() || (s.addTo(this, s),
                            a.subTo(t, a)),
                            s.rShiftTo(1, s)) : a.isEven() || a.subTo(t, a),
                            a.rShiftTo(1, a);
                        0 <= i.compareTo(r) ? (i.subTo(r, i),
                        e && o.subTo(s, o),
                        n.subTo(a, n)) : (r.subTo(i, r),
                        e && s.subTo(o, s),
                        a.subTo(n, a));
                    }
                    return 0 != r.compareTo(C.ONE) ? C.ZERO : 0 <= a.compareTo(t) ? a.subtract(t) : a.signum() < 0 ? (a.addTo(t, a),
                    a.signum() < 0 ? a.add(t) : a) : a
                }
                ,
                C.prototype.pow = function(t) {
                    return this.exp(t, new G)
                }
                ,
                C.prototype.gcd = function(t) {
                    var e, i = this.s < 0 ? this.negate() : this.clone(), r = t.s < 0 ? t.negate() : t.clone();
                    i.compareTo(r) < 0 && (e = i,
                    i = r,
                    r = e);
                    var o = i.getLowestSetBit()
                      , n = r.getLowestSetBit();
                    if (n < 0)
                        return i;
                    for (o < n && (n = o),
                    0 < n && (i.rShiftTo(n, i),
                    r.rShiftTo(n, r)); 0 < i.signum(); )
                        0 < (o = i.getLowestSetBit()) && i.rShiftTo(o, i),
                        0 < (o = r.getLowestSetBit()) && r.rShiftTo(o, r),
                        0 <= i.compareTo(r) ? (i.subTo(r, i),
                        i.rShiftTo(1, i)) : (r.subTo(i, r),
                        r.rShiftTo(1, r));
                    return 0 < n && r.lShiftTo(n, r),
                    r
                }
                ,
                C.prototype.isProbablePrime = function(t) {
                    var e, i = this.abs();
                    if (1 == i.t && i[0] <= W[W.length - 1]) {
                        for (e = 0; e < W.length; ++e)
                            if (i[0] == W[e])
                                return !0;
                        return !1
                    }
                    if (i.isEven())
                        return !1;
                    for (e = 1; e < W.length; ) {
                        for (var r = W[e], o = e + 1; o < W.length && r < q; )
                            r *= W[o++];
                        for (r = i.modInt(r); e < o; )
                            if (r % W[e++] == 0)
                                return !1
                    }
                    return i.millerRabin(t)
                }
                ,
                C.prototype.square = function() {
                    var t = A();
                    return this.squareTo(t),
                    t
                }
                ;
                var H = function() {
                    this.global = window,
                    this.document = document,
                    this.headerEle = document.head || document.getElementsByTagName("head")[0],
                    this._eles = [];
                };
                function X(t) {
                    return (X = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                        return typeof t
                    }
                    : function(t) {
                        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                    }
                    )(t)
                }
                H.prototype.createScript = function(t) {
                    var e = this
                      , i = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : null
                      , r = this.document.createElement("script");
                    for (var o in r.charset = "utf-8",
                    "string" == typeof t && (t = {
                        src: t
                    }),
                    t)
                        r.setAttribute(o, t[o]);
                    r.onload = r.onreadystatechange = function() {
                        r.readyState && "loaded" !== r.readyState && "complete" !== r.readyState || (i && i(null, r),
                        e.headerEle.removeChild(r));
                    }
                    ,
                    r.onerror = function(t) {
                        i && i(t);
                    }
                    ,
                    this._eles.push(r),
                    this.headerEle.appendChild(r);
                }
                ,
                H.prototype.runScript = function(t) {
                    var e = this.document.createElement("script");
                    this.headerEle.appendChild(e),
                    e.innerHTML = t;
                }
                ,
                H.prototype.createStyle = function(t) {
                    var e = this.document.createElement("style");
                    e.innerHTML = t,
                    this.headerEle.appendChild(e);
                }
                ,
                H.prototype.createLink = function(t) {
                    var e;
                    this.headerEle ? ((e = this.document.createElement("link")).setAttribute("rel", "stylesheet"),
                    e.setAttribute("type", "text/css"),
                    e.setAttribute("href", t),
                    this.headerEle.appendChild(e)) : this.document.write("<link rel='stylesheet' href='" + t + "'/>");
                }
                ,
                H.prototype.blobURL = function(t, e, i) {}
                ;
                var Y = a((function(t, e) {
                    !function(i, r) {
                        var o = "function"
                          , n = "model"
                          , s = "name"
                          , a = "type"
                          , l = "vendor"
                          , c = "version"
                          , h = "architecture"
                          , u = "console"
                          , d = "mobile"
                          , f = "tablet"
                          , _ = "smarttv"
                          , p = "wearable"
                          , m = {
                            extend: function(t, e) {
                                var i = {};
                                for (var r in t)
                                    i[r] = e[r] && e[r].length % 2 == 0 ? e[r].concat(t[r]) : t[r];
                                return i
                            },
                            has: function(t, e) {
                                return "string" == typeof t && -1 !== e.toLowerCase().indexOf(t.toLowerCase())
                            },
                            lowerize: function(t) {
                                return t.toLowerCase()
                            },
                            major: function(t) {
                                return "string" === X(t) ? t.replace(/[^\d\.]/g, "").split(".")[0] : r
                            },
                            trim: function(t) {
                                return t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
                            }
                        }
                          , g = {
                            rgx: function(t, e) {
                                for (var i, n, s, a, l, c = 0; c < e.length && !a; ) {
                                    for (var h = e[c], u = e[c + 1], d = i = 0; d < h.length && !a; )
                                        if (a = h[d++].exec(t))
                                            for (n = 0; n < u.length; n++)
                                                l = a[++i],
                                                "object" === X(s = u[n]) && 0 < s.length ? 2 == s.length ? this[s[0]] = X(s[1]) == o ? s[1].call(this, l) : s[1] : 3 == s.length ? this[s[0]] = X(s[1]) !== o || s[1].exec && s[1].test ? l ? l.replace(s[1], s[2]) : r : l ? s[1].call(this, l, s[2]) : r : 4 == s.length && (this[s[0]] = l ? s[3].call(this, l.replace(s[1], s[2])) : r) : this[s] = l || r;
                                    c += 2;
                                }
                            },
                            str: function(t, e) {
                                for (var i in e)
                                    if ("object" === X(e[i]) && 0 < e[i].length) {
                                        for (var o = 0; o < e[i].length; o++)
                                            if (m.has(e[i][o], t))
                                                return "?" === i ? r : i
                                    } else if (m.has(e[i], t))
                                        return "?" === i ? r : i;
                                return t
                            }
                        }
                          , v = {
                            browser: {
                                oldsafari: {
                                    version: {
                                        "1.0": "/8",
                                        1.2: "/1",
                                        1.3: "/3",
                                        "2.0": "/412",
                                        "2.0.2": "/416",
                                        "2.0.3": "/417",
                                        "2.0.4": "/419",
                                        "?": "/"
                                    }
                                }
                            },
                            device: {
                                amazon: {
                                    model: {
                                        "Fire Phone": ["SD", "KF"]
                                    }
                                },
                                sprint: {
                                    model: {
                                        "Evo Shift 4G": "7373KT"
                                    },
                                    vendor: {
                                        HTC: "APA",
                                        Sprint: "Sprint"
                                    }
                                }
                            },
                            os: {
                                windows: {
                                    version: {
                                        ME: "4.90",
                                        "NT 3.11": "NT3.51",
                                        "NT 4.0": "NT4.0",
                                        2e3: "NT 5.0",
                                        XP: ["NT 5.1", "NT 5.2"],
                                        Vista: "NT 6.0",
                                        7: "NT 6.1",
                                        8: "NT 6.2",
                                        8.1: "NT 6.3",
                                        10: ["NT 6.4", "NT 10.0"],
                                        RT: "ARM"
                                    }
                                }
                            }
                        }
                          , y = {
                            browser: [[/(opera\smini)\/([\w\.-]+)/i, /(opera\s[mobiletab]+).+version\/([\w\.-]+)/i, /(opera).+version\/([\w\.]+)/i, /(opera)[\/\s]+([\w\.]+)/i], [s, c], [/(opios)[\/\s]+([\w\.]+)/i], [[s, "Opera Mini"], c], [/\s(opr)\/([\w\.]+)/i], [[s, "Opera"], c], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]*)/i, /(avant\s|iemobile|slim)(?:browser)?[\/\s]?([\w\.]*)/i, /(bidubrowser|baidubrowser)[\/\s]?([\w\.]+)/i, /(?:ms|\()(ie)\s([\w\.]+)/i, /(rekonq)\/([\w\.]*)/i, /(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon)\/([\w\.-]+)/i], [s, c], [/(konqueror)\/([\w\.]+)/i], [[s, "Konqueror"], c], [/(trident).+rv[:\s]([\w\.]+).+like\sgecko/i], [[s, "IE"], c], [/(edge|edgios|edga|edg)\/((\d+)?[\w\.]+)/i], [[s, "Edge"], c], [/(yabrowser)\/([\w\.]+)/i], [[s, "Yandex"], c], [/(Avast)\/([\w\.]+)/i], [[s, "Avast Secure Browser"], c], [/(AVG)\/([\w\.]+)/i], [[s, "AVG Secure Browser"], c], [/(puffin)\/([\w\.]+)/i], [[s, "Puffin"], c], [/(focus)\/([\w\.]+)/i], [[s, "Firefox Focus"], c], [/(opt)\/([\w\.]+)/i], [[s, "Opera Touch"], c], [/((?:[\s\/])uc?\s?browser|(?:juc.+)ucweb)[\/\s]?([\w\.]+)/i], [[s, "UCBrowser"], c], [/(comodo_dragon)\/([\w\.]+)/i], [[s, /_/g, " "], c], [/(windowswechat qbcore)\/([\w\.]+)/i], [[s, "WeChat(Win) Desktop"], c], [/(micromessenger)\/([\w\.]+)/i], [[s, "WeChat"], c], [/(brave)\/([\w\.]+)/i], [[s, "Brave"], c], [/(qqbrowserlite)\/([\w\.]+)/i], [s, c], [/(QQ)\/([\d\.]+)/i], [s, c], [/m?(qqbrowser)[\/\s]?([\w\.]+)/i], [s, c], [/(baiduboxapp)[\/\s]?([\w\.]+)/i], [s, c], [/(2345Explorer)[\/\s]?([\w\.]+)/i], [s, c], [/(MetaSr)[\/\s]?([\w\.]+)/i], [s], [/(LBBROWSER)/i], [s], [/xiaomi\/miuibrowser\/([\w\.]+)/i], [c, [s, "MIUI Browser"]], [/;fbav\/([\w\.]+);/i], [c, [s, "Facebook"]], [/safari\s(line)\/([\w\.]+)/i, /android.+(line)\/([\w\.]+)\/iab/i], [s, c], [/headlesschrome(?:\/([\w\.]+)|\s)/i], [c, [s, "Chrome Headless"]], [/\swv\).+(chrome)\/([\w\.]+)/i], [[s, /(.+)/, "$1 WebView"], c], [/((?:oculus|samsung)browser)\/([\w\.]+)/i], [[s, /(.+(?:g|us))(.+)/, "$1 $2"], c], [/android.+version\/([\w\.]+)\s+(?:mobile\s?safari|safari)*/i], [c, [s, "Android Browser"]], [/(sailfishbrowser)\/([\w\.]+)/i], [[s, "Sailfish Browser"], c], [/(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i], [s, c], [/(dolfin)\/([\w\.]+)/i], [[s, "Dolphin"], c], [/(qihu|qhbrowser|qihoobrowser|360browser)/i], [[s, "360 Browser"]], [/((?:android.+)crmo|crios)\/([\w\.]+)/i], [[s, "Chrome"], c], [/(coast)\/([\w\.]+)/i], [[s, "Opera Coast"], c], [/fxios\/([\w\.-]+)/i], [c, [s, "Firefox"]], [/version\/([\w\.]+).+?mobile\/\w+\s(safari)/i], [c, [s, "Mobile Safari"]], [/version\/([\w\.]+).+?(mobile\s?safari|safari)/i], [c, s], [/webkit.+?(gsa)\/([\w\.]+).+?(mobile\s?safari|safari)(\/[\w\.]+)/i], [[s, "GSA"], c], [/webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i], [s, [c, g.str, v.browser.oldsafari.version]], [/(webkit|khtml)\/([\w\.]+)/i], [s, c], [/(navigator|netscape)\/([\w\.-]+)/i], [[s, "Netscape"], c], [/(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i, /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([\w\.-]+)$/i, /(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i, /(links)\s\(([\w\.]+)/i, /(gobrowser)\/?([\w\.]*)/i, /(ice\s?browser)\/v?([\w\._]+)/i, /(mosaic)[\/\s]([\w\.]+)/i], [s, c]],
                            cpu: [[/(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\)]/i], [[h, "amd64"]], [/(ia32(?=;))/i], [[h, m.lowerize]], [/((?:i[346]|x)86)[;\)]/i], [[h, "ia32"]], [/windows\s(ce|mobile);\sppc;/i], [[h, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?:\smac|;|\))/i], [[h, /ower/, "", m.lowerize]], [/(sun4\w)[;\)]/i], [[h, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|arm(?:64|(?=v\d+[;l]))|(?=atmel\s)avr|(?:irix|mips|sparc)(?:64)?(?=;)|pa-risc)/i], [[h, m.lowerize]]],
                            device: [[/\((ipad|playbook);[\w\s\),;-]+(rim|apple)/i], [n, l, [a, f]], [/applecoremedia\/[\w\.]+ \((ipad)/], [n, [l, "Apple"], [a, f]], [/(apple\s{0,1}tv)/i], [[n, "Apple TV"], [l, "Apple"], [a, _]], [/(archos)\s(gamepad2?)/i, /(hp).+(touchpad)/i, /(hp).+(tablet)/i, /(kindle)\/([\w\.]+)/i, /\s(nook)[\w\s]+build\/(\w+)/i, /(dell)\s(strea[kpr\s\d]*[\dko])/i], [l, n, [a, f]], [/(kf[A-z]+)\sbuild\/.+silk\//i], [n, [l, "Amazon"], [a, f]], [/(sd|kf)[0349hijorstuw]+\sbuild\/.+silk\//i], [[n, g.str, v.device.amazon.model], [l, "Amazon"], [a, d]], [/android.+aft([bms])\sbuild/i], [n, [l, "Amazon"], [a, _]], [/\((ip[honed|\s\w*]+);.+(apple)/i], [n, l, [a, d]], [/\((ip[honed|\s\w*]+);/i], [n, [l, "Apple"], [a, d]], [/(blackberry)[\s-]?(\w+)/i, /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[\s_-]?([\w-]*)/i, /(hp)\s([\w\s]+\w)/i, /(asus)-?(\w+)/i], [l, n, [a, d]], [/\(bb10;\s(\w+)/i], [n, [l, "BlackBerry"], [a, d]], [/android.+(transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus 7|padfone|p00c)/i], [n, [l, "Asus"], [a, f]], [/(sony)\s(tablet\s[ps])\sbuild\//i, /(sony)?(?:sgp.+)\sbuild\//i], [[l, "Sony"], [n, "Xperia Tablet"], [a, f]], [/android.+\s([c-g]\d{4}|so[-l]\w+)(?=\sbuild\/|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [n, [l, "Sony"], [a, d]], [/\s(ouya)\s/i, /(nintendo)\s([wids3u]+)/i], [l, n, [a, u]], [/android.+;\s(shield)\sbuild/i], [n, [l, "Nvidia"], [a, u]], [/(playstation\s[34portablevi]+)/i], [n, [l, "Sony"], [a, u]], [/(sprint\s(\w+))/i], [[l, g.str, v.device.sprint.vendor], [n, g.str, v.device.sprint.model], [a, d]], [/(htc)[;_\s-]+([\w\s]+(?=\)|\sbuild)|\w+)/i, /(zte)-(\w*)/i, /(alcatel|geeksphone|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]*)/i], [l, [n, /_/g, " "], [a, d]], [/(nexus\s9)/i], [n, [l, "HTC"], [a, f]], [/d\/huawei([\w\s-]+)[;\)]/i, /(nexus\s6p|vog-l29|ane-lx1|eml-l29)/i], [n, [l, "Huawei"], [a, d]], [/android.+(bah2?-a?[lw]\d{2})/i], [n, [l, "Huawei"], [a, f]], [/(microsoft);\s(lumia[\s\w]+)/i], [l, n, [a, d]], [/[\s\(;](xbox(?:\sone)?)[\s\);]/i], [n, [l, "Microsoft"], [a, u]], [/(kin\.[onetw]{3})/i], [[n, /\./g, " "], [l, "Microsoft"], [a, d]], [/\s(milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?:?(\s4g)?)[\w\s]+build\//i, /mot[\s-]?(\w*)/i, /(XT\d{3,4}) build\//i, /(nexus\s6)/i], [n, [l, "Motorola"], [a, d]], [/android.+\s(mz60\d|xoom[\s2]{0,2})\sbuild\//i], [n, [l, "Motorola"], [a, f]], [/hbbtv\/\d+\.\d+\.\d+\s+\([\w\s]*;\s*(\w[^;]*);([^;]*)/i], [[l, m.trim], [n, m.trim], [a, _]], [/hbbtv.+maple;(\d+)/i], [[n, /^/, "SmartTV"], [l, "Samsung"], [a, _]], [/\(dtv[\);].+(aquos)/i], [n, [l, "Sharp"], [a, _]], [/android.+((sch-i[89]0\d|shw-m380s|gt-p\d{4}|gt-n\d+|sgh-t8[56]9|nexus 10))/i, /((SM-T\w+))/i], [[l, "Samsung"], n, [a, f]], [/smart-tv.+(samsung)/i], [l, [a, _], n], [/((s[cgp]h-\w+|gt-\w+|galaxy\snexus|sm-\w[\w\d]+))/i, /(sam[sung]*)[\s-]*(\w+-?[\w-]*)/i, /sec-((sgh\w+))/i], [[l, "Samsung"], n, [a, d]], [/sie-(\w*)/i], [n, [l, "Siemens"], [a, d]], [/(maemo|nokia).*(n900|lumia\s\d+)/i, /(nokia)[\s_-]?([\w-]*)/i], [[l, "Nokia"], n, [a, d]], [/android[x\d\.\s;]+\s([ab][1-7]\-?[0178a]\d\d?)/i], [n, [l, "Acer"], [a, f]], [/android.+([vl]k\-?\d{3})\s+build/i], [n, [l, "LG"], [a, f]], [/android\s3\.[\s\w;-]{10}(lg?)-([06cv9]{3,4})/i], [[l, "LG"], n, [a, f]], [/(lg) netcast\.tv/i], [l, n, [a, _]], [/(nexus\s[45])/i, /lg[e;\s\/-]+(\w*)/i, /android.+lg(\-?[\d\w]+)\s+build/i], [n, [l, "LG"], [a, d]], [/(lenovo)\s?(s(?:5000|6000)(?:[\w-]+)|tab(?:[\s\w]+))/i], [l, n, [a, f]], [/android.+(ideatab[a-z0-9\-\s]+)/i], [n, [l, "Lenovo"], [a, f]], [/(lenovo)[_\s-]?([\w-]+)/i], [l, n, [a, d]], [/linux;.+((jolla));/i], [l, n, [a, d]], [/((pebble))app\/[\d\.]+\s/i], [l, n, [a, p]], [/android.+;\s(oppo)\s?([\w\s]+)\sbuild/i], [l, n, [a, d]], [/crkey/i], [[n, "Chromecast"], [l, "Google"], [a, _]], [/android.+;\s(glass)\s\d/i], [n, [l, "Google"], [a, p]], [/android.+;\s(pixel c)[\s)]/i], [n, [l, "Google"], [a, f]], [/android.+;\s(pixel( [23])?( xl)?)[\s)]/i], [n, [l, "Google"], [a, d]], [/android.+;\s(\w+)\s+build\/hm\1/i, /android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i, /android.+(mi[\s\-_]*(?:a\d|one|one[\s_]plus|note lte)?[\s_]*(?:\d?\w?)[\s_]*(?:plus)?)\s+build/i, /android.+(redmi[\s\-_]*(?:note)?(?:[\s_]*[\w\s]+))\s+build/i], [[n, /_/g, " "], [l, "Xiaomi"], [a, d]], [/android.+(mi[\s\-_]*(?:pad)(?:[\s_]*[\w\s]+))\s+build/i], [[n, /_/g, " "], [l, "Xiaomi"], [a, f]], [/android.+;\s(m[1-5]\snote)\sbuild/i], [n, [l, "Meizu"], [a, d]], [/(mz)-([\w-]{2,})/i], [[l, "Meizu"], n, [a, d]], [/android.+a000(1)\s+build/i, /android.+oneplus\s(a\d{4})[\s)]/i], [n, [l, "OnePlus"], [a, d]], [/android.+[;\/]\s*(RCT[\d\w]+)\s+build/i], [n, [l, "RCA"], [a, f]], [/android.+[;\/\s]+(Venue[\d\s]{2,7})\s+build/i], [n, [l, "Dell"], [a, f]], [/android.+[;\/]\s*(Q[T|M][\d\w]+)\s+build/i], [n, [l, "Verizon"], [a, f]], [/android.+[;\/]\s+(Barnes[&\s]+Noble\s+|BN[RT])(V?.*)\s+build/i], [[l, "Barnes & Noble"], n, [a, f]], [/android.+[;\/]\s+(TM\d{3}.*\b)\s+build/i], [n, [l, "NuVision"], [a, f]], [/android.+;\s(k88)\sbuild/i], [n, [l, "ZTE"], [a, f]], [/android.+[;\/]\s*(gen\d{3})\s+build.*49h/i], [n, [l, "Swiss"], [a, d]], [/android.+[;\/]\s*(zur\d{3})\s+build/i], [n, [l, "Swiss"], [a, f]], [/android.+[;\/]\s*((Zeki)?TB.*\b)\s+build/i], [n, [l, "Zeki"], [a, f]], [/(android).+[;\/]\s+([YR]\d{2})\s+build/i, /android.+[;\/]\s+(Dragon[\-\s]+Touch\s+|DT)(\w{5})\sbuild/i], [[l, "Dragon Touch"], n, [a, f]], [/android.+[;\/]\s*(NS-?\w{0,9})\sbuild/i], [n, [l, "Insignia"], [a, f]], [/android.+[;\/]\s*((NX|Next)-?\w{0,9})\s+build/i], [n, [l, "NextBook"], [a, f]], [/android.+[;\/]\s*(Xtreme\_)?(V(1[045]|2[015]|30|40|60|7[05]|90))\s+build/i], [[l, "Voice"], n, [a, d]], [/android.+[;\/]\s*(LVTEL\-)?(V1[12])\s+build/i], [[l, "LvTel"], n, [a, d]], [/android.+;\s(PH-1)\s/i], [n, [l, "Essential"], [a, d]], [/android.+[;\/]\s*(V(100MD|700NA|7011|917G).*\b)\s+build/i], [n, [l, "Envizen"], [a, f]], [/android.+[;\/]\s*(Le[\s\-]+Pan)[\s\-]+(\w{1,9})\s+build/i], [l, n, [a, f]], [/android.+[;\/]\s*(Trio[\s\-]*.*)\s+build/i], [n, [l, "MachSpeed"], [a, f]], [/android.+[;\/]\s*(Trinity)[\-\s]*(T\d{3})\s+build/i], [l, n, [a, f]], [/android.+[;\/]\s*TU_(1491)\s+build/i], [n, [l, "Rotor"], [a, f]], [/android.+(KS(.+))\s+build/i], [n, [l, "Amazon"], [a, f]], [/android.+(Gigaset)[\s\-]+(Q\w{1,9})\s+build/i], [l, n, [a, f]], [/\s(tablet|tab)[;\/]/i, /\s(mobile)(?:[;\/]|\ssafari)/i], [[a, m.lowerize], l, n], [/[\s\/\(](smart-?tv)[;\)]/i], [[a, _]], [/(android[\w\.\s\-]{0,9});.+build/i], [n, [l, "Generic"]]],
                            engine: [[/windows.+\sedge\/([\w\.]+)/i], [c, [s, "EdgeHTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [c, [s, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i, /(icab)[\/\s]([23]\.[\d\.]+)/i], [s, c], [/rv\:([\w\.]{1,9}).+(gecko)/i], [c, s]],
                            os: [[/microsoft\s(windows)\s(vista|xp)/i], [s, c], [/(windows)\snt\s6\.2;\s(arm)/i, /(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s\w]*)/i, /(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i], [s, [c, g.str, v.os.windows.version]], [/(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i], [[s, "Windows"], [c, g.str, v.os.windows.version]], [/\((bb)(10);/i], [[s, "BlackBerry"], c], [/(blackberry)\w*\/?([\w\.]*)/i, /(tizen|kaios)[\/\s]([\w\.]+)/i, /(android|webos|palm\sos|qnx|bada|rim\stablet\sos|meego|sailfish|contiki)[\/\s-]?([\w\.]*)/i], [s, c], [/(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]*)/i], [[s, "Symbian"], c], [/\((series40);/i], [s], [/mozilla.+\(mobile;.+gecko.+firefox/i], [[s, "Firefox OS"], c], [/(nintendo|playstation)\s([wids34portablevu]+)/i, /(mint)[\/\s\(]?(\w*)/i, /(mageia|vectorlinux)[;\s]/i, /(joli|[kxln]?ubuntu|debian|suse|opensuse|gentoo|(?=\s)arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\/\s-]?(?!chrom)([\w\.-]*)/i, /(hurd|linux)\s?([\w\.]*)/i, /(gnu)\s?([\w\.]*)/i], [s, c], [/(cros)\s[\w]+\s([\w\.]+\w)/i], [[s, "Chromium OS"], c], [/(sunos)\s?([\w\.\d]*)/i], [[s, "Solaris"], c], [/\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]*)/i], [s, c], [/(haiku)\s(\w+)/i], [s, c], [/cfnetwork\/.+darwin/i, /ip[honead]{2,4}(?:.*os\s([\w]+)\slike\smac|;\sopera)/i], [[c, /_/g, "."], [s, "iOS"]], [/(mac\sos\sx)\s?([\w\s\.]*)/i, /(macintosh|mac(?=_powerpc)\s)/i], [[s, "Mac OS"], [c, /_/g, "."]], [/((?:open)?solaris)[\/\s-]?([\w\.]*)/i, /(aix)\s((\d)(?=\.|\)|\s)[\w\.])*/i, /(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms|fuchsia)/i, /(unix)\s?([\w\.]*)/i], [s, c]]
                        }
                          , b = function t(e, o) {
                            if ("object" === X(e) && (o = e,
                            e = r),
                            !(this instanceof t))
                                return new t(e,o).getResult();
                            var n = e || (i && i.navigator && i.navigator.userAgent ? i.navigator.userAgent : "")
                              , s = o ? m.extend(y, o) : y;
                            return this.getBrowser = function() {
                                var t = {
                                    name: r,
                                    version: r
                                };
                                return g.rgx.call(t, n, s.browser),
                                t.major = m.major(t.version),
                                t
                            }
                            ,
                            this.getCPU = function() {
                                var t = {
                                    architecture: r
                                };
                                return g.rgx.call(t, n, s.cpu),
                                t
                            }
                            ,
                            this.getDevice = function() {
                                var t = {
                                    vendor: r,
                                    model: r,
                                    type: r
                                };
                                return g.rgx.call(t, n, s.device),
                                t
                            }
                            ,
                            this.getEngine = function() {
                                var t = {
                                    name: r,
                                    version: r
                                };
                                return g.rgx.call(t, n, s.engine),
                                t
                            }
                            ,
                            this.getOS = function() {
                                var t = {
                                    name: r,
                                    version: r
                                };
                                return g.rgx.call(t, n, s.os),
                                t
                            }
                            ,
                            this.getResult = function() {
                                return {
                                    ua: this.getUA(),
                                    browser: this.getBrowser(),
                                    engine: this.getEngine(),
                                    os: this.getOS(),
                                    device: this.getDevice(),
                                    cpu: this.getCPU()
                                }
                            }
                            ,
                            this.getUA = function() {
                                return n
                            }
                            ,
                            this.setUA = function(t) {
                                return n = t,
                                this
                            }
                            ,
                            this
                        };
                        b.VERSION = "0.7.21",
                        b.BROWSER = {
                            NAME: s,
                            MAJOR: "major",
                            VERSION: c
                        },
                        b.CPU = {
                            ARCHITECTURE: h
                        },
                        b.DEVICE = {
                            MODEL: n,
                            VENDOR: l,
                            TYPE: a,
                            CONSOLE: u,
                            MOBILE: d,
                            SMARTTV: _,
                            TABLET: f,
                            WEARABLE: p,
                            EMBEDDED: "embedded"
                        },
                        b.ENGINE = {
                            NAME: s,
                            VERSION: c
                        },
                        b.OS = {
                            NAME: s,
                            VERSION: c
                        },
                        t.exports && (e = t.exports = b),
                        e.UAParser = b;
                        var x, w = i && (i.jQuery || i.Zepto);
                        w && !w.ua && (x = new b,
                        w.ua = x.getResult(),
                        w.ua.get = function() {
                            return x.getUA()
                        }
                        ,
                        w.ua.set = function(t) {
                            x.setUA(t);
                            var e = x.getResult();
                            for (var i in e)
                                w.ua[i] = e[i];
                        }
                        );
                    }("object" === ("undefined" == typeof window ? "undefined" : X(window)) ? window : s);
                }
                ))
                  , K = window.localStorage
                  , J = function() {
                    this.canuse = Object.prototype.hasOwnProperty.call(window, "localStorage") && window.localStorage;
                };
                J.prototype.setItem = function(t) {
                    var e = {
                        name: "",
                        value: "",
                        expires: "",
                        startTime: (new Date).getTime()
                    }
                      , i = Object.assign({}, e, t);
                    try {
                        K.setItem(i.name, JSON.stringify(i));
                    } catch (t) {}
                }
                ,
                J.prototype.getItem = function(e, i) {
                    var r = K.getItem(e);
                    if (!r)
                        return null;
                    var o = JSON.parse(r);
                    if (o.v !== i)
                        return null;
                    if (o.enc !== t.enc)
                        return null;
                    var n = (new Date).getTime() - o.startTime;
                    return n > o.expires || o.expires != t.expires || n < 0 ? (K.removeItem(e),
                    null) : o.value
                }
                ,
                J.prototype.removeItem = function(t) {
                    K.removeItem(t);
                }
                ,
                J.prototype.clear = function() {
                    K.clear();
                }
                ;
                var $ = new J
                  , Q = function(t, e) {
                    return (Array.isArray(t) ? t : [t]).filter((function(t) {
                        return $.getItem("_EPGIS_".concat(t), e)
                    }
                    ))
                }
                  , tt = function(t, e) {
                    return (Array.isArray(t) ? t : [t]).filter((function(t) {
                        return !$.canuse || !$.getItem("_EPGIS_".concat(t), e)
                    }
                    ))
                }
                  , et = function(t) {
                    var e = [];
                    for (var i in t)
                        e.push("".concat(i, "=").concat(t[i]));
                    return e.join("&")
                }
                  , it = new Y
                  , rt = function() {
                    return window.SGMap
                }
                  , ot = function(t) {
                    t = t || 32;
                    for (var e = "ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678", i = e.length, r = "", o = 0; o < t; o++)
                        r += e.charAt(Math.floor(Math.random() * i));
                    return r
                };
                Array.prototype.filter || (Array.prototype.filter = function(t) {
                    for (var e = [], i = -1; ++i < this.length; )
                        t(this[i]) && e.push(this[i]);
                    return e
                }
                ),
                Array.prototype.forEach || (Array.prototype.forEach = function(t) {
                    for (var e = -1; ++e < this.length; )
                        t(this[e]);
                }
                ),
                Array.prototype.includes || (Array.prototype.includes = function(t) {
                    return 0 < this.filter((function(e) {
                        return e === t
                    }
                    )).length
                }
                ),
                Array.prototype.reduce || (Array.prototype.reduce = function(t, e) {
                    for (var r = e; ++i < this.length; )
                        t(r, this[i]);
                    return r
                }
                ),
                Array.isArray || (Array.isArray = function(t) {
                    return "Array" === t.constructor.name
                }
                ),
                Object.keys || (Object.keys = function(t) {
                    var e = [];
                    for (var i in t)
                        e.push(i);
                    return e
                }
                ),
                Function.prototype.bind || (Function.prototype.bind = function(t) {
                    if ("function" != typeof this)
                        throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
                    var e = Array.prototype.slice.call(arguments, 1)
                      , i = this
                      , r = function() {}
                      , o = function() {
                        return i.apply(this instanceof r && t ? this : t, e.concat(Array.prototype.slice.call(arguments)))
                    };
                    return r.prototype = this.prototype,
                    o.prototype = new r,
                    o
                }
                );
                var nt = function() {
                    this._modules = [],
                    this.core = new H,
                    this.init();
                };
                nt.prototype.init = function() {}
                ,
                nt.prototype.loadModules = function() {
                    var e = this
                      , i = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : []
                      , r = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : null;
                    if (!i || 0 == i.length)
                        return r("插件列表参数有误"),
                        !1;
                    var o = {
                        v: t.version
                    };
                    t.isDev && (o.dev = 1),
                    $.canuse && Q(i, t.version).forEach((function(i) {
                        e.run($.getItem("_EPGIS_".concat(i), t.version).code);
                    }
                    ));
                    var n = tt(i, t.version);
                    n.length && (o.plugin = n),
                    o.plugin ? (o.access_token = rt().accessToken,
                    o.rnd = Math.random(),
                    o.cb = "__jsload" + (new Date).getTime() + "_" + ot(6),
                    window[o.cb] = function(t) {
                        e.__jsload(t, i, r);
                    }
                    ,
                    this.core.createScript("".concat(t.apiUrl, "/webplugin/?").concat(et(o)))) : i && i.length ? r && r(null, i) : r && r("没有传入插件名称");
                }
                ,
                nt.prototype.__jsload = function(t, e, i) {
                    if ("{}" === JSON.stringify(t))
                        i && i("您使用的插件" + e.join(",") + ",名称错误，或者不存在，请排查SGMap.plugin参数");
                    else if (!1 === t.success)
                        i && i(t.message);
                    else {
                        for (var r in t)
                            this._parseSinglePlugin(r, t[r]);
                        i && i(null, Object.keys(t));
                    }
                }
                ,
                nt.prototype._parseSinglePlugin = function(e, i) {
                    var r;
                    this._modules.includes(e) ? console.warn("插件".concat(e, "已经存在，并不会重复执行。请注意代码，不要重复加载。")) : (r = {
                        notes: this.getNotes(i),
                        code: i && i.replace(/\/\*(\s|\S)*\*\//g, "")
                    },
                    $.canuse && $.setItem({
                        name: "_EPGIS_".concat(e),
                        value: r,
                        v: t.version,
                        expires: t.expires,
                        enc: t.enc
                    }),
                    this.run(r.code),
                    this._modules.push(e));
                }
                ,
                nt.prototype.getRequire = function(t) {
                    var e = null;
                    return t && (e = t.split(" @").reduce((function(t, e) {
                        var i = e.split(/\s/);
                        return 1 < i.length ? t[i[0]] = i[1] : t.title = i[0],
                        t
                    }
                    ), {})),
                    e && e.require ? e.require.replace(/,{2,}/g, ",").replace(/\s{2,}/g, " ").replace(/\s/g, ",").split(",") : []
                }
                ,
                nt.prototype.getNotes = function(t) {
                    var e = null;
                    return t && (e = t.match(/\/\*([\S\s]*)\*\//)),
                    e ? e[1] : ""
                }
                ,
                nt.prototype.run = function(t) {
                    ((function(t) {
                        return -1 === t.indexOf("!function")
                    }
                    ))(t) && (t = function(t, e) {
                        if (!r)
                            return null;
                        var i = r.enc.Utf8.parse("epgisgisaegismapssgcc");
                        return n.decrypt({
                            ciphertext: r.enc.Base64.parse(t)
                        }, i, {
                            mode: r.mode.ECB,
                            padding: r.pad.Pkcs7
                        }).toString(r.enc.Utf8)
                    }(t)),
                    new Function("!function(){" + t + "}.bind((window||self).SGMap)()")();
                }
                ;
                var st = new nt
                  , at = function(t, e) {
                    if ("string" == typeof t && (t = t.split(",")),
                    Promise)
                        return new Promise((function(i, r) {
                            st.loadModules(t, (function(t, o) {
                                t ? (r(t),
                                e && e(t)) : (i(o),
                                e && e(null, o));
                            }
                            ));
                        }
                        ));
                    st.loadModules(t, e);
                };
                return at.config = t,
                at.Loader = nt,
                at.userAgent = it,
                at.onError = function(t) {
                    window.onerror = function(e, i, r, o, n) {
                        t && t(e, i, r, o, n ? n.stack : null);
                    }
                    ,
                    window.onunhandledrejection = function(e) {
                        t && t(e.reason);
                    }
                    ;
                }
                ,
                at
            }
            ));
        }
        ))
          , sa = t.createCommonjsModule((function(t) {
            var e = t.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
            "number" == typeof __g && (__g = e);
        }
        ))
          , aa = {}.hasOwnProperty
          , la = function(t, e) {
            return aa.call(t, e)
        }
          , ca = function(t) {
            try {
                return !!t()
            } catch (t) {
                return !0
            }
        }
          , ha = !ca((function() {
            return 7 != Object.defineProperty({}, "a", {
                get: function() {
                    return 7
                }
            }).a
        }
        ))
          , ua = t.createCommonjsModule((function(t) {
            var e = t.exports = {
                version: "2.6.12"
            };
            "number" == typeof __e && (__e = e);
        }
        ))
          , da = function(t) {
            return "object" == typeof t ? null !== t : "function" == typeof t
        }
          , fa = function(t) {
            if (!da(t))
                throw TypeError(t + " is not an object!");
            return t
        }
          , _a = sa.document
          , pa = da(_a) && da(_a.createElement)
          , ma = function(t) {
            return pa ? _a.createElement(t) : {}
        }
          , ga = !ha && !ca((function() {
            return 7 != Object.defineProperty(ma("div"), "a", {
                get: function() {
                    return 7
                }
            }).a
        }
        ))
          , va = function(t, e) {
            if (!da(t))
                return t;
            var i, r;
            if (e && "function" == typeof (i = t.toString) && !da(r = i.call(t)))
                return r;
            if ("function" == typeof (i = t.valueOf) && !da(r = i.call(t)))
                return r;
            if (!e && "function" == typeof (i = t.toString) && !da(r = i.call(t)))
                return r;
            throw TypeError("Can't convert object to primitive value")
        }
          , ya = Object.defineProperty
          , ba = {
            f: ha ? Object.defineProperty : function(t, e, i) {
                if (fa(t),
                e = va(e, !0),
                fa(i),
                ga)
                    try {
                        return ya(t, e, i)
                    } catch (t) {}
                if ("get"in i || "set"in i)
                    throw TypeError("Accessors not supported!");
                return "value"in i && (t[e] = i.value),
                t
            }
        }
          , xa = function(t, e) {
            return {
                enumerable: !(1 & t),
                configurable: !(2 & t),
                writable: !(4 & t),
                value: e
            }
        }
          , wa = ha ? function(t, e, i) {
            return ba.f(t, e, xa(1, i))
        }
        : function(t, e, i) {
            return t[e] = i,
            t
        }
          , Ta = 0
          , Ea = Math.random()
          , Sa = function(t) {
            return "Symbol(".concat(void 0 === t ? "" : t, ")_", (++Ta + Ea).toString(36))
        }
          , Ca = t.createCommonjsModule((function(t) {
            var e = "__core-js_shared__"
              , i = sa[e] || (sa[e] = {});
            (t.exports = function(t, e) {
                return i[t] || (i[t] = void 0 !== e ? e : {})
            }
            )("versions", []).push({
                version: ua.version,
                mode: "global",
                copyright: "© 2020 Denis Pushkarev (zloirock.ru)"
            });
        }
        ))
          , Aa = Ca("native-function-to-string", Function.toString)
          , Ma = t.createCommonjsModule((function(t) {
            var e = Sa("src")
              , i = "toString"
              , r = ("" + Aa).split(i);
            ua.inspectSource = function(t) {
                return Aa.call(t)
            }
            ,
            (t.exports = function(t, i, o, n) {
                var s = "function" == typeof o;
                s && (la(o, "name") || wa(o, "name", i)),
                t[i] !== o && (s && (la(o, e) || wa(o, e, t[i] ? "" + t[i] : r.join(String(i)))),
                t === sa ? t[i] = o : n ? t[i] ? t[i] = o : wa(t, i, o) : (delete t[i],
                wa(t, i, o)));
            }
            )(Function.prototype, i, (function() {
                return "function" == typeof this && this[e] || Aa.call(this)
            }
            ));
        }
        ))
          , Ia = function(t) {
            if ("function" != typeof t)
                throw TypeError(t + " is not a function!");
            return t
        }
          , za = function(t, e, i) {
            if (Ia(t),
            void 0 === e)
                return t;
            switch (i) {
            case 1:
                return function(i) {
                    return t.call(e, i)
                }
                ;
            case 2:
                return function(i, r) {
                    return t.call(e, i, r)
                }
                ;
            case 3:
                return function(i, r, o) {
                    return t.call(e, i, r, o)
                }
            }
            return function() {
                return t.apply(e, arguments)
            }
        }
          , Pa = function(t, e, i) {
            var r, o, n, s, a = t & Pa.F, l = t & Pa.G, c = t & Pa.P, h = t & Pa.B, u = l ? sa : t & Pa.S ? sa[e] || (sa[e] = {}) : (sa[e] || {}).prototype, d = l ? ua : ua[e] || (ua[e] = {}), f = d.prototype || (d.prototype = {});
            for (r in l && (i = e),
            i)
                n = ((o = !a && u && void 0 !== u[r]) ? u : i)[r],
                s = h && o ? za(n, sa) : c && "function" == typeof n ? za(Function.call, n) : n,
                u && Ma(u, r, n, t & Pa.U),
                d[r] != n && wa(d, r, s),
                c && f[r] != n && (f[r] = n);
        };
        sa.core = ua,
        Pa.F = 1,
        Pa.G = 2,
        Pa.S = 4,
        Pa.P = 8,
        Pa.B = 16,
        Pa.W = 32,
        Pa.U = 64,
        Pa.R = 128;
        var Da = Pa
          , Ba = t.createCommonjsModule((function(t) {
            var e = Sa("meta")
              , i = ba.f
              , r = 0
              , o = Object.isExtensible || function() {
                return !0
            }
              , n = !ca((function() {
                return o(Object.preventExtensions({}))
            }
            ))
              , s = function(t) {
                i(t, e, {
                    value: {
                        i: "O" + ++r,
                        w: {}
                    }
                });
            }
              , a = t.exports = {
                KEY: e,
                NEED: !1,
                fastKey: function(t, i) {
                    if (!da(t))
                        return "symbol" == typeof t ? t : ("string" == typeof t ? "S" : "P") + t;
                    if (!la(t, e)) {
                        if (!o(t))
                            return "F";
                        if (!i)
                            return "E";
                        s(t);
                    }
                    return t[e].i
                },
                getWeak: function(t, i) {
                    if (!la(t, e)) {
                        if (!o(t))
                            return !0;
                        if (!i)
                            return !1;
                        s(t);
                    }
                    return t[e].w
                },
                onFreeze: function(t) {
                    return n && a.NEED && o(t) && !la(t, e) && s(t),
                    t
                }
            };
        }
        ))
          , La = t.createCommonjsModule((function(t) {
            var e = Ca("wks")
              , i = sa.Symbol
              , r = "function" == typeof i;
            (t.exports = function(t) {
                return e[t] || (e[t] = r && i[t] || (r ? i : Sa)("Symbol." + t))
            }
            ).store = e;
        }
        ))
          , Ra = ba.f
          , ka = La("toStringTag")
          , Oa = function(t, e, i) {
            t && !la(t = i ? t : t.prototype, ka) && Ra(t, ka, {
                configurable: !0,
                value: e
            });
        }
          , Fa = {
            f: La
        }
          , Ua = ba.f
          , Na = function(t) {
            var e = ua.Symbol || (ua.Symbol = sa.Symbol || {});
            "_" == t.charAt(0) || t in e || Ua(e, t, {
                value: Fa.f(t)
            });
        }
          , ja = {}.toString
          , Ga = function(t) {
            return ja.call(t).slice(8, -1)
        }
          , Va = Object("z").propertyIsEnumerable(0) ? Object : function(t) {
            return "String" == Ga(t) ? t.split("") : Object(t)
        }
          , Za = function(t) {
            if (null == t)
                throw TypeError("Can't call method on  " + t);
            return t
        }
          , Wa = function(t) {
            return Va(Za(t))
        }
          , qa = Math.ceil
          , Ha = Math.floor
          , Xa = function(t) {
            return isNaN(t = +t) ? 0 : (t > 0 ? Ha : qa)(t)
        }
          , Ya = Math.min
          , Ka = function(t) {
            return t > 0 ? Ya(Xa(t), 9007199254740991) : 0
        }
          , Ja = Math.max
          , $a = Math.min
          , Qa = function(t, e) {
            return (t = Xa(t)) < 0 ? Ja(t + e, 0) : $a(t, e)
        }
          , tl = function(t) {
            return function(e, i, r) {
                var o, n = Wa(e), s = Ka(n.length), a = Qa(r, s);
                if (t && i != i) {
                    for (; s > a; )
                        if ((o = n[a++]) != o)
                            return !0
                } else
                    for (; s > a; a++)
                        if ((t || a in n) && n[a] === i)
                            return t || a || 0;
                return !t && -1
            }
        }
          , el = Ca("keys")
          , il = function(t) {
            return el[t] || (el[t] = Sa(t))
        }
          , rl = tl(!1)
          , ol = il("IE_PROTO")
          , nl = function(t, e) {
            var i, r = Wa(t), o = 0, n = [];
            for (i in r)
                i != ol && la(r, i) && n.push(i);
            for (; e.length > o; )
                la(r, i = e[o++]) && (~rl(n, i) || n.push(i));
            return n
        }
          , sl = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")
          , al = Object.keys || function(t) {
            return nl(t, sl)
        }
          , ll = {
            f: Object.getOwnPropertySymbols
        }
          , cl = {
            f: {}.propertyIsEnumerable
        }
          , hl = Array.isArray || function(t) {
            return "Array" == Ga(t)
        }
          , ul = function(t) {
            return Object(Za(t))
        }
          , dl = ha ? Object.defineProperties : function(t, e) {
            fa(t);
            for (var i, r = al(e), o = r.length, n = 0; o > n; )
                ba.f(t, i = r[n++], e[i]);
            return t
        }
          , fl = sa.document
          , _l = fl && fl.documentElement
          , pl = il("IE_PROTO")
          , ml = function() {}
          , gl = function() {
            var t, e = ma("iframe"), i = sl.length;
            for (e.style.display = "none",
            _l.appendChild(e),
            e.src = "javascript:",
            (t = e.contentWindow.document).open(),
            t.write("<script>document.F=Object<\/script>"),
            t.close(),
            gl = t.F; i--; )
                delete gl.prototype[sl[i]];
            return gl()
        }
          , vl = Object.create || function(t, e) {
            var i;
            return null !== t ? (ml.prototype = fa(t),
            i = new ml,
            ml.prototype = null,
            i[pl] = t) : i = gl(),
            void 0 === e ? i : dl(i, e)
        }
          , yl = sl.concat("length", "prototype")
          , bl = {
            f: Object.getOwnPropertyNames || function(t) {
                return nl(t, yl)
            }
        }
          , xl = bl.f
          , wl = {}.toString
          , Tl = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : []
          , El = {
            f: function(t) {
                return Tl && "[object Window]" == wl.call(t) ? function(t) {
                    try {
                        return xl(t)
                    } catch (t) {
                        return Tl.slice()
                    }
                }(t) : xl(Wa(t))
            }
        }
          , Sl = Object.getOwnPropertyDescriptor
          , Cl = {
            f: ha ? Sl : function(t, e) {
                if (t = Wa(t),
                e = va(e, !0),
                ga)
                    try {
                        return Sl(t, e)
                    } catch (t) {}
                if (la(t, e))
                    return xa(!cl.f.call(t, e), t[e])
            }
        }
          , Al = Ba.KEY
          , Ml = Cl.f
          , Il = ba.f
          , zl = El.f
          , Pl = sa.Symbol
          , Dl = sa.JSON
          , Bl = Dl && Dl.stringify
          , Ll = La("_hidden")
          , Rl = La("toPrimitive")
          , kl = {}.propertyIsEnumerable
          , Ol = Ca("symbol-registry")
          , Fl = Ca("symbols")
          , Ul = Ca("op-symbols")
          , Nl = Object.prototype
          , jl = "function" == typeof Pl && !!ll.f
          , Gl = sa.QObject
          , Vl = !Gl || !Gl.prototype || !Gl.prototype.findChild
          , Zl = ha && ca((function() {
            return 7 != vl(Il({}, "a", {
                get: function() {
                    return Il(this, "a", {
                        value: 7
                    }).a
                }
            })).a
        }
        )) ? function(t, e, i) {
            var r = Ml(Nl, e);
            r && delete Nl[e],
            Il(t, e, i),
            r && t !== Nl && Il(Nl, e, r);
        }
        : Il
          , Wl = function(t) {
            var e = Fl[t] = vl(Pl.prototype);
            return e._k = t,
            e
        }
          , ql = jl && "symbol" == typeof Pl.iterator ? function(t) {
            return "symbol" == typeof t
        }
        : function(t) {
            return t instanceof Pl
        }
          , Hl = function(t, e, i) {
            return t === Nl && Hl(Ul, e, i),
            fa(t),
            e = va(e, !0),
            fa(i),
            la(Fl, e) ? (i.enumerable ? (la(t, Ll) && t[Ll][e] && (t[Ll][e] = !1),
            i = vl(i, {
                enumerable: xa(0, !1)
            })) : (la(t, Ll) || Il(t, Ll, xa(1, {})),
            t[Ll][e] = !0),
            Zl(t, e, i)) : Il(t, e, i)
        }
          , Xl = function(t, e) {
            fa(t);
            for (var i, r = function(t) {
                var e = al(t)
                  , i = ll.f;
                if (i)
                    for (var r, o = i(t), n = cl.f, s = 0; o.length > s; )
                        n.call(t, r = o[s++]) && e.push(r);
                return e
            }(e = Wa(e)), o = 0, n = r.length; n > o; )
                Hl(t, i = r[o++], e[i]);
            return t
        }
          , Yl = function(t) {
            var e = kl.call(this, t = va(t, !0));
            return !(this === Nl && la(Fl, t) && !la(Ul, t)) && (!(e || !la(this, t) || !la(Fl, t) || la(this, Ll) && this[Ll][t]) || e)
        }
          , Kl = function(t, e) {
            if (t = Wa(t),
            e = va(e, !0),
            t !== Nl || !la(Fl, e) || la(Ul, e)) {
                var i = Ml(t, e);
                return !i || !la(Fl, e) || la(t, Ll) && t[Ll][e] || (i.enumerable = !0),
                i
            }
        }
          , Jl = function(t) {
            for (var e, i = zl(Wa(t)), r = [], o = 0; i.length > o; )
                la(Fl, e = i[o++]) || e == Ll || e == Al || r.push(e);
            return r
        }
          , $l = function(t) {
            for (var e, i = t === Nl, r = zl(i ? Ul : Wa(t)), o = [], n = 0; r.length > n; )
                !la(Fl, e = r[n++]) || i && !la(Nl, e) || o.push(Fl[e]);
            return o
        };
        jl || (Ma((Pl = function() {
            if (this instanceof Pl)
                throw TypeError("Symbol is not a constructor!");
            var t = Sa(arguments.length > 0 ? arguments[0] : void 0)
              , e = function(i) {
                this === Nl && e.call(Ul, i),
                la(this, Ll) && la(this[Ll], t) && (this[Ll][t] = !1),
                Zl(this, t, xa(1, i));
            };
            return ha && Vl && Zl(Nl, t, {
                configurable: !0,
                set: e
            }),
            Wl(t)
        }
        ).prototype, "toString", (function() {
            return this._k
        }
        )),
        Cl.f = Kl,
        ba.f = Hl,
        bl.f = El.f = Jl,
        cl.f = Yl,
        ll.f = $l,
        ha && Ma(Nl, "propertyIsEnumerable", Yl, !0),
        Fa.f = function(t) {
            return Wl(La(t))
        }
        ),
        Da(Da.G + Da.W + Da.F * !jl, {
            Symbol: Pl
        });
        for (var Ql = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), tc = 0; Ql.length > tc; )
            La(Ql[tc++]);
        for (var ec = al(La.store), ic = 0; ec.length > ic; )
            Na(ec[ic++]);
        Da(Da.S + Da.F * !jl, "Symbol", {
            for: function(t) {
                return la(Ol, t += "") ? Ol[t] : Ol[t] = Pl(t)
            },
            keyFor: function(t) {
                if (!ql(t))
                    throw TypeError(t + " is not a symbol!");
                for (var e in Ol)
                    if (Ol[e] === t)
                        return e
            },
            useSetter: function() {
                Vl = !0;
            },
            useSimple: function() {
                Vl = !1;
            }
        }),
        Da(Da.S + Da.F * !jl, "Object", {
            create: function(t, e) {
                return void 0 === e ? vl(t) : Xl(vl(t), e)
            },
            defineProperty: Hl,
            defineProperties: Xl,
            getOwnPropertyDescriptor: Kl,
            getOwnPropertyNames: Jl,
            getOwnPropertySymbols: $l
        });
        var rc = ca((function() {
            ll.f(1);
        }
        ));
        Da(Da.S + Da.F * rc, "Object", {
            getOwnPropertySymbols: function(t) {
                return ll.f(ul(t))
            }
        }),
        Dl && Da(Da.S + Da.F * (!jl || ca((function() {
            var t = Pl();
            return "[null]" != Bl([t]) || "{}" != Bl({
                a: t
            }) || "{}" != Bl(Object(t))
        }
        ))), "JSON", {
            stringify: function(t) {
                for (var e, i, r = [t], o = 1; arguments.length > o; )
                    r.push(arguments[o++]);
                if (i = e = r[1],
                (da(e) || void 0 !== t) && !ql(t))
                    return hl(e) || (e = function(t, e) {
                        if ("function" == typeof i && (e = i.call(this, t, e)),
                        !ql(e))
                            return e
                    }
                    ),
                    r[1] = e,
                    Bl.apply(Dl, r)
            }
        }),
        Pl.prototype[Rl] || wa(Pl.prototype, Rl, Pl.prototype.valueOf),
        Oa(Pl, "Symbol"),
        Oa(Math, "Math", !0),
        Oa(sa.JSON, "JSON", !0),
        Da(Da.S, "Object", {
            create: vl
        }),
        Da(Da.S + Da.F * !ha, "Object", {
            defineProperty: ba.f
        }),
        Da(Da.S + Da.F * !ha, "Object", {
            defineProperties: dl
        });
        var oc = function(t, e) {
            var i = (ua.Object || {})[t] || Object[t]
              , r = {};
            r[t] = e(i),
            Da(Da.S + Da.F * ca((function() {
                i(1);
            }
            )), "Object", r);
        }
          , nc = Cl.f;
        oc("getOwnPropertyDescriptor", (function() {
            return function(t, e) {
                return nc(Wa(t), e)
            }
        }
        ));
        var sc = il("IE_PROTO")
          , ac = Object.prototype
          , lc = Object.getPrototypeOf || function(t) {
            return t = ul(t),
            la(t, sc) ? t[sc] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? ac : null
        }
        ;
        oc("getPrototypeOf", (function() {
            return function(t) {
                return lc(ul(t))
            }
        }
        )),
        oc("keys", (function() {
            return function(t) {
                return al(ul(t))
            }
        }
        )),
        oc("getOwnPropertyNames", (function() {
            return El.f
        }
        ));
        var cc = Ba.onFreeze;
        oc("freeze", (function(t) {
            return function(e) {
                return t && da(e) ? t(cc(e)) : e
            }
        }
        ));
        var hc = Ba.onFreeze;
        oc("seal", (function(t) {
            return function(e) {
                return t && da(e) ? t(hc(e)) : e
            }
        }
        ));
        var uc = Ba.onFreeze;
        oc("preventExtensions", (function(t) {
            return function(e) {
                return t && da(e) ? t(uc(e)) : e
            }
        }
        )),
        oc("isFrozen", (function(t) {
            return function(e) {
                return !da(e) || !!t && t(e)
            }
        }
        )),
        oc("isSealed", (function(t) {
            return function(e) {
                return !da(e) || !!t && t(e)
            }
        }
        )),
        oc("isExtensible", (function(t) {
            return function(e) {
                return !!da(e) && (!t || t(e))
            }
        }
        ));
        var dc = Object.assign
          , fc = !dc || ca((function() {
            var t = {}
              , e = {}
              , i = Symbol()
              , r = "abcdefghijklmnopqrst";
            return t[i] = 7,
            r.split("").forEach((function(t) {
                e[t] = t;
            }
            )),
            7 != dc({}, t)[i] || Object.keys(dc({}, e)).join("") != r
        }
        )) ? function(t, e) {
            for (var i = ul(t), r = arguments.length, o = 1, n = ll.f, s = cl.f; r > o; )
                for (var a, l = Va(arguments[o++]), c = n ? al(l).concat(n(l)) : al(l), h = c.length, u = 0; h > u; )
                    a = c[u++],
                    ha && !s.call(l, a) || (i[a] = l[a]);
            return i
        }
        : dc;
        Da(Da.S + Da.F, "Object", {
            assign: fc
        });
        var _c = Object.is || function(t, e) {
            return t === e ? 0 !== t || 1 / t == 1 / e : t != t && e != e
        }
        ;
        Da(Da.S, "Object", {
            is: _c
        });
        var pc = function(t, e) {
            if (fa(t),
            !da(e) && null !== e)
                throw TypeError(e + ": can't set as prototype!")
        }
          , mc = {
            set: Object.setPrototypeOf || ("__proto__"in {} ? function(t, e, i) {
                try {
                    (i = za(Function.call, Cl.f(Object.prototype, "__proto__").set, 2))(t, []),
                    e = !(t instanceof Array);
                } catch (t) {
                    e = !0;
                }
                return function(t, r) {
                    return pc(t, r),
                    e ? t.__proto__ = r : i(t, r),
                    t
                }
            }({}, !1) : void 0),
            check: pc
        };
        Da(Da.S, "Object", {
            setPrototypeOf: mc.set
        });
        var gc = La("toStringTag")
          , vc = "Arguments" == Ga(function() {
            return arguments
        }())
          , yc = function(t) {
            var e, i, r;
            return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (i = function(t, e) {
                try {
                    return t[e]
                } catch (t) {}
            }(e = Object(t), gc)) ? i : vc ? Ga(e) : "Object" == (r = Ga(e)) && "function" == typeof e.callee ? "Arguments" : r
        }
          , bc = {};
        bc[La("toStringTag")] = "z",
        bc + "" != "[object z]" && Ma(Object.prototype, "toString", (function() {
            return "[object " + yc(this) + "]"
        }
        ), !0);
        var xc = function(t, e, i) {
            var r = void 0 === i;
            switch (e.length) {
            case 0:
                return r ? t() : t.call(i);
            case 1:
                return r ? t(e[0]) : t.call(i, e[0]);
            case 2:
                return r ? t(e[0], e[1]) : t.call(i, e[0], e[1]);
            case 3:
                return r ? t(e[0], e[1], e[2]) : t.call(i, e[0], e[1], e[2]);
            case 4:
                return r ? t(e[0], e[1], e[2], e[3]) : t.call(i, e[0], e[1], e[2], e[3])
            }
            return t.apply(i, e)
        }
          , wc = [].slice
          , Tc = {}
          , Ec = function(t, e, i) {
            if (!(e in Tc)) {
                for (var r = [], o = 0; o < e; o++)
                    r[o] = "a[" + o + "]";
                Tc[e] = Function("F,a", "return new F(" + r.join(",") + ")");
            }
            return Tc[e](t, i)
        }
          , Sc = Function.bind || function(t) {
            var e = Ia(this)
              , i = wc.call(arguments, 1)
              , r = function() {
                var o = i.concat(wc.call(arguments));
                return this instanceof r ? Ec(e, o.length, o) : xc(e, o, t)
            };
            return da(e.prototype) && (r.prototype = e.prototype),
            r
        }
        ;
        Da(Da.P, "Function", {
            bind: Sc
        });
        var Cc = Function.prototype
          , Ac = /^\s*function ([^ (]*)/
          , Mc = "name";
        Mc in Cc || ha && (0,
        ba.f)(Cc, Mc, {
            configurable: !0,
            get: function() {
                try {
                    return ("" + this).match(Ac)[1]
                } catch (t) {
                    return ""
                }
            }
        });
        var Ic = La("hasInstance")
          , zc = Function.prototype;
        Ic in zc || ba.f(zc, Ic, {
            value: function(t) {
                if ("function" != typeof this || !da(t))
                    return !1;
                if (!da(this.prototype))
                    return t instanceof this;
                for (; t = lc(t); )
                    if (this.prototype === t)
                        return !0;
                return !1
            }
        });
        var Pc = "\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"
          , Dc = "[" + Pc + "]"
          , Bc = RegExp("^" + Dc + Dc + "*")
          , Lc = RegExp(Dc + Dc + "*$")
          , Rc = function(t, e, i) {
            var r = {}
              , o = ca((function() {
                return !!Pc[t]() || "​" != "​"[t]()
            }
            ))
              , n = r[t] = o ? e(kc) : Pc[t];
            i && (r[i] = n),
            Da(Da.P + Da.F * o, "String", r);
        }
          , kc = Rc.trim = function(t, e) {
            return t = String(Za(t)),
            1 & e && (t = t.replace(Bc, "")),
            2 & e && (t = t.replace(Lc, "")),
            t
        }
          , Oc = Rc
          , Fc = sa.parseInt
          , Uc = Oc.trim
          , Nc = /^[-+]?0[xX]/
          , jc = 8 !== Fc(Pc + "08") || 22 !== Fc(Pc + "0x16") ? function(t, e) {
            var i = Uc(String(t), 3);
            return Fc(i, e >>> 0 || (Nc.test(i) ? 16 : 10))
        }
        : Fc;
        Da(Da.G + Da.F * (parseInt != jc), {
            parseInt: jc
        });
        var Gc = sa.parseFloat
          , Vc = Oc.trim
          , Zc = 1 / Gc(Pc + "-0") != -1 / 0 ? function(t) {
            var e = Vc(String(t), 3)
              , i = Gc(e);
            return 0 === i && "-" == e.charAt(0) ? -0 : i
        }
        : Gc;
        Da(Da.G + Da.F * (parseFloat != Zc), {
            parseFloat: Zc
        });
        var Wc = mc.set
          , qc = function(t, e, i) {
            var r, o = e.constructor;
            return o !== i && "function" == typeof o && (r = o.prototype) !== i.prototype && da(r) && Wc && Wc(t, r),
            t
        }
          , Hc = bl.f
          , Xc = Cl.f
          , Yc = ba.f
          , Kc = Oc.trim
          , Jc = "Number"
          , $c = sa.Number
          , Qc = $c
          , th = $c.prototype
          , eh = Ga(vl(th)) == Jc
          , ih = "trim"in String.prototype
          , rh = function(t) {
            var e = va(t, !1);
            if ("string" == typeof e && e.length > 2) {
                var i, r, o, n = (e = ih ? e.trim() : Kc(e, 3)).charCodeAt(0);
                if (43 === n || 45 === n) {
                    if (88 === (i = e.charCodeAt(2)) || 120 === i)
                        return NaN
                } else if (48 === n) {
                    switch (e.charCodeAt(1)) {
                    case 66:
                    case 98:
                        r = 2,
                        o = 49;
                        break;
                    case 79:
                    case 111:
                        r = 8,
                        o = 55;
                        break;
                    default:
                        return +e
                    }
                    for (var s, a = e.slice(2), l = 0, c = a.length; l < c; l++)
                        if ((s = a.charCodeAt(l)) < 48 || s > o)
                            return NaN;
                    return parseInt(a, r)
                }
            }
            return +e
        };
        if (!$c(" 0o1") || !$c("0b1") || $c("+0x1")) {
            $c = function(t) {
                var e = arguments.length < 1 ? 0 : t
                  , i = this;
                return i instanceof $c && (eh ? ca((function() {
                    th.valueOf.call(i);
                }
                )) : Ga(i) != Jc) ? qc(new Qc(rh(e)), i, $c) : rh(e)
            }
            ;
            for (var oh, nh = ha ? Hc(Qc) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","), sh = 0; nh.length > sh; sh++)
                la(Qc, oh = nh[sh]) && !la($c, oh) && Yc($c, oh, Xc(Qc, oh));
            $c.prototype = th,
            th.constructor = $c,
            Ma(sa, Jc, $c);
        }
        var ah = function(t, e) {
            if ("number" != typeof t && "Number" != Ga(t))
                throw TypeError(e);
            return +t
        }
          , lh = function(t) {
            var e = String(Za(this))
              , i = ""
              , r = Xa(t);
            if (r < 0 || r == 1 / 0)
                throw RangeError("Count can't be negative");
            for (; r > 0; (r >>>= 1) && (e += e))
                1 & r && (i += e);
            return i
        }
          , ch = 1..toFixed
          , hh = Math.floor
          , uh = [0, 0, 0, 0, 0, 0]
          , dh = "Number.toFixed: incorrect invocation!"
          , fh = "0"
          , _h = function(t, e) {
            for (var i = -1, r = e; ++i < 6; )
                uh[i] = (r += t * uh[i]) % 1e7,
                r = hh(r / 1e7);
        }
          , ph = function(t) {
            for (var e = 6, i = 0; --e >= 0; )
                uh[e] = hh((i += uh[e]) / t),
                i = i % t * 1e7;
        }
          , mh = function() {
            for (var t = 6, e = ""; --t >= 0; )
                if ("" !== e || 0 === t || 0 !== uh[t]) {
                    var i = String(uh[t]);
                    e = "" === e ? i : e + lh.call(fh, 7 - i.length) + i;
                }
            return e
        }
          , gh = function(t, e, i) {
            return 0 === e ? i : e % 2 == 1 ? gh(t, e - 1, i * t) : gh(t * t, e / 2, i)
        };
        Da(Da.P + Da.F * (!!ch && ("0.000" !== 8e-5.toFixed(3) || "1" !== .9.toFixed(0) || "1.25" !== 1.255.toFixed(2) || "1000000000000000128" !== (0xde0b6b3a7640080).toFixed(0)) || !ca((function() {
            ch.call({});
        }
        ))), "Number", {
            toFixed: function(t) {
                var e, i, r, o, n = ah(this, dh), s = Xa(t), a = "", l = fh;
                if (s < 0 || s > 20)
                    throw RangeError(dh);
                if (n != n)
                    return "NaN";
                if (n <= -1e21 || n >= 1e21)
                    return String(n);
                if (n < 0 && (a = "-",
                n = -n),
                n > 1e-21)
                    if (i = (e = function(t) {
                        for (var e = 0, i = t; i >= 4096; )
                            e += 12,
                            i /= 4096;
                        for (; i >= 2; )
                            e += 1,
                            i /= 2;
                        return e
                    }(n * gh(2, 69, 1)) - 69) < 0 ? n * gh(2, -e, 1) : n / gh(2, e, 1),
                    i *= 4503599627370496,
                    (e = 52 - e) > 0) {
                        for (_h(0, i),
                        r = s; r >= 7; )
                            _h(1e7, 0),
                            r -= 7;
                        for (_h(gh(10, r, 1), 0),
                        r = e - 1; r >= 23; )
                            ph(1 << 23),
                            r -= 23;
                        ph(1 << r),
                        _h(1, 1),
                        ph(2),
                        l = mh();
                    } else
                        _h(0, i),
                        _h(1 << -e, 0),
                        l = mh() + lh.call(fh, s);
                return s > 0 ? a + ((o = l.length) <= s ? "0." + lh.call(fh, s - o) + l : l.slice(0, o - s) + "." + l.slice(o - s)) : a + l
            }
        });
        var vh = 1..toPrecision;
        Da(Da.P + Da.F * (ca((function() {
            return "1" !== vh.call(1, void 0)
        }
        )) || !ca((function() {
            vh.call({});
        }
        ))), "Number", {
            toPrecision: function(t) {
                var e = ah(this, "Number#toPrecision: incorrect invocation!");
                return void 0 === t ? vh.call(e) : vh.call(e, t)
            }
        }),
        Da(Da.S, "Number", {
            EPSILON: Math.pow(2, -52)
        });
        var yh = sa.isFinite;
        Da(Da.S, "Number", {
            isFinite: function(t) {
                return "number" == typeof t && yh(t)
            }
        });
        var bh = Math.floor
          , xh = function(t) {
            return !da(t) && isFinite(t) && bh(t) === t
        };
        Da(Da.S, "Number", {
            isInteger: xh
        }),
        Da(Da.S, "Number", {
            isNaN: function(t) {
                return t != t
            }
        });
        var wh = Math.abs;
        Da(Da.S, "Number", {
            isSafeInteger: function(t) {
                return xh(t) && wh(t) <= 9007199254740991
            }
        }),
        Da(Da.S, "Number", {
            MAX_SAFE_INTEGER: 9007199254740991
        }),
        Da(Da.S, "Number", {
            MIN_SAFE_INTEGER: -9007199254740991
        }),
        Da(Da.S + Da.F * (Number.parseFloat != Zc), "Number", {
            parseFloat: Zc
        }),
        Da(Da.S + Da.F * (Number.parseInt != jc), "Number", {
            parseInt: jc
        });
        var Th = Math.log1p || function(t) {
            return (t = +t) > -1e-8 && t < 1e-8 ? t - t * t / 2 : Math.log(1 + t)
        }
          , Eh = Math.sqrt
          , Sh = Math.acosh;
        Da(Da.S + Da.F * !(Sh && 710 == Math.floor(Sh(Number.MAX_VALUE)) && Sh(1 / 0) == 1 / 0), "Math", {
            acosh: function(t) {
                return (t = +t) < 1 ? NaN : t > 94906265.62425156 ? Math.log(t) + Math.LN2 : Th(t - 1 + Eh(t - 1) * Eh(t + 1))
            }
        });
        var Ch = Math.asinh;
        Da(Da.S + Da.F * !(Ch && 1 / Ch(0) > 0), "Math", {
            asinh: function t(e) {
                return isFinite(e = +e) && 0 != e ? e < 0 ? -t(-e) : Math.log(e + Math.sqrt(e * e + 1)) : e
            }
        });
        var Ah = Math.atanh;
        Da(Da.S + Da.F * !(Ah && 1 / Ah(-0) < 0), "Math", {
            atanh: function(t) {
                return 0 == (t = +t) ? t : Math.log((1 + t) / (1 - t)) / 2
            }
        });
        var Mh = Math.sign || function(t) {
            return 0 == (t = +t) || t != t ? t : t < 0 ? -1 : 1
        }
        ;
        Da(Da.S, "Math", {
            cbrt: function(t) {
                return Mh(t = +t) * Math.pow(Math.abs(t), 1 / 3)
            }
        }),
        Da(Da.S, "Math", {
            clz32: function(t) {
                return (t >>>= 0) ? 31 - Math.floor(Math.log(t + .5) * Math.LOG2E) : 32
            }
        });
        var Ih = Math.exp;
        Da(Da.S, "Math", {
            cosh: function(t) {
                return (Ih(t = +t) + Ih(-t)) / 2
            }
        });
        var zh = Math.expm1
          , Ph = !zh || zh(10) > 22025.465794806718 || zh(10) < 22025.465794806718 || -2e-17 != zh(-2e-17) ? function(t) {
            return 0 == (t = +t) ? t : t > -1e-6 && t < 1e-6 ? t + t * t / 2 : Math.exp(t) - 1
        }
        : zh;
        Da(Da.S + Da.F * (Ph != Math.expm1), "Math", {
            expm1: Ph
        });
        var Dh = Math.pow
          , Bh = Dh(2, -52)
          , Lh = Dh(2, -23)
          , Rh = Dh(2, 127) * (2 - Lh)
          , kh = Dh(2, -126)
          , Oh = Math.fround || function(t) {
            var e, i, r = Math.abs(t), o = Mh(t);
            return r < kh ? o * (r / kh / Lh + 1 / Bh - 1 / Bh) * kh * Lh : (i = (e = (1 + Lh / Bh) * r) - (e - r)) > Rh || i != i ? o * (1 / 0) : o * i
        }
        ;
        Da(Da.S, "Math", {
            fround: Oh
        });
        var Fh = Math.abs;
        Da(Da.S, "Math", {
            hypot: function(t, e) {
                for (var i, r, o = 0, n = 0, s = arguments.length, a = 0; n < s; )
                    a < (i = Fh(arguments[n++])) ? (o = o * (r = a / i) * r + 1,
                    a = i) : o += i > 0 ? (r = i / a) * r : i;
                return a === 1 / 0 ? 1 / 0 : a * Math.sqrt(o)
            }
        });
        var Uh = Math.imul;
        Da(Da.S + Da.F * ca((function() {
            return -5 != Uh(4294967295, 5) || 2 != Uh.length
        }
        )), "Math", {
            imul: function(t, e) {
                var i = 65535
                  , r = +t
                  , o = +e
                  , n = i & r
                  , s = i & o;
                return 0 | n * s + ((i & r >>> 16) * s + n * (i & o >>> 16) << 16 >>> 0)
            }
        }),
        Da(Da.S, "Math", {
            log10: function(t) {
                return Math.log(t) * Math.LOG10E
            }
        }),
        Da(Da.S, "Math", {
            log1p: Th
        }),
        Da(Da.S, "Math", {
            log2: function(t) {
                return Math.log(t) / Math.LN2
            }
        }),
        Da(Da.S, "Math", {
            sign: Mh
        });
        var Nh = Math.exp;
        Da(Da.S + Da.F * ca((function() {
            return -2e-17 != !Math.sinh(-2e-17)
        }
        )), "Math", {
            sinh: function(t) {
                return Math.abs(t = +t) < 1 ? (Ph(t) - Ph(-t)) / 2 : (Nh(t - 1) - Nh(-t - 1)) * (Math.E / 2)
            }
        });
        var jh = Math.exp;
        Da(Da.S, "Math", {
            tanh: function(t) {
                var e = Ph(t = +t)
                  , i = Ph(-t);
                return e == 1 / 0 ? 1 : i == 1 / 0 ? -1 : (e - i) / (jh(t) + jh(-t))
            }
        }),
        Da(Da.S, "Math", {
            trunc: function(t) {
                return (t > 0 ? Math.floor : Math.ceil)(t)
            }
        });
        var Gh = String.fromCharCode
          , Vh = String.fromCodePoint;
        Da(Da.S + Da.F * (!!Vh && 1 != Vh.length), "String", {
            fromCodePoint: function(t) {
                for (var e, i = [], r = arguments.length, o = 0; r > o; ) {
                    if (e = +arguments[o++],
                    Qa(e, 1114111) !== e)
                        throw RangeError(e + " is not a valid code point");
                    i.push(e < 65536 ? Gh(e) : Gh(55296 + ((e -= 65536) >> 10), e % 1024 + 56320));
                }
                return i.join("")
            }
        }),
        Da(Da.S, "String", {
            raw: function(t) {
                for (var e = Wa(t.raw), i = Ka(e.length), r = arguments.length, o = [], n = 0; i > n; )
                    o.push(String(e[n++])),
                    n < r && o.push(String(arguments[n]));
                return o.join("")
            }
        }),
        Oc("trim", (function(t) {
            return function() {
                return t(this, 3)
            }
        }
        ));
        var Zh = function(t) {
            return function(e, i) {
                var r, o, n = String(Za(e)), s = Xa(i), a = n.length;
                return s < 0 || s >= a ? t ? "" : void 0 : (r = n.charCodeAt(s)) < 55296 || r > 56319 || s + 1 === a || (o = n.charCodeAt(s + 1)) < 56320 || o > 57343 ? t ? n.charAt(s) : r : t ? n.slice(s, s + 2) : o - 56320 + (r - 55296 << 10) + 65536
            }
        }
          , Wh = {}
          , qh = {};
        wa(qh, La("iterator"), (function() {
            return this
        }
        ));
        var Hh = function(t, e, i) {
            t.prototype = vl(qh, {
                next: xa(1, i)
            }),
            Oa(t, e + " Iterator");
        }
          , Xh = La("iterator")
          , Yh = !([].keys && "next"in [].keys())
          , Kh = "keys"
          , Jh = "values"
          , $h = function() {
            return this
        }
          , Qh = function(t, e, i, r, o, n, s) {
            Hh(i, e, r);
            var a, l, c, h = function(t) {
                if (!Yh && t in _)
                    return _[t];
                switch (t) {
                case Kh:
                case Jh:
                    return function() {
                        return new i(this,t)
                    }
                }
                return function() {
                    return new i(this,t)
                }
            }, u = e + " Iterator", d = o == Jh, f = !1, _ = t.prototype, p = _[Xh] || _["@@iterator"] || o && _[o], m = p || h(o), g = o ? d ? h("entries") : m : void 0, v = "Array" == e && _.entries || p;
            if (v && (c = lc(v.call(new t))) !== Object.prototype && c.next && (Oa(c, u, !0),
            "function" != typeof c[Xh] && wa(c, Xh, $h)),
            d && p && p.name !== Jh && (f = !0,
            m = function() {
                return p.call(this)
            }
            ),
            (Yh || f || !_[Xh]) && wa(_, Xh, m),
            Wh[e] = m,
            Wh[u] = $h,
            o)
                if (a = {
                    values: d ? m : h(Jh),
                    keys: n ? m : h(Kh),
                    entries: g
                },
                s)
                    for (l in a)
                        l in _ || Ma(_, l, a[l]);
                else
                    Da(Da.P + Da.F * (Yh || f), e, a);
            return a
        }
          , tu = Zh(!0);
        Qh(String, "String", (function(t) {
            this._t = String(t),
            this._i = 0;
        }
        ), (function() {
            var t, e = this._t, i = this._i;
            return i >= e.length ? {
                value: void 0,
                done: !0
            } : (t = tu(e, i),
            this._i += t.length,
            {
                value: t,
                done: !1
            })
        }
        ));
        var eu = Zh(!1);
        Da(Da.P, "String", {
            codePointAt: function(t) {
                return eu(this, t)
            }
        });
        var iu = La("match")
          , ru = function(t) {
            var e;
            return da(t) && (void 0 !== (e = t[iu]) ? !!e : "RegExp" == Ga(t))
        }
          , ou = function(t, e, i) {
            if (ru(e))
                throw TypeError("String#" + i + " doesn't accept regex!");
            return String(Za(t))
        }
          , nu = La("match")
          , su = function(t) {
            var e = /./;
            try {
                "/./"[t](e);
            } catch (i) {
                try {
                    return e[nu] = !1,
                    !"/./"[t](e)
                } catch (t) {}
            }
            return !0
        }
          , au = "endsWith"
          , lu = "".endsWith;
        Da(Da.P + Da.F * su(au), "String", {
            endsWith: function(t) {
                var e = ou(this, t, au)
                  , i = arguments.length > 1 ? arguments[1] : void 0
                  , r = Ka(e.length)
                  , o = void 0 === i ? r : Math.min(Ka(i), r)
                  , n = String(t);
                return lu ? lu.call(e, n, o) : e.slice(o - n.length, o) === n
            }
        });
        var cu = "includes";
        Da(Da.P + Da.F * su(cu), "String", {
            includes: function(t) {
                return !!~ou(this, t, cu).indexOf(t, arguments.length > 1 ? arguments[1] : void 0)
            }
        }),
        Da(Da.P, "String", {
            repeat: lh
        });
        var hu = "startsWith"
          , uu = "".startsWith;
        Da(Da.P + Da.F * su(hu), "String", {
            startsWith: function(t) {
                var e = ou(this, t, hu)
                  , i = Ka(Math.min(arguments.length > 1 ? arguments[1] : void 0, e.length))
                  , r = String(t);
                return uu ? uu.call(e, r, i) : e.slice(i, i + r.length) === r
            }
        });
        var du = /"/g
          , fu = function(t, e, i, r) {
            var o = String(Za(t))
              , n = "<" + e;
            return "" !== i && (n += " " + i + '="' + String(r).replace(du, "&quot;") + '"'),
            n + ">" + o + "</" + e + ">"
        }
          , _u = function(t, e) {
            var i = {};
            i[t] = e(fu),
            Da(Da.P + Da.F * ca((function() {
                var e = ""[t]('"');
                return e !== e.toLowerCase() || e.split('"').length > 3
            }
            )), "String", i);
        };
        _u("anchor", (function(t) {
            return function(e) {
                return t(this, "a", "name", e)
            }
        }
        )),
        _u("big", (function(t) {
            return function() {
                return t(this, "big", "", "")
            }
        }
        )),
        _u("blink", (function(t) {
            return function() {
                return t(this, "blink", "", "")
            }
        }
        )),
        _u("bold", (function(t) {
            return function() {
                return t(this, "b", "", "")
            }
        }
        )),
        _u("fixed", (function(t) {
            return function() {
                return t(this, "tt", "", "")
            }
        }
        )),
        _u("fontcolor", (function(t) {
            return function(e) {
                return t(this, "font", "color", e)
            }
        }
        )),
        _u("fontsize", (function(t) {
            return function(e) {
                return t(this, "font", "size", e)
            }
        }
        )),
        _u("italics", (function(t) {
            return function() {
                return t(this, "i", "", "")
            }
        }
        )),
        _u("link", (function(t) {
            return function(e) {
                return t(this, "a", "href", e)
            }
        }
        )),
        _u("small", (function(t) {
            return function() {
                return t(this, "small", "", "")
            }
        }
        )),
        _u("strike", (function(t) {
            return function() {
                return t(this, "strike", "", "")
            }
        }
        )),
        _u("sub", (function(t) {
            return function() {
                return t(this, "sub", "", "")
            }
        }
        )),
        _u("sup", (function(t) {
            return function() {
                return t(this, "sup", "", "")
            }
        }
        )),
        Da(Da.S, "Date", {
            now: function() {
                return (new Date).getTime()
            }
        }),
        Da(Da.P + Da.F * ca((function() {
            return null !== new Date(NaN).toJSON() || 1 !== Date.prototype.toJSON.call({
                toISOString: function() {
                    return 1
                }
            })
        }
        )), "Date", {
            toJSON: function(t) {
                var e = ul(this)
                  , i = va(e);
                return "number" != typeof i || isFinite(i) ? e.toISOString() : null
            }
        });
        var pu = Date.prototype.getTime
          , mu = Date.prototype.toISOString
          , gu = function(t) {
            return t > 9 ? t : "0" + t
        }
          , vu = ca((function() {
            return "0385-07-25T07:06:39.999Z" != mu.call(new Date(-50000000000001))
        }
        )) || !ca((function() {
            mu.call(new Date(NaN));
        }
        )) ? function() {
            if (!isFinite(pu.call(this)))
                throw RangeError("Invalid time value");
            var t = this
              , e = t.getUTCFullYear()
              , i = t.getUTCMilliseconds()
              , r = e < 0 ? "-" : e > 9999 ? "+" : "";
            return r + ("00000" + Math.abs(e)).slice(r ? -6 : -4) + "-" + gu(t.getUTCMonth() + 1) + "-" + gu(t.getUTCDate()) + "T" + gu(t.getUTCHours()) + ":" + gu(t.getUTCMinutes()) + ":" + gu(t.getUTCSeconds()) + "." + (i > 99 ? i : "0" + gu(i)) + "Z"
        }
        : mu;
        Da(Da.P + Da.F * (Date.prototype.toISOString !== vu), "Date", {
            toISOString: vu
        });
        var yu = Date.prototype
          , bu = "Invalid Date"
          , xu = yu.toString
          , wu = yu.getTime;
        new Date(NaN) + "" != bu && Ma(yu, "toString", (function() {
            var t = wu.call(this);
            return t == t ? xu.call(this) : bu
        }
        ));
        var Tu = "number"
          , Eu = La("toPrimitive")
          , Su = Date.prototype;
        Eu in Su || wa(Su, Eu, (function(t) {
            if ("string" !== t && t !== Tu && "default" !== t)
                throw TypeError("Incorrect hint");
            return va(fa(this), t != Tu)
        }
        )),
        Da(Da.S, "Array", {
            isArray: hl
        });
        var Cu = function(t, e, i, r) {
            try {
                return r ? e(fa(i)[0], i[1]) : e(i)
            } catch (e) {
                var o = t.return;
                throw void 0 !== o && fa(o.call(t)),
                e
            }
        }
          , Au = La("iterator")
          , Mu = Array.prototype
          , Iu = function(t) {
            return void 0 !== t && (Wh.Array === t || Mu[Au] === t)
        }
          , zu = function(t, e, i) {
            e in t ? ba.f(t, e, xa(0, i)) : t[e] = i;
        }
          , Pu = La("iterator")
          , Du = ua.getIteratorMethod = function(t) {
            if (null != t)
                return t[Pu] || t["@@iterator"] || Wh[yc(t)]
        }
          , Bu = La("iterator")
          , Lu = !1;
        try {
            var Ru = [7][Bu]();
            Ru.return = function() {
                Lu = !0;
            }
            ,
            Array.from(Ru, (function() {
                throw 2
            }
            ));
        } catch (qt) {}
        var ku = function(t, e) {
            if (!e && !Lu)
                return !1;
            var i = !1;
            try {
                var r = [7]
                  , o = r[Bu]();
                o.next = function() {
                    return {
                        done: i = !0
                    }
                }
                ,
                r[Bu] = function() {
                    return o
                }
                ,
                t(r);
            } catch (t) {}
            return i
        };
        Da(Da.S + Da.F * !ku((function(t) {
            Array.from(t);
        }
        )), "Array", {
            from: function(t) {
                var e, i, r, o, n = ul(t), s = "function" == typeof this ? this : Array, a = arguments.length, l = a > 1 ? arguments[1] : void 0, c = void 0 !== l, h = 0, u = Du(n);
                if (c && (l = za(l, a > 2 ? arguments[2] : void 0, 2)),
                null == u || s == Array && Iu(u))
                    for (i = new s(e = Ka(n.length)); e > h; h++)
                        zu(i, h, c ? l(n[h], h) : n[h]);
                else
                    for (o = u.call(n),
                    i = new s; !(r = o.next()).done; h++)
                        zu(i, h, c ? Cu(o, l, [r.value, h], !0) : r.value);
                return i.length = h,
                i
            }
        }),
        Da(Da.S + Da.F * ca((function() {
            function t() {}
            return !(Array.of.call(t)instanceof t)
        }
        )), "Array", {
            of: function() {
                for (var t = 0, e = arguments.length, i = new ("function" == typeof this ? this : Array)(e); e > t; )
                    zu(i, t, arguments[t++]);
                return i.length = e,
                i
            }
        });
        var Ou = function(t, e) {
            return !!t && ca((function() {
                e ? t.call(null, (function() {}
                ), 1) : t.call(null);
            }
            ))
        }
          , Fu = [].join;
        Da(Da.P + Da.F * (Va != Object || !Ou(Fu)), "Array", {
            join: function(t) {
                return Fu.call(Wa(this), void 0 === t ? "," : t)
            }
        });
        var Uu = [].slice;
        Da(Da.P + Da.F * ca((function() {
            _l && Uu.call(_l);
        }
        )), "Array", {
            slice: function(t, e) {
                var i = Ka(this.length)
                  , r = Ga(this);
                if (e = void 0 === e ? i : e,
                "Array" == r)
                    return Uu.call(this, t, e);
                for (var o = Qa(t, i), n = Qa(e, i), s = Ka(n - o), a = new Array(s), l = 0; l < s; l++)
                    a[l] = "String" == r ? this.charAt(o + l) : this[o + l];
                return a
            }
        });
        var Nu = [].sort
          , ju = [1, 2, 3];
        Da(Da.P + Da.F * (ca((function() {
            ju.sort(void 0);
        }
        )) || !ca((function() {
            ju.sort(null);
        }
        )) || !Ou(Nu)), "Array", {
            sort: function(t) {
                return void 0 === t ? Nu.call(ul(this)) : Nu.call(ul(this), Ia(t))
            }
        });
        var Gu = La("species")
          , Vu = function(t, e) {
            return new (function(t) {
                var e;
                return hl(t) && ("function" != typeof (e = t.constructor) || e !== Array && !hl(e.prototype) || (e = void 0),
                da(e) && null === (e = e[Gu]) && (e = void 0)),
                void 0 === e ? Array : e
            }(t))(e)
        }
          , Zu = function(t, e) {
            var i = 1 == t
              , r = 2 == t
              , o = 3 == t
              , n = 4 == t
              , s = 6 == t
              , a = 5 == t || s
              , l = e || Vu;
            return function(e, c, h) {
                for (var u, d, f = ul(e), _ = Va(f), p = za(c, h, 3), m = Ka(_.length), g = 0, v = i ? l(e, m) : r ? l(e, 0) : void 0; m > g; g++)
                    if ((a || g in _) && (d = p(u = _[g], g, f),
                    t))
                        if (i)
                            v[g] = d;
                        else if (d)
                            switch (t) {
                            case 3:
                                return !0;
                            case 5:
                                return u;
                            case 6:
                                return g;
                            case 2:
                                v.push(u);
                            }
                        else if (n)
                            return !1;
                return s ? -1 : o || n ? n : v
            }
        }
          , Wu = Zu(0)
          , qu = Ou([].forEach, !0);
        Da(Da.P + Da.F * !qu, "Array", {
            forEach: function(t) {
                return Wu(this, t, arguments[1])
            }
        });
        var Hu = Zu(1);
        Da(Da.P + Da.F * !Ou([].map, !0), "Array", {
            map: function(t) {
                return Hu(this, t, arguments[1])
            }
        });
        var Xu = Zu(2);
        Da(Da.P + Da.F * !Ou([].filter, !0), "Array", {
            filter: function(t) {
                return Xu(this, t, arguments[1])
            }
        });
        var Yu = Zu(3);
        Da(Da.P + Da.F * !Ou([].some, !0), "Array", {
            some: function(t) {
                return Yu(this, t, arguments[1])
            }
        });
        var Ku = Zu(4);
        Da(Da.P + Da.F * !Ou([].every, !0), "Array", {
            every: function(t) {
                return Ku(this, t, arguments[1])
            }
        });
        var Ju = function(t, e, i, r, o) {
            Ia(e);
            var n = ul(t)
              , s = Va(n)
              , a = Ka(n.length)
              , l = o ? a - 1 : 0
              , c = o ? -1 : 1;
            if (i < 2)
                for (; ; ) {
                    if (l in s) {
                        r = s[l],
                        l += c;
                        break
                    }
                    if (l += c,
                    o ? l < 0 : a <= l)
                        throw TypeError("Reduce of empty array with no initial value")
                }
            for (; o ? l >= 0 : a > l; l += c)
                l in s && (r = e(r, s[l], l, n));
            return r
        };
        Da(Da.P + Da.F * !Ou([].reduce, !0), "Array", {
            reduce: function(t) {
                return Ju(this, t, arguments.length, arguments[1], !1)
            }
        }),
        Da(Da.P + Da.F * !Ou([].reduceRight, !0), "Array", {
            reduceRight: function(t) {
                return Ju(this, t, arguments.length, arguments[1], !0)
            }
        });
        var $u = tl(!1)
          , Qu = [].indexOf
          , td = !!Qu && 1 / [1].indexOf(1, -0) < 0;
        Da(Da.P + Da.F * (td || !Ou(Qu)), "Array", {
            indexOf: function(t) {
                return td ? Qu.apply(this, arguments) || 0 : $u(this, t, arguments[1])
            }
        });
        var ed = [].lastIndexOf
          , id = !!ed && 1 / [1].lastIndexOf(1, -0) < 0;
        Da(Da.P + Da.F * (id || !Ou(ed)), "Array", {
            lastIndexOf: function(t) {
                if (id)
                    return ed.apply(this, arguments) || 0;
                var e = Wa(this)
                  , i = Ka(e.length)
                  , r = i - 1;
                for (arguments.length > 1 && (r = Math.min(r, Xa(arguments[1]))),
                r < 0 && (r = i + r); r >= 0; r--)
                    if (r in e && e[r] === t)
                        return r || 0;
                return -1
            }
        });
        var rd = [].copyWithin || function(t, e) {
            var i = ul(this)
              , r = Ka(i.length)
              , o = Qa(t, r)
              , n = Qa(e, r)
              , s = arguments.length > 2 ? arguments[2] : void 0
              , a = Math.min((void 0 === s ? r : Qa(s, r)) - n, r - o)
              , l = 1;
            for (n < o && o < n + a && (l = -1,
            n += a - 1,
            o += a - 1); a-- > 0; )
                n in i ? i[o] = i[n] : delete i[o],
                o += l,
                n += l;
            return i
        }
          , od = La("unscopables")
          , nd = Array.prototype;
        null == nd[od] && wa(nd, od, {});
        var sd = function(t) {
            nd[od][t] = !0;
        };
        Da(Da.P, "Array", {
            copyWithin: rd
        }),
        sd("copyWithin");
        var ad = function(t) {
            for (var e = ul(this), i = Ka(e.length), r = arguments.length, o = Qa(r > 1 ? arguments[1] : void 0, i), n = r > 2 ? arguments[2] : void 0, s = void 0 === n ? i : Qa(n, i); s > o; )
                e[o++] = t;
            return e
        };
        Da(Da.P, "Array", {
            fill: ad
        }),
        sd("fill");
        var ld = Zu(5)
          , cd = "find"
          , hd = !0;
        cd in [] && Array(1).find((function() {
            hd = !1;
        }
        )),
        Da(Da.P + Da.F * hd, "Array", {
            find: function(t) {
                return ld(this, t, arguments.length > 1 ? arguments[1] : void 0)
            }
        }),
        sd(cd);
        var ud = Zu(6)
          , dd = "findIndex"
          , fd = !0;
        dd in [] && Array(1)[dd]((function() {
            fd = !1;
        }
        )),
        Da(Da.P + Da.F * fd, "Array", {
            findIndex: function(t) {
                return ud(this, t, arguments.length > 1 ? arguments[1] : void 0)
            }
        }),
        sd(dd);
        var _d = La("species")
          , pd = function(t) {
            var e = sa[t];
            ha && e && !e[_d] && ba.f(e, _d, {
                configurable: !0,
                get: function() {
                    return this
                }
            });
        };
        pd("Array");
        var md = function(t, e) {
            return {
                value: e,
                done: !!t
            }
        }
          , gd = Qh(Array, "Array", (function(t, e) {
            this._t = Wa(t),
            this._i = 0,
            this._k = e;
        }
        ), (function() {
            var t = this._t
              , e = this._k
              , i = this._i++;
            return !t || i >= t.length ? (this._t = void 0,
            md(1)) : md(0, "keys" == e ? i : "values" == e ? t[i] : [i, t[i]])
        }
        ), "values");
        Wh.Arguments = Wh.Array,
        sd("keys"),
        sd("values"),
        sd("entries");
        var vd = function() {
            var t = fa(this)
              , e = "";
            return t.global && (e += "g"),
            t.ignoreCase && (e += "i"),
            t.multiline && (e += "m"),
            t.unicode && (e += "u"),
            t.sticky && (e += "y"),
            e
        }
          , yd = ba.f
          , bd = bl.f
          , xd = sa.RegExp
          , wd = xd
          , Td = xd.prototype
          , Ed = /a/g
          , Sd = /a/g
          , Cd = new xd(Ed) !== Ed;
        if (ha && (!Cd || ca((function() {
            return Sd[La("match")] = !1,
            xd(Ed) != Ed || xd(Sd) == Sd || "/a/i" != xd(Ed, "i")
        }
        )))) {
            xd = function(t, e) {
                var i = this instanceof xd
                  , r = ru(t)
                  , o = void 0 === e;
                return !i && r && t.constructor === xd && o ? t : qc(Cd ? new wd(r && !o ? t.source : t,e) : wd((r = t instanceof xd) ? t.source : t, r && o ? vd.call(t) : e), i ? this : Td, xd)
            }
            ;
            for (var Ad = function(t) {
                t in xd || yd(xd, t, {
                    configurable: !0,
                    get: function() {
                        return wd[t]
                    },
                    set: function(e) {
                        wd[t] = e;
                    }
                });
            }, Md = bd(wd), Id = 0; Md.length > Id; )
                Ad(Md[Id++]);
            Td.constructor = xd,
            xd.prototype = Td,
            Ma(sa, "RegExp", xd);
        }
        pd("RegExp");
        var zd = RegExp.prototype.exec
          , Pd = String.prototype.replace
          , Dd = zd
          , Bd = function() {
            var t = /a/
              , e = /b*/g;
            return zd.call(t, "a"),
            zd.call(e, "a"),
            0 !== t.lastIndex || 0 !== e.lastIndex
        }()
          , Ld = void 0 !== /()??/.exec("")[1];
        (Bd || Ld) && (Dd = function(t) {
            var e, i, r, o, n = this;
            return Ld && (i = new RegExp("^" + n.source + "$(?!\\s)",vd.call(n))),
            Bd && (e = n.lastIndex),
            r = zd.call(n, t),
            Bd && r && (n.lastIndex = n.global ? r.index + r[0].length : e),
            Ld && r && r.length > 1 && Pd.call(r[0], i, (function() {
                for (o = 1; o < arguments.length - 2; o++)
                    void 0 === arguments[o] && (r[o] = void 0);
            }
            )),
            r
        }
        );
        var Rd = Dd;
        Da({
            target: "RegExp",
            proto: !0,
            forced: Rd !== /./.exec
        }, {
            exec: Rd
        }),
        ha && "g" != /./g.flags && ba.f(RegExp.prototype, "flags", {
            configurable: !0,
            get: vd
        });
        var kd = "toString"
          , Od = /./.toString
          , Fd = function(t) {
            Ma(RegExp.prototype, kd, t, !0);
        };
        ca((function() {
            return "/a/b" != Od.call({
                source: "a",
                flags: "b"
            })
        }
        )) ? Fd((function() {
            var t = fa(this);
            return "/".concat(t.source, "/", "flags"in t ? t.flags : !ha && t instanceof RegExp ? vd.call(t) : void 0)
        }
        )) : Od.name != kd && Fd((function() {
            return Od.call(this)
        }
        ));
        var Ud = Zh(!0)
          , Nd = function(t, e, i) {
            return e + (i ? Ud(t, e).length : 1)
        }
          , jd = RegExp.prototype.exec
          , Gd = function(t, e) {
            var i = t.exec;
            if ("function" == typeof i) {
                var r = i.call(t, e);
                if ("object" != typeof r)
                    throw new TypeError("RegExp exec method returned something other than an Object or null");
                return r
            }
            if ("RegExp" !== yc(t))
                throw new TypeError("RegExp#exec called on incompatible receiver");
            return jd.call(t, e)
        }
          , Vd = La("species")
          , Zd = !ca((function() {
            var t = /./;
            return t.exec = function() {
                var t = [];
                return t.groups = {
                    a: "7"
                },
                t
            }
            ,
            "7" !== "".replace(t, "$<a>")
        }
        ))
          , Wd = function() {
            var t = /(?:)/
              , e = t.exec;
            t.exec = function() {
                return e.apply(this, arguments)
            }
            ;
            var i = "ab".split(t);
            return 2 === i.length && "a" === i[0] && "b" === i[1]
        }()
          , qd = function(t, e, i) {
            var r = La(t)
              , o = !ca((function() {
                var e = {};
                return e[r] = function() {
                    return 7
                }
                ,
                7 != ""[t](e)
            }
            ))
              , n = o ? !ca((function() {
                var e = !1
                  , i = /a/;
                return i.exec = function() {
                    return e = !0,
                    null
                }
                ,
                "split" === t && (i.constructor = {},
                i.constructor[Vd] = function() {
                    return i
                }
                ),
                i[r](""),
                !e
            }
            )) : void 0;
            if (!o || !n || "replace" === t && !Zd || "split" === t && !Wd) {
                var s = /./[r]
                  , a = i(Za, r, ""[t], (function(t, e, i, r, n) {
                    return e.exec === Rd ? o && !n ? {
                        done: !0,
                        value: s.call(e, i, r)
                    } : {
                        done: !0,
                        value: t.call(i, e, r)
                    } : {
                        done: !1
                    }
                }
                ))
                  , l = a[1];
                Ma(String.prototype, t, a[0]),
                wa(RegExp.prototype, r, 2 == e ? function(t, e) {
                    return l.call(t, this, e)
                }
                : function(t) {
                    return l.call(t, this)
                }
                );
            }
        };
        qd("match", 1, (function(t, e, i, r) {
            return [function(i) {
                var r = t(this)
                  , o = null == i ? void 0 : i[e];
                return void 0 !== o ? o.call(i, r) : new RegExp(i)[e](String(r))
            }
            , function(t) {
                var e = r(i, t, this);
                if (e.done)
                    return e.value;
                var o = fa(t)
                  , n = String(this);
                if (!o.global)
                    return Gd(o, n);
                var s = o.unicode;
                o.lastIndex = 0;
                for (var a, l = [], c = 0; null !== (a = Gd(o, n)); ) {
                    var h = String(a[0]);
                    l[c] = h,
                    "" === h && (o.lastIndex = Nd(n, Ka(o.lastIndex), s)),
                    c++;
                }
                return 0 === c ? null : l
            }
            ]
        }
        ));
        var Hd = Math.max
          , Xd = Math.min
          , Yd = Math.floor
          , Kd = /\$([$&`']|\d\d?|<[^>]*>)/g
          , Jd = /\$([$&`']|\d\d?)/g;
        qd("replace", 2, (function(t, e, i, r) {
            return [function(r, o) {
                var n = t(this)
                  , s = null == r ? void 0 : r[e];
                return void 0 !== s ? s.call(r, n, o) : i.call(String(n), r, o)
            }
            , function(t, e) {
                var n = r(i, t, this, e);
                if (n.done)
                    return n.value;
                var s = fa(t)
                  , a = String(this)
                  , l = "function" == typeof e;
                l || (e = String(e));
                var c = s.global;
                if (c) {
                    var h = s.unicode;
                    s.lastIndex = 0;
                }
                for (var u = []; ; ) {
                    var d = Gd(s, a);
                    if (null === d)
                        break;
                    if (u.push(d),
                    !c)
                        break;
                    "" === String(d[0]) && (s.lastIndex = Nd(a, Ka(s.lastIndex), h));
                }
                for (var f, _ = "", p = 0, m = 0; m < u.length; m++) {
                    d = u[m];
                    for (var g = String(d[0]), v = Hd(Xd(Xa(d.index), a.length), 0), y = [], b = 1; b < d.length; b++)
                        y.push(void 0 === (f = d[b]) ? f : String(f));
                    var x = d.groups;
                    if (l) {
                        var w = [g].concat(y, v, a);
                        void 0 !== x && w.push(x);
                        var T = String(e.apply(void 0, w));
                    } else
                        T = o(g, a, v, y, x, e);
                    v >= p && (_ += a.slice(p, v) + T,
                    p = v + g.length);
                }
                return _ + a.slice(p)
            }
            ];
            function o(t, e, r, o, n, s) {
                var a = r + t.length
                  , l = o.length
                  , c = Jd;
                return void 0 !== n && (n = ul(n),
                c = Kd),
                i.call(s, c, (function(i, s) {
                    var c;
                    switch (s.charAt(0)) {
                    case "$":
                        return "$";
                    case "&":
                        return t;
                    case "`":
                        return e.slice(0, r);
                    case "'":
                        return e.slice(a);
                    case "<":
                        c = n[s.slice(1, -1)];
                        break;
                    default:
                        var h = +s;
                        if (0 === h)
                            return i;
                        if (h > l) {
                            var u = Yd(h / 10);
                            return 0 === u ? i : u <= l ? void 0 === o[u - 1] ? s.charAt(1) : o[u - 1] + s.charAt(1) : i
                        }
                        c = o[h - 1];
                    }
                    return void 0 === c ? "" : c
                }
                ))
            }
        }
        )),
        qd("search", 1, (function(t, e, i, r) {
            return [function(i) {
                var r = t(this)
                  , o = null == i ? void 0 : i[e];
                return void 0 !== o ? o.call(i, r) : new RegExp(i)[e](String(r))
            }
            , function(t) {
                var e = r(i, t, this);
                if (e.done)
                    return e.value;
                var o = fa(t)
                  , n = String(this)
                  , s = o.lastIndex;
                _c(s, 0) || (o.lastIndex = 0);
                var a = Gd(o, n);
                return _c(o.lastIndex, s) || (o.lastIndex = s),
                null === a ? -1 : a.index
            }
            ]
        }
        ));
        var $d = La("species")
          , Qd = function(t, e) {
            var i, r = fa(t).constructor;
            return void 0 === r || null == (i = fa(r)[$d]) ? e : Ia(i)
        }
          , tf = Math.min
          , ef = [].push
          , rf = 4294967295
          , of = !ca((function() {
            RegExp(rf, "y");
        }
        ));
        qd("split", 2, (function(t, e, i, r) {
            var o;
            return o = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(t, e) {
                var r = String(this);
                if (void 0 === t && 0 === e)
                    return [];
                if (!ru(t))
                    return i.call(r, t, e);
                for (var o, n, s, a = [], l = 0, c = void 0 === e ? rf : e >>> 0, h = new RegExp(t.source,(t.ignoreCase ? "i" : "") + (t.multiline ? "m" : "") + (t.unicode ? "u" : "") + (t.sticky ? "y" : "") + "g"); (o = Rd.call(h, r)) && !((n = h.lastIndex) > l && (a.push(r.slice(l, o.index)),
                o.length > 1 && o.index < r.length && ef.apply(a, o.slice(1)),
                s = o[0].length,
                l = n,
                a.length >= c)); )
                    h.lastIndex === o.index && h.lastIndex++;
                return l === r.length ? !s && h.test("") || a.push("") : a.push(r.slice(l)),
                a.length > c ? a.slice(0, c) : a
            }
            : "0".split(void 0, 0).length ? function(t, e) {
                return void 0 === t && 0 === e ? [] : i.call(this, t, e)
            }
            : i,
            [function(i, r) {
                var n = t(this)
                  , s = null == i ? void 0 : i[e];
                return void 0 !== s ? s.call(i, n, r) : o.call(String(n), i, r)
            }
            , function(t, e) {
                var n = r(o, t, this, e, o !== i);
                if (n.done)
                    return n.value;
                var s = fa(t)
                  , a = String(this)
                  , l = Qd(s, RegExp)
                  , c = s.unicode
                  , h = new l(of ? s : "^(?:" + s.source + ")",(s.ignoreCase ? "i" : "") + (s.multiline ? "m" : "") + (s.unicode ? "u" : "") + (of ? "y" : "g"))
                  , u = void 0 === e ? rf : e >>> 0;
                if (0 === u)
                    return [];
                if (0 === a.length)
                    return null === Gd(h, a) ? [a] : [];
                for (var d = 0, f = 0, _ = []; f < a.length; ) {
                    h.lastIndex = of ? f : 0;
                    var p, m = Gd(h, of ? a : a.slice(f));
                    if (null === m || (p = tf(Ka(h.lastIndex + (of ? 0 : f)), a.length)) === d)
                        f = Nd(a, f, c);
                    else {
                        if (_.push(a.slice(d, f)),
                        _.length === u)
                            return _;
                        for (var g = 1; g <= m.length - 1; g++)
                            if (_.push(m[g]),
                            _.length === u)
                                return _;
                        f = d = p;
                    }
                }
                return _.push(a.slice(d)),
                _
            }
            ]
        }
        ));
        var nf, sf, af, lf = function(t, e, i, r) {
            if (!(t instanceof e) || void 0 !== r && r in t)
                throw TypeError(i + ": incorrect invocation!");
            return t
        }, cf = t.createCommonjsModule((function(t) {
            var e = {}
              , i = {}
              , r = t.exports = function(t, r, o, n, s) {
                var a, l, c, h, u = s ? function() {
                    return t
                }
                : Du(t), d = za(o, n, r ? 2 : 1), f = 0;
                if ("function" != typeof u)
                    throw TypeError(t + " is not iterable!");
                if (Iu(u)) {
                    for (a = Ka(t.length); a > f; f++)
                        if ((h = r ? d(fa(l = t[f])[0], l[1]) : d(t[f])) === e || h === i)
                            return h
                } else
                    for (c = u.call(t); !(l = c.next()).done; )
                        if ((h = Cu(c, d, l.value, r)) === e || h === i)
                            return h
            }
            ;
            r.BREAK = e,
            r.RETURN = i;
        }
        )), hf = sa.process, uf = sa.setImmediate, df = sa.clearImmediate, ff = sa.MessageChannel, _f = sa.Dispatch, pf = 0, mf = {}, gf = function() {
            var t = +this;
            if (mf.hasOwnProperty(t)) {
                var e = mf[t];
                delete mf[t],
                e();
            }
        }, vf = function(t) {
            gf.call(t.data);
        };
        uf && df || (uf = function(t) {
            for (var e = [], i = 1; arguments.length > i; )
                e.push(arguments[i++]);
            return mf[++pf] = function() {
                xc("function" == typeof t ? t : Function(t), e);
            }
            ,
            nf(pf),
            pf
        }
        ,
        df = function(t) {
            delete mf[t];
        }
        ,
        "process" == Ga(hf) ? nf = function(t) {
            hf.nextTick(za(gf, t, 1));
        }
        : _f && _f.now ? nf = function(t) {
            _f.now(za(gf, t, 1));
        }
        : ff ? (af = (sf = new ff).port2,
        sf.port1.onmessage = vf,
        nf = za(af.postMessage, af, 1)) : sa.addEventListener && "function" == typeof postMessage && !sa.importScripts ? (nf = function(t) {
            sa.postMessage(t + "", "*");
        }
        ,
        sa.addEventListener("message", vf, !1)) : nf = "onreadystatechange"in ma("script") ? function(t) {
            _l.appendChild(ma("script")).onreadystatechange = function() {
                _l.removeChild(this),
                gf.call(t);
            }
            ;
        }
        : function(t) {
            setTimeout(za(gf, t, 1), 0);
        }
        );
        var yf = {
            set: uf,
            clear: df
        }
          , bf = yf.set
          , xf = sa.MutationObserver || sa.WebKitMutationObserver
          , wf = sa.process
          , Tf = sa.Promise
          , Ef = "process" == Ga(wf);
        function Sf(t) {
            var e, i;
            this.promise = new t((function(t, r) {
                if (void 0 !== e || void 0 !== i)
                    throw TypeError("Bad Promise constructor");
                e = t,
                i = r;
            }
            )),
            this.resolve = Ia(e),
            this.reject = Ia(i);
        }
        var Cf, Af, Mf, If, zf = {
            f: function(t) {
                return new Sf(t)
            }
        }, Pf = function(t) {
            try {
                return {
                    e: !1,
                    v: t()
                }
            } catch (t) {
                return {
                    e: !0,
                    v: t
                }
            }
        }, Df = sa.navigator, Bf = Df && Df.userAgent || "", Lf = function(t, e) {
            if (fa(t),
            da(e) && e.constructor === t)
                return e;
            var i = zf.f(t);
            return (0,
            i.resolve)(e),
            i.promise
        }, Rf = function(t, e, i) {
            for (var r in e)
                Ma(t, r, e[r], i);
            return t
        }, kf = yf.set, Of = function() {
            var t, e, i, r = function() {
                var r, o;
                for (Ef && (r = wf.domain) && r.exit(); t; ) {
                    o = t.fn,
                    t = t.next;
                    try {
                        o();
                    } catch (r) {
                        throw t ? i() : e = void 0,
                        r
                    }
                }
                e = void 0,
                r && r.enter();
            };
            if (Ef)
                i = function() {
                    wf.nextTick(r);
                }
                ;
            else if (!xf || sa.navigator && sa.navigator.standalone)
                if (Tf && Tf.resolve) {
                    var o = Tf.resolve(void 0);
                    i = function() {
                        o.then(r);
                    }
                    ;
                } else
                    i = function() {
                        bf.call(sa, r);
                    }
                    ;
            else {
                var n = !0
                  , s = document.createTextNode("");
                new xf(r).observe(s, {
                    characterData: !0
                }),
                i = function() {
                    s.data = n = !n;
                }
                ;
            }
            return function(r) {
                var o = {
                    fn: r,
                    next: void 0
                };
                e && (e.next = o),
                t || (t = o,
                i()),
                e = o;
            }
        }(), Ff = "Promise", Uf = sa.TypeError, Nf = sa.process, jf = Nf && Nf.versions, Gf = jf && jf.v8 || "", Vf = sa.Promise, Zf = "process" == yc(Nf), Wf = function() {}, qf = Af = zf.f, Hf = !!function() {
            try {
                var t = Vf.resolve(1)
                  , e = (t.constructor = {})[La("species")] = function(t) {
                    t(Wf, Wf);
                }
                ;
                return (Zf || "function" == typeof PromiseRejectionEvent) && t.then(Wf)instanceof e && 0 !== Gf.indexOf("6.6") && -1 === Bf.indexOf("Chrome/66")
            } catch (t) {}
        }(), Xf = function(t) {
            var e;
            return !(!da(t) || "function" != typeof (e = t.then)) && e
        }, Yf = function(t, e) {
            if (!t._n) {
                t._n = !0;
                var i = t._c;
                Of((function() {
                    for (var r = t._v, o = 1 == t._s, n = 0, s = function(e) {
                        var i, n, s, a = o ? e.ok : e.fail, l = e.resolve, c = e.reject, h = e.domain;
                        try {
                            a ? (o || (2 == t._h && $f(t),
                            t._h = 1),
                            !0 === a ? i = r : (h && h.enter(),
                            i = a(r),
                            h && (h.exit(),
                            s = !0)),
                            i === e.promise ? c(Uf("Promise-chain cycle")) : (n = Xf(i)) ? n.call(i, l, c) : l(i)) : c(r);
                        } catch (t) {
                            h && !s && h.exit(),
                            c(t);
                        }
                    }; i.length > n; )
                        s(i[n++]);
                    t._c = [],
                    t._n = !1,
                    e && !t._h && Kf(t);
                }
                ));
            }
        }, Kf = function(t) {
            kf.call(sa, (function() {
                var e, i, r, o = t._v, n = Jf(t);
                if (n && (e = Pf((function() {
                    Zf ? Nf.emit("unhandledRejection", o, t) : (i = sa.onunhandledrejection) ? i({
                        promise: t,
                        reason: o
                    }) : (r = sa.console) && r.error && r.error("Unhandled promise rejection", o);
                }
                )),
                t._h = Zf || Jf(t) ? 2 : 1),
                t._a = void 0,
                n && e.e)
                    throw e.v
            }
            ));
        }, Jf = function(t) {
            return 1 !== t._h && 0 === (t._a || t._c).length
        }, $f = function(t) {
            kf.call(sa, (function() {
                var e;
                Zf ? Nf.emit("rejectionHandled", t) : (e = sa.onrejectionhandled) && e({
                    promise: t,
                    reason: t._v
                });
            }
            ));
        }, Qf = function(t) {
            var e = this;
            e._d || (e._d = !0,
            (e = e._w || e)._v = t,
            e._s = 2,
            e._a || (e._a = e._c.slice()),
            Yf(e, !0));
        }, t_ = function(t) {
            var e, i = this;
            if (!i._d) {
                i._d = !0,
                i = i._w || i;
                try {
                    if (i === t)
                        throw Uf("Promise can't be resolved itself");
                    (e = Xf(t)) ? Of((function() {
                        var r = {
                            _w: i,
                            _d: !1
                        };
                        try {
                            e.call(t, za(t_, r, 1), za(Qf, r, 1));
                        } catch (t) {
                            Qf.call(r, t);
                        }
                    }
                    )) : (i._v = t,
                    i._s = 1,
                    Yf(i, !1));
                } catch (t) {
                    Qf.call({
                        _w: i,
                        _d: !1
                    }, t);
                }
            }
        };
        Hf || (Vf = function(t) {
            lf(this, Vf, Ff, "_h"),
            Ia(t),
            Cf.call(this);
            try {
                t(za(t_, this, 1), za(Qf, this, 1));
            } catch (t) {
                Qf.call(this, t);
            }
        }
        ,
        (Cf = function(t) {
            this._c = [],
            this._a = void 0,
            this._s = 0,
            this._d = !1,
            this._v = void 0,
            this._h = 0,
            this._n = !1;
        }
        ).prototype = Rf(Vf.prototype, {
            then: function(t, e) {
                var i = qf(Qd(this, Vf));
                return i.ok = "function" != typeof t || t,
                i.fail = "function" == typeof e && e,
                i.domain = Zf ? Nf.domain : void 0,
                this._c.push(i),
                this._a && this._a.push(i),
                this._s && Yf(this, !1),
                i.promise
            },
            catch: function(t) {
                return this.then(void 0, t)
            }
        }),
        Mf = function() {
            var t = new Cf;
            this.promise = t,
            this.resolve = za(t_, t, 1),
            this.reject = za(Qf, t, 1);
        }
        ,
        zf.f = qf = function(t) {
            return t === Vf || t === If ? new Mf(t) : Af(t)
        }
        ),
        Da(Da.G + Da.W + Da.F * !Hf, {
            Promise: Vf
        }),
        Oa(Vf, Ff),
        pd(Ff),
        If = ua.Promise,
        Da(Da.S + Da.F * !Hf, Ff, {
            reject: function(t) {
                var e = qf(this);
                return (0,
                e.reject)(t),
                e.promise
            }
        }),
        Da(Da.S + Da.F * !Hf, Ff, {
            resolve: function(t) {
                return Lf(this, t)
            }
        }),
        Da(Da.S + Da.F * !(Hf && ku((function(t) {
            Vf.all(t).catch(Wf);
        }
        ))), Ff, {
            all: function(t) {
                var e = this
                  , i = qf(e)
                  , r = i.resolve
                  , o = i.reject
                  , n = Pf((function() {
                    var i = []
                      , n = 0
                      , s = 1;
                    cf(t, !1, (function(t) {
                        var a = n++
                          , l = !1;
                        i.push(void 0),
                        s++,
                        e.resolve(t).then((function(t) {
                            l || (l = !0,
                            i[a] = t,
                            --s || r(i));
                        }
                        ), o);
                    }
                    )),
                    --s || r(i);
                }
                ));
                return n.e && o(n.v),
                i.promise
            },
            race: function(t) {
                var e = this
                  , i = qf(e)
                  , r = i.reject
                  , o = Pf((function() {
                    cf(t, !1, (function(t) {
                        e.resolve(t).then(i.resolve, r);
                    }
                    ));
                }
                ));
                return o.e && r(o.v),
                i.promise
            }
        });
        var e_ = function(t, e) {
            if (!da(t) || t._t !== e)
                throw TypeError("Incompatible receiver, " + e + " required!");
            return t
        }
          , i_ = ba.f
          , r_ = Ba.fastKey
          , o_ = ha ? "_s" : "size"
          , n_ = function(t, e) {
            var i, r = r_(e);
            if ("F" !== r)
                return t._i[r];
            for (i = t._f; i; i = i.n)
                if (i.k == e)
                    return i
        }
          , s_ = {
            getConstructor: function(t, e, i, r) {
                var o = t((function(t, n) {
                    lf(t, o, e, "_i"),
                    t._t = e,
                    t._i = vl(null),
                    t._f = void 0,
                    t._l = void 0,
                    t[o_] = 0,
                    null != n && cf(n, i, t[r], t);
                }
                ));
                return Rf(o.prototype, {
                    clear: function() {
                        for (var t = e_(this, e), i = t._i, r = t._f; r; r = r.n)
                            r.r = !0,
                            r.p && (r.p = r.p.n = void 0),
                            delete i[r.i];
                        t._f = t._l = void 0,
                        t[o_] = 0;
                    },
                    delete: function(t) {
                        var i = e_(this, e)
                          , r = n_(i, t);
                        if (r) {
                            var o = r.n
                              , n = r.p;
                            delete i._i[r.i],
                            r.r = !0,
                            n && (n.n = o),
                            o && (o.p = n),
                            i._f == r && (i._f = o),
                            i._l == r && (i._l = n),
                            i[o_]--;
                        }
                        return !!r
                    },
                    forEach: function(t) {
                        e_(this, e);
                        for (var i, r = za(t, arguments.length > 1 ? arguments[1] : void 0, 3); i = i ? i.n : this._f; )
                            for (r(i.v, i.k, this); i && i.r; )
                                i = i.p;
                    },
                    has: function(t) {
                        return !!n_(e_(this, e), t)
                    }
                }),
                ha && i_(o.prototype, "size", {
                    get: function() {
                        return e_(this, e)[o_]
                    }
                }),
                o
            },
            def: function(t, e, i) {
                var r, o, n = n_(t, e);
                return n ? n.v = i : (t._l = n = {
                    i: o = r_(e, !0),
                    k: e,
                    v: i,
                    p: r = t._l,
                    n: void 0,
                    r: !1
                },
                t._f || (t._f = n),
                r && (r.n = n),
                t[o_]++,
                "F" !== o && (t._i[o] = n)),
                t
            },
            getEntry: n_,
            setStrong: function(t, e, i) {
                Qh(t, e, (function(t, i) {
                    this._t = e_(t, e),
                    this._k = i,
                    this._l = void 0;
                }
                ), (function() {
                    for (var t = this, e = t._k, i = t._l; i && i.r; )
                        i = i.p;
                    return t._t && (t._l = i = i ? i.n : t._t._f) ? md(0, "keys" == e ? i.k : "values" == e ? i.v : [i.k, i.v]) : (t._t = void 0,
                    md(1))
                }
                ), i ? "entries" : "values", !i, !0),
                pd(e);
            }
        }
          , a_ = function(t, e, i, r, o, n) {
            var s = sa[t]
              , a = s
              , l = o ? "set" : "add"
              , c = a && a.prototype
              , h = {}
              , u = function(t) {
                var e = c[t];
                Ma(c, t, "delete" == t || "has" == t ? function(t) {
                    return !(n && !da(t)) && e.call(this, 0 === t ? 0 : t)
                }
                : "get" == t ? function(t) {
                    return n && !da(t) ? void 0 : e.call(this, 0 === t ? 0 : t)
                }
                : "add" == t ? function(t) {
                    return e.call(this, 0 === t ? 0 : t),
                    this
                }
                : function(t, i) {
                    return e.call(this, 0 === t ? 0 : t, i),
                    this
                }
                );
            };
            if ("function" == typeof a && (n || c.forEach && !ca((function() {
                (new a).entries().next();
            }
            )))) {
                var d = new a
                  , f = d[l](n ? {} : -0, 1) != d
                  , _ = ca((function() {
                    d.has(1);
                }
                ))
                  , p = ku((function(t) {
                    new a(t);
                }
                ))
                  , m = !n && ca((function() {
                    for (var t = new a, e = 5; e--; )
                        t[l](e, e);
                    return !t.has(-0)
                }
                ));
                p || ((a = e((function(e, i) {
                    lf(e, a, t);
                    var r = qc(new s, e, a);
                    return null != i && cf(i, o, r[l], r),
                    r
                }
                ))).prototype = c,
                c.constructor = a),
                (_ || m) && (u("delete"),
                u("has"),
                o && u("get")),
                (m || f) && u(l),
                n && c.clear && delete c.clear;
            } else
                a = r.getConstructor(e, t, o, l),
                Rf(a.prototype, i),
                Ba.NEED = !0;
            return Oa(a, t),
            h[t] = a,
            Da(Da.G + Da.W + Da.F * (a != s), h),
            n || r.setStrong(a, t, o),
            a
        }
          , l_ = "Map";
        a_(l_, (function(t) {
            return function() {
                return t(this, arguments.length > 0 ? arguments[0] : void 0)
            }
        }
        ), {
            get: function(t) {
                var e = s_.getEntry(e_(this, l_), t);
                return e && e.v
            },
            set: function(t, e) {
                return s_.def(e_(this, l_), 0 === t ? 0 : t, e)
            }
        }, s_, !0),
        a_("Set", (function(t) {
            return function() {
                return t(this, arguments.length > 0 ? arguments[0] : void 0)
            }
        }
        ), {
            add: function(t) {
                return s_.def(e_(this, "Set"), t = 0 === t ? 0 : t, t)
            }
        }, s_);
        var c_ = Ba.getWeak
          , h_ = Zu(5)
          , u_ = Zu(6)
          , d_ = 0
          , f_ = function(t) {
            return t._l || (t._l = new __)
        }
          , __ = function() {
            this.a = [];
        }
          , p_ = function(t, e) {
            return h_(t.a, (function(t) {
                return t[0] === e
            }
            ))
        };
        __.prototype = {
            get: function(t) {
                var e = p_(this, t);
                if (e)
                    return e[1]
            },
            has: function(t) {
                return !!p_(this, t)
            },
            set: function(t, e) {
                var i = p_(this, t);
                i ? i[1] = e : this.a.push([t, e]);
            },
            delete: function(t) {
                var e = u_(this.a, (function(e) {
                    return e[0] === t
                }
                ));
                return ~e && this.a.splice(e, 1),
                !!~e
            }
        };
        var m_ = {
            getConstructor: function(t, e, i, r) {
                var o = t((function(t, n) {
                    lf(t, o, e, "_i"),
                    t._t = e,
                    t._i = d_++,
                    t._l = void 0,
                    null != n && cf(n, i, t[r], t);
                }
                ));
                return Rf(o.prototype, {
                    delete: function(t) {
                        if (!da(t))
                            return !1;
                        var i = c_(t);
                        return !0 === i ? f_(e_(this, e)).delete(t) : i && la(i, this._i) && delete i[this._i]
                    },
                    has: function(t) {
                        if (!da(t))
                            return !1;
                        var i = c_(t);
                        return !0 === i ? f_(e_(this, e)).has(t) : i && la(i, this._i)
                    }
                }),
                o
            },
            def: function(t, e, i) {
                var r = c_(fa(e), !0);
                return !0 === r ? f_(t).set(e, i) : r[t._i] = i,
                t
            },
            ufstore: f_
        };
        t.createCommonjsModule((function(t) {
            var e, i = Zu(0), r = e_, o = !sa.ActiveXObject && "ActiveXObject"in sa, n = "WeakMap", s = Ba.getWeak, a = Object.isExtensible, l = m_.ufstore, c = function(t) {
                return function() {
                    return t(this, arguments.length > 0 ? arguments[0] : void 0)
                }
            }, h = {
                get: function(t) {
                    if (da(t)) {
                        var e = s(t);
                        return !0 === e ? l(e_(this, n)).get(t) : e ? e[this._i] : void 0
                    }
                },
                set: function(t, e) {
                    return m_.def(e_(this, n), t, e)
                }
            }, u = t.exports = a_(n, c, h, m_, !0, !0);
            r && o && (e = m_.getConstructor(c, n),
            fc(e.prototype, h),
            Ba.NEED = !0,
            i(["delete", "has", "get", "set"], (function(t) {
                var i = u.prototype
                  , r = i[t];
                Ma(i, t, (function(i, o) {
                    if (da(i) && !a(i)) {
                        this._f || (this._f = new e);
                        var n = this._f[t](i, o);
                        return "set" == t ? this : n
                    }
                    return r.call(this, i, o)
                }
                ));
            }
            )));
        }
        ));
        var g_ = "WeakSet";
        a_(g_, (function(t) {
            return function() {
                return t(this, arguments.length > 0 ? arguments[0] : void 0)
            }
        }
        ), {
            add: function(t) {
                return m_.def(e_(this, g_), t, !0)
            }
        }, m_, !1, !0);
        for (var v_, y_ = Sa("typed_array"), b_ = Sa("view"), x_ = !(!sa.ArrayBuffer || !sa.DataView), w_ = x_, T_ = 0, E_ = "Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(","); T_ < 9; )
            (v_ = sa[E_[T_++]]) ? (wa(v_.prototype, y_, !0),
            wa(v_.prototype, b_, !0)) : w_ = !1;
        var S_ = {
            ABV: x_,
            CONSTR: w_,
            TYPED: y_,
            VIEW: b_
        }
          , C_ = function(t) {
            if (void 0 === t)
                return 0;
            var e = Xa(t)
              , i = Ka(e);
            if (e !== i)
                throw RangeError("Wrong length!");
            return i
        }
          , A_ = t.createCommonjsModule((function(t, e) {
            var i = bl.f
              , r = ba.f
              , o = "ArrayBuffer"
              , n = "DataView"
              , s = "Wrong index!"
              , a = sa.ArrayBuffer
              , l = sa.DataView
              , c = sa.Math
              , h = sa.RangeError
              , u = sa.Infinity
              , d = a
              , f = c.abs
              , _ = c.pow
              , p = c.floor
              , m = c.log
              , g = c.LN2
              , v = "buffer"
              , y = "byteLength"
              , b = "byteOffset"
              , x = ha ? "_b" : v
              , w = ha ? "_l" : y
              , T = ha ? "_o" : b;
            function E(t, e, i) {
                var r, o, n, s = new Array(i), a = 8 * i - e - 1, l = (1 << a) - 1, c = l >> 1, h = 23 === e ? _(2, -24) - _(2, -77) : 0, d = 0, v = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
                for ((t = f(t)) != t || t === u ? (o = t != t ? 1 : 0,
                r = l) : (r = p(m(t) / g),
                t * (n = _(2, -r)) < 1 && (r--,
                n *= 2),
                (t += r + c >= 1 ? h / n : h * _(2, 1 - c)) * n >= 2 && (r++,
                n /= 2),
                r + c >= l ? (o = 0,
                r = l) : r + c >= 1 ? (o = (t * n - 1) * _(2, e),
                r += c) : (o = t * _(2, c - 1) * _(2, e),
                r = 0)); e >= 8; s[d++] = 255 & o,
                o /= 256,
                e -= 8)
                    ;
                for (r = r << e | o,
                a += e; a > 0; s[d++] = 255 & r,
                r /= 256,
                a -= 8)
                    ;
                return s[--d] |= 128 * v,
                s
            }
            function S(t, e, i) {
                var r, o = 8 * i - e - 1, n = (1 << o) - 1, s = n >> 1, a = o - 7, l = i - 1, c = t[l--], h = 127 & c;
                for (c >>= 7; a > 0; h = 256 * h + t[l],
                l--,
                a -= 8)
                    ;
                for (r = h & (1 << -a) - 1,
                h >>= -a,
                a += e; a > 0; r = 256 * r + t[l],
                l--,
                a -= 8)
                    ;
                if (0 === h)
                    h = 1 - s;
                else {
                    if (h === n)
                        return r ? NaN : c ? -u : u;
                    r += _(2, e),
                    h -= s;
                }
                return (c ? -1 : 1) * r * _(2, h - e)
            }
            function C(t) {
                return t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0]
            }
            function A(t) {
                return [255 & t]
            }
            function M(t) {
                return [255 & t, t >> 8 & 255]
            }
            function I(t) {
                return [255 & t, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255]
            }
            function z(t) {
                return E(t, 52, 8)
            }
            function P(t) {
                return E(t, 23, 4)
            }
            function D(t, e, i) {
                r(t.prototype, e, {
                    get: function() {
                        return this[i]
                    }
                });
            }
            function B(t, e, i, r) {
                var o = C_(+i);
                if (o + e > t[w])
                    throw h(s);
                var n = o + t[T]
                  , a = t[x]._b.slice(n, n + e);
                return r ? a : a.reverse()
            }
            function L(t, e, i, r, o, n) {
                var a = C_(+i);
                if (a + e > t[w])
                    throw h(s);
                for (var l = t[x]._b, c = a + t[T], u = r(+o), d = 0; d < e; d++)
                    l[c + d] = u[n ? d : e - d - 1];
            }
            if (S_.ABV) {
                if (!ca((function() {
                    a(1);
                }
                )) || !ca((function() {
                    new a(-1);
                }
                )) || ca((function() {
                    return new a,
                    new a(1.5),
                    new a(NaN),
                    a.name != o
                }
                ))) {
                    for (var R, k = (a = function(t) {
                        return lf(this, a),
                        new d(C_(t))
                    }
                    ).prototype = d.prototype, O = i(d), F = 0; O.length > F; )
                        (R = O[F++])in a || wa(a, R, d[R]);
                    k.constructor = a;
                }
                var U = new l(new a(2))
                  , N = l.prototype.setInt8;
                U.setInt8(0, 2147483648),
                U.setInt8(1, 2147483649),
                !U.getInt8(0) && U.getInt8(1) || Rf(l.prototype, {
                    setInt8: function(t, e) {
                        N.call(this, t, e << 24 >> 24);
                    },
                    setUint8: function(t, e) {
                        N.call(this, t, e << 24 >> 24);
                    }
                }, !0);
            } else
                a = function(t) {
                    lf(this, a, o);
                    var e = C_(t);
                    this._b = ad.call(new Array(e), 0),
                    this[w] = e;
                }
                ,
                l = function(t, e, i) {
                    lf(this, l, n),
                    lf(t, a, n);
                    var r = t[w]
                      , o = Xa(e);
                    if (o < 0 || o > r)
                        throw h("Wrong offset!");
                    if (o + (i = void 0 === i ? r - o : Ka(i)) > r)
                        throw h("Wrong length!");
                    this[x] = t,
                    this[T] = o,
                    this[w] = i;
                }
                ,
                ha && (D(a, y, "_l"),
                D(l, v, "_b"),
                D(l, y, "_l"),
                D(l, b, "_o")),
                Rf(l.prototype, {
                    getInt8: function(t) {
                        return B(this, 1, t)[0] << 24 >> 24
                    },
                    getUint8: function(t) {
                        return B(this, 1, t)[0]
                    },
                    getInt16: function(t) {
                        var e = B(this, 2, t, arguments[1]);
                        return (e[1] << 8 | e[0]) << 16 >> 16
                    },
                    getUint16: function(t) {
                        var e = B(this, 2, t, arguments[1]);
                        return e[1] << 8 | e[0]
                    },
                    getInt32: function(t) {
                        return C(B(this, 4, t, arguments[1]))
                    },
                    getUint32: function(t) {
                        return C(B(this, 4, t, arguments[1])) >>> 0
                    },
                    getFloat32: function(t) {
                        return S(B(this, 4, t, arguments[1]), 23, 4)
                    },
                    getFloat64: function(t) {
                        return S(B(this, 8, t, arguments[1]), 52, 8)
                    },
                    setInt8: function(t, e) {
                        L(this, 1, t, A, e);
                    },
                    setUint8: function(t, e) {
                        L(this, 1, t, A, e);
                    },
                    setInt16: function(t, e) {
                        L(this, 2, t, M, e, arguments[2]);
                    },
                    setUint16: function(t, e) {
                        L(this, 2, t, M, e, arguments[2]);
                    },
                    setInt32: function(t, e) {
                        L(this, 4, t, I, e, arguments[2]);
                    },
                    setUint32: function(t, e) {
                        L(this, 4, t, I, e, arguments[2]);
                    },
                    setFloat32: function(t, e) {
                        L(this, 4, t, P, e, arguments[2]);
                    },
                    setFloat64: function(t, e) {
                        L(this, 8, t, z, e, arguments[2]);
                    }
                });
            Oa(a, o),
            Oa(l, n),
            wa(l.prototype, S_.VIEW, !0),
            e.ArrayBuffer = a,
            e.DataView = l;
        }
        ))
          , M_ = sa.ArrayBuffer
          , I_ = A_.ArrayBuffer
          , z_ = A_.DataView
          , P_ = S_.ABV && M_.isView
          , D_ = I_.prototype.slice
          , B_ = S_.VIEW
          , L_ = "ArrayBuffer";
        Da(Da.G + Da.W + Da.F * (M_ !== I_), {
            ArrayBuffer: I_
        }),
        Da(Da.S + Da.F * !S_.CONSTR, L_, {
            isView: function(t) {
                return P_ && P_(t) || da(t) && B_ in t
            }
        }),
        Da(Da.P + Da.U + Da.F * ca((function() {
            return !new I_(2).slice(1, void 0).byteLength
        }
        )), L_, {
            slice: function(t, e) {
                if (void 0 !== D_ && void 0 === e)
                    return D_.call(fa(this), t);
                for (var i = fa(this).byteLength, r = Qa(t, i), o = Qa(void 0 === e ? i : e, i), n = new (Qd(this, I_))(Ka(o - r)), s = new z_(this), a = new z_(n), l = 0; r < o; )
                    a.setUint8(l++, s.getUint8(r++));
                return n
            }
        }),
        pd(L_),
        Da(Da.G + Da.W + Da.F * !S_.ABV, {
            DataView: A_.DataView
        });
        var R_ = t.createCommonjsModule((function(t) {
            if (ha) {
                var e = sa
                  , i = ca
                  , r = Da
                  , o = S_
                  , n = za
                  , s = lf
                  , a = xa
                  , l = wa
                  , c = Rf
                  , h = Xa
                  , u = Ka
                  , d = C_
                  , f = Qa
                  , _ = va
                  , p = la
                  , m = yc
                  , g = da
                  , v = ul
                  , y = Iu
                  , b = vl
                  , x = lc
                  , w = bl.f
                  , T = Du
                  , E = Sa
                  , S = La
                  , C = Zu
                  , A = tl
                  , M = Qd
                  , I = gd
                  , z = Wh
                  , P = ku
                  , D = pd
                  , B = ad
                  , L = rd
                  , R = ba
                  , k = Cl
                  , O = R.f
                  , F = k.f
                  , U = e.RangeError
                  , N = e.TypeError
                  , j = e.Uint8Array
                  , G = "ArrayBuffer"
                  , V = "SharedArrayBuffer"
                  , Z = "BYTES_PER_ELEMENT"
                  , W = Array.prototype
                  , q = A_.ArrayBuffer
                  , H = A_.DataView
                  , X = C(0)
                  , Y = C(2)
                  , K = C(3)
                  , J = C(4)
                  , $ = C(5)
                  , Q = C(6)
                  , tt = A(!0)
                  , et = A(!1)
                  , it = I.values
                  , rt = I.keys
                  , ot = I.entries
                  , nt = W.lastIndexOf
                  , st = W.reduce
                  , at = W.reduceRight
                  , lt = W.join
                  , ct = W.sort
                  , ht = W.slice
                  , ut = W.toString
                  , dt = W.toLocaleString
                  , ft = S("iterator")
                  , _t = S("toStringTag")
                  , pt = E("typed_constructor")
                  , mt = E("def_constructor")
                  , gt = o.CONSTR
                  , vt = o.TYPED
                  , yt = o.VIEW
                  , bt = "Wrong length!"
                  , xt = C(1, (function(t, e) {
                    return Ct(M(t, t[mt]), e)
                }
                ))
                  , wt = i((function() {
                    return 1 === new j(new Uint16Array([1]).buffer)[0]
                }
                ))
                  , Tt = !!j && !!j.prototype.set && i((function() {
                    new j(1).set({});
                }
                ))
                  , Et = function(t, e) {
                    var i = h(t);
                    if (i < 0 || i % e)
                        throw U("Wrong offset!");
                    return i
                }
                  , St = function(t) {
                    if (g(t) && vt in t)
                        return t;
                    throw N(t + " is not a typed array!")
                }
                  , Ct = function(t, e) {
                    if (!g(t) || !(pt in t))
                        throw N("It is not a typed array constructor!");
                    return new t(e)
                }
                  , At = function(t, e) {
                    return Mt(M(t, t[mt]), e)
                }
                  , Mt = function(t, e) {
                    for (var i = 0, r = e.length, o = Ct(t, r); r > i; )
                        o[i] = e[i++];
                    return o
                }
                  , It = function(t, e, i) {
                    O(t, e, {
                        get: function() {
                            return this._d[i]
                        }
                    });
                }
                  , zt = function(t) {
                    var e, i, r, o, s, a, l = v(t), c = arguments.length, h = c > 1 ? arguments[1] : void 0, d = void 0 !== h, f = T(l);
                    if (null != f && !y(f)) {
                        for (a = f.call(l),
                        r = [],
                        e = 0; !(s = a.next()).done; e++)
                            r.push(s.value);
                        l = r;
                    }
                    for (d && c > 2 && (h = n(h, arguments[2], 2)),
                    e = 0,
                    i = u(l.length),
                    o = Ct(this, i); i > e; e++)
                        o[e] = d ? h(l[e], e) : l[e];
                    return o
                }
                  , Pt = function() {
                    for (var t = 0, e = arguments.length, i = Ct(this, e); e > t; )
                        i[t] = arguments[t++];
                    return i
                }
                  , Dt = !!j && i((function() {
                    dt.call(new j(1));
                }
                ))
                  , Bt = function() {
                    return dt.apply(Dt ? ht.call(St(this)) : St(this), arguments)
                }
                  , Lt = {
                    copyWithin: function(t, e) {
                        return L.call(St(this), t, e, arguments.length > 2 ? arguments[2] : void 0)
                    },
                    every: function(t) {
                        return J(St(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    fill: function(t) {
                        return B.apply(St(this), arguments)
                    },
                    filter: function(t) {
                        return At(this, Y(St(this), t, arguments.length > 1 ? arguments[1] : void 0))
                    },
                    find: function(t) {
                        return $(St(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    findIndex: function(t) {
                        return Q(St(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    forEach: function(t) {
                        X(St(this), t, arguments.length > 1 ? arguments[1] : void 0);
                    },
                    indexOf: function(t) {
                        return et(St(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    includes: function(t) {
                        return tt(St(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    join: function(t) {
                        return lt.apply(St(this), arguments)
                    },
                    lastIndexOf: function(t) {
                        return nt.apply(St(this), arguments)
                    },
                    map: function(t) {
                        return xt(St(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    reduce: function(t) {
                        return st.apply(St(this), arguments)
                    },
                    reduceRight: function(t) {
                        return at.apply(St(this), arguments)
                    },
                    reverse: function() {
                        for (var t, e = this, i = St(e).length, r = Math.floor(i / 2), o = 0; o < r; )
                            t = e[o],
                            e[o++] = e[--i],
                            e[i] = t;
                        return e
                    },
                    some: function(t) {
                        return K(St(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    sort: function(t) {
                        return ct.call(St(this), t)
                    },
                    subarray: function(t, e) {
                        var i = St(this)
                          , r = i.length
                          , o = f(t, r);
                        return new (M(i, i[mt]))(i.buffer,i.byteOffset + o * i.BYTES_PER_ELEMENT,u((void 0 === e ? r : f(e, r)) - o))
                    }
                }
                  , Rt = function(t, e) {
                    return At(this, ht.call(St(this), t, e))
                }
                  , kt = function(t) {
                    St(this);
                    var e = Et(arguments[1], 1)
                      , i = this.length
                      , r = v(t)
                      , o = u(r.length)
                      , n = 0;
                    if (o + e > i)
                        throw U(bt);
                    for (; n < o; )
                        this[e + n] = r[n++];
                }
                  , Ot = {
                    entries: function() {
                        return ot.call(St(this))
                    },
                    keys: function() {
                        return rt.call(St(this))
                    },
                    values: function() {
                        return it.call(St(this))
                    }
                }
                  , Ft = function(t, e) {
                    return g(t) && t[vt] && "symbol" != typeof e && e in t && String(+e) == String(e)
                }
                  , Ut = function(t, e) {
                    return Ft(t, e = _(e, !0)) ? a(2, t[e]) : F(t, e)
                }
                  , Nt = function(t, e, i) {
                    return !(Ft(t, e = _(e, !0)) && g(i) && p(i, "value")) || p(i, "get") || p(i, "set") || i.configurable || p(i, "writable") && !i.writable || p(i, "enumerable") && !i.enumerable ? O(t, e, i) : (t[e] = i.value,
                    t)
                };
                gt || (k.f = Ut,
                R.f = Nt),
                r(r.S + r.F * !gt, "Object", {
                    getOwnPropertyDescriptor: Ut,
                    defineProperty: Nt
                }),
                i((function() {
                    ut.call({});
                }
                )) && (ut = dt = function() {
                    return lt.call(this)
                }
                );
                var jt = c({}, Lt);
                c(jt, Ot),
                l(jt, ft, Ot.values),
                c(jt, {
                    slice: Rt,
                    set: kt,
                    constructor: function() {},
                    toString: ut,
                    toLocaleString: Bt
                }),
                It(jt, "buffer", "b"),
                It(jt, "byteOffset", "o"),
                It(jt, "byteLength", "l"),
                It(jt, "length", "e"),
                O(jt, _t, {
                    get: function() {
                        return this[vt]
                    }
                }),
                t.exports = function(t, n, a, c) {
                    var h = t + ((c = !!c) ? "Clamped" : "") + "Array"
                      , f = "get" + t
                      , _ = "set" + t
                      , p = e[h]
                      , v = p || {}
                      , y = p && x(p)
                      , T = {}
                      , E = p && p.prototype
                      , S = function(t, e) {
                        O(t, e, {
                            get: function() {
                                return function(t, e) {
                                    var i = t._d;
                                    return i.v[f](e * n + i.o, wt)
                                }(this, e)
                            },
                            set: function(t) {
                                return function(t, e, i) {
                                    var r = t._d;
                                    c && (i = (i = Math.round(i)) < 0 ? 0 : i > 255 ? 255 : 255 & i),
                                    r.v[_](e * n + r.o, i, wt);
                                }(this, e, t)
                            },
                            enumerable: !0
                        });
                    };
                    p && o.ABV ? i((function() {
                        p(1);
                    }
                    )) && i((function() {
                        new p(-1);
                    }
                    )) && P((function(t) {
                        new p,
                        new p(null),
                        new p(1.5),
                        new p(t);
                    }
                    ), !0) || (p = a((function(t, e, i, r) {
                        var o;
                        return s(t, p, h),
                        g(e) ? e instanceof q || (o = m(e)) == G || o == V ? void 0 !== r ? new v(e,Et(i, n),r) : void 0 !== i ? new v(e,Et(i, n)) : new v(e) : vt in e ? Mt(p, e) : zt.call(p, e) : new v(d(e))
                    }
                    )),
                    X(y !== Function.prototype ? w(v).concat(w(y)) : w(v), (function(t) {
                        t in p || l(p, t, v[t]);
                    }
                    )),
                    p.prototype = E,
                    E.constructor = p) : (p = a((function(t, e, i, r) {
                        s(t, p, h, "_d");
                        var o, a, c, f, _ = 0, v = 0;
                        if (g(e)) {
                            if (!(e instanceof q || (f = m(e)) == G || f == V))
                                return vt in e ? Mt(p, e) : zt.call(p, e);
                            o = e,
                            v = Et(i, n);
                            var y = e.byteLength;
                            if (void 0 === r) {
                                if (y % n)
                                    throw U(bt);
                                if ((a = y - v) < 0)
                                    throw U(bt)
                            } else if ((a = u(r) * n) + v > y)
                                throw U(bt);
                            c = a / n;
                        } else
                            c = d(e),
                            o = new q(a = c * n);
                        for (l(t, "_d", {
                            b: o,
                            o: v,
                            l: a,
                            e: c,
                            v: new H(o)
                        }); _ < c; )
                            S(t, _++);
                    }
                    )),
                    E = p.prototype = b(jt),
                    l(E, "constructor", p));
                    var C = E[ft]
                      , A = !!C && ("values" == C.name || null == C.name)
                      , M = Ot.values;
                    l(p, pt, !0),
                    l(E, vt, h),
                    l(E, yt, !0),
                    l(E, mt, p),
                    (c ? new p(1)[_t] == h : _t in E) || O(E, _t, {
                        get: function() {
                            return h
                        }
                    }),
                    T[h] = p,
                    r(r.G + r.W + r.F * (p != v), T),
                    r(r.S, h, {
                        BYTES_PER_ELEMENT: n
                    }),
                    r(r.S + r.F * i((function() {
                        v.of.call(p, 1);
                    }
                    )), h, {
                        from: zt,
                        of: Pt
                    }),
                    Z in E || l(E, Z, n),
                    r(r.P, h, Lt),
                    D(h),
                    r(r.P + r.F * Tt, h, {
                        set: kt
                    }),
                    r(r.P + r.F * !A, h, Ot),
                    E.toString != ut && (E.toString = ut),
                    r(r.P + r.F * i((function() {
                        new p(1).slice();
                    }
                    )), h, {
                        slice: Rt
                    }),
                    r(r.P + r.F * (i((function() {
                        return [1, 2].toLocaleString() != new p([1, 2]).toLocaleString()
                    }
                    )) || !i((function() {
                        E.toLocaleString.call([1, 2]);
                    }
                    ))), h, {
                        toLocaleString: Bt
                    }),
                    z[h] = A ? C : M,
                    A || l(E, ft, M);
                }
                ;
            } else
                t.exports = function() {}
                ;
        }
        ));
        R_("Int8", 1, (function(t) {
            return function(e, i, r) {
                return t(this, e, i, r)
            }
        }
        )),
        R_("Uint8", 1, (function(t) {
            return function(e, i, r) {
                return t(this, e, i, r)
            }
        }
        )),
        R_("Uint8", 1, (function(t) {
            return function(e, i, r) {
                return t(this, e, i, r)
            }
        }
        ), !0),
        R_("Int16", 2, (function(t) {
            return function(e, i, r) {
                return t(this, e, i, r)
            }
        }
        )),
        R_("Uint16", 2, (function(t) {
            return function(e, i, r) {
                return t(this, e, i, r)
            }
        }
        )),
        R_("Int32", 4, (function(t) {
            return function(e, i, r) {
                return t(this, e, i, r)
            }
        }
        )),
        R_("Uint32", 4, (function(t) {
            return function(e, i, r) {
                return t(this, e, i, r)
            }
        }
        )),
        R_("Float32", 4, (function(t) {
            return function(e, i, r) {
                return t(this, e, i, r)
            }
        }
        )),
        R_("Float64", 8, (function(t) {
            return function(e, i, r) {
                return t(this, e, i, r)
            }
        }
        ));
        var k_ = (sa.Reflect || {}).apply
          , O_ = Function.apply;
        Da(Da.S + Da.F * !ca((function() {
            k_((function() {}
            ));
        }
        )), "Reflect", {
            apply: function(t, e, i) {
                var r = Ia(t)
                  , o = fa(i);
                return k_ ? k_(r, e, o) : O_.call(r, e, o)
            }
        });
        var F_ = (sa.Reflect || {}).construct
          , U_ = ca((function() {
            function t() {}
            return !(F_((function() {}
            ), [], t)instanceof t)
        }
        ))
          , N_ = !ca((function() {
            F_((function() {}
            ));
        }
        ));
        Da(Da.S + Da.F * (U_ || N_), "Reflect", {
            construct: function(t, e) {
                Ia(t),
                fa(e);
                var i = arguments.length < 3 ? t : Ia(arguments[2]);
                if (N_ && !U_)
                    return F_(t, e, i);
                if (t == i) {
                    switch (e.length) {
                    case 0:
                        return new t;
                    case 1:
                        return new t(e[0]);
                    case 2:
                        return new t(e[0],e[1]);
                    case 3:
                        return new t(e[0],e[1],e[2]);
                    case 4:
                        return new t(e[0],e[1],e[2],e[3])
                    }
                    var r = [null];
                    return r.push.apply(r, e),
                    new (Sc.apply(t, r))
                }
                var o = i.prototype
                  , n = vl(da(o) ? o : Object.prototype)
                  , s = Function.apply.call(t, n, e);
                return da(s) ? s : n
            }
        }),
        Da(Da.S + Da.F * ca((function() {
            Reflect.defineProperty(ba.f({}, 1, {
                value: 1
            }), 1, {
                value: 2
            });
        }
        )), "Reflect", {
            defineProperty: function(t, e, i) {
                fa(t),
                e = va(e, !0),
                fa(i);
                try {
                    return ba.f(t, e, i),
                    !0
                } catch (t) {
                    return !1
                }
            }
        });
        var j_ = Cl.f;
        Da(Da.S, "Reflect", {
            deleteProperty: function(t, e) {
                var i = j_(fa(t), e);
                return !(i && !i.configurable) && delete t[e]
            }
        });
        var G_ = function(t) {
            this._t = fa(t),
            this._i = 0;
            var e, i = this._k = [];
            for (e in t)
                i.push(e);
        };
        Hh(G_, "Object", (function() {
            var t, e = this, i = e._k;
            do {
                if (e._i >= i.length)
                    return {
                        value: void 0,
                        done: !0
                    }
            } while (!((t = i[e._i++])in e._t));
            return {
                value: t,
                done: !1
            }
        }
        )),
        Da(Da.S, "Reflect", {
            enumerate: function(t) {
                return new G_(t)
            }
        }),
        Da(Da.S, "Reflect", {
            get: function t(e, i) {
                var r, o, n = arguments.length < 3 ? e : arguments[2];
                return fa(e) === n ? e[i] : (r = Cl.f(e, i)) ? la(r, "value") ? r.value : void 0 !== r.get ? r.get.call(n) : void 0 : da(o = lc(e)) ? t(o, i, n) : void 0
            }
        }),
        Da(Da.S, "Reflect", {
            getOwnPropertyDescriptor: function(t, e) {
                return Cl.f(fa(t), e)
            }
        }),
        Da(Da.S, "Reflect", {
            getPrototypeOf: function(t) {
                return lc(fa(t))
            }
        }),
        Da(Da.S, "Reflect", {
            has: function(t, e) {
                return e in t
            }
        });
        var V_ = Object.isExtensible;
        Da(Da.S, "Reflect", {
            isExtensible: function(t) {
                return fa(t),
                !V_ || V_(t)
            }
        });
        var Z_ = sa.Reflect
          , W_ = Z_ && Z_.ownKeys || function(t) {
            var e = bl.f(fa(t))
              , i = ll.f;
            return i ? e.concat(i(t)) : e
        }
        ;
        Da(Da.S, "Reflect", {
            ownKeys: W_
        });
        var q_ = Object.preventExtensions;
        Da(Da.S, "Reflect", {
            preventExtensions: function(t) {
                fa(t);
                try {
                    return q_ && q_(t),
                    !0
                } catch (t) {
                    return !1
                }
            }
        }),
        Da(Da.S, "Reflect", {
            set: function t(e, i, r) {
                var o, n, s = arguments.length < 4 ? e : arguments[3], a = Cl.f(fa(e), i);
                if (!a) {
                    if (da(n = lc(e)))
                        return t(n, i, r, s);
                    a = xa(0);
                }
                if (la(a, "value")) {
                    if (!1 === a.writable || !da(s))
                        return !1;
                    if (o = Cl.f(s, i)) {
                        if (o.get || o.set || !1 === o.writable)
                            return !1;
                        o.value = r,
                        ba.f(s, i, o);
                    } else
                        ba.f(s, i, xa(0, r));
                    return !0
                }
                return void 0 !== a.set && (a.set.call(s, r),
                !0)
            }
        }),
        mc && Da(Da.S, "Reflect", {
            setPrototypeOf: function(t, e) {
                mc.check(t, e);
                try {
                    return mc.set(t, e),
                    !0
                } catch (t) {
                    return !1
                }
            }
        });
        var H_ = tl(!0);
        Da(Da.P, "Array", {
            includes: function(t) {
                return H_(this, t, arguments.length > 1 ? arguments[1] : void 0)
            }
        }),
        sd("includes");
        var X_ = La("isConcatSpreadable")
          , Y_ = function t(e, i, r, o, n, s, a, l) {
            for (var c, h, u = n, d = 0, f = !!a && za(a, l, 3); d < o; ) {
                if (d in r) {
                    if (c = f ? f(r[d], d, i) : r[d],
                    h = !1,
                    da(c) && (h = void 0 !== (h = c[X_]) ? !!h : hl(c)),
                    h && s > 0)
                        u = t(e, i, c, Ka(c.length), u, s - 1) - 1;
                    else {
                        if (u >= 9007199254740991)
                            throw TypeError();
                        e[u] = c;
                    }
                    u++;
                }
                d++;
            }
            return u
        };
        Da(Da.P, "Array", {
            flatMap: function(t) {
                var e, i, r = ul(this);
                return Ia(t),
                e = Ka(r.length),
                i = Vu(r, 0),
                Y_(i, r, r, e, 0, 1, t, arguments[1]),
                i
            }
        }),
        sd("flatMap");
        var K_ = function(t, e, i, r) {
            var o = String(Za(t))
              , n = o.length
              , s = void 0 === i ? " " : String(i)
              , a = Ka(e);
            if (a <= n || "" == s)
                return o;
            var l = a - n
              , c = lh.call(s, Math.ceil(l / s.length));
            return c.length > l && (c = c.slice(0, l)),
            r ? c + o : o + c
        }
          , J_ = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(Bf);
        Da(Da.P + Da.F * J_, "String", {
            padStart: function(t) {
                return K_(this, t, arguments.length > 1 ? arguments[1] : void 0, !0)
            }
        });
        var $_ = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(Bf);
        Da(Da.P + Da.F * $_, "String", {
            padEnd: function(t) {
                return K_(this, t, arguments.length > 1 ? arguments[1] : void 0, !1)
            }
        }),
        Oc("trimLeft", (function(t) {
            return function() {
                return t(this, 1)
            }
        }
        ), "trimStart"),
        Oc("trimRight", (function(t) {
            return function() {
                return t(this, 2)
            }
        }
        ), "trimEnd"),
        Na("asyncIterator"),
        Fa.f("asyncIterator"),
        Da(Da.S, "Object", {
            getOwnPropertyDescriptors: function(t) {
                for (var e, i, r = Wa(t), o = Cl.f, n = W_(r), s = {}, a = 0; n.length > a; )
                    void 0 !== (i = o(r, e = n[a++])) && zu(s, e, i);
                return s
            }
        });
        var Q_ = cl.f
          , tp = function(t) {
            return function(e) {
                for (var i, r = Wa(e), o = al(r), n = o.length, s = 0, a = []; n > s; )
                    i = o[s++],
                    ha && !Q_.call(r, i) || a.push(t ? [i, r[i]] : r[i]);
                return a
            }
        }
          , ep = tp(!1);
        Da(Da.S, "Object", {
            values: function(t) {
                return ep(t)
            }
        });
        var ip = tp(!0);
        Da(Da.S, "Object", {
            entries: function(t) {
                return ip(t)
            }
        }),
        Da(Da.P + Da.R, "Promise", {
            finally: function(t) {
                var e = Qd(this, ua.Promise || sa.Promise)
                  , i = "function" == typeof t;
                return this.then(i ? function(i) {
                    return Lf(e, t()).then((function() {
                        return i
                    }
                    ))
                }
                : t, i ? function(i) {
                    return Lf(e, t()).then((function() {
                        throw i
                    }
                    ))
                }
                : t)
            }
        });
        var rp = [].slice
          , op = /MSIE .\./.test(Bf)
          , np = function(t) {
            return function(e, i) {
                var r = arguments.length > 2
                  , o = !!r && rp.call(arguments, 2);
                return t(r ? function() {
                    ("function" == typeof e ? e : Function(e)).apply(this, o);
                }
                : e, i)
            }
        };
        Da(Da.G + Da.B + Da.F * op, {
            setTimeout: np(sa.setTimeout),
            setInterval: np(sa.setInterval)
        }),
        Da(Da.G + Da.B, {
            setImmediate: yf.set,
            clearImmediate: yf.clear
        });
        for (var sp = La("iterator"), ap = La("toStringTag"), lp = Wh.Array, cp = {
            CSSRuleList: !0,
            CSSStyleDeclaration: !1,
            CSSValueList: !1,
            ClientRectList: !1,
            DOMRectList: !1,
            DOMStringList: !1,
            DOMTokenList: !0,
            DataTransferItemList: !1,
            FileList: !1,
            HTMLAllCollection: !1,
            HTMLCollection: !1,
            HTMLFormElement: !1,
            HTMLSelectElement: !1,
            MediaList: !0,
            MimeTypeArray: !1,
            NamedNodeMap: !1,
            NodeList: !0,
            PaintRequestList: !1,
            Plugin: !1,
            PluginArray: !1,
            SVGLengthList: !1,
            SVGNumberList: !1,
            SVGPathSegList: !1,
            SVGPointList: !1,
            SVGStringList: !1,
            SVGTransformList: !1,
            SourceBufferList: !1,
            StyleSheetList: !0,
            TextTrackCueList: !1,
            TextTrackList: !1,
            TouchList: !1
        }, hp = al(cp), up = 0; up < hp.length; up++) {
            var dp, fp = hp[up], _p = cp[fp], pp = sa[fp], mp = pp && pp.prototype;
            if (mp && (mp[sp] || wa(mp, sp, lp),
            mp[ap] || wa(mp, ap, fp),
            Wh[fp] = lp,
            _p))
                for (dp in gd)
                    mp[dp] || Ma(mp, dp, gd[dp], !0);
        }
        t.createCommonjsModule((function(t) {
            var e = function(t) {
                var e, i = Object.prototype, r = i.hasOwnProperty, o = "function" == typeof Symbol ? Symbol : {}, n = o.iterator || "@@iterator", s = o.asyncIterator || "@@asyncIterator", a = o.toStringTag || "@@toStringTag";
                function l(t, e, i) {
                    return Object.defineProperty(t, e, {
                        value: i,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }),
                    t[e]
                }
                try {
                    l({}, "");
                } catch (t) {
                    l = function(t, e, i) {
                        return t[e] = i
                    }
                    ;
                }
                function c(t, e, i, r) {
                    var o = Object.create((e && e.prototype instanceof m ? e : m).prototype)
                      , n = new M(r || []);
                    return o._invoke = function(t, e, i) {
                        var r = u;
                        return function(o, n) {
                            if (r === f)
                                throw new Error("Generator is already running");
                            if (r === _) {
                                if ("throw" === o)
                                    throw n;
                                return z()
                            }
                            for (i.method = o,
                            i.arg = n; ; ) {
                                var s = i.delegate;
                                if (s) {
                                    var a = S(s, i);
                                    if (a) {
                                        if (a === p)
                                            continue;
                                        return a
                                    }
                                }
                                if ("next" === i.method)
                                    i.sent = i._sent = i.arg;
                                else if ("throw" === i.method) {
                                    if (r === u)
                                        throw r = _,
                                        i.arg;
                                    i.dispatchException(i.arg);
                                } else
                                    "return" === i.method && i.abrupt("return", i.arg);
                                r = f;
                                var l = h(t, e, i);
                                if ("normal" === l.type) {
                                    if (r = i.done ? _ : d,
                                    l.arg === p)
                                        continue;
                                    return {
                                        value: l.arg,
                                        done: i.done
                                    }
                                }
                                "throw" === l.type && (r = _,
                                i.method = "throw",
                                i.arg = l.arg);
                            }
                        }
                    }(t, i, n),
                    o
                }
                function h(t, e, i) {
                    try {
                        return {
                            type: "normal",
                            arg: t.call(e, i)
                        }
                    } catch (t) {
                        return {
                            type: "throw",
                            arg: t
                        }
                    }
                }
                t.wrap = c;
                var u = "suspendedStart"
                  , d = "suspendedYield"
                  , f = "executing"
                  , _ = "completed"
                  , p = {};
                function m() {}
                function g() {}
                function v() {}
                var y = {};
                y[n] = function() {
                    return this
                }
                ;
                var b = Object.getPrototypeOf
                  , x = b && b(b(I([])));
                x && x !== i && r.call(x, n) && (y = x);
                var w = v.prototype = m.prototype = Object.create(y);
                function T(t) {
                    ["next", "throw", "return"].forEach((function(e) {
                        l(t, e, (function(t) {
                            return this._invoke(e, t)
                        }
                        ));
                    }
                    ));
                }
                function E(t, e) {
                    function i(o, n, s, a) {
                        var l = h(t[o], t, n);
                        if ("throw" !== l.type) {
                            var c = l.arg
                              , u = c.value;
                            return u && "object" == typeof u && r.call(u, "__await") ? e.resolve(u.__await).then((function(t) {
                                i("next", t, s, a);
                            }
                            ), (function(t) {
                                i("throw", t, s, a);
                            }
                            )) : e.resolve(u).then((function(t) {
                                c.value = t,
                                s(c);
                            }
                            ), (function(t) {
                                return i("throw", t, s, a)
                            }
                            ))
                        }
                        a(l.arg);
                    }
                    var o;
                    this._invoke = function(t, r) {
                        function n() {
                            return new e((function(e, o) {
                                i(t, r, e, o);
                            }
                            ))
                        }
                        return o = o ? o.then(n, n) : n()
                    }
                    ;
                }
                function S(t, i) {
                    var r = t.iterator[i.method];
                    if (r === e) {
                        if (i.delegate = null,
                        "throw" === i.method) {
                            if (t.iterator.return && (i.method = "return",
                            i.arg = e,
                            S(t, i),
                            "throw" === i.method))
                                return p;
                            i.method = "throw",
                            i.arg = new TypeError("The iterator does not provide a 'throw' method");
                        }
                        return p
                    }
                    var o = h(r, t.iterator, i.arg);
                    if ("throw" === o.type)
                        return i.method = "throw",
                        i.arg = o.arg,
                        i.delegate = null,
                        p;
                    var n = o.arg;
                    return n ? n.done ? (i[t.resultName] = n.value,
                    i.next = t.nextLoc,
                    "return" !== i.method && (i.method = "next",
                    i.arg = e),
                    i.delegate = null,
                    p) : n : (i.method = "throw",
                    i.arg = new TypeError("iterator result is not an object"),
                    i.delegate = null,
                    p)
                }
                function C(t) {
                    var e = {
                        tryLoc: t[0]
                    };
                    1 in t && (e.catchLoc = t[1]),
                    2 in t && (e.finallyLoc = t[2],
                    e.afterLoc = t[3]),
                    this.tryEntries.push(e);
                }
                function A(t) {
                    var e = t.completion || {};
                    e.type = "normal",
                    delete e.arg,
                    t.completion = e;
                }
                function M(t) {
                    this.tryEntries = [{
                        tryLoc: "root"
                    }],
                    t.forEach(C, this),
                    this.reset(!0);
                }
                function I(t) {
                    if (t) {
                        var i = t[n];
                        if (i)
                            return i.call(t);
                        if ("function" == typeof t.next)
                            return t;
                        if (!isNaN(t.length)) {
                            var o = -1
                              , s = function i() {
                                for (; ++o < t.length; )
                                    if (r.call(t, o))
                                        return i.value = t[o],
                                        i.done = !1,
                                        i;
                                return i.value = e,
                                i.done = !0,
                                i
                            };
                            return s.next = s
                        }
                    }
                    return {
                        next: z
                    }
                }
                function z() {
                    return {
                        value: e,
                        done: !0
                    }
                }
                return g.prototype = w.constructor = v,
                v.constructor = g,
                g.displayName = l(v, a, "GeneratorFunction"),
                t.isGeneratorFunction = function(t) {
                    var e = "function" == typeof t && t.constructor;
                    return !!e && (e === g || "GeneratorFunction" === (e.displayName || e.name))
                }
                ,
                t.mark = function(t) {
                    return Object.setPrototypeOf ? Object.setPrototypeOf(t, v) : (t.__proto__ = v,
                    l(t, a, "GeneratorFunction")),
                    t.prototype = Object.create(w),
                    t
                }
                ,
                t.awrap = function(t) {
                    return {
                        __await: t
                    }
                }
                ,
                T(E.prototype),
                E.prototype[s] = function() {
                    return this
                }
                ,
                t.AsyncIterator = E,
                t.async = function(e, i, r, o, n) {
                    void 0 === n && (n = Promise);
                    var s = new E(c(e, i, r, o),n);
                    return t.isGeneratorFunction(i) ? s : s.next().then((function(t) {
                        return t.done ? t.value : s.next()
                    }
                    ))
                }
                ,
                T(w),
                l(w, a, "Generator"),
                w[n] = function() {
                    return this
                }
                ,
                w.toString = function() {
                    return "[object Generator]"
                }
                ,
                t.keys = function(t) {
                    var e = [];
                    for (var i in t)
                        e.push(i);
                    return e.reverse(),
                    function i() {
                        for (; e.length; ) {
                            var r = e.pop();
                            if (r in t)
                                return i.value = r,
                                i.done = !1,
                                i
                        }
                        return i.done = !0,
                        i
                    }
                }
                ,
                t.values = I,
                M.prototype = {
                    constructor: M,
                    reset: function(t) {
                        if (this.prev = 0,
                        this.next = 0,
                        this.sent = this._sent = e,
                        this.done = !1,
                        this.delegate = null,
                        this.method = "next",
                        this.arg = e,
                        this.tryEntries.forEach(A),
                        !t)
                            for (var i in this)
                                "t" === i.charAt(0) && r.call(this, i) && !isNaN(+i.slice(1)) && (this[i] = e);
                    },
                    stop: function() {
                        this.done = !0;
                        var t = this.tryEntries[0].completion;
                        if ("throw" === t.type)
                            throw t.arg;
                        return this.rval
                    },
                    dispatchException: function(t) {
                        if (this.done)
                            throw t;
                        var i = this;
                        function o(r, o) {
                            return a.type = "throw",
                            a.arg = t,
                            i.next = r,
                            o && (i.method = "next",
                            i.arg = e),
                            !!o
                        }
                        for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                            var s = this.tryEntries[n]
                              , a = s.completion;
                            if ("root" === s.tryLoc)
                                return o("end");
                            if (s.tryLoc <= this.prev) {
                                var l = r.call(s, "catchLoc")
                                  , c = r.call(s, "finallyLoc");
                                if (l && c) {
                                    if (this.prev < s.catchLoc)
                                        return o(s.catchLoc, !0);
                                    if (this.prev < s.finallyLoc)
                                        return o(s.finallyLoc)
                                } else if (l) {
                                    if (this.prev < s.catchLoc)
                                        return o(s.catchLoc, !0)
                                } else {
                                    if (!c)
                                        throw new Error("try statement without catch or finally");
                                    if (this.prev < s.finallyLoc)
                                        return o(s.finallyLoc)
                                }
                            }
                        }
                    },
                    abrupt: function(t, e) {
                        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                            var o = this.tryEntries[i];
                            if (o.tryLoc <= this.prev && r.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
                                var n = o;
                                break
                            }
                        }
                        n && ("break" === t || "continue" === t) && n.tryLoc <= e && e <= n.finallyLoc && (n = null);
                        var s = n ? n.completion : {};
                        return s.type = t,
                        s.arg = e,
                        n ? (this.method = "next",
                        this.next = n.finallyLoc,
                        p) : this.complete(s)
                    },
                    complete: function(t, e) {
                        if ("throw" === t.type)
                            throw t.arg;
                        return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg,
                        this.method = "return",
                        this.next = "end") : "normal" === t.type && e && (this.next = e),
                        p
                    },
                    finish: function(t) {
                        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                            var i = this.tryEntries[e];
                            if (i.finallyLoc === t)
                                return this.complete(i.completion, i.afterLoc),
                                A(i),
                                p
                        }
                    },
                    catch: function(t) {
                        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                            var i = this.tryEntries[e];
                            if (i.tryLoc === t) {
                                var r = i.completion;
                                if ("throw" === r.type) {
                                    var o = r.arg;
                                    A(i);
                                }
                                return o
                            }
                        }
                        throw new Error("illegal catch attempt")
                    },
                    delegateYield: function(t, i, r) {
                        return this.delegate = {
                            iterator: I(t),
                            resultName: i,
                            nextLoc: r
                        },
                        "next" === this.method && (this.arg = e),
                        p
                    }
                },
                t
            }(t.exports);
            try {
                regeneratorRuntime = e;
            } catch (t) {
                Function("r", "regeneratorRuntime = r")(e);
            }
        }
        ));
        var gp = t.createCommonjsModule((function(t) {
            var e = t.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
            "number" == typeof __g && (__g = e);
        }
        ))
          , vp = t.createCommonjsModule((function(t) {
            var e = t.exports = {
                version: "2.6.12"
            };
            "number" == typeof __e && (__e = e);
        }
        ))
          , yp = function(t, e, i) {
            if (function(t) {
                if ("function" != typeof t)
                    throw TypeError(t + " is not a function!")
            }(t),
            void 0 === e)
                return t;
            switch (i) {
            case 1:
                return function(i) {
                    return t.call(e, i)
                }
                ;
            case 2:
                return function(i, r) {
                    return t.call(e, i, r)
                }
                ;
            case 3:
                return function(i, r, o) {
                    return t.call(e, i, r, o)
                }
            }
            return function() {
                return t.apply(e, arguments)
            }
        }
          , bp = function(t) {
            return "object" == typeof t ? null !== t : "function" == typeof t
        }
          , xp = function(t) {
            if (!bp(t))
                throw TypeError(t + " is not an object!");
            return t
        }
          , wp = function(t) {
            try {
                return !!t()
            } catch (t) {
                return !0
            }
        }
          , Tp = !wp((function() {
            return 7 != Object.defineProperty({}, "a", {
                get: function() {
                    return 7
                }
            }).a
        }
        ))
          , Ep = gp.document
          , Sp = bp(Ep) && bp(Ep.createElement)
          , Cp = !Tp && !wp((function() {
            return 7 != Object.defineProperty(Sp ? Ep.createElement("div") : {}, "a", {
                get: function() {
                    return 7
                }
            }).a
        }
        ))
          , Ap = Object.defineProperty
          , Mp = {
            f: Tp ? Object.defineProperty : function(t, e, i) {
                if (xp(t),
                e = function(t, e) {
                    if (!bp(t))
                        return t;
                    var i, r;
                    if ("function" == typeof (i = t.toString) && !bp(r = i.call(t)))
                        return r;
                    if ("function" == typeof (i = t.valueOf) && !bp(r = i.call(t)))
                        return r;
                    throw TypeError("Can't convert object to primitive value")
                }(e),
                xp(i),
                Cp)
                    try {
                        return Ap(t, e, i)
                    } catch (t) {}
                if ("get"in i || "set"in i)
                    throw TypeError("Accessors not supported!");
                return "value"in i && (t[e] = i.value),
                t
            }
        }
          , Ip = Tp ? function(t, e, i) {
            return Mp.f(t, e, function(t, e) {
                return {
                    enumerable: !1,
                    configurable: !0,
                    writable: !0,
                    value: e
                }
            }(0, i))
        }
        : function(t, e, i) {
            return t[e] = i,
            t
        }
          , zp = {}.hasOwnProperty
          , Pp = function(t, e) {
            return zp.call(t, e)
        }
          , Dp = function(t, e, i) {
            var r, o, n, s = t & Dp.F, a = t & Dp.G, l = t & Dp.S, c = t & Dp.P, h = t & Dp.B, u = t & Dp.W, d = a ? vp : vp[e] || (vp[e] = {}), f = d.prototype, _ = a ? gp : l ? gp[e] : (gp[e] || {}).prototype;
            for (r in a && (i = e),
            i)
                (o = !s && _ && void 0 !== _[r]) && Pp(d, r) || (n = o ? _[r] : i[r],
                d[r] = a && "function" != typeof _[r] ? i[r] : h && o ? yp(n, gp) : u && _[r] == n ? function(t) {
                    var e = function(e, i, r) {
                        if (this instanceof t) {
                            switch (arguments.length) {
                            case 0:
                                return new t;
                            case 1:
                                return new t(e);
                            case 2:
                                return new t(e,i)
                            }
                            return new t(e,i,r)
                        }
                        return t.apply(this, arguments)
                    };
                    return e.prototype = t.prototype,
                    e
                }(n) : c && "function" == typeof n ? yp(Function.call, n) : n,
                c && ((d.virtual || (d.virtual = {}))[r] = n,
                t & Dp.R && f && !f[r] && Ip(f, r, n)));
        };
        Dp.F = 1,
        Dp.G = 2,
        Dp.S = 4,
        Dp.P = 8,
        Dp.B = 16,
        Dp.W = 32,
        Dp.U = 64,
        Dp.R = 128,
        Dp(Dp.G, {
            global: gp
        });
        var Bp, Lp = (Bp = vp.global) && Bp.__esModule ? Bp : {
            default: Bp
        };
        Lp.default._babelPolyfill && "undefined" != typeof console && console.warn && console.warn("@babel/polyfill is loaded more than once on this page. This is probably not desirable/intended and may have consequences if different versions of the polyfills are applied sequentially. If you do need to load the polyfill more than once, use @babel/polyfill/noConflict instead to bypass the warning."),
        Lp.default._babelPolyfill = !0;
        const Rp = {
            version: f,
            supported: h,
            setRTLTextPlugin: t.setRTLTextPlugin,
            getRTLTextPluginStatus: t.getRTLTextPluginStatus,
            Map: class extends Ys {
                constructor(e) {
                    if (!t.config.ACCESS_TOKEN)
                        throw new Error("请参考. See https://map.sgcc.com.cn/products/js-sdk/v3/# 进行登陆后获取资源");
                    try {
                        window.console && window.console.log && console.log("欢迎使用思极地图");
                    } catch (t) {}
                    if (e.minZoom < 1)
                        throw new Error("minZoom must be greater than or equal to 1");
                    t.config.crs = e.crs || "EPSG:3857",
                    super(e),
                    Ks[this._mapId] = new Fs,
                    Ks[this._mapId].onAdd(this),
                    this.on("style.load", ( () => {
                        t.setWaterMarkLayer(this);
                    }
                    )),
                    this._userDatas = {
                        layers: [],
                        images: {},
                        sources: {}
                    };
                }
                _updateDiff(t, e) {
                    if (t.xml || super.getStyle().xml) {
                        if (JSON.stringify(t.xml) != JSON.stringify(super.getStyle().xml))
                            return super._updateStyle(t, e);
                        e.diff = !1;
                    }
                    return super._updateDiff(t, e)
                }
                remove() {
                    super.remove(),
                    Ks[this._mapId].onRemove(),
                    Ks[this._mapId] = null;
                }
                setStyle(...t) {
                    let e = super.setStyle(...t);
                    return this._userDatas = {
                        layers: [],
                        images: {},
                        sources: {}
                    },
                    e
                }
                setBaseStyle(t, e, i) {
                    return this.setBaseMap(t, i)
                }
                addSource(...t) {
                    let e = super.addSource(...t);
                    return this._userDatas.sources[t[0]] = !0,
                    e
                }
                removeSource(...t) {
                    let e = super.removeSource(...t);
                    return delete this._userDatas.sources[t[0]],
                    e
                }
                addLayer(...t) {
                    let e = super.addLayer(...t)
                      , i = t[0].id;
                    return this._userDatas.layers.indexOf(i) < 0 && this._userDatas.layers.push(i),
                    "string" == typeof t[0].source ? this._userDatas.sources[t[0].source] = !0 : t[0].source && (this._userDatas.sources[i] = !0),
                    e
                }
                removeLayer(...t) {
                    let e = super.removeLayer(...t)
                      , i = this._userDatas.layers.indexOf(t[0]);
                    return i >= 0 && this._userDatas.layers.splice(i, 1),
                    e
                }
                addImage(...t) {
                    let e = super.addImage(...t);
                    return this._userDatas.images[t[0]] = t,
                    e
                }
                removeImage(...t) {
                    let e = super.removeImage(...t);
                    return delete this._userDatas.images[t[0]],
                    e
                }
                _loadStyle(e, i) {
                    let r = this._requestManager.normalizeStyleURL(e)
                      , o = this._requestManager.transformRequest(r, t.ResourceType.Style);
                    t.getJSON(o, ( (e, r) => {
                        e ? this.fire(new t.ErrorEvent(e)) : r && i && i(r);
                    }
                    ));
                }
                setBaseMap(e, i) {
                    let r = this
                      , o = r.getStyle()
                      , n = r.style
                      , s = JSON.parse(JSON.stringify(n.stylesheet))
                      , a = function(e) {
                        let o = n._order[0]
                          , s = r._userDatas.layers.length;
                        for (let t = 0; t < e.layers.length; t++) {
                            let i = e.layers[t];
                            n.getLayer(i.id) || (s > 0 ? n.addLayer(i, o) : n.addLayer(i));
                        }
                        n.fire(new t.Event("data",{
                            dataType: "style"
                        })),
                        n.fire(new t.Event("style.load")),
                        r._update(!0),
                        i && i();
                    }
                      , l = function(e) {
                        if (function(t) {
                            let e = {};
                            o.layers.forEach((t => {
                                r._userDatas.layers.indexOf(t.id) < 0 ? n.getLayer(t.id) && n.removeLayer(t.id) : "string" == typeof t.source ? e[t.source] = !0 : e[t.id] = !0;
                            }
                            ));
                            for (let t in o.sources)
                                e[t] || r._userDatas.sources[t] || n.getSource(t) && n.removeSource(t);
                            t.sprite && s.sprite != t.sprite && r.listImages().forEach((t => {
                                r._userDatas.images[t] || n.removeImage(t);
                            }
                            ));
                        }(e),
                        n.stylesheet = e,
                        e.glyphs && e.glyphs != s.glyphs && n.glyphManager.setURL(e.glyphs),
                        e.xml && n.dispatcher.broadcast("setXml", e.xml),
                        e.light && e.light != s.light && n.setLight(e.light),
                        e.hasOwnProperty("projection") && r.setProjection(e.projection),
                        e.sources)
                            for (let t in e.sources)
                                !n.getSource(t) && n.addSource(t, e.sources[t]);
                        n._changed = !1,
                        e.sprite && s.sprite != e.sprite ? (n._spriteRequest && (n._spriteRequest.cancel(),
                        n._spriteRequest = null),
                        n._spriteRequest = M(e.sprite, n.map._requestManager, ( (i, r) => {
                            if (n._spriteRequest = null,
                            i)
                                n.fire(new t.ErrorEvent(i));
                            else if (r) {
                                for (const t in r)
                                    n.getImage(t) || n.addImage(t, r[t]);
                                a(e);
                            }
                        }
                        ))) : a(e);
                    };
                    if (n._request && n._request.cancel(),
                    n._spriteRequest && (n._spriteRequest.cancel(),
                    n._spriteRequest = null),
                    "string" == typeof e) {
                        const i = r._requestManager.normalizeStyleURL(e)
                          , o = r._requestManager.transformRequest(i, t.ResourceType.Style);
                        n._request = t.getJSON(o, ( (e, i) => {
                            n._request = null,
                            e ? n.fire(new t.ErrorEvent(e)) : i && l(i);
                        }
                        ));
                    } else
                        l(e);
                }
                addEleSymbolVertexs(t, e) {
                    this.style.addEleSymbolVertexs(t, e);
                }
                setGlyphs(t) {
                    this.style.glyphManager.setURLData(t);
                }
                _addCustomSource(e) {
                    t._addCustomSource(e);
                }
                _removeCustomSource(e) {
                    t._removeCustomSource(e);
                }
            }
            ,
            NavigationControl: class {
                constructor(e) {
                    this.options = t.extend({}, Js, e),
                    this._container = _("div", "sgmap-ctrl sgmap-ctrl-group"),
                    this._container.addEventListener("contextmenu", (t => t.preventDefault())),
                    this.options.showZoom && (t.bindAll(["_setButtonTitle", "_updateZoomButtons"], this),
                    this._zoomInButton = this._createButton("sgmap-ctrl-zoom-in", (t => {
                        this._map && this._map.zoomIn({}, {
                            originalEvent: t
                        });
                    }
                    )),
                    _("span", "sgmap-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"),
                    this._zoomOutButton = this._createButton("sgmap-ctrl-zoom-out", (t => {
                        this._map && this._map.zoomOut({}, {
                            originalEvent: t
                        });
                    }
                    )),
                    _("span", "sgmap-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")),
                    this.options.showCompass && (t.bindAll(["_rotateCompassArrow"], this),
                    this._compass = this._createButton("sgmap-ctrl-compass", (t => {
                        const e = this._map;
                        e && (this.options.visualizePitch ? e.resetNorthPitch({}, {
                            originalEvent: t
                        }) : e.resetNorth({}, {
                            originalEvent: t
                        }));
                    }
                    )),
                    this._compassIcon = _("span", "sgmap-ctrl-icon", this._compass),
                    this._compassIcon.setAttribute("aria-hidden", "true"));
                }
                _updateZoomButtons() {
                    const t = this._map;
                    if (!t)
                        return;
                    const e = t.getZoom()
                      , i = e === t.getMaxZoom()
                      , r = e === t.getMinZoom();
                    this._zoomInButton.disabled = i,
                    this._zoomOutButton.disabled = r,
                    this._zoomInButton.setAttribute("aria-disabled", i.toString()),
                    this._zoomOutButton.setAttribute("aria-disabled", r.toString());
                }
                _rotateCompassArrow() {
                    const t = this._map;
                    if (!t)
                        return;
                    const e = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(t.transform.pitch * (Math.PI / 180)), .5)}) rotateX(${t.transform.pitch}deg) rotateZ(${t.transform.angle * (180 / Math.PI)}deg)` : `rotate(${t.transform.angle * (180 / Math.PI)}deg)`;
                    t._requestDomTask(( () => {
                        this._compassIcon && (this._compassIcon.style.transform = e);
                    }
                    ));
                }
                onAdd(t) {
                    return this._map = t,
                    this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"),
                    this._setButtonTitle(this._zoomOutButton, "ZoomOut"),
                    t.on("zoom", this._updateZoomButtons),
                    this._updateZoomButtons()),
                    this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"),
                    this.options.visualizePitch && t.on("pitch", this._rotateCompassArrow),
                    t.on("rotate", this._rotateCompassArrow),
                    this._rotateCompassArrow(),
                    this._handler = new $s(t,this._compass,this.options.visualizePitch)),
                    this._container
                }
                onRemove() {
                    const t = this._map;
                    t && (this._container.remove(),
                    this.options.showZoom && t.off("zoom", this._updateZoomButtons),
                    this.options.showCompass && (this.options.visualizePitch && t.off("pitch", this._rotateCompassArrow),
                    t.off("rotate", this._rotateCompassArrow),
                    this._handler && this._handler.off(),
                    this._handler = void 0),
                    this._map = void 0);
                }
                _createButton(t, e) {
                    const i = _("button", t, this._container);
                    return i.type = "button",
                    i.addEventListener("click", e),
                    i
                }
                _setButtonTitle(t, e) {
                    if (!this._map)
                        return;
                    const i = this._map._getUIString(`NavigationControl.${e}`);
                    t.setAttribute("aria-label", i),
                    t.firstElementChild && t.firstElementChild.setAttribute("title", i);
                }
            }
            ,
            GeolocateControl: class extends ta {
                _parsePosition(e, i) {
                    t.makeRequest({
                        method: "POST",
                        url: `${t.config.API_URL}/geoconv/v2`,
                        type: "json",
                        body: `coords=${e.join(",")}&from=1&encode=0`,
                        headers: {
                            Authorization: t.config.ACCESS_TOKEN,
                            "Content-Type": "application/x-www-form-urlencoded;charset=utf-8"
                        }
                    }, i);
                }
                _onSuccess(t) {
                    this._parsePosition([t.coords.longitude, t.coords.latitude], ( (e, i) => {
                        if (!e && 1e4 === i.code) {
                            const e = i.value.map((t => [t.x, t.y]));
                            super._onSuccess({
                                coords: {
                                    longitude: e[0][0],
                                    latitude: e[0][1],
                                    accuracy: t.coords.accuracy
                                }
                            });
                        }
                    }
                    ));
                }
            }
            ,
            AttributionControl: Rs,
            ScaleControl: class {
                constructor(e) {
                    this.options = t.extend({}, ea, e),
                    function() {
                        try {
                            return new Intl.NumberFormat("en",{
                                style: "unit",
                                unitDisplay: "narrow",
                                unit: "meter"
                            }),
                            !0
                        } catch (t) {
                            return !1
                        }
                    }() || (this._setScale = ia.bind(this)),
                    t.bindAll(["_update", "_setScale", "setUnit"], this);
                }
                getDefaultPosition() {
                    return "bottom-left"
                }
                _update() {
                    const t = this.options.maxWidth || 100
                      , e = this._map
                      , i = e._containerHeight / 2
                      , r = e._containerWidth / 2 - t / 2
                      , o = e.unproject([r, i])
                      , n = e.unproject([r + t, i])
                      , s = o.distanceTo(n);
                    if ("imperial" === this.options.unit) {
                        const e = 3.2808 * s;
                        e > 5280 ? this._setScale(t, e / 5280, "mile") : this._setScale(t, e, "foot");
                    } else
                        "nautical" === this.options.unit ? this._setScale(t, s / 1852, "nautical-mile") : s >= 1e3 ? this._setScale(t, s / 1e3, "kilometer") : this._setScale(t, s, "meter");
                }
                _setScale(t, e, i) {
                    const r = ra(e)
                      , o = r / e;
                    this._map._requestDomTask(( () => {
                        this._container.style.width = t * o + "px",
                        this._container.innerHTML = "nautical-mile" !== i ? new Intl.NumberFormat(this._language,{
                            style: "unit",
                            unitDisplay: "narrow",
                            unit: i
                        }).format(r) : `${r}&nbsp;nm`;
                    }
                    ));
                }
                onAdd(t) {
                    return this._map = t,
                    this._language = t.getLanguage(),
                    this._container = _("div", "sgmap-ctrl sgmap-ctrl-scale", t.getContainer()),
                    this._container.dir = "auto",
                    this._map.on("move", this._update),
                    this._update(),
                    this._container
                }
                onRemove() {
                    this._container.remove(),
                    this._map.off("move", this._update),
                    this._map = void 0;
                }
                _setLanguage(t) {
                    this._language = t,
                    this._update();
                }
                setUnit(t) {
                    this.options.unit = t,
                    this._update();
                }
            }
            ,
            PitchControl: class {
                constructor() {
                    t.bindAll(["_onClickPitch", "_changeIcon"], this);
                }
                getDefaultPosition() {
                    return "bottom-right"
                }
                onAdd(t) {
                    return this._map = t,
                    this._container = _("div", "sgmap-ctrl sgmap-ctrl-group"),
                    this._pitchControlBtn = _("button", "sgmap-ctrl-pitch-text", this._container),
                    this._pitchControlBtn.innerHTML = "2D",
                    this._pitchControlBtn.addEventListener("click", this._onClickPitch),
                    this._map.on("pitch", this._changeIcon),
                    this._container
                }
                onRemove() {
                    this._map.off("pitch", this._changeIcon),
                    this._container.remove();
                }
                _onClickPitch() {
                    this._ispitch ? (this._pitchControlBtn.innerHTML = "2D",
                    this._map.easeTo({
                        pitch: 0
                    }),
                    this._ispitch = !1) : (this._pitchControlBtn.innerHTML = "3D",
                    this._map.easeTo({
                        pitch: 50
                    }),
                    this._ispitch = !0);
                }
                _changeIcon() {
                    0 != this._map.getPitch() ? (this._pitchControlBtn.innerHTML = "3D",
                    this._ispitch = !0) : (this._pitchControlBtn.innerHTML = "2D",
                    this._ispitch = !1);
                }
            }
            ,
            FullscreenControl: class {
                constructor(e) {
                    this._fullscreen = !1,
                    e && e.container && (e.container instanceof t.window.HTMLElement ? this._container = e.container : t.warnOnce("Full screen control 'container' must be a DOM element.")),
                    t.bindAll(["_onClickFullscreen", "_changeIcon"], this),
                    "onfullscreenchange"in t.window.document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange"in t.window.document && (this._fullscreenchange = "webkitfullscreenchange");
                }
                onAdd(e) {
                    return this._map = e,
                    this._container || (this._container = this._map.getContainer()),
                    this._controlContainer = _("div", "sgmap-ctrl sgmap-ctrl-group"),
                    this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none",
                    t.warnOnce("This device does not support fullscreen mode.")),
                    this._controlContainer
                }
                onRemove() {
                    this._controlContainer.remove(),
                    this._map = null,
                    t.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
                }
                _checkFullscreenSupport() {
                    return !(!t.window.document.fullscreenEnabled && !t.window.document.webkitFullscreenEnabled)
                }
                _setupUI() {
                    const e = this._fullscreenButton = _("button", "sgmap-ctrl-fullscreen", this._controlContainer);
                    _("span", "sgmap-ctrl-icon", e).setAttribute("aria-hidden", "true"),
                    e.type = "button",
                    this._updateTitle(),
                    this._fullscreenButton.addEventListener("click", this._onClickFullscreen),
                    t.window.document.addEventListener(this._fullscreenchange, this._changeIcon);
                }
                _updateTitle() {
                    const t = this._getTitle();
                    this._fullscreenButton.setAttribute("aria-label", t),
                    this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", t);
                }
                _getTitle() {
                    return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter")
                }
                _isFullscreen() {
                    return this._fullscreen
                }
                _changeIcon() {
                    (t.window.document.fullscreenElement || t.window.document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen,
                    this._fullscreenButton.classList.toggle("sgmap-ctrl-shrink"),
                    this._fullscreenButton.classList.toggle("sgmap-ctrl-fullscreen"),
                    this._updateTitle());
                }
                _onClickFullscreen() {
                    this._isFullscreen() ? t.window.document.exitFullscreen ? t.window.document.exitFullscreen() : t.window.document.webkitCancelFullScreen && t.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
                }
            }
            ,
            Popup: class extends t.Evented {
                constructor(e) {
                    super(),
                    this.options = t.extend(Object.create(Vs), e),
                    t.bindAll(["_update", "_onClose", "remove", "_onMouseEvent"], this),
                    this._classList = new Set(e && e.className ? e.className.trim().split(/\s+/) : []);
                }
                addTo(e) {
                    return this._map && this.remove(),
                    this._map = e,
                    this.options.closeOnClick && e.on("preclick", this._onClose),
                    this.options.closeOnMove && e.on("move", this._onClose),
                    e.on("remove", this.remove),
                    this._update(),
                    e._addPopup(this),
                    this._focusFirstElement(),
                    this._trackPointer ? (e.on("mousemove", this._onMouseEvent),
                    e.on("mouseup", this._onMouseEvent),
                    e._canvasContainer.classList.add("sgmap-track-pointer")) : e.on("move", this._update),
                    this.fire(new t.Event("open")),
                    this
                }
                isOpen() {
                    return !!this._map
                }
                remove() {
                    this._content && this._content.remove(),
                    this._container && (this._container.remove(),
                    this._container = void 0);
                    const e = this._map;
                    return e && (e.off("move", this._update),
                    e.off("move", this._onClose),
                    e.off("preclick", this._onClose),
                    e.off("click", this._onClose),
                    e.off("remove", this.remove),
                    e.off("mousemove", this._onMouseEvent),
                    e.off("mouseup", this._onMouseEvent),
                    e.off("drag", this._onMouseEvent),
                    e._canvasContainer && e._canvasContainer.classList.remove("sgmap-track-pointer"),
                    e._removePopup(this),
                    this._map = void 0),
                    this.fire(new t.Event("close")),
                    this
                }
                getLngLat() {
                    return this._lngLat
                }
                setLngLat(e) {
                    this._lngLat = t.LngLat.convert(e),
                    this._pos = null,
                    this._trackPointer = !1,
                    this._update();
                    const i = this._map;
                    return i && (i.on("move", this._update),
                    i.off("mousemove", this._onMouseEvent),
                    i._canvasContainer.classList.remove("sgmap-track-pointer")),
                    this
                }
                trackPointer() {
                    this._trackPointer = !0,
                    this._pos = null,
                    this._update();
                    const t = this._map;
                    return t && (t.off("move", this._update),
                    t.on("mousemove", this._onMouseEvent),
                    t.on("drag", this._onMouseEvent),
                    t._canvasContainer.classList.add("sgmap-track-pointer")),
                    this
                }
                getElement() {
                    return this._container
                }
                setText(e) {
                    return this.setDOMContent(t.window.document.createTextNode(e))
                }
                setHTML(e) {
                    const i = t.window.document.createDocumentFragment()
                      , r = t.window.document.createElement("body");
                    let o;
                    for (r.innerHTML = e; o = r.firstChild,
                    o; )
                        i.appendChild(o);
                    return this.setDOMContent(i)
                }
                getMaxWidth() {
                    return this._container && this._container.style.maxWidth
                }
                setMaxWidth(t) {
                    return this.options.maxWidth = t,
                    this._update(),
                    this
                }
                setDOMContent(t) {
                    let e = this._content;
                    if (e)
                        for (; e.hasChildNodes(); )
                            e.firstChild && e.removeChild(e.firstChild);
                    else
                        e = this._content = _("div", "sgmap-popup-content", this._container || void 0);
                    if (e.appendChild(t),
                    this.options.closeButton) {
                        const t = this._closeButton = _("button", "sgmap-popup-close-button", e);
                        t.type = "button",
                        t.setAttribute("aria-label", "Close popup"),
                        t.setAttribute("aria-hidden", "true"),
                        t.innerHTML = "&#215;",
                        t.addEventListener("click", this._onClose);
                    }
                    return this._update(),
                    this._focusFirstElement(),
                    this
                }
                addClassName(t) {
                    return this._classList.add(t),
                    this._updateClassList(),
                    this
                }
                removeClassName(t) {
                    return this._classList.delete(t),
                    this._updateClassList(),
                    this
                }
                setOffset(t) {
                    return this.options.offset = t,
                    this._update(),
                    this
                }
                toggleClassName(t) {
                    let e;
                    return this._classList.delete(t) ? e = !1 : (this._classList.add(t),
                    e = !0),
                    this._updateClassList(),
                    e
                }
                _onMouseEvent(t) {
                    this._update(t.point);
                }
                _getAnchor(t) {
                    if (this.options.anchor)
                        return this.options.anchor;
                    const e = this._map
                      , i = this._container
                      , r = this._pos;
                    if (!e || !i || !r)
                        return "bottom";
                    const o = i.offsetWidth
                      , n = i.offsetHeight
                      , s = r.x < o / 2
                      , a = r.x > e.transform.width - o / 2;
                    if (r.y + t < n)
                        return s ? "top-left" : a ? "top-right" : "top";
                    if (r.y > e.transform.height - n) {
                        if (s)
                            return "bottom-left";
                        if (a)
                            return "bottom-right"
                    }
                    return s ? "left" : a ? "right" : "bottom"
                }
                _updateClassList() {
                    const t = this._container;
                    if (!t)
                        return;
                    const e = Array.from(this._classList);
                    e.push("sgmap-popup"),
                    this._anchor && e.push(`sgmap-popup-anchor-${this._anchor}`),
                    this._trackPointer && e.push("sgmap-popup-track-pointer"),
                    t.className = e.join(" ");
                }
                _update(e) {
                    const i = this._map
                      , r = this._content;
                    if (!i || !this._lngLat && !this._trackPointer || !r)
                        return;
                    let o = this._container;
                    if (o || (o = this._container = _("div", "sgmap-popup", i.getContainer()),
                    this._tip = _("div", "sgmap-popup-tip", o),
                    o.appendChild(r)),
                    this.options.maxWidth && o.style.maxWidth !== this.options.maxWidth && (o.style.maxWidth = this.options.maxWidth),
                    i.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Ns(this._lngLat, this._pos, i.transform)),
                    !this._trackPointer || e) {
                        const t = this._pos = this._trackPointer && e ? e : i.project(this._lngLat)
                          , r = Ws(this.options.offset)
                          , o = this._anchor = this._getAnchor(r.y)
                          , n = Ws(this.options.offset, o)
                          , s = t.add(n).round();
                        i._requestDomTask(( () => {
                            this._container && o && (this._container.style.transform = `${js[o]} translate(${s.x}px,${s.y}px)`);
                        }
                        ));
                    }
                    if (!this._marker && i._showingGlobe()) {
                        const e = t.isLngLatBehindGlobe(i.transform, this._lngLat) ? 0 : 1;
                        this._setOpacity(e);
                    } else
                        this._setOpacity(1);
                    this._updateClassList();
                }
                _focusFirstElement() {
                    if (!this.options.focusAfterOpen || !this._container)
                        return;
                    const t = this._container.querySelector(Zs);
                    t && t.focus();
                }
                _onClose() {
                    this.remove();
                }
                _setOpacity(t) {
                    this._container && (this._container.style.opacity = `${t}`),
                    this._content && (this._content.style.pointerEvents = t ? "auto" : "none");
                }
            }
            ,
            Marker: Gs,
            Style: Ir,
            LngLat: t.LngLat,
            LngLatBounds: t.LngLatBounds,
            Point: t.pointGeometry,
            MercatorCoordinate: t.MercatorCoordinate,
            FreeCameraOptions: An,
            Evented: t.Evented,
            config: JSON.parse(JSON.stringify(t.config)),
            prewarm: function() {
                mi().acquire(fi);
            },
            clearPrewarmedResources: function() {
                const t = pi;
                t && (t.isPreloaded() && 1 === t.numActive() ? (t.release(fi),
                pi = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
            },
            get accessToken() {
                return t.config.ACCESS_TOKEN
            },
            set accessToken(t) {
                console.error("禁止外部修改accessToken为", t);
            },
            get baseApiUrl() {
                return t.config.API_URL
            },
            set baseApiUrl(t) {
                console.error("禁止外部修改baseApiUrl为", t);
            },
            get workerCount() {
                return _i.workerCount
            },
            set workerCount(t) {
                _i.workerCount = t;
            },
            get maxParallelImageRequests() {
                return t.config.MAX_PARALLEL_IMAGE_REQUESTS
            },
            set maxParallelImageRequests(e) {
                t.config.MAX_PARALLEL_IMAGE_REQUESTS = e;
            },
            clearStorage(e) {
                t.clearTileCache(e);
            },
            workerUrl: "",
            workerClass: null,
            setNow: t.exported.setNow,
            restoreNow: t.exported.restoreNow
        }
          , kp = f.split(".").slice(0, 2).concat([0]).join(".");
        return na.config.version = kp,
        Rp._loader = na,
        Rp.ajax = (e, i, r=!1) => {
            if (e = t.formatAjax(e),
            Promise && !i)
                return new Promise(( (i, o) => {
                    void 0 === e.cache && (e.cache = !1),
                    t.makeRequest2(e, ( (t, e, n, s) => {
                        t ? o(t) : i(r ? {
                            data: e,
                            cacheControl: n,
                            expires: s
                        } : e);
                    }
                    ));
                }
                ));
            t.makeRequest2(e, i);
        }
        ,
        Rp.tokenTask = new oa,
        Rp.tokenTask._setting = (e, i) => {
            t.config[e] = i;
        }
        ,
        Rp.plugin = (t, e) => na(t, e),
        Rp.version = f,
        "" !== t.config.API_URL ? console.warn("SDK为DEV版本，版本号3.1.2.4，部署请使用发布版本。") : t.initApiURI(kp, t.config),
        na.config.apiUrl = Rp.config.API_URL = t.config.API_URL,
        Rp.userAgent = na.userAgent,
        Rp
    }
    ));

    //

    var sgmap$1 = sgmap;
    window.bwnck = [];
    return sgmap$1;

}
));
